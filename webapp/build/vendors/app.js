!function(I){function g(t){if(C[t])return C[t].exports;var i=C[t]={exports:{},id:t,loaded:!1};return I[t].call(i.exports,i,i.exports,g),i.loaded=!0,i.exports}var t=window.webpackJsonp;window.webpackJsonp=function(n,e){for(var l,a,c=0,A=[];c<n.length;c++)a=n[c],i[a]&&A.push.apply(A,i[a]),i[a]=0;for(l in e)I[l]=e[l];for(t&&t(n,e);A.length;)A.shift().call(null,g);if(e[0])return C[0]=0,g(0)};var C={},i={2:0};return g.e=function(I,t){if(0===i[I])return t.call(null,g);if(void 0!==i[I])i[I].push(t);else{i[I]=[t];var C=document.getElementsByTagName("head")[0],n=document.createElement("script");n.type="text/javascript",n.charset="utf-8",n.async=!0,n.src=g.p+""+I+"."+({0:"home",1:"login",3:"common"}[I]||I)+"/app.js",C.appendChild(n)}},g.m=I,g.c=C,g.p="",g(0)}([function(I,g,t){t(1),t(5),t(2),I.exports=t(9)},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(_, $, module) {/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license\n //@ sourceMappingURL=jquery.min.map\n */\n(function (e, t) {\n    var n, r, i = typeof t, o = e.location, a = e.document, s = a.documentElement, l = e.jQuery, u = e.$, c = {}, p = [], f = "1.10.2", d = p.concat, h = p.push, g = p.slice, m = p.indexOf, y = c.toString, v = c.hasOwnProperty, b = f.trim, x = function (e, t) {\n        return new x.fn.init(e, t, r)\n    }, w = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source, T = /\\S+/g, C = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, N = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/, k = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/, E = /^[\\],:{}\\s]*$/, S = /(?:^|:|,)(?:\\s*\\[)+/g, A = /\\\\(?:["\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g, j = /"[^"\\\\\\r\\n]*"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g, D = /^-ms-/, L = /-([\\da-z])/gi, H = function (e, t) {\n        return t.toUpperCase()\n    }, q = function (e) {\n        (a.addEventListener || "load" === e.type || "complete" === a.readyState) && (_(), x.ready())\n    }, _ = function () {\n        a.addEventListener ? (a.removeEventListener("DOMContentLoaded", q, !1), e.removeEventListener("load", q, !1)) : (a.detachEvent("onreadystatechange", q), e.detachEvent("onload", q))\n    };\n    x.fn = x.prototype = {jquery: f, constructor: x, init: function (e, n, r) {\n            var i, o;\n            if (!e)\n                return this;\n            if ("string" == typeof e) {\n                if (i = "<" === e.charAt(0) && ">" === e.charAt(e.length - 1) && e.length >= 3 ? [null, e, null] : N.exec(e), !i || !i[1] && n)\n                    return!n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e);\n                if (i[1]) {\n                    if (n = n instanceof x ? n[0] : n, x.merge(this, x.parseHTML(i[1], n && n.nodeType ? n.ownerDocument || n : a, !0)), k.test(i[1]) && x.isPlainObject(n))\n                        for (i in n)\n                            x.isFunction(this[i]) ? this[i](n[i]) : this.attr(i, n[i]);\n                    return this\n                }\n                if (o = a.getElementById(i[2]), o && o.parentNode) {\n                    if (o.id !== i[2])\n                        return r.find(e);\n                    this.length = 1, this[0] = o\n                }\n                return this.context = a, this.selector = e, this\n            }\n            return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : x.isFunction(e) ? r.ready(e) : (e.selector !== t && (this.selector = e.selector, this.context = e.context), x.makeArray(e, this))\n        }, selector: "", length: 0, toArray: function () {\n            return g.call(this)\n        }, get: function (e) {\n            return null == e ? this.toArray() : 0 > e ? this[this.length + e] : this[e]\n        }, pushStack: function (e) {\n            var t = x.merge(this.constructor(), e);\n            return t.prevObject = this, t.context = this.context, t\n        }, each: function (e, t) {\n            return x.each(this, e, t)\n        }, ready: function (e) {\n            return x.ready.promise().done(e), this\n        }, slice: function () {\n            return this.pushStack(g.apply(this, arguments))\n        }, first: function () {\n            return this.eq(0)\n        }, last: function () {\n            return this.eq(-1)\n        }, eq: function (e) {\n            var t = this.length, n = +e + (0 > e ? t : 0);\n            return this.pushStack(n >= 0 && t > n ? [this[n]] : [])\n        }, map: function (e) {\n            return this.pushStack(x.map(this, function (t, n) {\n                return e.call(t, n, t)\n            }))\n        }, end: function () {\n            return this.prevObject || this.constructor(null)\n        }, push: h, sort: [].sort, splice: [].splice}, x.fn.init.prototype = x.fn, x.extend = x.fn.extend = function () {\n        var e, n, r, i, o, a, s = arguments[0] || {}, l = 1, u = arguments.length, c = !1;\n        for ("boolean" == typeof s && (c = s, s = arguments[1] || {}, l = 2), "object" == typeof s || x.isFunction(s) || (s = {}), u === l && (s = this, --l); u > l; l++)\n            if (null != (o = arguments[l]))\n                for (i in o)\n                    e = s[i], r = o[i], s !== r && (c && r && (x.isPlainObject(r) || (n = x.isArray(r))) ? (n ? (n = !1, a = e && x.isArray(e) ? e : []) : a = e && x.isPlainObject(e) ? e : {}, s[i] = x.extend(c, a, r)) : r !== t && (s[i] = r));\n        return s\n    }, x.extend({expando: "jQuery" + (f + Math.random()).replace(/\\D/g, ""), noConflict: function (t) {\n            return e.$ === x && (e.$ = u), t && e.jQuery === x && (e.jQuery = l), x\n        }, isReady: !1, readyWait: 1, holdReady: function (e) {\n            e ? x.readyWait++ : x.ready(!0)\n        }, ready: function (e) {\n            if (e === !0 ? !--x.readyWait : !x.isReady) {\n                if (!a.body)\n                    return setTimeout(x.ready);\n                x.isReady = !0, e !== !0 && --x.readyWait > 0 || (n.resolveWith(a, [x]), x.fn.trigger && x(a).trigger("ready").off("ready"))\n            }\n        }, isFunction: function (e) {\n            return"function" === x.type(e)\n        }, isArray: Array.isArray || function (e) {\n            return"array" === x.type(e)\n        }, isWindow: function (e) {\n            return null != e && e == e.window\n        }, isNumeric: function (e) {\n            return!isNaN(parseFloat(e)) && isFinite(e)\n        }, type: function (e) {\n            return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? c[y.call(e)] || "object" : typeof e\n        }, isPlainObject: function (e) {\n            var n;\n            if (!e || "object" !== x.type(e) || e.nodeType || x.isWindow(e))\n                return!1;\n            try {\n                if (e.constructor && !v.call(e, "constructor") && !v.call(e.constructor.prototype, "isPrototypeOf"))\n                    return!1\n            } catch (r) {\n                return!1\n            }\n            if (x.support.ownLast)\n                for (n in e)\n                    return v.call(e, n);\n            for (n in e)\n                ;\n            return n === t || v.call(e, n)\n        }, isEmptyObject: function (e) {\n            var t;\n            for (t in e)\n                return!1;\n            return!0\n        }, error: function (e) {\n            throw Error(e)\n        }, parseHTML: function (e, t, n) {\n            if (!e || "string" != typeof e)\n                return null;\n            "boolean" == typeof t && (n = t, t = !1), t = t || a;\n            var r = k.exec(e), i = !n && [];\n            return r ? [t.createElement(r[1])] : (r = x.buildFragment([e], t, i), i && x(i).remove(), x.merge([], r.childNodes))\n        }, parseJSON: function (n) {\n            return e.JSON && e.JSON.parse ? e.JSON.parse(n) : null === n ? n : "string" == typeof n && (n = x.trim(n), n && E.test(n.replace(A, "@").replace(j, "]").replace(S, ""))) ? Function("return " + n)() : (x.error("Invalid JSON: " + n), t)\n        }, parseXML: function (n) {\n            var r, i;\n            if (!n || "string" != typeof n)\n                return null;\n            try {\n                e.DOMParser ? (i = new DOMParser, r = i.parseFromString(n, "text/xml")) : (r = new ActiveXObject("Microsoft.XMLDOM"), r.async = "false", r.loadXML(n))\n            } catch (o) {\n                r = t\n            }\n            return r && r.documentElement && !r.getElementsByTagName("parsererror").length || x.error("Invalid XML: " + n), r\n        }, noop: function () {\n        }, globalEval: function (t) {\n            t && x.trim(t) && (e.execScript || function (t) {\n                e.eval.call(e, t)\n            })(t)\n        }, camelCase: function (e) {\n            return e.replace(D, "ms-").replace(L, H)\n        }, nodeName: function (e, t) {\n            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()\n        }, each: function (e, t, n) {\n            var r, i = 0, o = e.length, a = M(e);\n            if (n) {\n                if (a) {\n                    for (; o > i; i++)\n                        if (r = t.apply(e[i], n), r === !1)\n                            break\n                } else\n                    for (i in e)\n                        if (r = t.apply(e[i], n), r === !1)\n                            break\n            } else if (a) {\n                for (; o > i; i++)\n                    if (r = t.call(e[i], i, e[i]), r === !1)\n                        break\n            } else\n                for (i in e)\n                    if (r = t.call(e[i], i, e[i]), r === !1)\n                        break;\n            return e\n        }, trim: b && !b.call("\\ufeff\\u00a0") ? function (e) {\n            return null == e ? "" : b.call(e)\n        } : function (e) {\n            return null == e ? "" : (e + "").replace(C, "")\n        }, makeArray: function (e, t) {\n            var n = t || [];\n            return null != e && (M(Object(e)) ? x.merge(n, "string" == typeof e ? [e] : e) : h.call(n, e)), n\n        }, inArray: function (e, t, n) {\n            var r;\n            if (t) {\n                if (m)\n                    return m.call(t, e, n);\n                for (r = t.length, n = n?0 > n?Math.max(0, r + n):n:0; r > n; n++)\n                    if (n in t && t[n] === e)\n                        return n\n            }\n            return-1\n        }, merge: function (e, n) {\n            var r = n.length, i = e.length, o = 0;\n            if ("number" == typeof r)\n                for (; r > o; o++)\n                    e[i++] = n[o];\n            else\n                while (n[o] !== t)\n                    e[i++] = n[o++];\n            return e.length = i, e\n        }, grep: function (e, t, n) {\n            var r, i = [], o = 0, a = e.length;\n            for (n = !!n; a > o; o++)\n                r = !!t(e[o], o), n !== r && i.push(e[o]);\n            return i\n        }, map: function (e, t, n) {\n            var r, i = 0, o = e.length, a = M(e), s = [];\n            if (a)\n                for (; o > i; i++)\n                    r = t(e[i], i, n), null != r && (s[s.length] = r);\n            else\n                for (i in e)\n                    r = t(e[i], i, n), null != r && (s[s.length] = r);\n            return d.apply([], s)\n        }, guid: 1, proxy: function (e, n) {\n            var r, i, o;\n            return"string" == typeof n && (o = e[n], n = e, e = o), x.isFunction(e) ? (r = g.call(arguments, 2), i = function () {\n                return e.apply(n || this, r.concat(g.call(arguments)))\n            }, i.guid = e.guid = e.guid || x.guid++, i) : t\n        }, access: function (e, n, r, i, o, a, s) {\n            var l = 0, u = e.length, c = null == r;\n            if ("object" === x.type(r)) {\n                o = !0;\n                for (l in r)\n                    x.access(e, n, l, r[l], !0, a, s)\n            } else if (i !== t && (o = !0, x.isFunction(i) || (s = !0), c && (s ? (n.call(e, i), n = null) : (c = n, n = function (e, t, n) {\n                return c.call(x(e), n)\n            })), n))\n                for (; u > l; l++)\n                    n(e[l], r, s ? i : i.call(e[l], l, n(e[l], r)));\n            return o ? e : c ? n.call(e) : u ? n(e[0], r) : a\n        }, now: function () {\n            return(new Date).getTime()\n        }, swap: function (e, t, n, r) {\n            var i, o, a = {};\n            for (o in t)\n                a[o] = e.style[o], e.style[o] = t[o];\n            i = n.apply(e, r || []);\n            for (o in t)\n                e.style[o] = a[o];\n            return i\n        }}), x.ready.promise = function (t) {\n        if (!n)\n            if (n = x.Deferred(), "complete" === a.readyState)\n                setTimeout(x.ready);\n            else if (a.addEventListener)\n                a.addEventListener("DOMContentLoaded", q, !1), e.addEventListener("load", q, !1);\n            else {\n                a.attachEvent("onreadystatechange", q), e.attachEvent("onload", q);\n                var r = !1;\n                try {\n                    r = null == e.frameElement && a.documentElement\n                } catch (i) {\n                }\n                r && r.doScroll && function o() {\n                    if (!x.isReady) {\n                        try {\n                            r.doScroll("left")\n                        } catch (e) {\n                            return setTimeout(o, 50)\n                        }\n                        _(), x.ready()\n                    }\n                }()\n            }\n        return n.promise(t)\n    }, x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (e, t) {\n        c["[object " + t + "]"] = t.toLowerCase()\n    });\n    function M(e) {\n        var t = e.length, n = x.type(e);\n        return x.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || "function" !== n && (0 === t || "number" == typeof t && t > 0 && t - 1 in e)\n    }\n    r = x(a), function (e, t) {\n        var n, r, i, o, a, s, l, u, c, p, f, d, h, g, m, y, v, b = "sizzle" + -new Date, w = e.document, T = 0, C = 0, N = st(), k = st(), E = st(), S = !1, A = function (e, t) {\n            return e === t ? (S = !0, 0) : 0\n        }, j = typeof t, D = 1 << 31, L = {}.hasOwnProperty, H = [], q = H.pop, _ = H.push, M = H.push, O = H.slice, F = H.indexOf || function (e) {\n            var t = 0, n = this.length;\n            for (; n > t; t++)\n                if (this[t] === e)\n                    return t;\n            return-1\n        }, B = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", P = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]", R = "(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+", W = R.replace("w", "w#"), $ = "\\\\[" + P + "*(" + R + ")" + P + "*(?:([*^$|!~]?=)" + P + "*(?:([\'\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(" + W + ")|)|)" + P + "*\\\\]", I = ":(" + R + ")(?:\\\\((([\'\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + $.replace(3, 8) + ")*)|.*)\\\\)|)", z = RegExp("^" + P + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + P + "+$", "g"), X = RegExp("^" + P + "*," + P + "*"), U = RegExp("^" + P + "*([>+~]|" + P + ")" + P + "*"), V = RegExp(P + "*[+~]"), Y = RegExp("=" + P + "*([^\\\\]\'\\"]*)" + P + "*\\\\]", "g"), J = RegExp(I), G = RegExp("^" + W + "$"), Q = {ID: RegExp("^#(" + R + ")"), CLASS: RegExp("^\\\\.(" + R + ")"), TAG: RegExp("^(" + R.replace("w", "w*") + ")"), ATTR: RegExp("^" + $), PSEUDO: RegExp("^" + I), CHILD: RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + P + "*(even|odd|(([+-]|)(\\\\d*)n|)" + P + "*(?:([+-]|)" + P + "*(\\\\d+)|))" + P + "*\\\\)|)", "i"), bool: RegExp("^(?:" + B + ")$", "i"), needsContext: RegExp("^" + P + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" + P + "*((?:-\\\\d)?\\\\d*)" + P + "*\\\\)|)(?=[^-]|$)", "i")}, K = /^[^{]+\\{\\s*\\[native \\w/, Z = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/, et = /^(?:input|select|textarea|button)$/i, tt = /^h\\d$/i, nt = /\'|\\\\/g, rt = RegExp("\\\\\\\\([\\\\da-f]{1,6}" + P + "?|(" + P + ")|.)", "ig"), it = function (e, t, n) {\n            var r = "0x" + t - 65536;\n            return r !== r || n ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)\n        };\n        try {\n            M.apply(H = O.call(w.childNodes), w.childNodes), H[w.childNodes.length].nodeType\n        } catch (ot) {\n            M = {apply: H.length ? function (e, t) {\n                    _.apply(e, O.call(t))\n                } : function (e, t) {\n                    var n = e.length, r = 0;\n                    while (e[n++] = t[r++])\n                        ;\n                    e.length = n - 1\n                }}\n        }\n        function at(e, t, n, i) {\n            var o, a, s, l, u, c, d, m, y, x;\n            if ((t ? t.ownerDocument || t : w) !== f && p(t), t = t || f, n = n || [], !e || "string" != typeof e)\n                return n;\n            if (1 !== (l = t.nodeType) && 9 !== l)\n                return[];\n            if (h && !i) {\n                if (o = Z.exec(e))\n                    if (s = o[1]) {\n                        if (9 === l) {\n                            if (a = t.getElementById(s), !a || !a.parentNode)\n                                return n;\n                            if (a.id === s)\n                                return n.push(a), n\n                        } else if (t.ownerDocument && (a = t.ownerDocument.getElementById(s)) && v(t, a) && a.id === s)\n                            return n.push(a), n\n                    } else {\n                        if (o[2])\n                            return M.apply(n, t.getElementsByTagName(e)), n;\n                        if ((s = o[3]) && r.getElementsByClassName && t.getElementsByClassName)\n                            return M.apply(n, t.getElementsByClassName(s)), n\n                    }\n                if (r.qsa && (!g || !g.test(e))) {\n                    if (m = d = b, y = t, x = 9 === l && e, 1 === l && "object" !== t.nodeName.toLowerCase()) {\n                        c = mt(e), (d = t.getAttribute("id")) ? m = d.replace(nt, "\\\\$&") : t.setAttribute("id", m), m = "[id=\'" + m + "\'] ", u = c.length;\n                        while (u--)\n                            c[u] = m + yt(c[u]);\n                        y = V.test(e) && t.parentNode || t, x = c.join(",")\n                    }\n                    if (x)\n                        try {\n                            return M.apply(n, y.querySelectorAll(x)), n\n                        } catch (T) {\n                        } finally {\n                            d || t.removeAttribute("id")\n                        }\n                }\n            }\n            return kt(e.replace(z, "$1"), t, n, i)\n        }\n        function st() {\n            var e = [];\n            function t(n, r) {\n                return e.push(n += " ") > o.cacheLength && delete t[e.shift()], t[n] = r\n            }\n            return t\n        }\n        function lt(e) {\n            return e[b] = !0, e\n        }\n        function ut(e) {\n            var t = f.createElement("div");\n            try {\n                return!!e(t)\n            } catch (n) {\n                return!1\n            } finally {\n                t.parentNode && t.parentNode.removeChild(t), t = null\n            }\n        }\n        function ct(e, t) {\n            var n = e.split("|"), r = e.length;\n            while (r--)\n                o.attrHandle[n[r]] = t\n        }\n        function pt(e, t) {\n            var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || D) - (~e.sourceIndex || D);\n            if (r)\n                return r;\n            if (n)\n                while (n = n.nextSibling)\n                    if (n === t)\n                        return-1;\n            return e ? 1 : -1\n        }\n        function ft(e) {\n            return function (t) {\n                var n = t.nodeName.toLowerCase();\n                return"input" === n && t.type === e\n            }\n        }\n        function dt(e) {\n            return function (t) {\n                var n = t.nodeName.toLowerCase();\n                return("input" === n || "button" === n) && t.type === e\n            }\n        }\n        function ht(e) {\n            return lt(function (t) {\n                return t = +t, lt(function (n, r) {\n                    var i, o = e([], n.length, t), a = o.length;\n                    while (a--)\n                        n[i = o[a]] && (n[i] = !(r[i] = n[i]))\n                })\n            })\n        }\n        s = at.isXML = function (e) {\n            var t = e && (e.ownerDocument || e).documentElement;\n            return t ? "HTML" !== t.nodeName : !1\n        }, r = at.support = {}, p = at.setDocument = function (e) {\n            var n = e ? e.ownerDocument || e : w, i = n.defaultView;\n            return n !== f && 9 === n.nodeType && n.documentElement ? (f = n, d = n.documentElement, h = !s(n), i && i.attachEvent && i !== i.top && i.attachEvent("onbeforeunload", function () {\n                p()\n            }), r.attributes = ut(function (e) {\n                return e.className = "i", !e.getAttribute("className")\n            }), r.getElementsByTagName = ut(function (e) {\n                return e.appendChild(n.createComment("")), !e.getElementsByTagName("*").length\n            }), r.getElementsByClassName = ut(function (e) {\n                return e.innerHTML = "<div class=\'a\'></div><div class=\'a i\'></div>", e.firstChild.className = "i", 2 === e.getElementsByClassName("i").length\n            }), r.getById = ut(function (e) {\n                return d.appendChild(e).id = b, !n.getElementsByName || !n.getElementsByName(b).length\n            }), r.getById ? (o.find.ID = function (e, t) {\n                if (typeof t.getElementById !== j && h) {\n                    var n = t.getElementById(e);\n                    return n && n.parentNode ? [n] : []\n                }\n            }, o.filter.ID = function (e) {\n                var t = e.replace(rt, it);\n                return function (e) {\n                    return e.getAttribute("id") === t\n                }\n            }) : (delete o.find.ID, o.filter.ID = function (e) {\n                var t = e.replace(rt, it);\n                return function (e) {\n                    var n = typeof e.getAttributeNode !== j && e.getAttributeNode("id");\n                    return n && n.value === t\n                }\n            }), o.find.TAG = r.getElementsByTagName ? function (e, n) {\n                return typeof n.getElementsByTagName !== j ? n.getElementsByTagName(e) : t\n            } : function (e, t) {\n                var n, r = [], i = 0, o = t.getElementsByTagName(e);\n                if ("*" === e) {\n                    while (n = o[i++])\n                        1 === n.nodeType && r.push(n);\n                    return r\n                }\n                return o\n            }, o.find.CLASS = r.getElementsByClassName && function (e, n) {\n                return typeof n.getElementsByClassName !== j && h ? n.getElementsByClassName(e) : t\n            }, m = [], g = [], (r.qsa = K.test(n.querySelectorAll)) && (ut(function (e) {\n                e.innerHTML = "<select><option selected=\'\'></option></select>", e.querySelectorAll("[selected]").length || g.push("\\\\[" + P + "*(?:value|" + B + ")"), e.querySelectorAll(":checked").length || g.push(":checked")\n            }), ut(function (e) {\n                var t = n.createElement("input");\n                t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("t", ""), e.querySelectorAll("[t^=\'\']").length && g.push("[*^$]=" + P + "*(?:\'\'|\\"\\")"), e.querySelectorAll(":enabled").length || g.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), g.push(",.*:")\n            })), (r.matchesSelector = K.test(y = d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.msMatchesSelector)) && ut(function (e) {\n                r.disconnectedMatch = y.call(e, "div"), y.call(e, "[s!=\'\']:x"), m.push("!=", I)\n            }), g = g.length && RegExp(g.join("|")), m = m.length && RegExp(m.join("|")), v = K.test(d.contains) || d.compareDocumentPosition ? function (e, t) {\n                var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode;\n                return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))\n            } : function (e, t) {\n                if (t)\n                    while (t = t.parentNode)\n                        if (t === e)\n                            return!0;\n                return!1\n            }, A = d.compareDocumentPosition ? function (e, t) {\n                if (e === t)\n                    return S = !0, 0;\n                var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition(t);\n                return i ? 1 & i || !r.sortDetached && t.compareDocumentPosition(e) === i ? e === n || v(w, e) ? -1 : t === n || v(w, t) ? 1 : c ? F.call(c, e) - F.call(c, t) : 0 : 4 & i ? -1 : 1 : e.compareDocumentPosition ? -1 : 1\n            } : function (e, t) {\n                var r, i = 0, o = e.parentNode, a = t.parentNode, s = [e], l = [t];\n                if (e === t)\n                    return S = !0, 0;\n                if (!o || !a)\n                    return e === n ? -1 : t === n ? 1 : o ? -1 : a ? 1 : c ? F.call(c, e) - F.call(c, t) : 0;\n                if (o === a)\n                    return pt(e, t);\n                r = e;\n                while (r = r.parentNode)\n                    s.unshift(r);\n                r = t;\n                while (r = r.parentNode)\n                    l.unshift(r);\n                while (s[i] === l[i])\n                    i++;\n                return i ? pt(s[i], l[i]) : s[i] === w ? -1 : l[i] === w ? 1 : 0\n            }, n) : f\n        }, at.matches = function (e, t) {\n            return at(e, null, null, t)\n        }, at.matchesSelector = function (e, t) {\n            if ((e.ownerDocument || e) !== f && p(e), t = t.replace(Y, "=\'$1\']"), !(!r.matchesSelector || !h || m && m.test(t) || g && g.test(t)))\n                try {\n                    var n = y.call(e, t);\n                    if (n || r.disconnectedMatch || e.document && 11 !== e.document.nodeType)\n                        return n\n                } catch (i) {\n                }\n            return at(t, f, null, [e]).length > 0\n        }, at.contains = function (e, t) {\n            return(e.ownerDocument || e) !== f && p(e), v(e, t)\n        }, at.attr = function (e, n) {\n            (e.ownerDocument || e) !== f && p(e);\n            var i = o.attrHandle[n.toLowerCase()], a = i && L.call(o.attrHandle, n.toLowerCase()) ? i(e, n, !h) : t;\n            return a === t ? r.attributes || !h ? e.getAttribute(n) : (a = e.getAttributeNode(n)) && a.specified ? a.value : null : a\n        }, at.error = function (e) {\n            throw Error("Syntax error, unrecognized expression: " + e)\n        }, at.uniqueSort = function (e) {\n            var t, n = [], i = 0, o = 0;\n            if (S = !r.detectDuplicates, c = !r.sortStable && e.slice(0), e.sort(A), S) {\n                while (t = e[o++])\n                    t === e[o] && (i = n.push(o));\n                while (i--)\n                    e.splice(n[i], 1)\n            }\n            return e\n        }, a = at.getText = function (e) {\n            var t, n = "", r = 0, i = e.nodeType;\n            if (i) {\n                if (1 === i || 9 === i || 11 === i) {\n                    if ("string" == typeof e.textContent)\n                        return e.textContent;\n                    for (e = e.firstChild; e; e = e.nextSibling)\n                        n += a(e)\n                } else if (3 === i || 4 === i)\n                    return e.nodeValue\n            } else\n                for (; t = e[r]; r++)\n                    n += a(t);\n            return n\n        }, o = at.selectors = {cacheLength: 50, createPseudo: lt, match: Q, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", first: !0}, " ": {dir: "parentNode"}, "+": {dir: "previousSibling", first: !0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {\n                    return e[1] = e[1].replace(rt, it), e[3] = (e[4] || e[5] || "").replace(rt, it), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)\n                }, CHILD: function (e) {\n                    return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || at.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && at.error(e[0]), e\n                }, PSEUDO: function (e) {\n                    var n, r = !e[5] && e[2];\n                    return Q.CHILD.test(e[0]) ? null : (e[3] && e[4] !== t ? e[2] = e[4] : r && J.test(r) && (n = mt(r, !0)) && (n = r.indexOf(")", r.length - n) - r.length) && (e[0] = e[0].slice(0, n), e[2] = r.slice(0, n)), e.slice(0, 3))\n                }}, filter: {TAG: function (e) {\n                    var t = e.replace(rt, it).toLowerCase();\n                    return"*" === e ? function () {\n                        return!0\n                    } : function (e) {\n                        return e.nodeName && e.nodeName.toLowerCase() === t\n                    }\n                }, CLASS: function (e) {\n                    var t = N[e + " "];\n                    return t || (t = RegExp("(^|" + P + ")" + e + "(" + P + "|$)")) && N(e, function (e) {\n                        return t.test("string" == typeof e.className && e.className || typeof e.getAttribute !== j && e.getAttribute("class") || "")\n                    })\n                }, ATTR: function (e, t, n) {\n                    return function (r) {\n                        var i = at.attr(r, e);\n                        return null == i ? "!=" === t : t ? (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i + " ").indexOf(n) > -1 : "|=" === t ? i === n || i.slice(0, n.length + 1) === n + "-" : !1) : !0\n                    }\n                }, CHILD: function (e, t, n, r, i) {\n                    var o = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), s = "of-type" === t;\n                    return 1 === r && 0 === i ? function (e) {\n                        return!!e.parentNode\n                    } : function (t, n, l) {\n                        var u, c, p, f, d, h, g = o !== a ? "nextSibling" : "previousSibling", m = t.parentNode, y = s && t.nodeName.toLowerCase(), v = !l && !s;\n                        if (m) {\n                            if (o) {\n                                while (g) {\n                                    p = t;\n                                    while (p = p[g])\n                                        if (s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType)\n                                            return!1;\n                                    h = g = "only" === e && !h && "nextSibling"\n                                }\n                                return!0\n                            }\n                            if (h = [a ? m.firstChild : m.lastChild], a && v) {\n                                c = m[b] || (m[b] = {}), u = c[e] || [], d = u[0] === T && u[1], f = u[0] === T && u[2], p = d && m.childNodes[d];\n                                while (p = ++d && p && p[g] || (f = d = 0) || h.pop())\n                                    if (1 === p.nodeType && ++f && p === t) {\n                                        c[e] = [T, d, f];\n                                        break\n                                    }\n                            } else if (v && (u = (t[b] || (t[b] = {}))[e]) && u[0] === T)\n                                f = u[1];\n                            else\n                                while (p = ++d && p && p[g] || (f = d = 0) || h.pop())\n                                    if ((s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) && ++f && (v && ((p[b] || (p[b] = {}))[e] = [T, f]), p === t))\n                                        break;\n                            return f -= i, f === r || 0 === f % r && f / r >= 0\n                        }\n                    }\n                }, PSEUDO: function (e, t) {\n                    var n, r = o.pseudos[e] || o.setFilters[e.toLowerCase()] || at.error("unsupported pseudo: " + e);\n                    return r[b] ? r(t) : r.length > 1 ? (n = [e, e, "", t], o.setFilters.hasOwnProperty(e.toLowerCase()) ? lt(function (e, n) {\n                        var i, o = r(e, t), a = o.length;\n                        while (a--)\n                            i = F.call(e, o[a]), e[i] = !(n[i] = o[a])\n                    }) : function (e) {\n                        return r(e, 0, n)\n                    }) : r\n                }}, pseudos: {not: lt(function (e) {\n                    var t = [], n = [], r = l(e.replace(z, "$1"));\n                    return r[b] ? lt(function (e, t, n, i) {\n                        var o, a = r(e, null, i, []), s = e.length;\n                        while (s--)\n                            (o = a[s]) && (e[s] = !(t[s] = o))\n                    }) : function (e, i, o) {\n                        return t[0] = e, r(t, null, o, n), !n.pop()\n                    }\n                }), has: lt(function (e) {\n                    return function (t) {\n                        return at(e, t).length > 0\n                    }\n                }), contains: lt(function (e) {\n                    return function (t) {\n                        return(t.textContent || t.innerText || a(t)).indexOf(e) > -1\n                    }\n                }), lang: lt(function (e) {\n                    return G.test(e || "") || at.error("unsupported lang: " + e), e = e.replace(rt, it).toLowerCase(), function (t) {\n                        var n;\n                        do\n                            if (n = h ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang"))\n                                return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-");\n                        while ((t = t.parentNode) && 1 === t.nodeType);\n                        return!1\n                    }\n                }), target: function (t) {\n                    var n = e.location && e.location.hash;\n                    return n && n.slice(1) === t.id\n                }, root: function (e) {\n                    return e === d\n                }, focus: function (e) {\n                    return e === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)\n                }, enabled: function (e) {\n                    return e.disabled === !1\n                }, disabled: function (e) {\n                    return e.disabled === !0\n                }, checked: function (e) {\n                    var t = e.nodeName.toLowerCase();\n                    return"input" === t && !!e.checked || "option" === t && !!e.selected\n                }, selected: function (e) {\n                    return e.parentNode && e.parentNode.selectedIndex, e.selected === !0\n                }, empty: function (e) {\n                    for (e = e.firstChild; e; e = e.nextSibling)\n                        if (e.nodeName > "@" || 3 === e.nodeType || 4 === e.nodeType)\n                            return!1;\n                    return!0\n                }, parent: function (e) {\n                    return!o.pseudos.empty(e)\n                }, header: function (e) {\n                    return tt.test(e.nodeName)\n                }, input: function (e) {\n                    return et.test(e.nodeName)\n                }, button: function (e) {\n                    var t = e.nodeName.toLowerCase();\n                    return"input" === t && "button" === e.type || "button" === t\n                }, text: function (e) {\n                    var t;\n                    return"input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || t.toLowerCase() === e.type)\n                }, first: ht(function () {\n                    return[0]\n                }), last: ht(function (e, t) {\n                    return[t - 1]\n                }), eq: ht(function (e, t, n) {\n                    return[0 > n ? n + t : n]\n                }), even: ht(function (e, t) {\n                    var n = 0;\n                    for (; t > n; n += 2)\n                        e.push(n);\n                    return e\n                }), odd: ht(function (e, t) {\n                    var n = 1;\n                    for (; t > n; n += 2)\n                        e.push(n);\n                    return e\n                }), lt: ht(function (e, t, n) {\n                    var r = 0 > n ? n + t : n;\n                    for (; --r >= 0; )\n                        e.push(r);\n                    return e\n                }), gt: ht(function (e, t, n) {\n                    var r = 0 > n ? n + t : n;\n                    for (; t > ++r; )\n                        e.push(r);\n                    return e\n                })}}, o.pseudos.nth = o.pseudos.eq;\n        for (n in{radio:!0, checkbox:!0, file:!0, password:!0, image:!0})\n            o.pseudos[n] = ft(n);\n        for (n in{submit:!0, reset:!0})\n            o.pseudos[n] = dt(n);\n        function gt() {\n        }\n        gt.prototype = o.filters = o.pseudos, o.setFilters = new gt;\n        function mt(e, t) {\n            var n, r, i, a, s, l, u, c = k[e + " "];\n            if (c)\n                return t ? 0 : c.slice(0);\n            s = e, l = [], u = o.preFilter;\n            while (s) {\n                (!n || (r = X.exec(s))) && (r && (s = s.slice(r[0].length) || s), l.push(i = [])), n = !1, (r = U.exec(s)) && (n = r.shift(), i.push({value: n, type: r[0].replace(z, " ")}), s = s.slice(n.length));\n                for (a in o.filter)\n                    !(r = Q[a].exec(s)) || u[a] && !(r = u[a](r)) || (n = r.shift(), i.push({value: n, type: a, matches: r}), s = s.slice(n.length));\n                if (!n)\n                    break\n            }\n            return t ? s.length : s ? at.error(e) : k(e, l).slice(0)\n        }\n        function yt(e) {\n            var t = 0, n = e.length, r = "";\n            for (; n > t; t++)\n                r += e[t].value;\n            return r\n        }\n        function vt(e, t, n) {\n            var r = t.dir, o = n && "parentNode" === r, a = C++;\n            return t.first ? function (t, n, i) {\n                while (t = t[r])\n                    if (1 === t.nodeType || o)\n                        return e(t, n, i)\n            } : function (t, n, s) {\n                var l, u, c, p = T + " " + a;\n                if (s) {\n                    while (t = t[r])\n                        if ((1 === t.nodeType || o) && e(t, n, s))\n                            return!0\n                } else\n                    while (t = t[r])\n                        if (1 === t.nodeType || o)\n                            if (c = t[b] || (t[b] = {}), (u = c[r]) && u[0] === p) {\n                                if ((l = u[1]) === !0 || l === i)\n                                    return l === !0\n                            } else if (u = c[r] = [p], u[1] = e(t, n, s) || i, u[1] === !0)\n                                return!0\n            }\n        }\n        function bt(e) {\n            return e.length > 1 ? function (t, n, r) {\n                var i = e.length;\n                while (i--)\n                    if (!e[i](t, n, r))\n                        return!1;\n                return!0\n            } : e[0]\n        }\n        function xt(e, t, n, r, i) {\n            var o, a = [], s = 0, l = e.length, u = null != t;\n            for (; l > s; s++)\n                (o = e[s]) && (!n || n(o, r, i)) && (a.push(o), u && t.push(s));\n            return a\n        }\n        function wt(e, t, n, r, i, o) {\n            return r && !r[b] && (r = wt(r)), i && !i[b] && (i = wt(i, o)), lt(function (o, a, s, l) {\n                var u, c, p, f = [], d = [], h = a.length, g = o || Nt(t || "*", s.nodeType ? [s] : s, []), m = !e || !o && t ? g : xt(g, f, e, s, l), y = n ? i || (o ? e : h || r) ? [] : a : m;\n                if (n && n(m, y, s, l), r) {\n                    u = xt(y, d), r(u, [], s, l), c = u.length;\n                    while (c--)\n                        (p = u[c]) && (y[d[c]] = !(m[d[c]] = p))\n                }\n                if (o) {\n                    if (i || e) {\n                        if (i) {\n                            u = [], c = y.length;\n                            while (c--)\n                                (p = y[c]) && u.push(m[c] = p);\n                            i(null, y = [], u, l)\n                        }\n                        c = y.length;\n                        while (c--)\n                            (p = y[c]) && (u = i ? F.call(o, p) : f[c]) > -1 && (o[u] = !(a[u] = p))\n                    }\n                } else\n                    y = xt(y === a ? y.splice(h, y.length) : y), i ? i(null, a, y, l) : M.apply(a, y)\n            })\n        }\n        function Tt(e) {\n            var t, n, r, i = e.length, a = o.relative[e[0].type], s = a || o.relative[" "], l = a ? 1 : 0, c = vt(function (e) {\n                return e === t\n            }, s, !0), p = vt(function (e) {\n                return F.call(t, e) > -1\n            }, s, !0), f = [function (e, n, r) {\n                    return!a && (r || n !== u) || ((t = n).nodeType ? c(e, n, r) : p(e, n, r))\n                }];\n            for (; i > l; l++)\n                if (n = o.relative[e[l].type])\n                    f = [vt(bt(f), n)];\n                else {\n                    if (n = o.filter[e[l].type].apply(null, e[l].matches), n[b]) {\n                        for (r = ++l; i > r; r++)\n                            if (o.relative[e[r].type])\n                                break;\n                        return wt(l > 1 && bt(f), l > 1 && yt(e.slice(0, l - 1).concat({value: " " === e[l - 2].type ? "*" : ""})).replace(z, "$1"), n, r > l && Tt(e.slice(l, r)), i > r && Tt(e = e.slice(r)), i > r && yt(e))\n                    }\n                    f.push(n)\n                }\n            return bt(f)\n        }\n        function Ct(e, t) {\n            var n = 0, r = t.length > 0, a = e.length > 0, s = function (s, l, c, p, d) {\n                var h, g, m, y = [], v = 0, b = "0", x = s && [], w = null != d, C = u, N = s || a && o.find.TAG("*", d && l.parentNode || l), k = T += null == C ? 1 : Math.random() || .1;\n                for (w && (u = l !== f && l, i = n); null != (h = N[b]); b++) {\n                    if (a && h) {\n                        g = 0;\n                        while (m = e[g++])\n                            if (m(h, l, c)) {\n                                p.push(h);\n                                break\n                            }\n                        w && (T = k, i = ++n)\n                    }\n                    r && ((h = !m && h) && v--, s && x.push(h))\n                }\n                if (v += b, r && b !== v) {\n                    g = 0;\n                    while (m = t[g++])\n                        m(x, y, l, c);\n                    if (s) {\n                        if (v > 0)\n                            while (b--)\n                                x[b] || y[b] || (y[b] = q.call(p));\n                        y = xt(y)\n                    }\n                    M.apply(p, y), w && !s && y.length > 0 && v + t.length > 1 && at.uniqueSort(p)\n                }\n                return w && (T = k, u = C), x\n            };\n            return r ? lt(s) : s\n        }\n        l = at.compile = function (e, t) {\n            var n, r = [], i = [], o = E[e + " "];\n            if (!o) {\n                t || (t = mt(e)), n = t.length;\n                while (n--)\n                    o = Tt(t[n]), o[b] ? r.push(o) : i.push(o);\n                o = E(e, Ct(i, r))\n            }\n            return o\n        };\n        function Nt(e, t, n) {\n            var r = 0, i = t.length;\n            for (; i > r; r++)\n                at(e, t[r], n);\n            return n\n        }\n        function kt(e, t, n, i) {\n            var a, s, u, c, p, f = mt(e);\n            if (!i && 1 === f.length) {\n                if (s = f[0] = f[0].slice(0), s.length > 2 && "ID" === (u = s[0]).type && r.getById && 9 === t.nodeType && h && o.relative[s[1].type]) {\n                    if (t = (o.find.ID(u.matches[0].replace(rt, it), t) || [])[0], !t)\n                        return n;\n                    e = e.slice(s.shift().value.length)\n                }\n                a = Q.needsContext.test(e) ? 0 : s.length;\n                while (a--) {\n                    if (u = s[a], o.relative[c = u.type])\n                        break;\n                    if ((p = o.find[c]) && (i = p(u.matches[0].replace(rt, it), V.test(s[0].type) && t.parentNode || t))) {\n                        if (s.splice(a, 1), e = i.length && yt(s), !e)\n                            return M.apply(n, i), n;\n                        break\n                    }\n                }\n            }\n            return l(e, f)(i, t, !h, n, V.test(e)), n\n        }\n        r.sortStable = b.split("").sort(A).join("") === b, r.detectDuplicates = S, p(), r.sortDetached = ut(function (e) {\n            return 1 & e.compareDocumentPosition(f.createElement("div"))\n        }), ut(function (e) {\n            return e.innerHTML = "<a href=\'#\'></a>", "#" === e.firstChild.getAttribute("href")\n        }) || ct("type|href|height|width", function (e, n, r) {\n            return r ? t : e.getAttribute(n, "type" === n.toLowerCase() ? 1 : 2)\n        }), r.attributes && ut(function (e) {\n            return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")\n        }) || ct("value", function (e, n, r) {\n            return r || "input" !== e.nodeName.toLowerCase() ? t : e.defaultValue\n        }), ut(function (e) {\n            return null == e.getAttribute("disabled")\n        }) || ct(B, function (e, n, r) {\n            var i;\n            return r ? t : (i = e.getAttributeNode(n)) && i.specified ? i.value : e[n] === !0 ? n.toLowerCase() : null\n        }), x.find = at, x.expr = at.selectors, x.expr[":"] = x.expr.pseudos, x.unique = at.uniqueSort, x.text = at.getText, x.isXMLDoc = at.isXML, x.contains = at.contains\n    }(e);\n    var O = {};\n    function F(e) {\n        var t = O[e] = {};\n        return x.each(e.match(T) || [], function (e, n) {\n            t[n] = !0\n        }), t\n    }\n    x.Callbacks = function (e) {\n        e = "string" == typeof e ? O[e] || F(e) : x.extend({}, e);\n        var n, r, i, o, a, s, l = [], u = !e.once && [], c = function (t) {\n            for (r = e.memory && t, i = !0, a = s || 0, s = 0, o = l.length, n = !0; l && o > a; a++)\n                if (l[a].apply(t[0], t[1]) === !1 && e.stopOnFalse) {\n                    r = !1;\n                    break\n                }\n            n = !1, l && (u ? u.length && c(u.shift()) : r ? l = [] : p.disable())\n        }, p = {add: function () {\n                if (l) {\n                    var t = l.length;\n                    (function i(t) {\n                        x.each(t, function (t, n) {\n                            var r = x.type(n);\n                            "function" === r ? e.unique && p.has(n) || l.push(n) : n && n.length && "string" !== r && i(n)\n                        })\n                    })(arguments), n ? o = l.length : r && (s = t, c(r))\n                }\n                return this\n            }, remove: function () {\n                return l && x.each(arguments, function (e, t) {\n                    var r;\n                    while ((r = x.inArray(t, l, r)) > - 1)\n                        l.splice(r, 1), n && (o >= r && o--, a >= r && a--)\n                }), this\n            }, has: function (e) {\n                return e ? x.inArray(e, l) > -1 : !(!l || !l.length)\n            }, empty: function () {\n                return l = [], o = 0, this\n            }, disable: function () {\n                return l = u = r = t, this\n            }, disabled: function () {\n                return!l\n            }, lock: function () {\n                return u = t, r || p.disable(), this\n            }, locked: function () {\n                return!u\n            }, fireWith: function (e, t) {\n                return!l || i && !u || (t = t || [], t = [e, t.slice ? t.slice() : t], n ? u.push(t) : c(t)), this\n            }, fire: function () {\n                return p.fireWith(this, arguments), this\n            }, fired: function () {\n                return!!i\n            }};\n        return p\n    }, x.extend({Deferred: function (e) {\n            var t = [["resolve", "done", x.Callbacks("once memory"), "resolved"], ["reject", "fail", x.Callbacks("once memory"), "rejected"], ["notify", "progress", x.Callbacks("memory")]], n = "pending", r = {state: function () {\n                    return n\n                }, always: function () {\n                    return i.done(arguments).fail(arguments), this\n                }, then: function () {\n                    var e = arguments;\n                    return x.Deferred(function (n) {\n                        x.each(t, function (t, o) {\n                            var a = o[0], s = x.isFunction(e[t]) && e[t];\n                            i[o[1]](function () {\n                                var e = s && s.apply(this, arguments);\n                                e && x.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[a + "With"](this === r ? n.promise() : this, s ? [e] : arguments)\n                            })\n                        }), e = null\n                    }).promise()\n                }, promise: function (e) {\n                    return null != e ? x.extend(e, r) : r\n                }}, i = {};\n            return r.pipe = r.then, x.each(t, function (e, o) {\n                var a = o[2], s = o[3];\n                r[o[1]] = a.add, s && a.add(function () {\n                    n = s\n                }, t[1 ^ e][2].disable, t[2][2].lock), i[o[0]] = function () {\n                    return i[o[0] + "With"](this === i ? r : this, arguments), this\n                }, i[o[0] + "With"] = a.fireWith\n            }), r.promise(i), e && e.call(i, i), i\n        }, when: function (e) {\n            var t = 0, n = g.call(arguments), r = n.length, i = 1 !== r || e && x.isFunction(e.promise) ? r : 0, o = 1 === i ? e : x.Deferred(), a = function (e, t, n) {\n                return function (r) {\n                    t[e] = this, n[e] = arguments.length > 1 ? g.call(arguments) : r, n === s ? o.notifyWith(t, n) : --i || o.resolveWith(t, n)\n                }\n            }, s, l, u;\n            if (r > 1)\n                for (s = Array(r), l = Array(r), u = Array(r); r > t; t++)\n                    n[t] && x.isFunction(n[t].promise) ? n[t].promise().done(a(t, u, n)).fail(o.reject).progress(a(t, l, s)) : --i;\n            return i || o.resolveWith(u, n), o.promise()\n        }}), x.support = function (t) {\n        var n, r, o, s, l, u, c, p, f, d = a.createElement("div");\n        if (d.setAttribute("className", "t"), d.innerHTML = "  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>", n = d.getElementsByTagName("*") || [], r = d.getElementsByTagName("a")[0], !r || !r.style || !n.length)\n            return t;\n        s = a.createElement("select"), u = s.appendChild(a.createElement("option")), o = d.getElementsByTagName("input")[0], r.style.cssText = "top:1px;float:left;opacity:.5", t.getSetAttribute = "t" !== d.className, t.leadingWhitespace = 3 === d.firstChild.nodeType, t.tbody = !d.getElementsByTagName("tbody").length, t.htmlSerialize = !!d.getElementsByTagName("link").length, t.style = /top/.test(r.getAttribute("style")), t.hrefNormalized = "/a" === r.getAttribute("href"), t.opacity = /^0.5/.test(r.style.opacity), t.cssFloat = !!r.style.cssFloat, t.checkOn = !!o.value, t.optSelected = u.selected, t.enctype = !!a.createElement("form").enctype, t.html5Clone = "<:nav></:nav>" !== a.createElement("nav").cloneNode(!0).outerHTML, t.inlineBlockNeedsLayout = !1, t.shrinkWrapBlocks = !1, t.pixelPosition = !1, t.deleteExpando = !0, t.noCloneEvent = !0, t.reliableMarginRight = !0, t.boxSizingReliable = !0, o.checked = !0, t.noCloneChecked = o.cloneNode(!0).checked, s.disabled = !0, t.optDisabled = !u.disabled;\n        try {\n            delete d.test\n        } catch (h) {\n            t.deleteExpando = !1\n        }\n        o = a.createElement("input"), o.setAttribute("value", ""), t.input = "" === o.getAttribute("value"), o.value = "t", o.setAttribute("type", "radio"), t.radioValue = "t" === o.value, o.setAttribute("checked", "t"), o.setAttribute("name", "t"), l = a.createDocumentFragment(), l.appendChild(o), t.appendChecked = o.checked, t.checkClone = l.cloneNode(!0).cloneNode(!0).lastChild.checked, d.attachEvent && (d.attachEvent("onclick", function () {\n            t.noCloneEvent = !1\n        }), d.cloneNode(!0).click());\n        for (f in{submit:!0, change:!0, focusin:!0})\n            d.setAttribute(c = "on" + f, "t"), t[f + "Bubbles"] = c in e || d.attributes[c].expando === !1;\n        d.style.backgroundClip = "content-box", d.cloneNode(!0).style.backgroundClip = "", t.clearCloneStyle = "content-box" === d.style.backgroundClip;\n        for (f in x(t))\n            break;\n        return t.ownLast = "0" !== f, x(function () {\n            var n, r, o, s = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;", l = a.getElementsByTagName("body")[0];\n            l && (n = a.createElement("div"), n.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", l.appendChild(n).appendChild(d), d.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", o = d.getElementsByTagName("td"), o[0].style.cssText = "padding:0;margin:0;border:0;display:none", p = 0 === o[0].offsetHeight, o[0].style.display = "", o[1].style.display = "none", t.reliableHiddenOffsets = p && 0 === o[0].offsetHeight, d.innerHTML = "", d.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;", x.swap(l, null != l.style.zoom ? {zoom: 1} : {}, function () {\n                t.boxSizing = 4 === d.offsetWidth\n            }), e.getComputedStyle && (t.pixelPosition = "1%" !== (e.getComputedStyle(d, null) || {}).top, t.boxSizingReliable = "4px" === (e.getComputedStyle(d, null) || {width: "4px"}).width, r = d.appendChild(a.createElement("div")), r.style.cssText = d.style.cssText = s, r.style.marginRight = r.style.width = "0", d.style.width = "1px", t.reliableMarginRight = !parseFloat((e.getComputedStyle(r, null) || {}).marginRight)), typeof d.style.zoom !== i && (d.innerHTML = "", d.style.cssText = s + "width:1px;padding:1px;display:inline;zoom:1", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display = "block", d.innerHTML = "<div></div>", d.firstChild.style.width = "5px", t.shrinkWrapBlocks = 3 !== d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild(n), n = d = o = r = null)\n        }), n = s = l = u = r = o = null, t\n    }({});\n    var B = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/, P = /([A-Z])/g;\n    function R(e, n, r, i) {\n        if (x.acceptData(e)) {\n            var o, a, s = x.expando, l = e.nodeType, u = l ? x.cache : e, c = l ? e[s] : e[s] && s;\n            if (c && u[c] && (i || u[c].data) || r !== t || "string" != typeof n)\n                return c || (c = l ? e[s] = p.pop() || x.guid++ : s), u[c] || (u[c] = l ? {} : {toJSON: x.noop}), ("object" == typeof n || "function" == typeof n) && (i ? u[c] = x.extend(u[c], n) : u[c].data = x.extend(u[c].data, n)), a = u[c], i || (a.data || (a.data = {}), a = a.data), r !== t && (a[x.camelCase(n)] = r), "string" == typeof n ? (o = a[n], null == o && (o = a[x.camelCase(n)])) : o = a, o\n        }\n    }\n    function W(e, t, n) {\n        if (x.acceptData(e)) {\n            var r, i, o = e.nodeType, a = o ? x.cache : e, s = o ? e[x.expando] : x.expando;\n            if (a[s]) {\n                if (t && (r = n ? a[s] : a[s].data)) {\n                    x.isArray(t) ? t = t.concat(x.map(t, x.camelCase)) : t in r ? t = [t] : (t = x.camelCase(t), t = t in r ? [t] : t.split(" ")), i = t.length;\n                    while (i--)\n                        delete r[t[i]];\n                    if (n ? !I(r) : !x.isEmptyObject(r))\n                        return\n                }\n                (n || (delete a[s].data, I(a[s]))) && (o ? x.cleanData([e], !0) : x.support.deleteExpando || a != a.window ? delete a[s] : a[s] = null)\n            }\n        }\n    }\n    x.extend({cache: {}, noData: {applet: !0, embed: !0, object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"}, hasData: function (e) {\n            return e = e.nodeType ? x.cache[e[x.expando]] : e[x.expando], !!e && !I(e)\n        }, data: function (e, t, n) {\n            return R(e, t, n)\n        }, removeData: function (e, t) {\n            return W(e, t)\n        }, _data: function (e, t, n) {\n            return R(e, t, n, !0)\n        }, _removeData: function (e, t) {\n            return W(e, t, !0)\n        }, acceptData: function (e) {\n            if (e.nodeType && 1 !== e.nodeType && 9 !== e.nodeType)\n                return!1;\n            var t = e.nodeName && x.noData[e.nodeName.toLowerCase()];\n            return!t || t !== !0 && e.getAttribute("classid") === t\n        }}), x.fn.extend({data: function (e, n) {\n            var r, i, o = null, a = 0, s = this[0];\n            if (e === t) {\n                if (this.length && (o = x.data(s), 1 === s.nodeType && !x._data(s, "parsedAttrs"))) {\n                    for (r = s.attributes; r.length > a; a++)\n                        i = r[a].name, 0 === i.indexOf("data-") && (i = x.camelCase(i.slice(5)), $(s, i, o[i]));\n                    x._data(s, "parsedAttrs", !0)\n                }\n                return o\n            }\n            return"object" == typeof e ? this.each(function () {\n                x.data(this, e)\n            }) : arguments.length > 1 ? this.each(function () {\n                x.data(this, e, n)\n            }) : s ? $(s, e, x.data(s, e)) : null\n        }, removeData: function (e) {\n            return this.each(function () {\n                x.removeData(this, e)\n            })\n        }});\n    function $(e, n, r) {\n        if (r === t && 1 === e.nodeType) {\n            var i = "data-" + n.replace(P, "-$1").toLowerCase();\n            if (r = e.getAttribute(i), "string" == typeof r) {\n                try {\n                    r = "true" === r ? !0 : "false" === r ? !1 : "null" === r ? null : +r + "" === r ? +r : B.test(r) ? x.parseJSON(r) : r\n                } catch (o) {\n                }\n                x.data(e, n, r)\n            } else\n                r = t\n        }\n        return r\n    }\n    function I(e) {\n        var t;\n        for (t in e)\n            if (("data" !== t || !x.isEmptyObject(e[t])) && "toJSON" !== t)\n                return!1;\n        return!0\n    }\n    x.extend({queue: function (e, n, r) {\n            var i;\n            return e ? (n = (n || "fx") + "queue", i = x._data(e, n), r && (!i || x.isArray(r) ? i = x._data(e, n, x.makeArray(r)) : i.push(r)), i || []) : t\n        }, dequeue: function (e, t) {\n            t = t || "fx";\n            var n = x.queue(e, t), r = n.length, i = n.shift(), o = x._queueHooks(e, t), a = function () {\n                x.dequeue(e, t)\n            };\n            "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire()\n        }, _queueHooks: function (e, t) {\n            var n = t + "queueHooks";\n            return x._data(e, n) || x._data(e, n, {empty: x.Callbacks("once memory").add(function () {\n                    x._removeData(e, t + "queue"), x._removeData(e, n)\n                })})\n        }}), x.fn.extend({queue: function (e, n) {\n            var r = 2;\n            return"string" != typeof e && (n = e, e = "fx", r--), r > arguments.length ? x.queue(this[0], e) : n === t ? this : this.each(function () {\n                var t = x.queue(this, e, n);\n                x._queueHooks(this, e), "fx" === e && "inprogress" !== t[0] && x.dequeue(this, e)\n            })\n        }, dequeue: function (e) {\n            return this.each(function () {\n                x.dequeue(this, e)\n            })\n        }, delay: function (e, t) {\n            return e = x.fx ? x.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function (t, n) {\n                var r = setTimeout(t, e);\n                n.stop = function () {\n                    clearTimeout(r)\n                }\n            })\n        }, clearQueue: function (e) {\n            return this.queue(e || "fx", [])\n        }, promise: function (e, n) {\n            var r, i = 1, o = x.Deferred(), a = this, s = this.length, l = function () {\n                --i || o.resolveWith(a, [a])\n            };\n            "string" != typeof e && (n = e, e = t), e = e || "fx";\n            while (s--)\n                r = x._data(a[s], e + "queueHooks"), r && r.empty && (i++, r.empty.add(l));\n            return l(), o.promise(n)\n        }});\n    var z, X, U = /[\\t\\r\\n\\f]/g, V = /\\r/g, Y = /^(?:input|select|textarea|button|object)$/i, J = /^(?:a|area)$/i, G = /^(?:checked|selected)$/i, Q = x.support.getSetAttribute, K = x.support.input;\n    x.fn.extend({attr: function (e, t) {\n            return x.access(this, x.attr, e, t, arguments.length > 1)\n        }, removeAttr: function (e) {\n            return this.each(function () {\n                x.removeAttr(this, e)\n            })\n        }, prop: function (e, t) {\n            return x.access(this, x.prop, e, t, arguments.length > 1)\n        }, removeProp: function (e) {\n            return e = x.propFix[e] || e, this.each(function () {\n                try {\n                    this[e] = t, delete this[e]\n                } catch (n) {\n                }\n            })\n        }, addClass: function (e) {\n            var t, n, r, i, o, a = 0, s = this.length, l = "string" == typeof e && e;\n            if (x.isFunction(e))\n                return this.each(function (t) {\n                    x(this).addClass(e.call(this, t, this.className))\n                });\n            if (l)\n                for (t = (e || "").match(T) || []; s > a; a++)\n                    if (n = this[a], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(U, " ") : " ")) {\n                        o = 0;\n                        while (i = t[o++])\n                            0 > r.indexOf(" " + i + " ") && (r += i + " ");\n                        n.className = x.trim(r)\n                    }\n            return this\n        }, removeClass: function (e) {\n            var t, n, r, i, o, a = 0, s = this.length, l = 0 === arguments.length || "string" == typeof e && e;\n            if (x.isFunction(e))\n                return this.each(function (t) {\n                    x(this).removeClass(e.call(this, t, this.className))\n                });\n            if (l)\n                for (t = (e || "").match(T) || []; s > a; a++)\n                    if (n = this[a], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(U, " ") : "")) {\n                        o = 0;\n                        while (i = t[o++])\n                            while (r.indexOf(" " + i + " ") >= 0)\n                                r = r.replace(" " + i + " ", " ");\n                        n.className = e ? x.trim(r) : ""\n                    }\n            return this\n        }, toggleClass: function (e, t) {\n            var n = typeof e;\n            return"boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : x.isFunction(e) ? this.each(function (n) {\n                x(this).toggleClass(e.call(this, n, this.className, t), t)\n            }) : this.each(function () {\n                if ("string" === n) {\n                    var t, r = 0, o = x(this), a = e.match(T) || [];\n                    while (t = a[r++])\n                        o.hasClass(t) ? o.removeClass(t) : o.addClass(t)\n                } else\n                    (n === i || "boolean" === n) && (this.className && x._data(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : x._data(this, "__className__") || "")\n            })\n        }, hasClass: function (e) {\n            var t = " " + e + " ", n = 0, r = this.length;\n            for (; r > n; n++)\n                if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(U, " ").indexOf(t) >= 0)\n                    return!0;\n            return!1\n        }, val: function (e) {\n            var n, r, i, o = this[0];\n            {\n                if (arguments.length)\n                    return i = x.isFunction(e), this.each(function (n) {\n                        var o;\n                        1 === this.nodeType && (o = i ? e.call(this, n, x(this).val()) : e, null == o ? o = "" : "number" == typeof o ? o += "" : x.isArray(o) && (o = x.map(o, function (e) {\n                            return null == e ? "" : e + ""\n                        })), r = x.valHooks[this.type] || x.valHooks[this.nodeName.toLowerCase()], r && "set"in r && r.set(this, o, "value") !== t || (this.value = o))\n                    });\n                if (o)\n                    return r = x.valHooks[o.type] || x.valHooks[o.nodeName.toLowerCase()], r && "get"in r && (n = r.get(o, "value")) !== t ? n : (n = o.value, "string" == typeof n ? n.replace(V, "") : null == n ? "" : n)\n            }\n        }}), x.extend({valHooks: {option: {get: function (e) {\n                    var t = x.find.attr(e, "value");\n                    return null != t ? t : e.text\n                }}, select: {get: function (e) {\n                    var t, n, r = e.options, i = e.selectedIndex, o = "select-one" === e.type || 0 > i, a = o ? null : [], s = o ? i + 1 : r.length, l = 0 > i ? s : o ? i : 0;\n                    for (; s > l; l++)\n                        if (n = r[l], !(!n.selected && l !== i || (x.support.optDisabled ? n.disabled : null !== n.getAttribute("disabled")) || n.parentNode.disabled && x.nodeName(n.parentNode, "optgroup"))) {\n                            if (t = x(n).val(), o)\n                                return t;\n                            a.push(t)\n                        }\n                    return a\n                }, set: function (e, t) {\n                    var n, r, i = e.options, o = x.makeArray(t), a = i.length;\n                    while (a--)\n                        r = i[a], (r.selected = x.inArray(x(r).val(), o) >= 0) && (n = !0);\n                    return n || (e.selectedIndex = -1), o\n                }}}, attr: function (e, n, r) {\n            var o, a, s = e.nodeType;\n            if (e && 3 !== s && 8 !== s && 2 !== s)\n                return typeof e.getAttribute === i ? x.prop(e, n, r) : (1 === s && x.isXMLDoc(e) || (n = n.toLowerCase(), o = x.attrHooks[n] || (x.expr.match.bool.test(n) ? X : z)), r === t ? o && "get"in o && null !== (a = o.get(e, n)) ? a : (a = x.find.attr(e, n), null == a ? t : a) : null !== r ? o && "set"in o && (a = o.set(e, r, n)) !== t ? a : (e.setAttribute(n, r + ""), r) : (x.removeAttr(e, n), t))\n        }, removeAttr: function (e, t) {\n            var n, r, i = 0, o = t && t.match(T);\n            if (o && 1 === e.nodeType)\n                while (n = o[i++])\n                    r = x.propFix[n] || n, x.expr.match.bool.test(n) ? K && Q || !G.test(n) ? e[r] = !1 : e[x.camelCase("default-" + n)] = e[r] = !1 : x.attr(e, n, ""), e.removeAttribute(Q ? n : r)\n        }, attrHooks: {type: {set: function (e, t) {\n                    if (!x.support.radioValue && "radio" === t && x.nodeName(e, "input")) {\n                        var n = e.value;\n                        return e.setAttribute("type", t), n && (e.value = n), t\n                    }\n                }}}, propFix: {"for": "htmlFor", "class": "className"}, prop: function (e, n, r) {\n            var i, o, a, s = e.nodeType;\n            if (e && 3 !== s && 8 !== s && 2 !== s)\n                return a = 1 !== s || !x.isXMLDoc(e), a && (n = x.propFix[n] || n, o = x.propHooks[n]), r !== t ? o && "set"in o && (i = o.set(e, r, n)) !== t ? i : e[n] = r : o && "get"in o && null !== (i = o.get(e, n)) ? i : e[n]\n        }, propHooks: {tabIndex: {get: function (e) {\n                    var t = x.find.attr(e, "tabindex");\n                    return t ? parseInt(t, 10) : Y.test(e.nodeName) || J.test(e.nodeName) && e.href ? 0 : -1\n                }}}}), X = {set: function (e, t, n) {\n            return t === !1 ? x.removeAttr(e, n) : K && Q || !G.test(n) ? e.setAttribute(!Q && x.propFix[n] || n, n) : e[x.camelCase("default-" + n)] = e[n] = !0, n\n        }}, x.each(x.expr.match.bool.source.match(/\\w+/g), function (e, n) {\n        var r = x.expr.attrHandle[n] || x.find.attr;\n        x.expr.attrHandle[n] = K && Q || !G.test(n) ? function (e, n, i) {\n            var o = x.expr.attrHandle[n], a = i ? t : (x.expr.attrHandle[n] = t) != r(e, n, i) ? n.toLowerCase() : null;\n            return x.expr.attrHandle[n] = o, a\n        } : function (e, n, r) {\n            return r ? t : e[x.camelCase("default-" + n)] ? n.toLowerCase() : null\n        }\n    }), K && Q || (x.attrHooks.value = {set: function (e, n, r) {\n            return x.nodeName(e, "input") ? (e.defaultValue = n, t) : z && z.set(e, n, r)\n        }}), Q || (z = {set: function (e, n, r) {\n            var i = e.getAttributeNode(r);\n            return i || e.setAttributeNode(i = e.ownerDocument.createAttribute(r)), i.value = n += "", "value" === r || n === e.getAttribute(r) ? n : t\n        }}, x.expr.attrHandle.id = x.expr.attrHandle.name = x.expr.attrHandle.coords = function (e, n, r) {\n        var i;\n        return r ? t : (i = e.getAttributeNode(n)) && "" !== i.value ? i.value : null\n    }, x.valHooks.button = {get: function (e, n) {\n            var r = e.getAttributeNode(n);\n            return r && r.specified ? r.value : t\n        }, set: z.set}, x.attrHooks.contenteditable = {set: function (e, t, n) {\n            z.set(e, "" === t ? !1 : t, n)\n        }}, x.each(["width", "height"], function (e, n) {\n        x.attrHooks[n] = {set: function (e, r) {\n                return"" === r ? (e.setAttribute(n, "auto"), r) : t\n            }}\n    })), x.support.hrefNormalized || x.each(["href", "src"], function (e, t) {\n        x.propHooks[t] = {get: function (e) {\n                return e.getAttribute(t, 4)\n            }}\n    }), x.support.style || (x.attrHooks.style = {get: function (e) {\n            return e.style.cssText || t\n        }, set: function (e, t) {\n            return e.style.cssText = t + ""\n        }}), x.support.optSelected || (x.propHooks.selected = {get: function (e) {\n            var t = e.parentNode;\n            return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null\n        }}), x.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {\n        x.propFix[this.toLowerCase()] = this\n    }), x.support.enctype || (x.propFix.enctype = "encoding"), x.each(["radio", "checkbox"], function () {\n        x.valHooks[this] = {set: function (e, n) {\n                return x.isArray(n) ? e.checked = x.inArray(x(e).val(), n) >= 0 : t\n            }}, x.support.checkOn || (x.valHooks[this].get = function (e) {\n            return null === e.getAttribute("value") ? "on" : e.value\n        })\n    });\n    var Z = /^(?:input|select|textarea)$/i, et = /^key/, tt = /^(?:mouse|contextmenu)|click/, nt = /^(?:focusinfocus|focusoutblur)$/, rt = /^([^.]*)(?:\\.(.+)|)$/;\n    function it() {\n        return!0\n    }\n    function ot() {\n        return!1\n    }\n    function at() {\n        try {\n            return a.activeElement\n        } catch (e) {\n        }\n    }\n    x.event = {global: {}, add: function (e, n, r, o, a) {\n            var s, l, u, c, p, f, d, h, g, m, y, v = x._data(e);\n            if (v) {\n                r.handler && (c = r, r = c.handler, a = c.selector), r.guid || (r.guid = x.guid++), (l = v.events) || (l = v.events = {}), (f = v.handle) || (f = v.handle = function (e) {\n                    return typeof x === i || e && x.event.triggered === e.type ? t : x.event.dispatch.apply(f.elem, arguments)\n                }, f.elem = e), n = (n || "").match(T) || [""], u = n.length;\n                while (u--)\n                    s = rt.exec(n[u]) || [], g = y = s[1], m = (s[2] || "").split(".").sort(), g && (p = x.event.special[g] || {}, g = (a ? p.delegateType : p.bindType) || g, p = x.event.special[g] || {}, d = x.extend({type: g, origType: y, data: o, handler: r, guid: r.guid, selector: a, needsContext: a && x.expr.match.needsContext.test(a), namespace: m.join(".")}, c), (h = l[g]) || (h = l[g] = [], h.delegateCount = 0, p.setup && p.setup.call(e, o, m, f) !== !1 || (e.addEventListener ? e.addEventListener(g, f, !1) : e.attachEvent && e.attachEvent("on" + g, f))), p.add && (p.add.call(e, d), d.handler.guid || (d.handler.guid = r.guid)), a ? h.splice(h.delegateCount++, 0, d) : h.push(d), x.event.global[g] = !0);\n                e = null\n            }\n        }, remove: function (e, t, n, r, i) {\n            var o, a, s, l, u, c, p, f, d, h, g, m = x.hasData(e) && x._data(e);\n            if (m && (c = m.events)) {\n                t = (t || "").match(T) || [""], u = t.length;\n                while (u--)\n                    if (s = rt.exec(t[u]) || [], d = g = s[1], h = (s[2] || "").split(".").sort(), d) {\n                        p = x.event.special[d] || {}, d = (r ? p.delegateType : p.bindType) || d, f = c[d] || [], s = s[2] && RegExp("(^|\\\\.)" + h.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)"), l = o = f.length;\n                        while (o--)\n                            a = f[o], !i && g !== a.origType || n && n.guid !== a.guid || s && !s.test(a.namespace) || r && r !== a.selector && ("**" !== r || !a.selector) || (f.splice(o, 1), a.selector && f.delegateCount--, p.remove && p.remove.call(e, a));\n                        l && !f.length && (p.teardown && p.teardown.call(e, h, m.handle) !== !1 || x.removeEvent(e, d, m.handle), delete c[d])\n                    } else\n                        for (d in c)\n                            x.event.remove(e, d + t[u], n, r, !0);\n                x.isEmptyObject(c) && (delete m.handle, x._removeData(e, "events"))\n            }\n        }, trigger: function (n, r, i, o) {\n            var s, l, u, c, p, f, d, h = [i || a], g = v.call(n, "type") ? n.type : n, m = v.call(n, "namespace") ? n.namespace.split(".") : [];\n            if (u = f = i = i || a, 3 !== i.nodeType && 8 !== i.nodeType && !nt.test(g + x.event.triggered) && (g.indexOf(".") >= 0 && (m = g.split("."), g = m.shift(), m.sort()), l = 0 > g.indexOf(":") && "on" + g, n = n[x.expando] ? n : new x.Event(g, "object" == typeof n && n), n.isTrigger = o ? 2 : 3, n.namespace = m.join("."), n.namespace_re = n.namespace ? RegExp("(^|\\\\.)" + m.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)") : null, n.result = t, n.target || (n.target = i), r = null == r ? [n] : x.makeArray(r, [n]), p = x.event.special[g] || {}, o || !p.trigger || p.trigger.apply(i, r) !== !1)) {\n                if (!o && !p.noBubble && !x.isWindow(i)) {\n                    for (c = p.delegateType || g, nt.test(c + g) || (u = u.parentNode); u; u = u.parentNode)\n                        h.push(u), f = u;\n                    f === (i.ownerDocument || a) && h.push(f.defaultView || f.parentWindow || e)\n                }\n                d = 0;\n                while ((u = h[d++]) && !n.isPropagationStopped())\n                    n.type = d > 1 ? c : p.bindType || g, s = (x._data(u, "events") || {})[n.type] && x._data(u, "handle"), s && s.apply(u, r), s = l && u[l], s && x.acceptData(u) && s.apply && s.apply(u, r) === !1 && n.preventDefault();\n                if (n.type = g, !o && !n.isDefaultPrevented() && (!p._default || p._default.apply(h.pop(), r) === !1) && x.acceptData(i) && l && i[g] && !x.isWindow(i)) {\n                    f = i[l], f && (i[l] = null), x.event.triggered = g;\n                    try {\n                        i[g]()\n                    } catch (y) {\n                    }\n                    x.event.triggered = t, f && (i[l] = f)\n                }\n                return n.result\n            }\n        }, dispatch: function (e) {\n            e = x.event.fix(e);\n            var n, r, i, o, a, s = [], l = g.call(arguments), u = (x._data(this, "events") || {})[e.type] || [], c = x.event.special[e.type] || {};\n            if (l[0] = e, e.delegateTarget = this, !c.preDispatch || c.preDispatch.call(this, e) !== !1) {\n                s = x.event.handlers.call(this, e, u), n = 0;\n                while ((o = s[n++]) && !e.isPropagationStopped()) {\n                    e.currentTarget = o.elem, a = 0;\n                    while ((i = o.handlers[a++]) && !e.isImmediatePropagationStopped())\n                        (!e.namespace_re || e.namespace_re.test(i.namespace)) && (e.handleObj = i, e.data = i.data, r = ((x.event.special[i.origType] || {}).handle || i.handler).apply(o.elem, l), r !== t && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()))\n                }\n                return c.postDispatch && c.postDispatch.call(this, e), e.result\n            }\n        }, handlers: function (e, n) {\n            var r, i, o, a, s = [], l = n.delegateCount, u = e.target;\n            if (l && u.nodeType && (!e.button || "click" !== e.type))\n                for (; u != this; u = u.parentNode || this)\n                    if (1 === u.nodeType && (u.disabled !== !0 || "click" !== e.type)) {\n                        for (o = [], a = 0; l > a; a++)\n                            i = n[a], r = i.selector + " ", o[r] === t && (o[r] = i.needsContext ? x(r, this).index(u) >= 0 : x.find(r, this, null, [u]).length), o[r] && o.push(i);\n                        o.length && s.push({elem: u, handlers: o})\n                    }\n            return n.length > l && s.push({elem: this, handlers: n.slice(l)}), s\n        }, fix: function (e) {\n            if (e[x.expando])\n                return e;\n            var t, n, r, i = e.type, o = e, s = this.fixHooks[i];\n            s || (this.fixHooks[i] = s = tt.test(i) ? this.mouseHooks : et.test(i) ? this.keyHooks : {}), r = s.props ? this.props.concat(s.props) : this.props, e = new x.Event(o), t = r.length;\n            while (t--)\n                n = r[t], e[n] = o[n];\n            return e.target || (e.target = o.srcElement || a), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !!e.metaKey, s.filter ? s.filter(e, o) : e\n        }, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: {props: "char charCode key keyCode".split(" "), filter: function (e, t) {\n                return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e\n            }}, mouseHooks: {props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function (e, n) {\n                var r, i, o, s = n.button, l = n.fromElement;\n                return null == e.pageX && null != n.clientX && (i = e.target.ownerDocument || a, o = i.documentElement, r = i.body, e.pageX = n.clientX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0), e.pageY = n.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0)), !e.relatedTarget && l && (e.relatedTarget = l === e.target ? n.toElement : l), e.which || s === t || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0), e\n            }}, special: {load: {noBubble: !0}, focus: {trigger: function () {\n                    if (this !== at() && this.focus)\n                        try {\n                            return this.focus(), !1\n                        } catch (e) {\n                        }\n                }, delegateType: "focusin"}, blur: {trigger: function () {\n                    return this === at() && this.blur ? (this.blur(), !1) : t\n                }, delegateType: "focusout"}, click: {trigger: function () {\n                    return x.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : t\n                }, _default: function (e) {\n                    return x.nodeName(e.target, "a")\n                }}, beforeunload: {postDispatch: function (e) {\n                    e.result !== t && (e.originalEvent.returnValue = e.result)\n                }}}, simulate: function (e, t, n, r) {\n            var i = x.extend(new x.Event, n, {type: e, isSimulated: !0, originalEvent: {}});\n            r ? x.event.trigger(i, null, t) : x.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault()\n        }}, x.removeEvent = a.removeEventListener ? function (e, t, n) {\n        e.removeEventListener && e.removeEventListener(t, n, !1)\n    } : function (e, t, n) {\n        var r = "on" + t;\n        e.detachEvent && (typeof e[r] === i && (e[r] = null), e.detachEvent(r, n))\n    }, x.Event = function (e, n) {\n        return this instanceof x.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e.getPreventDefault && e.getPreventDefault() ? it : ot) : this.type = e, n && x.extend(this, n), this.timeStamp = e && e.timeStamp || x.now(), this[x.expando] = !0, t) : new x.Event(e, n)\n    }, x.Event.prototype = {isDefaultPrevented: ot, isPropagationStopped: ot, isImmediatePropagationStopped: ot, preventDefault: function () {\n            var e = this.originalEvent;\n            this.isDefaultPrevented = it, e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1)\n        }, stopPropagation: function () {\n            var e = this.originalEvent;\n            this.isPropagationStopped = it, e && (e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0)\n        }, stopImmediatePropagation: function () {\n            this.isImmediatePropagationStopped = it, this.stopPropagation()\n        }}, x.each({mouseenter: "mouseover", mouseleave: "mouseout"}, function (e, t) {\n        x.event.special[e] = {delegateType: t, bindType: t, handle: function (e) {\n                var n, r = this, i = e.relatedTarget, o = e.handleObj;\n                return(!i || i !== r && !x.contains(r, i)) && (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n\n            }}\n    }), x.support.submitBubbles || (x.event.special.submit = {setup: function () {\n            return x.nodeName(this, "form") ? !1 : (x.event.add(this, "click._submit keypress._submit", function (e) {\n                var n = e.target, r = x.nodeName(n, "input") || x.nodeName(n, "button") ? n.form : t;\n                r && !x._data(r, "submitBubbles") && (x.event.add(r, "submit._submit", function (e) {\n                    e._submit_bubble = !0\n                }), x._data(r, "submitBubbles", !0))\n            }), t)\n        }, postDispatch: function (e) {\n            e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger && x.event.simulate("submit", this.parentNode, e, !0))\n        }, teardown: function () {\n            return x.nodeName(this, "form") ? !1 : (x.event.remove(this, "._submit"), t)\n        }}), x.support.changeBubbles || (x.event.special.change = {setup: function () {\n            return Z.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (x.event.add(this, "propertychange._change", function (e) {\n                "checked" === e.originalEvent.propertyName && (this._just_changed = !0)\n            }), x.event.add(this, "click._change", function (e) {\n                this._just_changed && !e.isTrigger && (this._just_changed = !1), x.event.simulate("change", this, e, !0)\n            })), !1) : (x.event.add(this, "beforeactivate._change", function (e) {\n                var t = e.target;\n                Z.test(t.nodeName) && !x._data(t, "changeBubbles") && (x.event.add(t, "change._change", function (e) {\n                    !this.parentNode || e.isSimulated || e.isTrigger || x.event.simulate("change", this.parentNode, e, !0)\n                }), x._data(t, "changeBubbles", !0))\n            }), t)\n        }, handle: function (e) {\n            var n = e.target;\n            return this !== n || e.isSimulated || e.isTrigger || "radio" !== n.type && "checkbox" !== n.type ? e.handleObj.handler.apply(this, arguments) : t\n        }, teardown: function () {\n            return x.event.remove(this, "._change"), !Z.test(this.nodeName)\n        }}), x.support.focusinBubbles || x.each({focus: "focusin", blur: "focusout"}, function (e, t) {\n        var n = 0, r = function (e) {\n            x.event.simulate(t, e.target, x.event.fix(e), !0)\n        };\n        x.event.special[t] = {setup: function () {\n                0 === n++ && a.addEventListener(e, r, !0)\n            }, teardown: function () {\n                0 === --n && a.removeEventListener(e, r, !0)\n            }}\n    }), x.fn.extend({on: function (e, n, r, i, o) {\n            var a, s;\n            if ("object" == typeof e) {\n                "string" != typeof n && (r = r || n, n = t);\n                for (a in e)\n                    this.on(a, n, r, e[a], o);\n                return this\n            }\n            if (null == r && null == i ? (i = n, r = n = t) : null == i && ("string" == typeof n ? (i = r, r = t) : (i = r, r = n, n = t)), i === !1)\n                i = ot;\n            else if (!i)\n                return this;\n            return 1 === o && (s = i, i = function (e) {\n                return x().off(e), s.apply(this, arguments)\n            }, i.guid = s.guid || (s.guid = x.guid++)), this.each(function () {\n                x.event.add(this, e, i, r, n)\n            })\n        }, one: function (e, t, n, r) {\n            return this.on(e, t, n, r, 1)\n        }, off: function (e, n, r) {\n            var i, o;\n            if (e && e.preventDefault && e.handleObj)\n                return i = e.handleObj, x(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;\n            if ("object" == typeof e) {\n                for (o in e)\n                    this.off(o, n, e[o]);\n                return this\n            }\n            return(n === !1 || "function" == typeof n) && (r = n, n = t), r === !1 && (r = ot), this.each(function () {\n                x.event.remove(this, e, r, n)\n            })\n        }, trigger: function (e, t) {\n            return this.each(function () {\n                x.event.trigger(e, t, this)\n            })\n        }, triggerHandler: function (e, n) {\n            var r = this[0];\n            return r ? x.event.trigger(e, n, r, !0) : t\n        }});\n    var st = /^.[^:#\\[\\.,]*$/, lt = /^(?:parents|prev(?:Until|All))/, ut = x.expr.match.needsContext, ct = {children: !0, contents: !0, next: !0, prev: !0};\n    x.fn.extend({find: function (e) {\n            var t, n = [], r = this, i = r.length;\n            if ("string" != typeof e)\n                return this.pushStack(x(e).filter(function () {\n                    for (t = 0; i > t; t++)\n                        if (x.contains(r[t], this))\n                            return!0\n                }));\n            for (t = 0; i > t; t++)\n                x.find(e, r[t], n);\n            return n = this.pushStack(i > 1 ? x.unique(n) : n), n.selector = this.selector ? this.selector + " " + e : e, n\n        }, has: function (e) {\n            var t, n = x(e, this), r = n.length;\n            return this.filter(function () {\n                for (t = 0; r > t; t++)\n                    if (x.contains(this, n[t]))\n                        return!0\n            })\n        }, not: function (e) {\n            return this.pushStack(ft(this, e || [], !0))\n        }, filter: function (e) {\n            return this.pushStack(ft(this, e || [], !1))\n        }, is: function (e) {\n            return!!ft(this, "string" == typeof e && ut.test(e) ? x(e) : e || [], !1).length\n        }, closest: function (e, t) {\n            var n, r = 0, i = this.length, o = [], a = ut.test(e) || "string" != typeof e ? x(e, t || this.context) : 0;\n            for (; i > r; r++)\n                for (n = this[r]; n && n !== t; n = n.parentNode)\n                    if (11 > n.nodeType && (a ? a.index(n) > -1 : 1 === n.nodeType && x.find.matchesSelector(n, e))) {\n                        n = o.push(n);\n                        break\n                    }\n            return this.pushStack(o.length > 1 ? x.unique(o) : o)\n        }, index: function (e) {\n            return e ? "string" == typeof e ? x.inArray(this[0], x(e)) : x.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1\n        }, add: function (e, t) {\n            var n = "string" == typeof e ? x(e, t) : x.makeArray(e && e.nodeType ? [e] : e), r = x.merge(this.get(), n);\n            return this.pushStack(x.unique(r))\n        }, addBack: function (e) {\n            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))\n        }});\n    function pt(e, t) {\n        do\n            e = e[t];\n        while (e && 1 !== e.nodeType);\n        return e\n    }\n    x.each({parent: function (e) {\n            var t = e.parentNode;\n            return t && 11 !== t.nodeType ? t : null\n        }, parents: function (e) {\n            return x.dir(e, "parentNode")\n        }, parentsUntil: function (e, t, n) {\n            return x.dir(e, "parentNode", n)\n        }, next: function (e) {\n            return pt(e, "nextSibling")\n        }, prev: function (e) {\n            return pt(e, "previousSibling")\n        }, nextAll: function (e) {\n            return x.dir(e, "nextSibling")\n        }, prevAll: function (e) {\n            return x.dir(e, "previousSibling")\n        }, nextUntil: function (e, t, n) {\n            return x.dir(e, "nextSibling", n)\n        }, prevUntil: function (e, t, n) {\n            return x.dir(e, "previousSibling", n)\n        }, siblings: function (e) {\n            return x.sibling((e.parentNode || {}).firstChild, e)\n        }, children: function (e) {\n            return x.sibling(e.firstChild)\n        }, contents: function (e) {\n            return x.nodeName(e, "iframe") ? e.contentDocument || e.contentWindow.document : x.merge([], e.childNodes)\n        }}, function (e, t) {\n        x.fn[e] = function (n, r) {\n            var i = x.map(this, t, n);\n            return"Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = x.filter(r, i)), this.length > 1 && (ct[e] || (i = x.unique(i)), lt.test(e) && (i = i.reverse())), this.pushStack(i)\n        }\n    }), x.extend({filter: function (e, t, n) {\n            var r = t[0];\n            return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? x.find.matchesSelector(r, e) ? [r] : [] : x.find.matches(e, x.grep(t, function (e) {\n                return 1 === e.nodeType\n            }))\n        }, dir: function (e, n, r) {\n            var i = [], o = e[n];\n            while (o && 9 !== o.nodeType && (r === t || 1 !== o.nodeType || !x(o).is(r)))\n                1 === o.nodeType && i.push(o), o = o[n];\n            return i\n        }, sibling: function (e, t) {\n            var n = [];\n            for (; e; e = e.nextSibling)\n                1 === e.nodeType && e !== t && n.push(e);\n            return n\n        }});\n    function ft(e, t, n) {\n        if (x.isFunction(t))\n            return x.grep(e, function (e, r) {\n                return!!t.call(e, r, e) !== n\n            });\n        if (t.nodeType)\n            return x.grep(e, function (e) {\n                return e === t !== n\n            });\n        if ("string" == typeof t) {\n            if (st.test(t))\n                return x.filter(t, e, n);\n            t = x.filter(t, e)\n        }\n        return x.grep(e, function (e) {\n            return x.inArray(e, t) >= 0 !== n\n        })\n    }\n    function dt(e) {\n        var t = ht.split("|"), n = e.createDocumentFragment();\n        if (n.createElement)\n            while (t.length)\n                n.createElement(t.pop());\n        return n\n    }\n    var ht = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", gt = / jQuery\\d+="(?:null|\\d+)"/g, mt = RegExp("<(?:" + ht + ")[\\\\s/>]", "i"), yt = /^\\s+/, vt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi, bt = /<([\\w:]+)/, xt = /<tbody/i, wt = /<|&#?\\w+;/, Tt = /<(?:script|style|link)/i, Ct = /^(?:checkbox|radio)$/i, Nt = /checked\\s*(?:[^=]|=\\s*.checked.)/i, kt = /^$|\\/(?:java|ecma)script/i, Et = /^true\\/(.*)/, St = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g, At = {option: [1, "<select multiple=\'multiple\'>", "</select>"], legend: [1, "<fieldset>", "</fieldset>"], area: [1, "<map>", "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table>"], tr: [2, "<table><tbody>", "</tbody></table>"], col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: x.support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]}, jt = dt(a), Dt = jt.appendChild(a.createElement("div"));\n    At.optgroup = At.option, At.tbody = At.tfoot = At.colgroup = At.caption = At.thead, At.th = At.td, x.fn.extend({text: function (e) {\n            return x.access(this, function (e) {\n                return e === t ? x.text(this) : this.empty().append((this[0] && this[0].ownerDocument || a).createTextNode(e))\n            }, null, e, arguments.length)\n        }, append: function () {\n            return this.domManip(arguments, function (e) {\n                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n                    var t = Lt(this, e);\n                    t.appendChild(e)\n                }\n            })\n        }, prepend: function () {\n            return this.domManip(arguments, function (e) {\n                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n                    var t = Lt(this, e);\n                    t.insertBefore(e, t.firstChild)\n                }\n            })\n        }, before: function () {\n            return this.domManip(arguments, function (e) {\n                this.parentNode && this.parentNode.insertBefore(e, this)\n            })\n        }, after: function () {\n            return this.domManip(arguments, function (e) {\n                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)\n            })\n        }, remove: function (e, t) {\n            var n, r = e ? x.filter(e, this) : this, i = 0;\n            for (; null != (n = r[i]); i++)\n                t || 1 !== n.nodeType || x.cleanData(Ft(n)), n.parentNode && (t && x.contains(n.ownerDocument, n) && _t(Ft(n, "script")), n.parentNode.removeChild(n));\n            return this\n        }, empty: function () {\n            var e, t = 0;\n            for (; null != (e = this[t]); t++) {\n                1 === e.nodeType && x.cleanData(Ft(e, !1));\n                while (e.firstChild)\n                    e.removeChild(e.firstChild);\n                e.options && x.nodeName(e, "select") && (e.options.length = 0)\n            }\n            return this\n        }, clone: function (e, t) {\n            return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function () {\n                return x.clone(this, e, t)\n            })\n        }, html: function (e) {\n            return x.access(this, function (e) {\n                var n = this[0] || {}, r = 0, i = this.length;\n                if (e === t)\n                    return 1 === n.nodeType ? n.innerHTML.replace(gt, "") : t;\n                if (!("string" != typeof e || Tt.test(e) || !x.support.htmlSerialize && mt.test(e) || !x.support.leadingWhitespace && yt.test(e) || At[(bt.exec(e) || ["", ""])[1].toLowerCase()])) {\n                    e = e.replace(vt, "<$1></$2>");\n                    try {\n                        for (; i > r; r++)\n                            n = this[r] || {}, 1 === n.nodeType && (x.cleanData(Ft(n, !1)), n.innerHTML = e);\n                        n = 0\n                    } catch (o) {\n                    }\n                }\n                n && this.empty().append(e)\n            }, null, e, arguments.length)\n        }, replaceWith: function () {\n            var e = x.map(this, function (e) {\n                return[e.nextSibling, e.parentNode]\n            }), t = 0;\n            return this.domManip(arguments, function (n) {\n                var r = e[t++], i = e[t++];\n                i && (r && r.parentNode !== i && (r = this.nextSibling), x(this).remove(), i.insertBefore(n, r))\n            }, !0), t ? this : this.remove()\n        }, detach: function (e) {\n            return this.remove(e, !0)\n        }, domManip: function (e, t, n) {\n            e = d.apply([], e);\n            var r, i, o, a, s, l, u = 0, c = this.length, p = this, f = c - 1, h = e[0], g = x.isFunction(h);\n            if (g || !(1 >= c || "string" != typeof h || x.support.checkClone) && Nt.test(h))\n                return this.each(function (r) {\n                    var i = p.eq(r);\n                    g && (e[0] = h.call(this, r, i.html())), i.domManip(e, t, n)\n                });\n            if (c && (l = x.buildFragment(e, this[0].ownerDocument, !1, !n && this), r = l.firstChild, 1 === l.childNodes.length && (l = r), r)) {\n                for (a = x.map(Ft(l, "script"), Ht), o = a.length; c > u; u++)\n                    i = l, u !== f && (i = x.clone(i, !0, !0), o && x.merge(a, Ft(i, "script"))), t.call(this[u], i, u);\n                if (o)\n                    for (s = a[a.length - 1].ownerDocument, x.map(a, qt), u = 0; o > u; u++)\n                        i = a[u], kt.test(i.type || "") && !x._data(i, "globalEval") && x.contains(s, i) && (i.src ? x._evalUrl(i.src) : x.globalEval((i.text || i.textContent || i.innerHTML || "").replace(St, "")));\n                l = r = null\n            }\n            return this\n        }});\n    function Lt(e, t) {\n        return x.nodeName(e, "table") && x.nodeName(1 === t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e\n    }\n    function Ht(e) {\n        return e.type = (null !== x.find.attr(e, "type")) + "/" + e.type, e\n    }\n    function qt(e) {\n        var t = Et.exec(e.type);\n        return t ? e.type = t[1] : e.removeAttribute("type"), e\n    }\n    function _t(e, t) {\n        var n, r = 0;\n        for (; null != (n = e[r]); r++)\n            x._data(n, "globalEval", !t || x._data(t[r], "globalEval"))\n    }\n    function Mt(e, t) {\n        if (1 === t.nodeType && x.hasData(e)) {\n            var n, r, i, o = x._data(e), a = x._data(t, o), s = o.events;\n            if (s) {\n                delete a.handle, a.events = {};\n                for (n in s)\n                    for (r = 0, i = s[n].length; i > r; r++)\n                        x.event.add(t, n, s[n][r])\n            }\n            a.data && (a.data = x.extend({}, a.data))\n        }\n    }\n    function Ot(e, t) {\n        var n, r, i;\n        if (1 === t.nodeType) {\n            if (n = t.nodeName.toLowerCase(), !x.support.noCloneEvent && t[x.expando]) {\n                i = x._data(t);\n                for (r in i.events)\n                    x.removeEvent(t, r, i.handle);\n                t.removeAttribute(x.expando)\n            }\n            "script" === n && t.text !== e.text ? (Ht(t).text = e.text, qt(t)) : "object" === n ? (t.parentNode && (t.outerHTML = e.outerHTML), x.support.html5Clone && e.innerHTML && !x.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : "input" === n && Ct.test(e.type) ? (t.defaultChecked = t.checked = e.checked, t.value !== e.value && (t.value = e.value)) : "option" === n ? t.defaultSelected = t.selected = e.defaultSelected : ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue)\n        }\n    }\n    x.each({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, function (e, t) {\n        x.fn[e] = function (e) {\n            var n, r = 0, i = [], o = x(e), a = o.length - 1;\n            for (; a >= r; r++)\n                n = r === a ? this : this.clone(!0), x(o[r])[t](n), h.apply(i, n.get());\n            return this.pushStack(i)\n        }\n    });\n    function Ft(e, n) {\n        var r, o, a = 0, s = typeof e.getElementsByTagName !== i ? e.getElementsByTagName(n || "*") : typeof e.querySelectorAll !== i ? e.querySelectorAll(n || "*") : t;\n        if (!s)\n            for (s = [], r = e.childNodes || e; null != (o = r[a]); a++)\n                !n || x.nodeName(o, n) ? s.push(o) : x.merge(s, Ft(o, n));\n        return n === t || n && x.nodeName(e, n) ? x.merge([e], s) : s\n    }\n    function Bt(e) {\n        Ct.test(e.type) && (e.defaultChecked = e.checked)\n    }\n    x.extend({clone: function (e, t, n) {\n            var r, i, o, a, s, l = x.contains(e.ownerDocument, e);\n            if (x.support.html5Clone || x.isXMLDoc(e) || !mt.test("<" + e.nodeName + ">") ? o = e.cloneNode(!0) : (Dt.innerHTML = e.outerHTML, Dt.removeChild(o = Dt.firstChild)), !(x.support.noCloneEvent && x.support.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || x.isXMLDoc(e)))\n                for (r = Ft(o), s = Ft(e), a = 0; null != (i = s[a]); ++a)\n                    r[a] && Ot(i, r[a]);\n            if (t)\n                if (n)\n                    for (s = s || Ft(e), r = r || Ft(o), a = 0; null != (i = s[a]); a++)\n                        Mt(i, r[a]);\n                else\n                    Mt(e, o);\n            return r = Ft(o, "script"), r.length > 0 && _t(r, !l && Ft(e, "script")), r = s = i = null, o\n        }, buildFragment: function (e, t, n, r) {\n            var i, o, a, s, l, u, c, p = e.length, f = dt(t), d = [], h = 0;\n            for (; p > h; h++)\n                if (o = e[h], o || 0 === o)\n                    if ("object" === x.type(o))\n                        x.merge(d, o.nodeType ? [o] : o);\n                    else if (wt.test(o)) {\n                        s = s || f.appendChild(t.createElement("div")), l = (bt.exec(o) || ["", ""])[1].toLowerCase(), c = At[l] || At._default, s.innerHTML = c[1] + o.replace(vt, "<$1></$2>") + c[2], i = c[0];\n                        while (i--)\n                            s = s.lastChild;\n                        if (!x.support.leadingWhitespace && yt.test(o) && d.push(t.createTextNode(yt.exec(o)[0])), !x.support.tbody) {\n                            o = "table" !== l || xt.test(o) ? "<table>" !== c[1] || xt.test(o) ? 0 : s : s.firstChild, i = o && o.childNodes.length;\n                            while (i--)\n                                x.nodeName(u = o.childNodes[i], "tbody") && !u.childNodes.length && o.removeChild(u)\n                        }\n                        x.merge(d, s.childNodes), s.textContent = "";\n                        while (s.firstChild)\n                            s.removeChild(s.firstChild);\n                        s = f.lastChild\n                    } else\n                        d.push(t.createTextNode(o));\n            s && f.removeChild(s), x.support.appendChecked || x.grep(Ft(d, "input"), Bt), h = 0;\n            while (o = d[h++])\n                if ((!r || -1 === x.inArray(o, r)) && (a = x.contains(o.ownerDocument, o), s = Ft(f.appendChild(o), "script"), a && _t(s), n)) {\n                    i = 0;\n                    while (o = s[i++])\n                        kt.test(o.type || "") && n.push(o)\n                }\n            return s = null, f\n        }, cleanData: function (e, t) {\n            var n, r, o, a, s = 0, l = x.expando, u = x.cache, c = x.support.deleteExpando, f = x.event.special;\n            for (; null != (n = e[s]); s++)\n                if ((t || x.acceptData(n)) && (o = n[l], a = o && u[o])) {\n                    if (a.events)\n                        for (r in a.events)\n                            f[r] ? x.event.remove(n, r) : x.removeEvent(n, r, a.handle);\n                    u[o] && (delete u[o], c ? delete n[l] : typeof n.removeAttribute !== i ? n.removeAttribute(l) : n[l] = null, p.push(o))\n                }\n        }, _evalUrl: function (e) {\n            return x.ajax({url: e, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0})\n        }}), x.fn.extend({wrapAll: function (e) {\n            if (x.isFunction(e))\n                return this.each(function (t) {\n                    x(this).wrapAll(e.call(this, t))\n                });\n            if (this[0]) {\n                var t = x(e, this[0].ownerDocument).eq(0).clone(!0);\n                this[0].parentNode && t.insertBefore(this[0]), t.map(function () {\n                    var e = this;\n                    while (e.firstChild && 1 === e.firstChild.nodeType)\n                        e = e.firstChild;\n                    return e\n                }).append(this)\n            }\n            return this\n        }, wrapInner: function (e) {\n            return x.isFunction(e) ? this.each(function (t) {\n                x(this).wrapInner(e.call(this, t))\n            }) : this.each(function () {\n                var t = x(this), n = t.contents();\n                n.length ? n.wrapAll(e) : t.append(e)\n            })\n        }, wrap: function (e) {\n            var t = x.isFunction(e);\n            return this.each(function (n) {\n                x(this).wrapAll(t ? e.call(this, n) : e)\n            })\n        }, unwrap: function () {\n            return this.parent().each(function () {\n                x.nodeName(this, "body") || x(this).replaceWith(this.childNodes)\n            }).end()\n        }});\n    var Pt, Rt, Wt, $t = /alpha\\([^)]*\\)/i, It = /opacity\\s*=\\s*([^)]*)/, zt = /^(top|right|bottom|left)$/, Xt = /^(none|table(?!-c[ea]).+)/, Ut = /^margin/, Vt = RegExp("^(" + w + ")(.*)$", "i"), Yt = RegExp("^(" + w + ")(?!px)[a-z%]+$", "i"), Jt = RegExp("^([+-])=(" + w + ")", "i"), Gt = {BODY: "block"}, Qt = {position: "absolute", visibility: "hidden", display: "block"}, Kt = {letterSpacing: 0, fontWeight: 400}, Zt = ["Top", "Right", "Bottom", "Left"], en = ["Webkit", "O", "Moz", "ms"];\n    function tn(e, t) {\n        if (t in e)\n            return t;\n        var n = t.charAt(0).toUpperCase() + t.slice(1), r = t, i = en.length;\n        while (i--)\n            if (t = en[i] + n, t in e)\n                return t;\n        return r\n    }\n    function nn(e, t) {\n        return e = t || e, "none" === x.css(e, "display") || !x.contains(e.ownerDocument, e)\n    }\n    function rn(e, t) {\n        var n, r, i, o = [], a = 0, s = e.length;\n        for (; s > a; a++)\n            r = e[a], r.style && (o[a] = x._data(r, "olddisplay"), n = r.style.display, t ? (o[a] || "none" !== n || (r.style.display = ""), "" === r.style.display && nn(r) && (o[a] = x._data(r, "olddisplay", ln(r.nodeName)))) : o[a] || (i = nn(r), (n && "none" !== n || !i) && x._data(r, "olddisplay", i ? n : x.css(r, "display"))));\n        for (a = 0; s > a; a++)\n            r = e[a], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[a] || "" : "none"));\n        return e\n    }\n    x.fn.extend({css: function (e, n) {\n            return x.access(this, function (e, n, r) {\n                var i, o, a = {}, s = 0;\n                if (x.isArray(n)) {\n                    for (o = Rt(e), i = n.length; i > s; s++)\n                        a[n[s]] = x.css(e, n[s], !1, o);\n                    return a\n                }\n                return r !== t ? x.style(e, n, r) : x.css(e, n)\n            }, e, n, arguments.length > 1)\n        }, show: function () {\n            return rn(this, !0)\n        }, hide: function () {\n            return rn(this)\n        }, toggle: function (e) {\n            return"boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {\n                nn(this) ? x(this).show() : x(this).hide()\n            })\n        }}), x.extend({cssHooks: {opacity: {get: function (e, t) {\n                    if (t) {\n                        var n = Wt(e, "opacity");\n                        return"" === n ? "1" : n\n                    }\n                }}}, cssNumber: {columnCount: !0, fillOpacity: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0}, cssProps: {"float": x.support.cssFloat ? "cssFloat" : "styleFloat"}, style: function (e, n, r, i) {\n            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {\n                var o, a, s, l = x.camelCase(n), u = e.style;\n                if (n = x.cssProps[l] || (x.cssProps[l] = tn(u, l)), s = x.cssHooks[n] || x.cssHooks[l], r === t)\n                    return s && "get"in s && (o = s.get(e, !1, i)) !== t ? o : u[n];\n                if (a = typeof r, "string" === a && (o = Jt.exec(r)) && (r = (o[1] + 1) * o[2] + parseFloat(x.css(e, n)), a = "number"), !(null == r || "number" === a && isNaN(r) || ("number" !== a || x.cssNumber[l] || (r += "px"), x.support.clearCloneStyle || "" !== r || 0 !== n.indexOf("background") || (u[n] = "inherit"), s && "set"in s && (r = s.set(e, r, i)) === t)))\n                    try {\n                        u[n] = r\n                    } catch (c) {\n                    }\n            }\n        }, css: function (e, n, r, i) {\n            var o, a, s, l = x.camelCase(n);\n            return n = x.cssProps[l] || (x.cssProps[l] = tn(e.style, l)), s = x.cssHooks[n] || x.cssHooks[l], s && "get"in s && (a = s.get(e, !0, r)), a === t && (a = Wt(e, n, i)), "normal" === a && n in Kt && (a = Kt[n]), "" === r || r ? (o = parseFloat(a), r === !0 || x.isNumeric(o) ? o || 0 : a) : a\n        }}), e.getComputedStyle ? (Rt = function (t) {\n        return e.getComputedStyle(t, null)\n    }, Wt = function (e, n, r) {\n        var i, o, a, s = r || Rt(e), l = s ? s.getPropertyValue(n) || s[n] : t, u = e.style;\n        return s && ("" !== l || x.contains(e.ownerDocument, e) || (l = x.style(e, n)), Yt.test(l) && Ut.test(n) && (i = u.width, o = u.minWidth, a = u.maxWidth, u.minWidth = u.maxWidth = u.width = l, l = s.width, u.width = i, u.minWidth = o, u.maxWidth = a)), l\n    }) : a.documentElement.currentStyle && (Rt = function (e) {\n        return e.currentStyle\n    }, Wt = function (e, n, r) {\n        var i, o, a, s = r || Rt(e), l = s ? s[n] : t, u = e.style;\n        return null == l && u && u[n] && (l = u[n]), Yt.test(l) && !zt.test(n) && (i = u.left, o = e.runtimeStyle, a = o && o.left, a && (o.left = e.currentStyle.left), u.left = "fontSize" === n ? "1em" : l, l = u.pixelLeft + "px", u.left = i, a && (o.left = a)), "" === l ? "auto" : l\n    });\n    function on(e, t, n) {\n        var r = Vt.exec(t);\n        return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t\n    }\n    function an(e, t, n, r, i) {\n        var o = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, a = 0;\n        for (; 4 > o; o += 2)\n            "margin" === n && (a += x.css(e, n + Zt[o], !0, i)), r ? ("content" === n && (a -= x.css(e, "padding" + Zt[o], !0, i)), "margin" !== n && (a -= x.css(e, "border" + Zt[o] + "Width", !0, i))) : (a += x.css(e, "padding" + Zt[o], !0, i), "padding" !== n && (a += x.css(e, "border" + Zt[o] + "Width", !0, i)));\n        return a\n    }\n    function sn(e, t, n) {\n        var r = !0, i = "width" === t ? e.offsetWidth : e.offsetHeight, o = Rt(e), a = x.support.boxSizing && "border-box" === x.css(e, "boxSizing", !1, o);\n        if (0 >= i || null == i) {\n            if (i = Wt(e, t, o), (0 > i || null == i) && (i = e.style[t]), Yt.test(i))\n                return i;\n            r = a && (x.support.boxSizingReliable || i === e.style[t]), i = parseFloat(i) || 0\n        }\n        return i + an(e, t, n || (a ? "border" : "content"), r, o) + "px"\n    }\n    function ln(e) {\n        var t = a, n = Gt[e];\n        return n || (n = un(e, t), "none" !== n && n || (Pt = (Pt || x("<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>").css("cssText", "display:block !important")).appendTo(t.documentElement), t = (Pt[0].contentWindow || Pt[0].contentDocument).document, t.write("<!doctype html><html><body>"), t.close(), n = un(e, t), Pt.detach()), Gt[e] = n), n\n    }\n    function un(e, t) {\n        var n = x(t.createElement(e)).appendTo(t.body), r = x.css(n[0], "display");\n        return n.remove(), r\n    }\n    x.each(["height", "width"], function (e, n) {\n        x.cssHooks[n] = {get: function (e, r, i) {\n                return r ? 0 === e.offsetWidth && Xt.test(x.css(e, "display")) ? x.swap(e, Qt, function () {\n                    return sn(e, n, i)\n                }) : sn(e, n, i) : t\n            }, set: function (e, t, r) {\n                var i = r && Rt(e);\n                return on(e, t, r ? an(e, n, r, x.support.boxSizing && "border-box" === x.css(e, "boxSizing", !1, i), i) : 0)\n            }}\n    }), x.support.opacity || (x.cssHooks.opacity = {get: function (e, t) {\n            return It.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : t ? "1" : ""\n        }, set: function (e, t) {\n            var n = e.style, r = e.currentStyle, i = x.isNumeric(t) ? "alpha(opacity=" + 100 * t + ")" : "", o = r && r.filter || n.filter || "";\n            n.zoom = 1, (t >= 1 || "" === t) && "" === x.trim(o.replace($t, "")) && n.removeAttribute && (n.removeAttribute("filter"), "" === t || r && !r.filter) || (n.filter = $t.test(o) ? o.replace($t, i) : o + " " + i)\n        }}), x(function () {\n        x.support.reliableMarginRight || (x.cssHooks.marginRight = {get: function (e, n) {\n                return n ? x.swap(e, {display: "inline-block"}, Wt, [e, "marginRight"]) : t\n            }}), !x.support.pixelPosition && x.fn.position && x.each(["top", "left"], function (e, n) {\n            x.cssHooks[n] = {get: function (e, r) {\n                    return r ? (r = Wt(e, n), Yt.test(r) ? x(e).position()[n] + "px" : r) : t\n                }}\n        })\n    }), x.expr && x.expr.filters && (x.expr.filters.hidden = function (e) {\n        return 0 >= e.offsetWidth && 0 >= e.offsetHeight || !x.support.reliableHiddenOffsets && "none" === (e.style && e.style.display || x.css(e, "display"))\n    }, x.expr.filters.visible = function (e) {\n        return!x.expr.filters.hidden(e)\n    }), x.each({margin: "", padding: "", border: "Width"}, function (e, t) {\n        x.cssHooks[e + t] = {expand: function (n) {\n                var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n];\n                for (; 4 > r; r++)\n                    i[e + Zt[r] + t] = o[r] || o[r - 2] || o[0];\n                return i\n            }}, Ut.test(e) || (x.cssHooks[e + t].set = on)\n    });\n    var cn = /%20/g, pn = /\\[\\]$/, fn = /\\r?\\n/g, dn = /^(?:submit|button|image|reset|file)$/i, hn = /^(?:input|select|textarea|keygen)/i;\n    x.fn.extend({serialize: function () {\n            return x.param(this.serializeArray())\n        }, serializeArray: function () {\n            return this.map(function () {\n                var e = x.prop(this, "elements");\n                return e ? x.makeArray(e) : this\n            }).filter(function () {\n                var e = this.type;\n                return this.name && !x(this).is(":disabled") && hn.test(this.nodeName) && !dn.test(e) && (this.checked || !Ct.test(e))\n            }).map(function (e, t) {\n                var n = x(this).val();\n                return null == n ? null : x.isArray(n) ? x.map(n, function (e) {\n                    return{name: t.name, value: e.replace(fn, "\\r\\n")}\n                }) : {name: t.name, value: n.replace(fn, "\\r\\n")}\n            }).get()\n        }}), x.param = function (e, n) {\n        var r, i = [], o = function (e, t) {\n            t = x.isFunction(t) ? t() : null == t ? "" : t, i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)\n        };\n        if (n === t && (n = x.ajaxSettings && x.ajaxSettings.traditional), x.isArray(e) || e.jquery && !x.isPlainObject(e))\n            x.each(e, function () {\n                o(this.name, this.value)\n            });\n        else\n            for (r in e)\n                gn(r, e[r], n, o);\n        return i.join("&").replace(cn, "+")\n    };\n    function gn(e, t, n, r) {\n        var i;\n        if (x.isArray(t))\n            x.each(t, function (t, i) {\n                n || pn.test(e) ? r(e, i) : gn(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r)\n            });\n        else if (n || "object" !== x.type(t))\n            r(e, t);\n        else\n            for (i in t)\n                gn(e + "[" + i + "]", t[i], n, r)\n    }\n    x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (e, t) {\n        x.fn[t] = function (e, n) {\n            return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)\n        }\n    }), x.fn.extend({hover: function (e, t) {\n            return this.mouseenter(e).mouseleave(t || e)\n        }, bind: function (e, t, n) {\n            return this.on(e, null, t, n)\n        }, unbind: function (e, t) {\n            return this.off(e, null, t)\n        }, delegate: function (e, t, n, r) {\n            return this.on(t, e, n, r)\n        }, undelegate: function (e, t, n) {\n            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)\n        }});\n    var mn, yn, vn = x.now(), bn = /\\?/, xn = /#.*$/, wn = /([?&])_=[^&]*/, Tn = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/gm, Cn = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Nn = /^(?:GET|HEAD)$/, kn = /^\\/\\//, En = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/, Sn = x.fn.load, An = {}, jn = {}, Dn = "*/".concat("*");\n    try {\n        yn = o.href\n    } catch (Ln) {\n        yn = a.createElement("a"), yn.href = "", yn = yn.href\n    }\n    mn = En.exec(yn.toLowerCase()) || [];\n    function Hn(e) {\n        return function (t, n) {\n            "string" != typeof t && (n = t, t = "*");\n            var r, i = 0, o = t.toLowerCase().match(T) || [];\n            if (x.isFunction(n))\n                while (r = o[i++])\n                    "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n)\n        }\n    }\n    function qn(e, n, r, i) {\n        var o = {}, a = e === jn;\n        function s(l) {\n            var u;\n            return o[l] = !0, x.each(e[l] || [], function (e, l) {\n                var c = l(n, r, i);\n                return"string" != typeof c || a || o[c] ? a ? !(u = c) : t : (n.dataTypes.unshift(c), s(c), !1)\n            }), u\n        }\n        return s(n.dataTypes[0]) || !o["*"] && s("*")\n    }\n    function _n(e, n) {\n        var r, i, o = x.ajaxSettings.flatOptions || {};\n        for (i in n)\n            n[i] !== t && ((o[i] ? e : r || (r = {}))[i] = n[i]);\n        return r && x.extend(!0, e, r), e\n    }\n    x.fn.load = function (e, n, r) {\n        if ("string" != typeof e && Sn)\n            return Sn.apply(this, arguments);\n        var i, o, a, s = this, l = e.indexOf(" ");\n        return l >= 0 && (i = e.slice(l, e.length), e = e.slice(0, l)), x.isFunction(n) ? (r = n, n = t) : n && "object" == typeof n && (a = "POST"), s.length > 0 && x.ajax({url: e, type: a, dataType: "html", data: n}).done(function (e) {\n            o = arguments, s.html(i ? x("<div>").append(x.parseHTML(e)).find(i) : e)\n        }).complete(r && function (e, t) {\n            s.each(r, o || [e.responseText, t, e])\n        }), this\n    }, x.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {\n        x.fn[t] = function (e) {\n            return this.on(t, e)\n        }\n    }), x.extend({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: yn, type: "GET", isLocal: Cn.test(mn[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: {"*": Dn, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript"}, contents: {xml: /xml/, html: /html/, json: /json/}, responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"}, converters: {"* text": String, "text html": !0, "text json": x.parseJSON, "text xml": x.parseXML}, flatOptions: {url: !0, context: !0}}, ajaxSetup: function (e, t) {\n            return t ? _n(_n(e, x.ajaxSettings), t) : _n(x.ajaxSettings, e)\n        }, ajaxPrefilter: Hn(An), ajaxTransport: Hn(jn), ajax: function (e, n) {\n            "object" == typeof e && (n = e, e = t), n = n || {};\n            var r, i, o, a, s, l, u, c, p = x.ajaxSetup({}, n), f = p.context || p, d = p.context && (f.nodeType || f.jquery) ? x(f) : x.event, h = x.Deferred(), g = x.Callbacks("once memory"), m = p.statusCode || {}, y = {}, v = {}, b = 0, w = "canceled", C = {readyState: 0, getResponseHeader: function (e) {\n                    var t;\n                    if (2 === b) {\n                        if (!c) {\n                            c = {};\n                            while (t = Tn.exec(a))\n                                c[t[1].toLowerCase()] = t[2]\n                        }\n                        t = c[e.toLowerCase()]\n                    }\n                    return null == t ? null : t\n                }, getAllResponseHeaders: function () {\n                    return 2 === b ? a : null\n                }, setRequestHeader: function (e, t) {\n                    var n = e.toLowerCase();\n                    return b || (e = v[n] = v[n] || e, y[e] = t), this\n                }, overrideMimeType: function (e) {\n                    return b || (p.mimeType = e), this\n                }, statusCode: function (e) {\n                    var t;\n                    if (e)\n                        if (2 > b)\n                            for (t in e)\n                                m[t] = [m[t], e[t]];\n                        else\n                            C.always(e[C.status]);\n                    return this\n                }, abort: function (e) {\n                    var t = e || w;\n                    return u && u.abort(t), k(0, t), this\n                }};\n            if (h.promise(C).complete = g.add, C.success = C.done, C.error = C.fail, p.url = ((e || p.url || yn) + "").replace(xn, "").replace(kn, mn[1] + "//"), p.type = n.method || n.type || p.method || p.type, p.dataTypes = x.trim(p.dataType || "*").toLowerCase().match(T) || [""], null == p.crossDomain && (r = En.exec(p.url.toLowerCase()), p.crossDomain = !(!r || r[1] === mn[1] && r[2] === mn[2] && (r[3] || ("http:" === r[1] ? "80" : "443")) === (mn[3] || ("http:" === mn[1] ? "80" : "443")))), p.data && p.processData && "string" != typeof p.data && (p.data = x.param(p.data, p.traditional)), qn(An, p, n, C), 2 === b)\n                return C;\n            l = p.global, l && 0 === x.active++ && x.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Nn.test(p.type), o = p.url, p.hasContent || (p.data && (o = p.url += (bn.test(o) ? "&" : "?") + p.data, delete p.data), p.cache === !1 && (p.url = wn.test(o) ? o.replace(wn, "$1_=" + vn++) : o + (bn.test(o) ? "&" : "?") + "_=" + vn++)), p.ifModified && (x.lastModified[o] && C.setRequestHeader("If-Modified-Since", x.lastModified[o]), x.etag[o] && C.setRequestHeader("If-None-Match", x.etag[o])), (p.data && p.hasContent && p.contentType !== !1 || n.contentType) && C.setRequestHeader("Content-Type", p.contentType), C.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Dn + "; q=0.01" : "") : p.accepts["*"]);\n            for (i in p.headers)\n                C.setRequestHeader(i, p.headers[i]);\n            if (p.beforeSend && (p.beforeSend.call(f, C, p) === !1 || 2 === b))\n                return C.abort();\n            w = "abort";\n            for (i in{success:1, error:1, complete:1})\n                C[i](p[i]);\n            if (u = qn(jn, p, n, C)) {\n                C.readyState = 1, l && d.trigger("ajaxSend", [C, p]), p.async && p.timeout > 0 && (s = setTimeout(function () {\n                    C.abort("timeout")\n                }, p.timeout));\n                try {\n                    b = 1, u.send(y, k)\n                } catch (N) {\n                    if (!(2 > b))\n                        throw N;\n                    k(-1, N)\n                }\n            } else\n                k(-1, "No Transport");\n            function k(e, n, r, i) {\n                var c, y, v, w, T, N = n;\n                2 !== b && (b = 2, s && clearTimeout(s), u = t, a = i || "", C.readyState = e > 0 ? 4 : 0, c = e >= 200 && 300 > e || 304 === e, r && (w = Mn(p, C, r)), w = On(p, w, C, c), c ? (p.ifModified && (T = C.getResponseHeader("Last-Modified"), T && (x.lastModified[o] = T), T = C.getResponseHeader("etag"), T && (x.etag[o] = T)), 204 === e || "HEAD" === p.type ? N = "nocontent" : 304 === e ? N = "notmodified" : (N = w.state, y = w.data, v = w.error, c = !v)) : (v = N, (e || !N) && (N = "error", 0 > e && (e = 0))), C.status = e, C.statusText = (n || N) + "", c ? h.resolveWith(f, [y, N, C]) : h.rejectWith(f, [C, N, v]), C.statusCode(m), m = t, l && d.trigger(c ? "ajaxSuccess" : "ajaxError", [C, p, c ? y : v]), g.fireWith(f, [C, N]), l && (d.trigger("ajaxComplete", [C, p]), --x.active || x.event.trigger("ajaxStop")))\n            }\n            return C\n        }, getJSON: function (e, t, n) {\n            return x.get(e, t, n, "json")\n        }, getScript: function (e, n) {\n            return x.get(e, t, n, "script")\n        }}), x.each(["get", "post"], function (e, n) {\n        x[n] = function (e, r, i, o) {\n            return x.isFunction(r) && (o = o || i, i = r, r = t), x.ajax({url: e, type: n, dataType: o, data: r, success: i})\n        }\n    });\n    function Mn(e, n, r) {\n        var i, o, a, s, l = e.contents, u = e.dataTypes;\n        while ("*" === u[0])\n            u.shift(), o === t && (o = e.mimeType || n.getResponseHeader("Content-Type"));\n        if (o)\n            for (s in l)\n                if (l[s] && l[s].test(o)) {\n                    u.unshift(s);\n                    break\n                }\n        if (u[0]in r)\n            a = u[0];\n        else {\n            for (s in r) {\n                if (!u[0] || e.converters[s + " " + u[0]]) {\n                    a = s;\n                    break\n                }\n                i || (i = s)\n            }\n            a = a || i\n        }\n        return a ? (a !== u[0] && u.unshift(a), r[a]) : t\n    }\n    function On(e, t, n, r) {\n        var i, o, a, s, l, u = {}, c = e.dataTypes.slice();\n        if (c[1])\n            for (a in e.converters)\n                u[a.toLowerCase()] = e.converters[a];\n        o = c.shift();\n        while (o)\n            if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = c.shift())\n                if ("*" === o)\n                    o = l;\n                else if ("*" !== l && l !== o) {\n                    if (a = u[l + " " + o] || u["* " + o], !a)\n                        for (i in u)\n                            if (s = i.split(" "), s[1] === o && (a = u[l + " " + s[0]] || u["* " + s[0]])) {\n                                a === !0 ? a = u[i] : u[i] !== !0 && (o = s[0], c.unshift(s[1]));\n                                break\n                            }\n                    if (a !== !0)\n                        if (a && e["throws"])\n                            t = a(t);\n                        else\n                            try {\n                                t = a(t)\n                            } catch (p) {\n                                return{state: "parsererror", error: a ? p : "No conversion from " + l + " to " + o}\n                            }\n                }\n        return{state: "success", data: t}\n    }\n    x.ajaxSetup({accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"}, contents: {script: /(?:java|ecma)script/}, converters: {"text script": function (e) {\n                return x.globalEval(e), e\n            }}}), x.ajaxPrefilter("script", function (e) {\n        e.cache === t && (e.cache = !1), e.crossDomain && (e.type = "GET", e.global = !1)\n    }), x.ajaxTransport("script", function (e) {\n        if (e.crossDomain) {\n            var n, r = a.head || x("head")[0] || a.documentElement;\n            return{send: function (t, i) {\n                    n = a.createElement("script"), n.async = !0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (e, t) {\n                        (t || !n.readyState || /loaded|complete/.test(n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), n = null, t || i(200, "success"))\n                    }, r.insertBefore(n, r.firstChild)\n                }, abort: function () {\n                    n && n.onload(t, !0)\n                }}\n        }\n    });\n    var Fn = [], Bn = /(=)\\?(?=&|$)|\\?\\?/;\n    x.ajaxSetup({jsonp: "callback", jsonpCallback: function () {\n            var e = Fn.pop() || x.expando + "_" + vn++;\n            return this[e] = !0, e\n        }}), x.ajaxPrefilter("json jsonp", function (n, r, i) {\n        var o, a, s, l = n.jsonp !== !1 && (Bn.test(n.url) ? "url" : "string" == typeof n.data && !(n.contentType || "").indexOf("application/x-www-form-urlencoded") && Bn.test(n.data) && "data");\n        return l || "jsonp" === n.dataTypes[0] ? (o = n.jsonpCallback = x.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback, l ? n[l] = n[l].replace(Bn, "$1" + o) : n.jsonp !== !1 && (n.url += (bn.test(n.url) ? "&" : "?") + n.jsonp + "=" + o), n.converters["script json"] = function () {\n            return s || x.error(o + " was not called"), s[0]\n        }, n.dataTypes[0] = "json", a = e[o], e[o] = function () {\n            s = arguments\n        }, i.always(function () {\n            e[o] = a, n[o] && (n.jsonpCallback = r.jsonpCallback, Fn.push(o)), s && x.isFunction(a) && a(s[0]), s = a = t\n        }), "script") : t\n    });\n    var Pn, Rn, Wn = 0, $n = e.ActiveXObject && function () {\n        var e;\n        for (e in Pn)\n            Pn[e](t, !0)\n    };\n    function In() {\n        try {\n            return new e.XMLHttpRequest\n        } catch (t) {\n        }\n    }\n    function zn() {\n        try {\n            return new e.ActiveXObject("Microsoft.XMLHTTP")\n        } catch (t) {\n        }\n    }\n    x.ajaxSettings.xhr = e.ActiveXObject ? function () {\n        return!this.isLocal && In() || zn()\n    } : In, Rn = x.ajaxSettings.xhr(), x.support.cors = !!Rn && "withCredentials"in Rn, Rn = x.support.ajax = !!Rn, Rn && x.ajaxTransport(function (n) {\n        if (!n.crossDomain || x.support.cors) {\n            var r;\n            return{send: function (i, o) {\n                    var a, s, l = n.xhr();\n                    if (n.username ? l.open(n.type, n.url, n.async, n.username, n.password) : l.open(n.type, n.url, n.async), n.xhrFields)\n                        for (s in n.xhrFields)\n                            l[s] = n.xhrFields[s];\n                    n.mimeType && l.overrideMimeType && l.overrideMimeType(n.mimeType), n.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest");\n                    try {\n                        for (s in i)\n                            l.setRequestHeader(s, i[s])\n                    } catch (u) {\n                    }\n                    l.send(n.hasContent && n.data || null), r = function (e, i) {\n                        var s, u, c, p;\n                        try {\n                            if (r && (i || 4 === l.readyState))\n                                if (r = t, a && (l.onreadystatechange = x.noop, $n && delete Pn[a]), i)\n                                    4 !== l.readyState && l.abort();\n                                else {\n                                    p = {}, s = l.status, u = l.getAllResponseHeaders(), "string" == typeof l.responseText && (p.text = l.responseText);\n                                    try {\n                                        c = l.statusText\n                                    } catch (f) {\n                                        c = ""\n                                    }\n                                    s || !n.isLocal || n.crossDomain ? 1223 === s && (s = 204) : s = p.text ? 200 : 404\n                                }\n                        } catch (d) {\n                            i || o(-1, d)\n                        }\n                        p && o(s, c, p, u)\n                    }, n.async ? 4 === l.readyState ? setTimeout(r) : (a = ++Wn, $n && (Pn || (Pn = {}, x(e).unload($n)), Pn[a] = r), l.onreadystatechange = r) : r()\n                }, abort: function () {\n                    r && r(t, !0)\n                }}\n        }\n    });\n    var Xn, Un, Vn = /^(?:toggle|show|hide)$/, Yn = RegExp("^(?:([+-])=|)(" + w + ")([a-z%]*)$", "i"), Jn = /queueHooks$/, Gn = [nr], Qn = {"*": [function (e, t) {\n                var n = this.createTween(e, t), r = n.cur(), i = Yn.exec(t), o = i && i[3] || (x.cssNumber[e] ? "" : "px"), a = (x.cssNumber[e] || "px" !== o && +r) && Yn.exec(x.css(n.elem, e)), s = 1, l = 20;\n                if (a && a[3] !== o) {\n                    o = o || a[3], i = i || [], a = +r || 1;\n                    do\n                        s = s || ".5", a /= s, x.style(n.elem, e, a + o);\n                    while (s !== (s = n.cur() / r) && 1 !== s && --l)\n                }\n                return i && (a = n.start = +a || +r || 0, n.unit = o, n.end = i[1] ? a + (i[1] + 1) * i[2] : +i[2]), n\n            }]};\n    function Kn() {\n        return setTimeout(function () {\n            Xn = t\n        }), Xn = x.now()\n    }\n    function Zn(e, t, n) {\n        var r, i = (Qn[t] || []).concat(Qn["*"]), o = 0, a = i.length;\n        for (; a > o; o++)\n            if (r = i[o].call(n, t, e))\n                return r\n    }\n    function er(e, t, n) {\n        var r, i, o = 0, a = Gn.length, s = x.Deferred().always(function () {\n            delete l.elem\n        }), l = function () {\n            if (i)\n                return!1;\n            var t = Xn || Kn(), n = Math.max(0, u.startTime + u.duration - t), r = n / u.duration || 0, o = 1 - r, a = 0, l = u.tweens.length;\n            for (; l > a; a++)\n                u.tweens[a].run(o);\n            return s.notifyWith(e, [u, o, n]), 1 > o && l ? n : (s.resolveWith(e, [u]), !1)\n        }, u = s.promise({elem: e, props: x.extend({}, t), opts: x.extend(!0, {specialEasing: {}}, n), originalProperties: t, originalOptions: n, startTime: Xn || Kn(), duration: n.duration, tweens: [], createTween: function (t, n) {\n                var r = x.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);\n                return u.tweens.push(r), r\n            }, stop: function (t) {\n                var n = 0, r = t ? u.tweens.length : 0;\n                if (i)\n                    return this;\n                for (i = !0; r > n; n++)\n                    u.tweens[n].run(1);\n                return t ? s.resolveWith(e, [u, t]) : s.rejectWith(e, [u, t]), this\n            }}), c = u.props;\n        for (tr(c, u.opts.specialEasing); a > o; o++)\n            if (r = Gn[o].call(u, e, c, u.opts))\n                return r;\n        return x.map(c, Zn, u), x.isFunction(u.opts.start) && u.opts.start.call(e, u), x.fx.timer(x.extend(l, {elem: e, anim: u, queue: u.opts.queue})), u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always)\n    }\n    function tr(e, t) {\n        var n, r, i, o, a;\n        for (n in e)\n            if (r = x.camelCase(n), i = t[r], o = e[n], x.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), a = x.cssHooks[r], a && "expand"in a) {\n                o = a.expand(o), delete e[r];\n                for (n in o)\n                    n in e || (e[n] = o[n], t[n] = i)\n            } else\n                t[r] = i\n    }\n    x.Animation = x.extend(er, {tweener: function (e, t) {\n            x.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");\n            var n, r = 0, i = e.length;\n            for (; i > r; r++)\n                n = e[r], Qn[n] = Qn[n] || [], Qn[n].unshift(t)\n        }, prefilter: function (e, t) {\n            t ? Gn.unshift(e) : Gn.push(e)\n        }});\n    function nr(e, t, n) {\n        var r, i, o, a, s, l, u = this, c = {}, p = e.style, f = e.nodeType && nn(e), d = x._data(e, "fxshow");\n        n.queue || (s = x._queueHooks(e, "fx"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function () {\n            s.unqueued || l()\n        }), s.unqueued++, u.always(function () {\n            u.always(function () {\n                s.unqueued--, x.queue(e, "fx").length || s.empty.fire()\n            })\n        })), 1 === e.nodeType && ("height"in t || "width"in t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], "inline" === x.css(e, "display") && "none" === x.css(e, "float") && (x.support.inlineBlockNeedsLayout && "inline" !== ln(e.nodeName) ? p.zoom = 1 : p.display = "inline-block")), n.overflow && (p.overflow = "hidden", x.support.shrinkWrapBlocks || u.always(function () {\n            p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2]\n        }));\n        for (r in t)\n            if (i = t[r], Vn.exec(i)) {\n                if (delete t[r], o = o || "toggle" === i, i === (f ? "hide" : "show"))\n                    continue;\n                c[r] = d && d[r] || x.style(e, r)\n            }\n        if (!x.isEmptyObject(c)) {\n            d ? "hidden"in d && (f = d.hidden) : d = x._data(e, "fxshow", {}), o && (d.hidden = !f), f ? x(e).show() : u.done(function () {\n                x(e).hide()\n            }), u.done(function () {\n                var t;\n                x._removeData(e, "fxshow");\n                for (t in c)\n                    x.style(e, t, c[t])\n            });\n            for (r in c)\n                a = Zn(f ? d[r] : 0, r, u), r in d || (d[r] = a.start, f && (a.end = a.start, a.start = "width" === r || "height" === r ? 1 : 0))\n        }\n    }\n    function rr(e, t, n, r, i) {\n        return new rr.prototype.init(e, t, n, r, i)\n    }\n    x.Tween = rr, rr.prototype = {constructor: rr, init: function (e, t, n, r, i, o) {\n            this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (x.cssNumber[n] ? "" : "px")\n        }, cur: function () {\n            var e = rr.propHooks[this.prop];\n            return e && e.get ? e.get(this) : rr.propHooks._default.get(this)\n        }, run: function (e) {\n            var t, n = rr.propHooks[this.prop];\n            return this.pos = t = this.options.duration ? x.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : rr.propHooks._default.set(this), this\n        }}, rr.prototype.init.prototype = rr.prototype, rr.propHooks = {_default: {get: function (e) {\n                var t;\n                return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = x.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop]\n            }, set: function (e) {\n                x.fx.step[e.prop] ? x.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[x.cssProps[e.prop]] || x.cssHooks[e.prop]) ? x.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now\n            }}}, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = {set: function (e) {\n            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)\n        }}, x.each(["toggle", "show", "hide"], function (e, t) {\n        var n = x.fn[t];\n        x.fn[t] = function (e, r, i) {\n            return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ir(t, !0), e, r, i)\n        }\n    }), x.fn.extend({fadeTo: function (e, t, n, r) {\n            return this.filter(nn).css("opacity", 0).show().end().animate({opacity: t}, e, n, r)\n        }, animate: function (e, t, n, r) {\n            var i = x.isEmptyObject(e), o = x.speed(t, n, r), a = function () {\n                var t = er(this, x.extend({}, e), o);\n                (i || x._data(this, "finish")) && t.stop(!0)\n            };\n            return a.finish = a, i || o.queue === !1 ? this.each(a) : this.queue(o.queue, a)\n        }, stop: function (e, n, r) {\n            var i = function (e) {\n                var t = e.stop;\n                delete e.stop, t(r)\n            };\n            return"string" != typeof e && (r = n, n = e, e = t), n && e !== !1 && this.queue(e || "fx", []), this.each(function () {\n                var t = !0, n = null != e && e + "queueHooks", o = x.timers, a = x._data(this);\n                if (n)\n                    a[n] && a[n].stop && i(a[n]);\n                else\n                    for (n in a)\n                        a[n] && a[n].stop && Jn.test(n) && i(a[n]);\n                for (n = o.length; n--; )\n                    o[n].elem !== this || null != e && o[n].queue !== e || (o[n].anim.stop(r), t = !1, o.splice(n, 1));\n                (t || !r) && x.dequeue(this, e)\n            })\n        }, finish: function (e) {\n            return e !== !1 && (e = e || "fx"), this.each(function () {\n                var t, n = x._data(this), r = n[e + "queue"], i = n[e + "queueHooks"], o = x.timers, a = r ? r.length : 0;\n                for (n.finish = !0, x.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--; )\n                    o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));\n                for (t = 0; a > t; t++)\n                    r[t] && r[t].finish && r[t].finish.call(this);\n                delete n.finish\n            })\n        }});\n    function ir(e, t) {\n        var n, r = {height: e}, i = 0;\n        for (t = t?1:0; 4 > i; i += 2 - t)\n            n = Zt[i], r["margin" + n] = r["padding" + n] = e;\n        return t && (r.opacity = r.width = e), r\n    }\n    x.each({slideDown: ir("show"), slideUp: ir("hide"), slideToggle: ir("toggle"), fadeIn: {opacity: "show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, function (e, t) {\n        x.fn[e] = function (e, n, r) {\n            return this.animate(t, e, n, r)\n        }\n    }), x.speed = function (e, t, n) {\n        var r = e && "object" == typeof e ? x.extend({}, e) : {complete: n || !n && t || x.isFunction(e) && e, duration: e, easing: n && t || t && !x.isFunction(t) && t};\n        return r.duration = x.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in x.fx.speeds ? x.fx.speeds[r.duration] : x.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () {\n            x.isFunction(r.old) && r.old.call(this), r.queue && x.dequeue(this, r.queue)\n        }, r\n    }, x.easing = {linear: function (e) {\n            return e\n        }, swing: function (e) {\n            return.5 - Math.cos(e * Math.PI) / 2\n        }}, x.timers = [], x.fx = rr.prototype.init, x.fx.tick = function () {\n        var e, n = x.timers, r = 0;\n        for (Xn = x.now(); n.length > r; r++)\n            e = n[r], e() || n[r] !== e || n.splice(r--, 1);\n        n.length || x.fx.stop(), Xn = t\n    }, x.fx.timer = function (e) {\n        e() && x.timers.push(e) && x.fx.start()\n    }, x.fx.interval = 13, x.fx.start = function () {\n        Un || (Un = setInterval(x.fx.tick, x.fx.interval))\n    }, x.fx.stop = function () {\n        clearInterval(Un), Un = null\n    }, x.fx.speeds = {slow: 600, fast: 200, _default: 400}, x.fx.step = {}, x.expr && x.expr.filters && (x.expr.filters.animated = function (e) {\n        return x.grep(x.timers, function (t) {\n            return e === t.elem\n        }).length\n    }), x.fn.offset = function (e) {\n        if (arguments.length)\n            return e === t ? this : this.each(function (t) {\n                x.offset.setOffset(this, e, t)\n            });\n        var n, r, o = {top: 0, left: 0}, a = this[0], s = a && a.ownerDocument;\n        if (s)\n            return n = s.documentElement, x.contains(n, a) ? (typeof a.getBoundingClientRect !== i && (o = a.getBoundingClientRect()), r = or(s), {top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0), left: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0)}) : o\n    }, x.offset = {setOffset: function (e, t, n) {\n            var r = x.css(e, "position");\n            "static" === r && (e.style.position = "relative");\n            var i = x(e), o = i.offset(), a = x.css(e, "top"), s = x.css(e, "left"), l = ("absolute" === r || "fixed" === r) && x.inArray("auto", [a, s]) > -1, u = {}, c = {}, p, f;\n            l ? (c = i.position(), p = c.top, f = c.left) : (p = parseFloat(a) || 0, f = parseFloat(s) || 0), x.isFunction(t) && (t = t.call(e, n, o)), null != t.top && (u.top = t.top - o.top + p), null != t.left && (u.left = t.left - o.left + f), "using"in t ? t.using.call(e, u) : i.css(u)\n        }}, x.fn.extend({position: function () {\n            if (this[0]) {\n                var e, t, n = {top: 0, left: 0}, r = this[0];\n                return"fixed" === x.css(r, "position") ? t = r.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), x.nodeName(e[0], "html") || (n = e.offset()), n.top += x.css(e[0], "borderTopWidth", !0), n.left += x.css(e[0], "borderLeftWidth", !0)), {top: t.top - n.top - x.css(r, "marginTop", !0), left: t.left - n.left - x.css(r, "marginLeft", !0)}\n            }\n        }, offsetParent: function () {\n            return this.map(function () {\n                var e = this.offsetParent || s;\n                while (e && !x.nodeName(e, "html") && "static" === x.css(e, "position"))\n                    e = e.offsetParent;\n                return e || s\n            })\n        }}), x.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (e, n) {\n        var r = /Y/.test(n);\n        x.fn[e] = function (i) {\n            return x.access(this, function (e, i, o) {\n                var a = or(e);\n                return o === t ? a ? n in a ? a[n] : a.document.documentElement[i] : e[i] : (a ? a.scrollTo(r ? x(a).scrollLeft() : o, r ? o : x(a).scrollTop()) : e[i] = o, t)\n            }, e, i, arguments.length, null)\n        }\n    });\n    function or(e) {\n        return x.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1\n    }\n    x.each({Height: "height", Width: "width"}, function (e, n) {\n        x.each({padding: "inner" + e, content: n, "": "outer" + e}, function (r, i) {\n            x.fn[i] = function (i, o) {\n                var a = arguments.length && (r || "boolean" != typeof i), s = r || (i === !0 || o === !0 ? "margin" : "border");\n                return x.access(this, function (n, r, i) {\n                    var o;\n                    return x.isWindow(n) ? n.document.documentElement["client" + e] : 9 === n.nodeType ? (o = n.documentElement, Math.max(n.body["scroll" + e], o["scroll" + e], n.body["offset" + e], o["offset" + e], o["client" + e])) : i === t ? x.css(n, r, s) : x.style(n, r, i, s)\n                }, n, a ? i : t, a, null)\n            }\n        })\n    }), x.fn.size = function () {\n        return this.length\n    }, x.fn.andSelf = x.fn.addBack, "object" == typeof module && module && "object" == typeof module.exports ? module.exports = x : (e.jQuery = e.$ = x, "function" == "function" && __webpack_require__(4) && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n        return x\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))\n})(window);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(1), __webpack_require__(3)(module)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdmVuZG9yL2pxdWVyeS5taW4uanM/MDhmMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0g7QUFDaEg7QUFDQSxLQUFLLG9NQUFvTSx1RUFBdUUsRUFBRTtBQUNsUjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQsb0RBQW9EO0FBQ3BELG9FQUFvRSw0REFBNEQsOEJBQThCLE9BQU87QUFDcks7QUFDQTtBQUNBLCtMQUErTDtBQUMvTDtBQUNBLEtBQUssWUFBWTtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FB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QUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBLG1KQUFtSix1SUFBdUk7QUFDMVIsS0FBSyxjQUFjO0FBQ25CO0FBQ0E7QUFDQSxzS0FBc0ssUUFBUTtBQUM5SztBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0MsZ1JBQWdSO0FBQ2hSO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVSxXQUFXLG9EQUFvRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsQ0FBQyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIGpRdWVyeSB2MS4xMC4yIHwgKGMpIDIwMDUsIDIwMTMgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gfCBqcXVlcnkub3JnL2xpY2Vuc2VcbiAvL0Agc291cmNlTWFwcGluZ1VSTD1qcXVlcnkubWluLm1hcFxuICovXG4oZnVuY3Rpb24gKGUsIHQpIHtcbiAgICB2YXIgbiwgciwgaSA9IHR5cGVvZiB0LCBvID0gZS5sb2NhdGlvbiwgYSA9IGUuZG9jdW1lbnQsIHMgPSBhLmRvY3VtZW50RWxlbWVudCwgbCA9IGUualF1ZXJ5LCB1ID0gZS4kLCBjID0ge30sIHAgPSBbXSwgZiA9IFwiMS4xMC4yXCIsIGQgPSBwLmNvbmNhdCwgaCA9IHAucHVzaCwgZyA9IHAuc2xpY2UsIG0gPSBwLmluZGV4T2YsIHkgPSBjLnRvU3RyaW5nLCB2ID0gYy5oYXNPd25Qcm9wZXJ0eSwgYiA9IGYudHJpbSwgeCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHJldHVybiBuZXcgeC5mbi5pbml0KGUsIHQsIHIpXG4gICAgfSwgdyA9IC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZSwgVCA9IC9cXFMrL2csIEMgPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csIE4gPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLywgayA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLywgRSA9IC9eW1xcXSw6e31cXHNdKiQvLCBTID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLCBBID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbXFxkYS1mQS1GXXs0fSkvZywgaiA9IC9cIlteXCJcXFxcXFxyXFxuXSpcInx0cnVlfGZhbHNlfG51bGx8LT8oPzpcXGQrXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpL2csIEQgPSAvXi1tcy0vLCBMID0gLy0oW1xcZGEtel0pL2dpLCBIID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIHQudG9VcHBlckNhc2UoKVxuICAgIH0sIHEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAoYS5hZGRFdmVudExpc3RlbmVyIHx8IFwibG9hZFwiID09PSBlLnR5cGUgfHwgXCJjb21wbGV0ZVwiID09PSBhLnJlYWR5U3RhdGUpICYmIChfKCksIHgucmVhZHkoKSlcbiAgICB9LCBfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhLmFkZEV2ZW50TGlzdGVuZXIgPyAoYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBxLCAhMSksIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcSwgITEpKSA6IChhLmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIHEpLCBlLmRldGFjaEV2ZW50KFwib25sb2FkXCIsIHEpKVxuICAgIH07XG4gICAgeC5mbiA9IHgucHJvdG90eXBlID0ge2pxdWVyeTogZiwgY29uc3RydWN0b3I6IHgsIGluaXQ6IGZ1bmN0aW9uIChlLCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgaSwgbztcbiAgICAgICAgICAgIGlmICghZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPSBcIjxcIiA9PT0gZS5jaGFyQXQoMCkgJiYgXCI+XCIgPT09IGUuY2hhckF0KGUubGVuZ3RoIC0gMSkgJiYgZS5sZW5ndGggPj0gMyA/IFtudWxsLCBlLCBudWxsXSA6IE4uZXhlYyhlKSwgIWkgfHwgIWlbMV0gJiYgbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIW4gfHwgbi5qcXVlcnkgPyAobiB8fCByKS5maW5kKGUpIDogdGhpcy5jb25zdHJ1Y3RvcihuKS5maW5kKGUpO1xuICAgICAgICAgICAgICAgIGlmIChpWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuID0gbiBpbnN0YW5jZW9mIHggPyBuWzBdIDogbiwgeC5tZXJnZSh0aGlzLCB4LnBhcnNlSFRNTChpWzFdLCBuICYmIG4ubm9kZVR5cGUgPyBuLm93bmVyRG9jdW1lbnQgfHwgbiA6IGEsICEwKSksIGsudGVzdChpWzFdKSAmJiB4LmlzUGxhaW5PYmplY3QobikpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmlzRnVuY3Rpb24odGhpc1tpXSkgPyB0aGlzW2ldKG5baV0pIDogdGhpcy5hdHRyKGksIG5baV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobyA9IGEuZ2V0RWxlbWVudEJ5SWQoaVsyXSksIG8gJiYgby5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLmlkICE9PSBpWzJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIuZmluZChlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxLCB0aGlzWzBdID0gb1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0ID0gYSwgdGhpcy5zZWxlY3RvciA9IGUsIHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlLm5vZGVUeXBlID8gKHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBlLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXMpIDogeC5pc0Z1bmN0aW9uKGUpID8gci5yZWFkeShlKSA6IChlLnNlbGVjdG9yICE9PSB0ICYmICh0aGlzLnNlbGVjdG9yID0gZS5zZWxlY3RvciwgdGhpcy5jb250ZXh0ID0gZS5jb250ZXh0KSwgeC5tYWtlQXJyYXkoZSwgdGhpcykpXG4gICAgICAgIH0sIHNlbGVjdG9yOiBcIlwiLCBsZW5ndGg6IDAsIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnLmNhbGwodGhpcylcbiAgICAgICAgfSwgZ2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSA/IHRoaXMudG9BcnJheSgpIDogMCA+IGUgPyB0aGlzW3RoaXMubGVuZ3RoICsgZV0gOiB0aGlzW2VdXG4gICAgICAgIH0sIHB1c2hTdGFjazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0geC5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGUpO1xuICAgICAgICAgICAgcmV0dXJuIHQucHJldk9iamVjdCA9IHRoaXMsIHQuY29udGV4dCA9IHRoaXMuY29udGV4dCwgdFxuICAgICAgICB9LCBlYWNoOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIHguZWFjaCh0aGlzLCBlLCB0KVxuICAgICAgICB9LCByZWFkeTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB4LnJlYWR5LnByb21pc2UoKS5kb25lKGUpLCB0aGlzXG4gICAgICAgIH0sIHNsaWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICAgICAgICB9LCBmaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoMClcbiAgICAgICAgfSwgbGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoLTEpXG4gICAgICAgIH0sIGVxOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmxlbmd0aCwgbiA9ICtlICsgKDAgPiBlID8gdCA6IDApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4gPj0gMCAmJiB0ID4gbiA/IFt0aGlzW25dXSA6IFtdKVxuICAgICAgICB9LCBtYXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soeC5tYXAodGhpcywgZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5jYWxsKHQsIG4sIHQpXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfSwgZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IobnVsbClcbiAgICAgICAgfSwgcHVzaDogaCwgc29ydDogW10uc29ydCwgc3BsaWNlOiBbXS5zcGxpY2V9LCB4LmZuLmluaXQucHJvdG90eXBlID0geC5mbiwgeC5leHRlbmQgPSB4LmZuLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsIG4sIHIsIGksIG8sIGEsIHMgPSBhcmd1bWVudHNbMF0gfHwge30sIGwgPSAxLCB1ID0gYXJndW1lbnRzLmxlbmd0aCwgYyA9ICExO1xuICAgICAgICBmb3IgKFwiYm9vbGVhblwiID09IHR5cGVvZiBzICYmIChjID0gcywgcyA9IGFyZ3VtZW50c1sxXSB8fCB7fSwgbCA9IDIpLCBcIm9iamVjdFwiID09IHR5cGVvZiBzIHx8IHguaXNGdW5jdGlvbihzKSB8fCAocyA9IHt9KSwgdSA9PT0gbCAmJiAocyA9IHRoaXMsIC0tbCk7IHUgPiBsOyBsKyspXG4gICAgICAgICAgICBpZiAobnVsbCAhPSAobyA9IGFyZ3VtZW50c1tsXSkpXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIG8pXG4gICAgICAgICAgICAgICAgICAgIGUgPSBzW2ldLCByID0gb1tpXSwgcyAhPT0gciAmJiAoYyAmJiByICYmICh4LmlzUGxhaW5PYmplY3QocikgfHwgKG4gPSB4LmlzQXJyYXkocikpKSA/IChuID8gKG4gPSAhMSwgYSA9IGUgJiYgeC5pc0FycmF5KGUpID8gZSA6IFtdKSA6IGEgPSBlICYmIHguaXNQbGFpbk9iamVjdChlKSA/IGUgOiB7fSwgc1tpXSA9IHguZXh0ZW5kKGMsIGEsIHIpKSA6IHIgIT09IHQgJiYgKHNbaV0gPSByKSk7XG4gICAgICAgIHJldHVybiBzXG4gICAgfSwgeC5leHRlbmQoe2V4cGFuZG86IFwialF1ZXJ5XCIgKyAoZiArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSwgbm9Db25mbGljdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlLiQgPT09IHggJiYgKGUuJCA9IHUpLCB0ICYmIGUualF1ZXJ5ID09PSB4ICYmIChlLmpRdWVyeSA9IGwpLCB4XG4gICAgICAgIH0sIGlzUmVhZHk6ICExLCByZWFkeVdhaXQ6IDEsIGhvbGRSZWFkeTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUgPyB4LnJlYWR5V2FpdCsrIDogeC5yZWFkeSghMClcbiAgICAgICAgfSwgcmVhZHk6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZSA9PT0gITAgPyAhLS14LnJlYWR5V2FpdCA6ICF4LmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWEuYm9keSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoeC5yZWFkeSk7XG4gICAgICAgICAgICAgICAgeC5pc1JlYWR5ID0gITAsIGUgIT09ICEwICYmIC0teC5yZWFkeVdhaXQgPiAwIHx8IChuLnJlc29sdmVXaXRoKGEsIFt4XSksIHguZm4udHJpZ2dlciAmJiB4KGEpLnRyaWdnZXIoXCJyZWFkeVwiKS5vZmYoXCJyZWFkeVwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaXNGdW5jdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVyblwiZnVuY3Rpb25cIiA9PT0geC50eXBlKGUpXG4gICAgICAgIH0sIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVyblwiYXJyYXlcIiA9PT0geC50eXBlKGUpXG4gICAgICAgIH0sIGlzV2luZG93OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gZSAmJiBlID09IGUud2luZG93XG4gICAgICAgIH0sIGlzTnVtZXJpYzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiFpc05hTihwYXJzZUZsb2F0KGUpKSAmJiBpc0Zpbml0ZShlKVxuICAgICAgICB9LCB0eXBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSA/IGUgKyBcIlwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBjW3kuY2FsbChlKV0gfHwgXCJvYmplY3RcIiA6IHR5cGVvZiBlXG4gICAgICAgIH0sIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgIGlmICghZSB8fCBcIm9iamVjdFwiICE9PSB4LnR5cGUoZSkgfHwgZS5ub2RlVHlwZSB8fCB4LmlzV2luZG93KGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiExO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jb25zdHJ1Y3RvciAmJiAhdi5jYWxsKGUsIFwiY29uc3RydWN0b3JcIikgJiYgIXYuY2FsbChlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4hMVxuICAgICAgICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiExXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeC5zdXBwb3J0Lm93bkxhc3QpXG4gICAgICAgICAgICAgICAgZm9yIChuIGluIGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2LmNhbGwoZSwgbik7XG4gICAgICAgICAgICBmb3IgKG4gaW4gZSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4gbiA9PT0gdCB8fCB2LmNhbGwoZSwgbilcbiAgICAgICAgfSwgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgZm9yICh0IGluIGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuITE7XG4gICAgICAgICAgICByZXR1cm4hMFxuICAgICAgICB9LCBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGUpXG4gICAgICAgIH0sIHBhcnNlSFRNTDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIGlmICghZSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgXCJib29sZWFuXCIgPT0gdHlwZW9mIHQgJiYgKG4gPSB0LCB0ID0gITEpLCB0ID0gdCB8fCBhO1xuICAgICAgICAgICAgdmFyIHIgPSBrLmV4ZWMoZSksIGkgPSAhbiAmJiBbXTtcbiAgICAgICAgICAgIHJldHVybiByID8gW3QuY3JlYXRlRWxlbWVudChyWzFdKV0gOiAociA9IHguYnVpbGRGcmFnbWVudChbZV0sIHQsIGkpLCBpICYmIHgoaSkucmVtb3ZlKCksIHgubWVyZ2UoW10sIHIuY2hpbGROb2RlcykpXG4gICAgICAgIH0sIHBhcnNlSlNPTjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBlLkpTT04gJiYgZS5KU09OLnBhcnNlID8gZS5KU09OLnBhcnNlKG4pIDogbnVsbCA9PT0gbiA/IG4gOiBcInN0cmluZ1wiID09IHR5cGVvZiBuICYmIChuID0geC50cmltKG4pLCBuICYmIEUudGVzdChuLnJlcGxhY2UoQSwgXCJAXCIpLnJlcGxhY2UoaiwgXCJdXCIpLnJlcGxhY2UoUywgXCJcIikpKSA/IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsgbikoKSA6ICh4LmVycm9yKFwiSW52YWxpZCBKU09OOiBcIiArIG4pLCB0KVxuICAgICAgICB9LCBwYXJzZVhNTDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciByLCBpO1xuICAgICAgICAgICAgaWYgKCFuIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGUuRE9NUGFyc2VyID8gKGkgPSBuZXcgRE9NUGFyc2VyLCByID0gaS5wYXJzZUZyb21TdHJpbmcobiwgXCJ0ZXh0L3htbFwiKSkgOiAociA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKSwgci5hc3luYyA9IFwiZmFsc2VcIiwgci5sb2FkWE1MKG4pKVxuICAgICAgICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICAgICAgICAgIHIgPSB0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gciAmJiByLmRvY3VtZW50RWxlbWVudCAmJiAhci5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpLmxlbmd0aCB8fCB4LmVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgbiksIHJcbiAgICAgICAgfSwgbm9vcDogZnVuY3Rpb24gKCkge1xuICAgICAgICB9LCBnbG9iYWxFdmFsOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdCAmJiB4LnRyaW0odCkgJiYgKGUuZXhlY1NjcmlwdCB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIGUuZXZhbC5jYWxsKGUsIHQpXG4gICAgICAgICAgICB9KSh0KVxuICAgICAgICB9LCBjYW1lbENhc2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5yZXBsYWNlKEQsIFwibXMtXCIpLnJlcGxhY2UoTCwgSClcbiAgICAgICAgfSwgbm9kZU5hbWU6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gZS5ub2RlTmFtZSAmJiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHQudG9Mb3dlckNhc2UoKVxuICAgICAgICB9LCBlYWNoOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIsIGkgPSAwLCBvID0gZS5sZW5ndGgsIGEgPSBNKGUpO1xuICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbyA+IGk7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID0gdC5hcHBseShlW2ldLCBuKSwgciA9PT0gITEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IHQuYXBwbHkoZVtpXSwgbiksIHIgPT09ICExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbyA+IGk7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSB0LmNhbGwoZVtpXSwgaSwgZVtpXSksIHIgPT09ICExKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBlKVxuICAgICAgICAgICAgICAgICAgICBpZiAociA9IHQuY2FsbChlW2ldLCBpLCBlW2ldKSwgciA9PT0gITEpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgIH0sIHRyaW06IGIgJiYgIWIuY2FsbChcIlxcdWZlZmZcXHUwMGEwXCIpID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGUgPyBcIlwiIDogYi5jYWxsKGUpXG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSA/IFwiXCIgOiAoZSArIFwiXCIpLnJlcGxhY2UoQywgXCJcIilcbiAgICAgICAgfSwgbWFrZUFycmF5OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0IHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gZSAmJiAoTShPYmplY3QoZSkpID8geC5tZXJnZShuLCBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gW2VdIDogZSkgOiBoLmNhbGwobiwgZSkpLCBuXG4gICAgICAgIH0sIGluQXJyYXk6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtLmNhbGwodCwgZSwgbik7XG4gICAgICAgICAgICAgICAgZm9yIChyID0gdC5sZW5ndGgsIG4gPSBuPzAgPiBuP01hdGgubWF4KDAsIHIgKyBuKTpuOjA7IHIgPiBuOyBuKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChuIGluIHQgJiYgdFtuXSA9PT0gZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4tMVxuICAgICAgICB9LCBtZXJnZTogZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgIHZhciByID0gbi5sZW5ndGgsIGkgPSBlLmxlbmd0aCwgbyA9IDA7XG4gICAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgcilcbiAgICAgICAgICAgICAgICBmb3IgKDsgciA+IG87IG8rKylcbiAgICAgICAgICAgICAgICAgICAgZVtpKytdID0gbltvXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3aGlsZSAobltvXSAhPT0gdClcbiAgICAgICAgICAgICAgICAgICAgZVtpKytdID0gbltvKytdO1xuICAgICAgICAgICAgcmV0dXJuIGUubGVuZ3RoID0gaSwgZVxuICAgICAgICB9LCBncmVwOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIsIGkgPSBbXSwgbyA9IDAsIGEgPSBlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobiA9ICEhbjsgYSA+IG87IG8rKylcbiAgICAgICAgICAgICAgICByID0gISF0KGVbb10sIG8pLCBuICE9PSByICYmIGkucHVzaChlW29dKTtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgIH0sIG1hcDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHZhciByLCBpID0gMCwgbyA9IGUubGVuZ3RoLCBhID0gTShlKSwgcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGEpXG4gICAgICAgICAgICAgICAgZm9yICg7IG8gPiBpOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0KGVbaV0sIGksIG4pLCBudWxsICE9IHIgJiYgKHNbcy5sZW5ndGhdID0gcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIGUpXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0KGVbaV0sIGksIG4pLCBudWxsICE9IHIgJiYgKHNbcy5sZW5ndGhdID0gcik7XG4gICAgICAgICAgICByZXR1cm4gZC5hcHBseShbXSwgcylcbiAgICAgICAgfSwgZ3VpZDogMSwgcHJveHk6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICB2YXIgciwgaSwgbztcbiAgICAgICAgICAgIHJldHVyblwic3RyaW5nXCIgPT0gdHlwZW9mIG4gJiYgKG8gPSBlW25dLCBuID0gZSwgZSA9IG8pLCB4LmlzRnVuY3Rpb24oZSkgPyAociA9IGcuY2FsbChhcmd1bWVudHMsIDIpLCBpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmFwcGx5KG4gfHwgdGhpcywgci5jb25jYXQoZy5jYWxsKGFyZ3VtZW50cykpKVxuICAgICAgICAgICAgfSwgaS5ndWlkID0gZS5ndWlkID0gZS5ndWlkIHx8IHguZ3VpZCsrLCBpKSA6IHRcbiAgICAgICAgfSwgYWNjZXNzOiBmdW5jdGlvbiAoZSwgbiwgciwgaSwgbywgYSwgcykge1xuICAgICAgICAgICAgdmFyIGwgPSAwLCB1ID0gZS5sZW5ndGgsIGMgPSBudWxsID09IHI7XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0geC50eXBlKHIpKSB7XG4gICAgICAgICAgICAgICAgbyA9ICEwO1xuICAgICAgICAgICAgICAgIGZvciAobCBpbiByKVxuICAgICAgICAgICAgICAgICAgICB4LmFjY2VzcyhlLCBuLCBsLCByW2xdLCAhMCwgYSwgcylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSAhPT0gdCAmJiAobyA9ICEwLCB4LmlzRnVuY3Rpb24oaSkgfHwgKHMgPSAhMCksIGMgJiYgKHMgPyAobi5jYWxsKGUsIGkpLCBuID0gbnVsbCkgOiAoYyA9IG4sIG4gPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLmNhbGwoeChlKSwgbilcbiAgICAgICAgICAgIH0pKSwgbikpXG4gICAgICAgICAgICAgICAgZm9yICg7IHUgPiBsOyBsKyspXG4gICAgICAgICAgICAgICAgICAgIG4oZVtsXSwgciwgcyA/IGkgOiBpLmNhbGwoZVtsXSwgbCwgbihlW2xdLCByKSkpO1xuICAgICAgICAgICAgcmV0dXJuIG8gPyBlIDogYyA/IG4uY2FsbChlKSA6IHUgPyBuKGVbMF0sIHIpIDogYVxuICAgICAgICB9LCBub3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpXG4gICAgICAgIH0sIHN3YXA6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgaSwgbywgYSA9IHt9O1xuICAgICAgICAgICAgZm9yIChvIGluIHQpXG4gICAgICAgICAgICAgICAgYVtvXSA9IGUuc3R5bGVbb10sIGUuc3R5bGVbb10gPSB0W29dO1xuICAgICAgICAgICAgaSA9IG4uYXBwbHkoZSwgciB8fCBbXSk7XG4gICAgICAgICAgICBmb3IgKG8gaW4gdClcbiAgICAgICAgICAgICAgICBlLnN0eWxlW29dID0gYVtvXTtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgIH19KSwgeC5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgaWYgKG4gPSB4LkRlZmVycmVkKCksIFwiY29tcGxldGVcIiA9PT0gYS5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoeC5yZWFkeSk7XG4gICAgICAgICAgICBlbHNlIGlmIChhLmFkZEV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBxLCAhMSksIGUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcSwgITEpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYS5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBxKSwgZS5hdHRhY2hFdmVudChcIm9ubG9hZFwiLCBxKTtcbiAgICAgICAgICAgICAgICB2YXIgciA9ICExO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBudWxsID09IGUuZnJhbWVFbGVtZW50ICYmIGEuZG9jdW1lbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByICYmIHIuZG9TY3JvbGwgJiYgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF4LmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5kb1Njcm9sbChcImxlZnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChvLCA1MClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF8oKSwgeC5yZWFkeSgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4ucHJvbWlzZSh0KVxuICAgIH0sIHguZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGNbXCJbb2JqZWN0IFwiICsgdCArIFwiXVwiXSA9IHQudG9Mb3dlckNhc2UoKVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIE0oZSkge1xuICAgICAgICB2YXIgdCA9IGUubGVuZ3RoLCBuID0geC50eXBlKGUpO1xuICAgICAgICByZXR1cm4geC5pc1dpbmRvdyhlKSA/ICExIDogMSA9PT0gZS5ub2RlVHlwZSAmJiB0ID8gITAgOiBcImFycmF5XCIgPT09IG4gfHwgXCJmdW5jdGlvblwiICE9PSBuICYmICgwID09PSB0IHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgJiYgdCA+IDAgJiYgdCAtIDEgaW4gZSlcbiAgICB9XG4gICAgciA9IHgoYSksIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciBuLCByLCBpLCBvLCBhLCBzLCBsLCB1LCBjLCBwLCBmLCBkLCBoLCBnLCBtLCB5LCB2LCBiID0gXCJzaXp6bGVcIiArIC1uZXcgRGF0ZSwgdyA9IGUuZG9jdW1lbnQsIFQgPSAwLCBDID0gMCwgTiA9IHN0KCksIGsgPSBzdCgpLCBFID0gc3QoKSwgUyA9ICExLCBBID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlID09PSB0ID8gKFMgPSAhMCwgMCkgOiAwXG4gICAgICAgIH0sIGogPSB0eXBlb2YgdCwgRCA9IDEgPDwgMzEsIEwgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgSCA9IFtdLCBxID0gSC5wb3AsIF8gPSBILnB1c2gsIE0gPSBILnB1c2gsIE8gPSBILnNsaWNlLCBGID0gSC5pbmRleE9mIHx8IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IDAsIG4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBuID4gdDsgdCsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzW3RdID09PSBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIHJldHVybi0xXG4gICAgICAgIH0sIEIgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsIFAgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsIFIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLCBXID0gUi5yZXBsYWNlKFwid1wiLCBcIncjXCIpLCAkID0gXCJcXFxcW1wiICsgUCArIFwiKihcIiArIFIgKyBcIilcIiArIFAgKyBcIiooPzooWypeJHwhfl0/PSlcIiArIFAgKyBcIiooPzooWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfChcIiArIFcgKyBcIil8KXwpXCIgKyBQICsgXCIqXFxcXF1cIiwgSSA9IFwiOihcIiArIFIgKyBcIikoPzpcXFxcKCgoWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArICQucmVwbGFjZSgzLCA4KSArIFwiKSopfC4qKVxcXFwpfClcIiwgeiA9IFJlZ0V4cChcIl5cIiArIFAgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyBQICsgXCIrJFwiLCBcImdcIiksIFggPSBSZWdFeHAoXCJeXCIgKyBQICsgXCIqLFwiICsgUCArIFwiKlwiKSwgVSA9IFJlZ0V4cChcIl5cIiArIFAgKyBcIiooWz4rfl18XCIgKyBQICsgXCIpXCIgKyBQICsgXCIqXCIpLCBWID0gUmVnRXhwKFAgKyBcIipbK35dXCIpLCBZID0gUmVnRXhwKFwiPVwiICsgUCArIFwiKihbXlxcXFxdJ1xcXCJdKilcIiArIFAgKyBcIipcXFxcXVwiLCBcImdcIiksIEogPSBSZWdFeHAoSSksIEcgPSBSZWdFeHAoXCJeXCIgKyBXICsgXCIkXCIpLCBRID0ge0lEOiBSZWdFeHAoXCJeIyhcIiArIFIgKyBcIilcIiksIENMQVNTOiBSZWdFeHAoXCJeXFxcXC4oXCIgKyBSICsgXCIpXCIpLCBUQUc6IFJlZ0V4cChcIl4oXCIgKyBSLnJlcGxhY2UoXCJ3XCIsIFwidypcIikgKyBcIilcIiksIEFUVFI6IFJlZ0V4cChcIl5cIiArICQpLCBQU0VVRE86IFJlZ0V4cChcIl5cIiArIEkpLCBDSElMRDogUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIFAgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgUCArIFwiKig/OihbKy1dfClcIiArIFAgKyBcIiooXFxcXGQrKXwpKVwiICsgUCArIFwiKlxcXFwpfClcIiwgXCJpXCIpLCBib29sOiBSZWdFeHAoXCJeKD86XCIgKyBCICsgXCIpJFwiLCBcImlcIiksIG5lZWRzQ29udGV4dDogUmVnRXhwKFwiXlwiICsgUCArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIFAgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyBQICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIpfSwgSyA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sIFogPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLywgZXQgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLCB0dCA9IC9eaFxcZCQvaSwgbnQgPSAvJ3xcXFxcL2csIHJ0ID0gUmVnRXhwKFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyBQICsgXCI/fChcIiArIFAgKyBcIil8LilcIiwgXCJpZ1wiKSwgaXQgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIgPSBcIjB4XCIgKyB0IC0gNjU1MzY7XG4gICAgICAgICAgICByZXR1cm4gciAhPT0gciB8fCBuID8gdCA6IDAgPiByID8gU3RyaW5nLmZyb21DaGFyQ29kZShyICsgNjU1MzYpIDogU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IHIgPj4gMTAsIDU2MzIwIHwgMTAyMyAmIHIpXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBNLmFwcGx5KEggPSBPLmNhbGwody5jaGlsZE5vZGVzKSwgdy5jaGlsZE5vZGVzKSwgSFt3LmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZVxuICAgICAgICB9IGNhdGNoIChvdCkge1xuICAgICAgICAgICAgTSA9IHthcHBseTogSC5sZW5ndGggPyBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBfLmFwcGx5KGUsIE8uY2FsbCh0KSlcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmxlbmd0aCwgciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlW24rK10gPSB0W3IrK10pXG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGUubGVuZ3RoID0gbiAtIDFcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGF0KGUsIHQsIG4sIGkpIHtcbiAgICAgICAgICAgIHZhciBvLCBhLCBzLCBsLCB1LCBjLCBkLCBtLCB5LCB4O1xuICAgICAgICAgICAgaWYgKCh0ID8gdC5vd25lckRvY3VtZW50IHx8IHQgOiB3KSAhPT0gZiAmJiBwKHQpLCB0ID0gdCB8fCBmLCBuID0gbiB8fCBbXSwgIWUgfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIGlmICgxICE9PSAobCA9IHQubm9kZVR5cGUpICYmIDkgIT09IGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuW107XG4gICAgICAgICAgICBpZiAoaCAmJiAhaSkge1xuICAgICAgICAgICAgICAgIGlmIChvID0gWi5leGVjKGUpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocyA9IG9bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICg5ID09PSBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPSB0LmdldEVsZW1lbnRCeUlkKHMpLCAhYSB8fCAhYS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5pZCA9PT0gcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4ucHVzaChhKSwgblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0Lm93bmVyRG9jdW1lbnQgJiYgKGEgPSB0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocykpICYmIHYodCwgYSkgJiYgYS5pZCA9PT0gcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5wdXNoKGEpLCBuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob1syXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTS5hcHBseShuLCB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpKSwgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocyA9IG9bM10pICYmIHIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE0uYXBwbHkobiwgdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHMpKSwgblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIucXNhICYmICghZyB8fCAhZy50ZXN0KGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobSA9IGQgPSBiLCB5ID0gdCwgeCA9IDkgPT09IGwgJiYgZSwgMSA9PT0gbCAmJiBcIm9iamVjdFwiICE9PSB0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBtdChlKSwgKGQgPSB0LmdldEF0dHJpYnV0ZShcImlkXCIpKSA/IG0gPSBkLnJlcGxhY2UobnQsIFwiXFxcXCQmXCIpIDogdC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBtKSwgbSA9IFwiW2lkPSdcIiArIG0gKyBcIiddIFwiLCB1ID0gYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbdV0gPSBtICsgeXQoY1t1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gVi50ZXN0KGUpICYmIHQucGFyZW50Tm9kZSB8fCB0LCB4ID0gYy5qb2luKFwiLFwiKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh4KVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTS5hcHBseShuLCB5LnF1ZXJ5U2VsZWN0b3JBbGwoeCkpLCBuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgfHwgdC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrdChlLnJlcGxhY2UoeiwgXCIkMVwiKSwgdCwgbiwgaSlcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdCgpIHtcbiAgICAgICAgICAgIHZhciBlID0gW107XG4gICAgICAgICAgICBmdW5jdGlvbiB0KG4sIHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5wdXNoKG4gKz0gXCIgXCIpID4gby5jYWNoZUxlbmd0aCAmJiBkZWxldGUgdFtlLnNoaWZ0KCldLCB0W25dID0gclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsdChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZVtiXSA9ICEwLCBlXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXQoZSkge1xuICAgICAgICAgICAgdmFyIHQgPSBmLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiEhZSh0KVxuICAgICAgICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICAgICAgICAgIHJldHVybiExXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCksIHQgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3QoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4gPSBlLnNwbGl0KFwifFwiKSwgciA9IGUubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHItLSlcbiAgICAgICAgICAgICAgICBvLmF0dHJIYW5kbGVbbltyXV0gPSB0XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHQoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0ICYmIGUsIHIgPSBuICYmIDEgPT09IGUubm9kZVR5cGUgJiYgMSA9PT0gdC5ub2RlVHlwZSAmJiAofnQuc291cmNlSW5kZXggfHwgRCkgLSAofmUuc291cmNlSW5kZXggfHwgRCk7XG4gICAgICAgICAgICBpZiAocilcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuID0gbi5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4tMTtcbiAgICAgICAgICAgIHJldHVybiBlID8gMSA6IC0xXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuXCJpbnB1dFwiID09PSBuICYmIHQudHlwZSA9PT0gZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGR0KGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybihcImlucHV0XCIgPT09IG4gfHwgXCJidXR0b25cIiA9PT0gbikgJiYgdC50eXBlID09PSBlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaHQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGx0KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQgPSArdCwgbHQoZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSBlKFtdLCBuLmxlbmd0aCwgdCksIGEgPSBvLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGEtLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5baSA9IG9bYV1dICYmIChuW2ldID0gIShyW2ldID0gbltpXSkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcyA9IGF0LmlzWE1MID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZSAmJiAoZS5vd25lckRvY3VtZW50IHx8IGUpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHJldHVybiB0ID8gXCJIVE1MXCIgIT09IHQubm9kZU5hbWUgOiAhMVxuICAgICAgICB9LCByID0gYXQuc3VwcG9ydCA9IHt9LCBwID0gYXQuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIG4gPSBlID8gZS5vd25lckRvY3VtZW50IHx8IGUgOiB3LCBpID0gbi5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIHJldHVybiBuICE9PSBmICYmIDkgPT09IG4ubm9kZVR5cGUgJiYgbi5kb2N1bWVudEVsZW1lbnQgPyAoZiA9IG4sIGQgPSBuLmRvY3VtZW50RWxlbWVudCwgaCA9ICFzKG4pLCBpICYmIGkuYXR0YWNoRXZlbnQgJiYgaSAhPT0gaS50b3AgJiYgaS5hdHRhY2hFdmVudChcIm9uYmVmb3JldW5sb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwKClcbiAgICAgICAgICAgIH0pLCByLmF0dHJpYnV0ZXMgPSB1dChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmNsYXNzTmFtZSA9IFwiaVwiLCAhZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIilcbiAgICAgICAgICAgIH0pLCByLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5hcHBlbmRDaGlsZChuLmNyZWF0ZUNvbW1lbnQoXCJcIikpLCAhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoXG4gICAgICAgICAgICB9KSwgci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2EnPjwvZGl2PjxkaXYgY2xhc3M9J2EgaSc+PC9kaXY+XCIsIGUuZmlyc3RDaGlsZC5jbGFzc05hbWUgPSBcImlcIiwgMiA9PT0gZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaVwiKS5sZW5ndGhcbiAgICAgICAgICAgIH0pLCByLmdldEJ5SWQgPSB1dChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmFwcGVuZENoaWxkKGUpLmlkID0gYiwgIW4uZ2V0RWxlbWVudHNCeU5hbWUgfHwgIW4uZ2V0RWxlbWVudHNCeU5hbWUoYikubGVuZ3RoXG4gICAgICAgICAgICB9KSwgci5nZXRCeUlkID8gKG8uZmluZC5JRCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0LmdldEVsZW1lbnRCeUlkICE9PSBqICYmIGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0LmdldEVsZW1lbnRCeUlkKGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAmJiBuLnBhcmVudE5vZGUgPyBbbl0gOiBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG8uZmlsdGVyLklEID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUucmVwbGFjZShydCwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pIDogKGRlbGV0ZSBvLmZpbmQuSUQsIG8uZmlsdGVyLklEID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUucmVwbGFjZShydCwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHR5cGVvZiBlLmdldEF0dHJpYnV0ZU5vZGUgIT09IGogJiYgZS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuICYmIG4udmFsdWUgPT09IHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgby5maW5kLlRBRyA9IHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygbi5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gaiA/IG4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSkgOiB0XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiwgciA9IFtdLCBpID0gMCwgbyA9IHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk7XG4gICAgICAgICAgICAgICAgaWYgKFwiKlwiID09PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuID0gb1tpKytdKVxuICAgICAgICAgICAgICAgICAgICAgICAgMSA9PT0gbi5ub2RlVHlwZSAmJiByLnB1c2gobik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvXG4gICAgICAgICAgICB9LCBvLmZpbmQuQ0xBU1MgPSByLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG4uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gaiAmJiBoID8gbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGUpIDogdFxuICAgICAgICAgICAgfSwgbSA9IFtdLCBnID0gW10sIChyLnFzYSA9IEsudGVzdChuLnF1ZXJ5U2VsZWN0b3JBbGwpKSAmJiAodXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLmlubmVySFRNTCA9IFwiPHNlbGVjdD48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCB8fCBnLnB1c2goXCJcXFxcW1wiICsgUCArIFwiKig/OnZhbHVlfFwiICsgQiArIFwiKVwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoIHx8IGcucHVzaChcIjpjaGVja2VkXCIpXG4gICAgICAgICAgICB9KSwgdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IG4uY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgIHQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKSwgZS5hcHBlbmRDaGlsZCh0KS5zZXRBdHRyaWJ1dGUoXCJ0XCIsIFwiXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbdF49JyddXCIpLmxlbmd0aCAmJiBnLnB1c2goXCJbKl4kXT1cIiArIFAgKyBcIiooPzonJ3xcXFwiXFxcIilcIiksIGUucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCB8fCBnLnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKSwgZy5wdXNoKFwiLC4qOlwiKVxuICAgICAgICAgICAgfSkpLCAoci5tYXRjaGVzU2VsZWN0b3IgPSBLLnRlc3QoeSA9IGQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGQubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGQub01hdGNoZXNTZWxlY3RvciB8fCBkLm1zTWF0Y2hlc1NlbGVjdG9yKSkgJiYgdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByLmRpc2Nvbm5lY3RlZE1hdGNoID0geS5jYWxsKGUsIFwiZGl2XCIpLCB5LmNhbGwoZSwgXCJbcyE9JyddOnhcIiksIG0ucHVzaChcIiE9XCIsIEkpXG4gICAgICAgICAgICB9KSwgZyA9IGcubGVuZ3RoICYmIFJlZ0V4cChnLmpvaW4oXCJ8XCIpKSwgbSA9IG0ubGVuZ3RoICYmIFJlZ0V4cChtLmpvaW4oXCJ8XCIpKSwgdiA9IEsudGVzdChkLmNvbnRhaW5zKSB8fCBkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID8gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IDkgPT09IGUubm9kZVR5cGUgPyBlLmRvY3VtZW50RWxlbWVudCA6IGUsIHIgPSB0ICYmIHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA9PT0gciB8fCAhKCFyIHx8IDEgIT09IHIubm9kZVR5cGUgfHwgIShuLmNvbnRhaW5zID8gbi5jb250YWlucyhyKSA6IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgMTYgJiBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHIpKSlcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgIGlmICh0KVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IHQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID09PSBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiEwO1xuICAgICAgICAgICAgICAgIHJldHVybiExXG4gICAgICAgICAgICB9LCBBID0gZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTID0gITAsIDA7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA/IDEgJiBpIHx8ICFyLnNvcnREZXRhY2hlZCAmJiB0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUpID09PSBpID8gZSA9PT0gbiB8fCB2KHcsIGUpID8gLTEgOiB0ID09PSBuIHx8IHYodywgdCkgPyAxIDogYyA/IEYuY2FsbChjLCBlKSAtIEYuY2FsbChjLCB0KSA6IDAgOiA0ICYgaSA/IC0xIDogMSA6IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gPyAtMSA6IDFcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgIHZhciByLCBpID0gMCwgbyA9IGUucGFyZW50Tm9kZSwgYSA9IHQucGFyZW50Tm9kZSwgcyA9IFtlXSwgbCA9IFt0XTtcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFMgPSAhMCwgMDtcbiAgICAgICAgICAgICAgICBpZiAoIW8gfHwgIWEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID09PSBuID8gLTEgOiB0ID09PSBuID8gMSA6IG8gPyAtMSA6IGEgPyAxIDogYyA/IEYuY2FsbChjLCBlKSAtIEYuY2FsbChjLCB0KSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKG8gPT09IGEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwdChlLCB0KTtcbiAgICAgICAgICAgICAgICByID0gZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAociA9IHIucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgcy51bnNoaWZ0KHIpO1xuICAgICAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChyID0gci5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBsLnVuc2hpZnQocik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNbaV0gPT09IGxbaV0pXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA/IHB0KHNbaV0sIGxbaV0pIDogc1tpXSA9PT0gdyA/IC0xIDogbFtpXSA9PT0gdyA/IDEgOiAwXG4gICAgICAgICAgICB9LCBuKSA6IGZcbiAgICAgICAgfSwgYXQubWF0Y2hlcyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXQoZSwgbnVsbCwgbnVsbCwgdClcbiAgICAgICAgfSwgYXQubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIGlmICgoZS5vd25lckRvY3VtZW50IHx8IGUpICE9PSBmICYmIHAoZSksIHQgPSB0LnJlcGxhY2UoWSwgXCI9JyQxJ11cIiksICEoIXIubWF0Y2hlc1NlbGVjdG9yIHx8ICFoIHx8IG0gJiYgbS50ZXN0KHQpIHx8IGcgJiYgZy50ZXN0KHQpKSlcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHkuY2FsbChlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gfHwgci5kaXNjb25uZWN0ZWRNYXRjaCB8fCBlLmRvY3VtZW50ICYmIDExICE9PSBlLmRvY3VtZW50Lm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0KHQsIGYsIG51bGwsIFtlXSkubGVuZ3RoID4gMFxuICAgICAgICB9LCBhdC5jb250YWlucyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4oZS5vd25lckRvY3VtZW50IHx8IGUpICE9PSBmICYmIHAoZSksIHYoZSwgdClcbiAgICAgICAgfSwgYXQuYXR0ciA9IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICAoZS5vd25lckRvY3VtZW50IHx8IGUpICE9PSBmICYmIHAoZSk7XG4gICAgICAgICAgICB2YXIgaSA9IG8uYXR0ckhhbmRsZVtuLnRvTG93ZXJDYXNlKCldLCBhID0gaSAmJiBMLmNhbGwoby5hdHRySGFuZGxlLCBuLnRvTG93ZXJDYXNlKCkpID8gaShlLCBuLCAhaCkgOiB0O1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IHQgPyByLmF0dHJpYnV0ZXMgfHwgIWggPyBlLmdldEF0dHJpYnV0ZShuKSA6IChhID0gZS5nZXRBdHRyaWJ1dGVOb2RlKG4pKSAmJiBhLnNwZWNpZmllZCA/IGEudmFsdWUgOiBudWxsIDogYVxuICAgICAgICB9LCBhdC5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgZSlcbiAgICAgICAgfSwgYXQudW5pcXVlU29ydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCwgbiA9IFtdLCBpID0gMCwgbyA9IDA7XG4gICAgICAgICAgICBpZiAoUyA9ICFyLmRldGVjdER1cGxpY2F0ZXMsIGMgPSAhci5zb3J0U3RhYmxlICYmIGUuc2xpY2UoMCksIGUuc29ydChBKSwgUykge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0ID0gZVtvKytdKVxuICAgICAgICAgICAgICAgICAgICB0ID09PSBlW29dICYmIChpID0gbi5wdXNoKG8pKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICBlLnNwbGljZShuW2ldLCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgfSwgYSA9IGF0LmdldFRleHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQsIG4gPSBcIlwiLCByID0gMCwgaSA9IGUubm9kZVR5cGU7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIGlmICgxID09PSBpIHx8IDkgPT09IGkgfHwgMTEgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUudGV4dENvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gYShlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoMyA9PT0gaSB8fCA0ID09PSBpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5ub2RlVmFsdWVcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGZvciAoOyB0ID0gZVtyXTsgcisrKVxuICAgICAgICAgICAgICAgICAgICBuICs9IGEodCk7XG4gICAgICAgICAgICByZXR1cm4gblxuICAgICAgICB9LCBvID0gYXQuc2VsZWN0b3JzID0ge2NhY2hlTGVuZ3RoOiA1MCwgY3JlYXRlUHNldWRvOiBsdCwgbWF0Y2g6IFEsIGF0dHJIYW5kbGU6IHt9LCBmaW5kOiB7fSwgcmVsYXRpdmU6IHtcIj5cIjoge2RpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiAhMH0sIFwiIFwiOiB7ZGlyOiBcInBhcmVudE5vZGVcIn0sIFwiK1wiOiB7ZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogITB9LCBcIn5cIjoge2RpcjogXCJwcmV2aW91c1NpYmxpbmdcIn19LCBwcmVGaWx0ZXI6IHtBVFRSOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVsxXSA9IGVbMV0ucmVwbGFjZShydCwgaXQpLCBlWzNdID0gKGVbNF0gfHwgZVs1XSB8fCBcIlwiKS5yZXBsYWNlKHJ0LCBpdCksIFwifj1cIiA9PT0gZVsyXSAmJiAoZVszXSA9IFwiIFwiICsgZVszXSArIFwiIFwiKSwgZS5zbGljZSgwLCA0KVxuICAgICAgICAgICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVsxXSA9IGVbMV0udG9Mb3dlckNhc2UoKSwgXCJudGhcIiA9PT0gZVsxXS5zbGljZSgwLCAzKSA/IChlWzNdIHx8IGF0LmVycm9yKGVbMF0pLCBlWzRdID0gKyhlWzRdID8gZVs1XSArIChlWzZdIHx8IDEpIDogMiAqIChcImV2ZW5cIiA9PT0gZVszXSB8fCBcIm9kZFwiID09PSBlWzNdKSksIGVbNV0gPSArKGVbN10gKyBlWzhdIHx8IFwib2RkXCIgPT09IGVbM10pKSA6IGVbM10gJiYgYXQuZXJyb3IoZVswXSksIGVcbiAgICAgICAgICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuLCByID0gIWVbNV0gJiYgZVsyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEuQ0hJTEQudGVzdChlWzBdKSA/IG51bGwgOiAoZVszXSAmJiBlWzRdICE9PSB0ID8gZVsyXSA9IGVbNF0gOiByICYmIEoudGVzdChyKSAmJiAobiA9IG10KHIsICEwKSkgJiYgKG4gPSByLmluZGV4T2YoXCIpXCIsIHIubGVuZ3RoIC0gbikgLSByLmxlbmd0aCkgJiYgKGVbMF0gPSBlWzBdLnNsaWNlKDAsIG4pLCBlWzJdID0gci5zbGljZSgwLCBuKSksIGUuc2xpY2UoMCwgMykpXG4gICAgICAgICAgICAgICAgfX0sIGZpbHRlcjoge1RBRzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnJlcGxhY2UocnQsIGl0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cIipcIiA9PT0gZSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiEwXG4gICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubm9kZU5hbWUgJiYgZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBDTEFTUzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBOW2UgKyBcIiBcIl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IHx8ICh0ID0gUmVnRXhwKFwiKF58XCIgKyBQICsgXCIpXCIgKyBlICsgXCIoXCIgKyBQICsgXCJ8JClcIikpICYmIE4oZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LnRlc3QoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5jbGFzc05hbWUgJiYgZS5jbGFzc05hbWUgfHwgdHlwZW9mIGUuZ2V0QXR0cmlidXRlICE9PSBqICYmIGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LCBBVFRSOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gYXQuYXR0cihyLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09IGkgPyBcIiE9XCIgPT09IHQgOiB0ID8gKGkgKz0gXCJcIiwgXCI9XCIgPT09IHQgPyBpID09PSBuIDogXCIhPVwiID09PSB0ID8gaSAhPT0gbiA6IFwiXj1cIiA9PT0gdCA/IG4gJiYgMCA9PT0gaS5pbmRleE9mKG4pIDogXCIqPVwiID09PSB0ID8gbiAmJiBpLmluZGV4T2YobikgPiAtMSA6IFwiJD1cIiA9PT0gdCA/IG4gJiYgaS5zbGljZSgtbi5sZW5ndGgpID09PSBuIDogXCJ+PVwiID09PSB0ID8gKFwiIFwiICsgaSArIFwiIFwiKS5pbmRleE9mKG4pID4gLTEgOiBcInw9XCIgPT09IHQgPyBpID09PSBuIHx8IGkuc2xpY2UoMCwgbi5sZW5ndGggKyAxKSA9PT0gbiArIFwiLVwiIDogITEpIDogITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IFwibnRoXCIgIT09IGUuc2xpY2UoMCwgMyksIGEgPSBcImxhc3RcIiAhPT0gZS5zbGljZSgtNCksIHMgPSBcIm9mLXR5cGVcIiA9PT0gdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgPT09IHIgJiYgMCA9PT0gaSA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hIWUucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHQsIG4sIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1LCBjLCBwLCBmLCBkLCBoLCBnID0gbyAhPT0gYSA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsIG0gPSB0LnBhcmVudE5vZGUsIHkgPSBzICYmIHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgdiA9ICFsICYmICFzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCA9IHBbZ10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPyBwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHkgOiAxID09PSBwLm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBnID0gXCJvbmx5XCIgPT09IGUgJiYgIWggJiYgXCJuZXh0U2libGluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggPSBbYSA/IG0uZmlyc3RDaGlsZCA6IG0ubGFzdENoaWxkXSwgYSAmJiB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBtW2JdIHx8IChtW2JdID0ge30pLCB1ID0gY1tlXSB8fCBbXSwgZCA9IHVbMF0gPT09IFQgJiYgdVsxXSwgZiA9IHVbMF0gPT09IFQgJiYgdVsyXSwgcCA9IGQgJiYgbS5jaGlsZE5vZGVzW2RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCA9ICsrZCAmJiBwICYmIHBbZ10gfHwgKGYgPSBkID0gMCkgfHwgaC5wb3AoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBwLm5vZGVUeXBlICYmICsrZiAmJiBwID09PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tlXSA9IFtULCBkLCBmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiAmJiAodSA9ICh0W2JdIHx8ICh0W2JdID0ge30pKVtlXSkgJiYgdVswXSA9PT0gVClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCA9ICsrZCAmJiBwICYmIHBbZ10gfHwgKGYgPSBkID0gMCkgfHwgaC5wb3AoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocyA/IHAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0geSA6IDEgPT09IHAubm9kZVR5cGUpICYmICsrZiAmJiAodiAmJiAoKHBbYl0gfHwgKHBbYl0gPSB7fSkpW2VdID0gW1QsIGZdKSwgcCA9PT0gdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYgLT0gaSwgZiA9PT0gciB8fCAwID09PSBmICUgciAmJiBmIC8gciA+PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuLCByID0gby5wc2V1ZG9zW2VdIHx8IG8uc2V0RmlsdGVyc1tlLnRvTG93ZXJDYXNlKCldIHx8IGF0LmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcltiXSA/IHIodCkgOiByLmxlbmd0aCA+IDEgPyAobiA9IFtlLCBlLCBcIlwiLCB0XSwgby5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KGUudG9Mb3dlckNhc2UoKSkgPyBsdChmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSByKGUsIHQpLCBhID0gby5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBGLmNhbGwoZSwgb1thXSksIGVbaV0gPSAhKG5baV0gPSBvW2FdKVxuICAgICAgICAgICAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcihlLCAwLCBuKVxuICAgICAgICAgICAgICAgICAgICB9KSA6IHJcbiAgICAgICAgICAgICAgICB9fSwgcHNldWRvczoge25vdDogbHQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBbXSwgbiA9IFtdLCByID0gbChlLnJlcGxhY2UoeiwgXCIkMVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByW2JdID8gbHQoZnVuY3Rpb24gKGUsIHQsIG4sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvLCBhID0gcihlLCBudWxsLCBpLCBbXSksIHMgPSBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG8gPSBhW3NdKSAmJiAoZVtzXSA9ICEodFtzXSA9IG8pKVxuICAgICAgICAgICAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFswXSA9IGUsIHIodCwgbnVsbCwgbywgbiksICFuLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgaGFzOiBsdChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdChlLCB0KS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgY29udGFpbnM6IGx0KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuKHQudGV4dENvbnRlbnQgfHwgdC5pbm5lclRleHQgfHwgYSh0KSkuaW5kZXhPZihlKSA+IC0xXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgbGFuZzogbHQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEcudGVzdChlIHx8IFwiXCIpIHx8IGF0LmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBlKSwgZSA9IGUucmVwbGFjZShydCwgaXQpLnRvTG93ZXJDYXNlKCksIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPSBoID8gdC5sYW5nIDogdC5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCB0LmdldEF0dHJpYnV0ZShcImxhbmdcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuID0gbi50b0xvd2VyQ2FzZSgpLCBuID09PSBlIHx8IDAgPT09IG4uaW5kZXhPZihlICsgXCItXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh0ID0gdC5wYXJlbnROb2RlKSAmJiAxID09PSB0Lm5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiExXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgdGFyZ2V0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUubG9jYXRpb24gJiYgZS5sb2NhdGlvbi5oYXNoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAmJiBuLnNsaWNlKDEpID09PSB0LmlkXG4gICAgICAgICAgICAgICAgfSwgcm9vdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IGRcbiAgICAgICAgICAgICAgICB9LCBmb2N1czogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IGYuYWN0aXZlRWxlbWVudCAmJiAoIWYuaGFzRm9jdXMgfHwgZi5oYXNGb2N1cygpKSAmJiAhIShlLnR5cGUgfHwgZS5ocmVmIHx8IH5lLnRhYkluZGV4KVxuICAgICAgICAgICAgICAgIH0sIGVuYWJsZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmRpc2FibGVkID09PSAhMVxuICAgICAgICAgICAgICAgIH0sIGRpc2FibGVkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5kaXNhYmxlZCA9PT0gITBcbiAgICAgICAgICAgICAgICB9LCBjaGVja2VkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXCJpbnB1dFwiID09PSB0ICYmICEhZS5jaGVja2VkIHx8IFwib3B0aW9uXCIgPT09IHQgJiYgISFlLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgfSwgc2VsZWN0ZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnBhcmVudE5vZGUgJiYgZS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsIGUuc2VsZWN0ZWQgPT09ICEwXG4gICAgICAgICAgICAgICAgfSwgZW1wdHk6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoZSA9IGUuZmlyc3RDaGlsZDsgZTsgZSA9IGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5ub2RlTmFtZSA+IFwiQFwiIHx8IDMgPT09IGUubm9kZVR5cGUgfHwgNCA9PT0gZS5ub2RlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuITBcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiFvLnBzZXVkb3MuZW1wdHkoZSlcbiAgICAgICAgICAgICAgICB9LCBoZWFkZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0dC50ZXN0KGUubm9kZU5hbWUpXG4gICAgICAgICAgICAgICAgfSwgaW5wdXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldC50ZXN0KGUubm9kZU5hbWUpXG4gICAgICAgICAgICAgICAgfSwgYnV0dG9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXCJpbnB1dFwiID09PSB0ICYmIFwiYnV0dG9uXCIgPT09IGUudHlwZSB8fCBcImJ1dHRvblwiID09PSB0XG4gICAgICAgICAgICAgICAgfSwgdGV4dDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblwiaW5wdXRcIiA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIFwidGV4dFwiID09PSBlLnR5cGUgJiYgKG51bGwgPT0gKHQgPSBlLmdldEF0dHJpYnV0ZShcInR5cGVcIikpIHx8IHQudG9Mb3dlckNhc2UoKSA9PT0gZS50eXBlKVxuICAgICAgICAgICAgICAgIH0sIGZpcnN0OiBodChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblswXVxuICAgICAgICAgICAgICAgIH0pLCBsYXN0OiBodChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5bdCAtIDFdXG4gICAgICAgICAgICAgICAgfSksIGVxOiBodChmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5bMCA+IG4gPyBuICsgdCA6IG5dXG4gICAgICAgICAgICAgICAgfSksIGV2ZW46IGh0KGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHQgPiBuOyBuICs9IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnB1c2gobik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgICAgICAgICAgfSksIG9kZDogaHQoZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAxO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgdCA+IG47IG4gKz0gMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICB9KSwgbHQ6IGh0KGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gMCA+IG4gPyBuICsgdCA6IG47XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyAtLXIgPj0gMDsgKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgIH0pLCBndDogaHQoZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAwID4gbiA/IG4gKyB0IDogbjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHQgPiArK3I7IClcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICB9KX19LCBvLnBzZXVkb3MubnRoID0gby5wc2V1ZG9zLmVxO1xuICAgICAgICBmb3IgKG4gaW57cmFkaW86ITAsIGNoZWNrYm94OiEwLCBmaWxlOiEwLCBwYXNzd29yZDohMCwgaW1hZ2U6ITB9KVxuICAgICAgICAgICAgby5wc2V1ZG9zW25dID0gZnQobik7XG4gICAgICAgIGZvciAobiBpbntzdWJtaXQ6ITAsIHJlc2V0OiEwfSlcbiAgICAgICAgICAgIG8ucHNldWRvc1tuXSA9IGR0KG4pO1xuICAgICAgICBmdW5jdGlvbiBndCgpIHtcbiAgICAgICAgfVxuICAgICAgICBndC5wcm90b3R5cGUgPSBvLmZpbHRlcnMgPSBvLnBzZXVkb3MsIG8uc2V0RmlsdGVycyA9IG5ldyBndDtcbiAgICAgICAgZnVuY3Rpb24gbXQoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4sIHIsIGksIGEsIHMsIGwsIHUsIGMgPSBrW2UgKyBcIiBcIl07XG4gICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICByZXR1cm4gdCA/IDAgOiBjLnNsaWNlKDApO1xuICAgICAgICAgICAgcyA9IGUsIGwgPSBbXSwgdSA9IG8ucHJlRmlsdGVyO1xuICAgICAgICAgICAgd2hpbGUgKHMpIHtcbiAgICAgICAgICAgICAgICAoIW4gfHwgKHIgPSBYLmV4ZWMocykpKSAmJiAociAmJiAocyA9IHMuc2xpY2UoclswXS5sZW5ndGgpIHx8IHMpLCBsLnB1c2goaSA9IFtdKSksIG4gPSAhMSwgKHIgPSBVLmV4ZWMocykpICYmIChuID0gci5zaGlmdCgpLCBpLnB1c2goe3ZhbHVlOiBuLCB0eXBlOiByWzBdLnJlcGxhY2UoeiwgXCIgXCIpfSksIHMgPSBzLnNsaWNlKG4ubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChhIGluIG8uZmlsdGVyKVxuICAgICAgICAgICAgICAgICAgICAhKHIgPSBRW2FdLmV4ZWMocykpIHx8IHVbYV0gJiYgIShyID0gdVthXShyKSkgfHwgKG4gPSByLnNoaWZ0KCksIGkucHVzaCh7dmFsdWU6IG4sIHR5cGU6IGEsIG1hdGNoZXM6IHJ9KSwgcyA9IHMuc2xpY2Uobi5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdCA/IHMubGVuZ3RoIDogcyA/IGF0LmVycm9yKGUpIDogayhlLCBsKS5zbGljZSgwKVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHl0KGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gMCwgbiA9IGUubGVuZ3RoLCByID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAoOyBuID4gdDsgdCsrKVxuICAgICAgICAgICAgICAgIHIgKz0gZVt0XS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdnQoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIgPSB0LmRpciwgbyA9IG4gJiYgXCJwYXJlbnROb2RlXCIgPT09IHIsIGEgPSBDKys7XG4gICAgICAgICAgICByZXR1cm4gdC5maXJzdCA/IGZ1bmN0aW9uICh0LCBuLCBpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHQgPSB0W3JdKVxuICAgICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gdC5ub2RlVHlwZSB8fCBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUodCwgbiwgaSlcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAodCwgbiwgcykge1xuICAgICAgICAgICAgICAgIHZhciBsLCB1LCBjLCBwID0gVCArIFwiIFwiICsgYTtcbiAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IHRbcl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDEgPT09IHQubm9kZVR5cGUgfHwgbykgJiYgZSh0LCBuLCBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMFxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IHRbcl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gdC5ub2RlVHlwZSB8fCBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID0gdFtiXSB8fCAodFtiXSA9IHt9KSwgKHUgPSBjW3JdKSAmJiB1WzBdID09PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobCA9IHVbMV0pID09PSAhMCB8fCBsID09PSBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwgPT09ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1ID0gY1tyXSA9IFtwXSwgdVsxXSA9IGUodCwgbiwgcykgfHwgaSwgdVsxXSA9PT0gITApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiEwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUubGVuZ3RoID4gMSA/IGZ1bmN0aW9uICh0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVbaV0odCwgbiwgcikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgICAgICAgICByZXR1cm4hMFxuICAgICAgICAgICAgfSA6IGVbMF1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB4dChlLCB0LCBuLCByLCBpKSB7XG4gICAgICAgICAgICB2YXIgbywgYSA9IFtdLCBzID0gMCwgbCA9IGUubGVuZ3RoLCB1ID0gbnVsbCAhPSB0O1xuICAgICAgICAgICAgZm9yICg7IGwgPiBzOyBzKyspXG4gICAgICAgICAgICAgICAgKG8gPSBlW3NdKSAmJiAoIW4gfHwgbihvLCByLCBpKSkgJiYgKGEucHVzaChvKSwgdSAmJiB0LnB1c2gocykpO1xuICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3dChlLCB0LCBuLCByLCBpLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gciAmJiAhcltiXSAmJiAociA9IHd0KHIpKSwgaSAmJiAhaVtiXSAmJiAoaSA9IHd0KGksIG8pKSwgbHQoZnVuY3Rpb24gKG8sIGEsIHMsIGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdSwgYywgcCwgZiA9IFtdLCBkID0gW10sIGggPSBhLmxlbmd0aCwgZyA9IG8gfHwgTnQodCB8fCBcIipcIiwgcy5ub2RlVHlwZSA/IFtzXSA6IHMsIFtdKSwgbSA9ICFlIHx8ICFvICYmIHQgPyBnIDogeHQoZywgZiwgZSwgcywgbCksIHkgPSBuID8gaSB8fCAobyA/IGUgOiBoIHx8IHIpID8gW10gOiBhIDogbTtcbiAgICAgICAgICAgICAgICBpZiAobiAmJiBuKG0sIHksIHMsIGwpLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHUgPSB4dCh5LCBkKSwgcih1LCBbXSwgcywgbCksIGMgPSB1Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGMtLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChwID0gdVtjXSkgJiYgKHlbZFtjXV0gPSAhKG1bZFtjXV0gPSBwKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgfHwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gW10sIGMgPSB5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYy0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocCA9IHlbY10pICYmIHUucHVzaChtW2NdID0gcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaShudWxsLCB5ID0gW10sIHUsIGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0geS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYy0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwID0geVtjXSkgJiYgKHUgPSBpID8gRi5jYWxsKG8sIHApIDogZltjXSkgPiAtMSAmJiAob1t1XSA9ICEoYVt1XSA9IHApKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHkgPSB4dCh5ID09PSBhID8geS5zcGxpY2UoaCwgeS5sZW5ndGgpIDogeSksIGkgPyBpKG51bGwsIGEsIHksIGwpIDogTS5hcHBseShhLCB5KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBUdChlKSB7XG4gICAgICAgICAgICB2YXIgdCwgbiwgciwgaSA9IGUubGVuZ3RoLCBhID0gby5yZWxhdGl2ZVtlWzBdLnR5cGVdLCBzID0gYSB8fCBvLnJlbGF0aXZlW1wiIFwiXSwgbCA9IGEgPyAxIDogMCwgYyA9IHZ0KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IHRcbiAgICAgICAgICAgIH0sIHMsICEwKSwgcCA9IHZ0KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEYuY2FsbCh0LCBlKSA+IC0xXG4gICAgICAgICAgICB9LCBzLCAhMCksIGYgPSBbZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIWEgJiYgKHIgfHwgbiAhPT0gdSkgfHwgKCh0ID0gbikubm9kZVR5cGUgPyBjKGUsIG4sIHIpIDogcChlLCBuLCByKSlcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIGZvciAoOyBpID4gbDsgbCsrKVxuICAgICAgICAgICAgICAgIGlmIChuID0gby5yZWxhdGl2ZVtlW2xdLnR5cGVdKVxuICAgICAgICAgICAgICAgICAgICBmID0gW3Z0KGJ0KGYpLCBuKV07XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuID0gby5maWx0ZXJbZVtsXS50eXBlXS5hcHBseShudWxsLCBlW2xdLm1hdGNoZXMpLCBuW2JdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHIgPSArK2w7IGkgPiByOyByKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ucmVsYXRpdmVbZVtyXS50eXBlXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3QobCA+IDEgJiYgYnQoZiksIGwgPiAxICYmIHl0KGUuc2xpY2UoMCwgbCAtIDEpLmNvbmNhdCh7dmFsdWU6IFwiIFwiID09PSBlW2wgLSAyXS50eXBlID8gXCIqXCIgOiBcIlwifSkpLnJlcGxhY2UoeiwgXCIkMVwiKSwgbiwgciA+IGwgJiYgVHQoZS5zbGljZShsLCByKSksIGkgPiByICYmIFR0KGUgPSBlLnNsaWNlKHIpKSwgaSA+IHIgJiYgeXQoZSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZi5wdXNoKG4pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ0KGYpXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQ3QoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4gPSAwLCByID0gdC5sZW5ndGggPiAwLCBhID0gZS5sZW5ndGggPiAwLCBzID0gZnVuY3Rpb24gKHMsIGwsIGMsIHAsIGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaCwgZywgbSwgeSA9IFtdLCB2ID0gMCwgYiA9IFwiMFwiLCB4ID0gcyAmJiBbXSwgdyA9IG51bGwgIT0gZCwgQyA9IHUsIE4gPSBzIHx8IGEgJiYgby5maW5kLlRBRyhcIipcIiwgZCAmJiBsLnBhcmVudE5vZGUgfHwgbCksIGsgPSBUICs9IG51bGwgPT0gQyA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IC4xO1xuICAgICAgICAgICAgICAgIGZvciAodyAmJiAodSA9IGwgIT09IGYgJiYgbCwgaSA9IG4pOyBudWxsICE9IChoID0gTltiXSk7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSAmJiBoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChtID0gZVtnKytdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtKGgsIGwsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAucHVzaChoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICYmIChUID0gaywgaSA9ICsrbilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByICYmICgoaCA9ICFtICYmIGgpICYmIHYtLSwgcyAmJiB4LnB1c2goaCkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2ICs9IGIsIHIgJiYgYiAhPT0gdikge1xuICAgICAgICAgICAgICAgICAgICBnID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG0gPSB0W2crK10pXG4gICAgICAgICAgICAgICAgICAgICAgICBtKHgsIHksIGwsIGMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhbYl0gfHwgeVtiXSB8fCAoeVtiXSA9IHEuY2FsbChwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0geHQoeSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBNLmFwcGx5KHAsIHkpLCB3ICYmICFzICYmIHkubGVuZ3RoID4gMCAmJiB2ICsgdC5sZW5ndGggPiAxICYmIGF0LnVuaXF1ZVNvcnQocClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHcgJiYgKFQgPSBrLCB1ID0gQyksIHhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gciA/IGx0KHMpIDogc1xuICAgICAgICB9XG4gICAgICAgIGwgPSBhdC5jb21waWxlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuLCByID0gW10sIGkgPSBbXSwgbyA9IEVbZSArIFwiIFwiXTtcbiAgICAgICAgICAgIGlmICghbykge1xuICAgICAgICAgICAgICAgIHQgfHwgKHQgPSBtdChlKSksIG4gPSB0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobi0tKVxuICAgICAgICAgICAgICAgICAgICBvID0gVHQodFtuXSksIG9bYl0gPyByLnB1c2gobykgOiBpLnB1c2gobyk7XG4gICAgICAgICAgICAgICAgbyA9IEUoZSwgQ3QoaSwgcikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBOdChlLCB0LCBuKSB7XG4gICAgICAgICAgICB2YXIgciA9IDAsIGkgPSB0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpID4gcjsgcisrKVxuICAgICAgICAgICAgICAgIGF0KGUsIHRbcl0sIG4pO1xuICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBrdChlLCB0LCBuLCBpKSB7XG4gICAgICAgICAgICB2YXIgYSwgcywgdSwgYywgcCwgZiA9IG10KGUpO1xuICAgICAgICAgICAgaWYgKCFpICYmIDEgPT09IGYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMgPSBmWzBdID0gZlswXS5zbGljZSgwKSwgcy5sZW5ndGggPiAyICYmIFwiSURcIiA9PT0gKHUgPSBzWzBdKS50eXBlICYmIHIuZ2V0QnlJZCAmJiA5ID09PSB0Lm5vZGVUeXBlICYmIGggJiYgby5yZWxhdGl2ZVtzWzFdLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID0gKG8uZmluZC5JRCh1Lm1hdGNoZXNbMF0ucmVwbGFjZShydCwgaXQpLCB0KSB8fCBbXSlbMF0sICF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgICAgIGUgPSBlLnNsaWNlKHMuc2hpZnQoKS52YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEgPSBRLm5lZWRzQ29udGV4dC50ZXN0KGUpID8gMCA6IHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChhLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPSBzW2FdLCBvLnJlbGF0aXZlW2MgPSB1LnR5cGVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocCA9IG8uZmluZFtjXSkgJiYgKGkgPSBwKHUubWF0Y2hlc1swXS5yZXBsYWNlKHJ0LCBpdCksIFYudGVzdChzWzBdLnR5cGUpICYmIHQucGFyZW50Tm9kZSB8fCB0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNwbGljZShhLCAxKSwgZSA9IGkubGVuZ3RoICYmIHl0KHMpLCAhZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTS5hcHBseShuLCBpKSwgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbChlLCBmKShpLCB0LCAhaCwgbiwgVi50ZXN0KGUpKSwgblxuICAgICAgICB9XG4gICAgICAgIHIuc29ydFN0YWJsZSA9IGIuc3BsaXQoXCJcIikuc29ydChBKS5qb2luKFwiXCIpID09PSBiLCByLmRldGVjdER1cGxpY2F0ZXMgPSBTLCBwKCksIHIuc29ydERldGFjaGVkID0gdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAxICYgZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihmLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpXG4gICAgICAgIH0pLCB1dChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCIsIFwiI1wiID09PSBlLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuICAgICAgICB9KSB8fCBjdChcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiByID8gdCA6IGUuZ2V0QXR0cmlidXRlKG4sIFwidHlwZVwiID09PSBuLnRvTG93ZXJDYXNlKCkgPyAxIDogMilcbiAgICAgICAgfSksIHIuYXR0cmlidXRlcyAmJiB1dChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiLCBlLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgXCJcIiksIFwiXCIgPT09IGUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuICAgICAgICB9KSB8fCBjdChcInZhbHVlXCIsIGZ1bmN0aW9uIChlLCBuLCByKSB7XG4gICAgICAgICAgICByZXR1cm4gciB8fCBcImlucHV0XCIgIT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA/IHQgOiBlLmRlZmF1bHRWYWx1ZVxuICAgICAgICB9KSwgdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGUuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIilcbiAgICAgICAgfSkgfHwgY3QoQiwgZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgcmV0dXJuIHIgPyB0IDogKGkgPSBlLmdldEF0dHJpYnV0ZU5vZGUobikpICYmIGkuc3BlY2lmaWVkID8gaS52YWx1ZSA6IGVbbl0gPT09ICEwID8gbi50b0xvd2VyQ2FzZSgpIDogbnVsbFxuICAgICAgICB9KSwgeC5maW5kID0gYXQsIHguZXhwciA9IGF0LnNlbGVjdG9ycywgeC5leHByW1wiOlwiXSA9IHguZXhwci5wc2V1ZG9zLCB4LnVuaXF1ZSA9IGF0LnVuaXF1ZVNvcnQsIHgudGV4dCA9IGF0LmdldFRleHQsIHguaXNYTUxEb2MgPSBhdC5pc1hNTCwgeC5jb250YWlucyA9IGF0LmNvbnRhaW5zXG4gICAgfShlKTtcbiAgICB2YXIgTyA9IHt9O1xuICAgIGZ1bmN0aW9uIEYoZSkge1xuICAgICAgICB2YXIgdCA9IE9bZV0gPSB7fTtcbiAgICAgICAgcmV0dXJuIHguZWFjaChlLm1hdGNoKFQpIHx8IFtdLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgdFtuXSA9ICEwXG4gICAgICAgIH0pLCB0XG4gICAgfVxuICAgIHguQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBPW2VdIHx8IEYoZSkgOiB4LmV4dGVuZCh7fSwgZSk7XG4gICAgICAgIHZhciBuLCByLCBpLCBvLCBhLCBzLCBsID0gW10sIHUgPSAhZS5vbmNlICYmIFtdLCBjID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGZvciAociA9IGUubWVtb3J5ICYmIHQsIGkgPSAhMCwgYSA9IHMgfHwgMCwgcyA9IDAsIG8gPSBsLmxlbmd0aCwgbiA9ICEwOyBsICYmIG8gPiBhOyBhKyspXG4gICAgICAgICAgICAgICAgaWYgKGxbYV0uYXBwbHkodFswXSwgdFsxXSkgPT09ICExICYmIGUuc3RvcE9uRmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9ICExO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSAhMSwgbCAmJiAodSA/IHUubGVuZ3RoICYmIGModS5zaGlmdCgpKSA6IHIgPyBsID0gW10gOiBwLmRpc2FibGUoKSlcbiAgICAgICAgfSwgcCA9IHthZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGwubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gaSh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LmVhY2godCwgZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHgudHlwZShuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHIgPyBlLnVuaXF1ZSAmJiBwLmhhcyhuKSB8fCBsLnB1c2gobikgOiBuICYmIG4ubGVuZ3RoICYmIFwic3RyaW5nXCIgIT09IHIgJiYgaShuKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSkoYXJndW1lbnRzKSwgbiA/IG8gPSBsLmxlbmd0aCA6IHIgJiYgKHMgPSB0LCBjKHIpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGwgJiYgeC5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgociA9IHguaW5BcnJheSh0LCBsLCByKSkgPiAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBsLnNwbGljZShyLCAxKSwgbiAmJiAobyA+PSByICYmIG8tLSwgYSA+PSByICYmIGEtLSlcbiAgICAgICAgICAgICAgICB9KSwgdGhpc1xuICAgICAgICAgICAgfSwgaGFzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlID8geC5pbkFycmF5KGUsIGwpID4gLTEgOiAhKCFsIHx8ICFsLmxlbmd0aClcbiAgICAgICAgICAgIH0sIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGwgPSBbXSwgbyA9IDAsIHRoaXNcbiAgICAgICAgICAgIH0sIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbCA9IHUgPSByID0gdCwgdGhpc1xuICAgICAgICAgICAgfSwgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4hbFxuICAgICAgICAgICAgfSwgbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1ID0gdCwgciB8fCBwLmRpc2FibGUoKSwgdGhpc1xuICAgICAgICAgICAgfSwgbG9ja2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIXVcbiAgICAgICAgICAgIH0sIGZpcmVXaXRoOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiFsIHx8IGkgJiYgIXUgfHwgKHQgPSB0IHx8IFtdLCB0ID0gW2UsIHQuc2xpY2UgPyB0LnNsaWNlKCkgOiB0XSwgbiA/IHUucHVzaCh0KSA6IGModCkpLCB0aGlzXG4gICAgICAgICAgICB9LCBmaXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuZmlyZVdpdGgodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgICAgICAgICAgfSwgZmlyZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4hIWlcbiAgICAgICAgICAgIH19O1xuICAgICAgICByZXR1cm4gcFxuICAgIH0sIHguZXh0ZW5kKHtEZWZlcnJlZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gW1tcInJlc29sdmVcIiwgXCJkb25lXCIsIHguQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIl0sIFtcInJlamVjdFwiLCBcImZhaWxcIiwgeC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiXSwgW1wibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgeC5DYWxsYmFja3MoXCJtZW1vcnlcIildXSwgbiA9IFwicGVuZGluZ1wiLCByID0ge3N0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgICAgICAgfSwgYWx3YXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyksIHRoaXNcbiAgICAgICAgICAgICAgICB9LCB0aGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5EZWZlcnJlZChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeC5lYWNoKHQsIGZ1bmN0aW9uICh0LCBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBvWzBdLCBzID0geC5pc0Z1bmN0aW9uKGVbdF0pICYmIGVbdF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVtvWzFdXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gcyAmJiBzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgJiYgeC5pc0Z1bmN0aW9uKGUucHJvbWlzZSkgPyBlLnByb21pc2UoKS5kb25lKG4ucmVzb2x2ZSkuZmFpbChuLnJlamVjdCkucHJvZ3Jlc3Mobi5ub3RpZnkpIDogblthICsgXCJXaXRoXCJdKHRoaXMgPT09IHIgPyBuLnByb21pc2UoKSA6IHRoaXMsIHMgPyBbZV0gOiBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBlID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KS5wcm9taXNlKClcbiAgICAgICAgICAgICAgICB9LCBwcm9taXNlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAhPSBlID8geC5leHRlbmQoZSwgcikgOiByXG4gICAgICAgICAgICAgICAgfX0sIGkgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiByLnBpcGUgPSByLnRoZW4sIHguZWFjaCh0LCBmdW5jdGlvbiAoZSwgbykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gb1syXSwgcyA9IG9bM107XG4gICAgICAgICAgICAgICAgcltvWzFdXSA9IGEuYWRkLCBzICYmIGEuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHNcbiAgICAgICAgICAgICAgICB9LCB0WzEgXiBlXVsyXS5kaXNhYmxlLCB0WzJdWzJdLmxvY2spLCBpW29bMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVtvWzBdICsgXCJXaXRoXCJdKHRoaXMgPT09IGkgPyByIDogdGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgICAgICAgICAgICAgIH0sIGlbb1swXSArIFwiV2l0aFwiXSA9IGEuZmlyZVdpdGhcbiAgICAgICAgICAgIH0pLCByLnByb21pc2UoaSksIGUgJiYgZS5jYWxsKGksIGkpLCBpXG4gICAgICAgIH0sIHdoZW46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IDAsIG4gPSBnLmNhbGwoYXJndW1lbnRzKSwgciA9IG4ubGVuZ3RoLCBpID0gMSAhPT0gciB8fCBlICYmIHguaXNGdW5jdGlvbihlLnByb21pc2UpID8gciA6IDAsIG8gPSAxID09PSBpID8gZSA6IHguRGVmZXJyZWQoKSwgYSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRbZV0gPSB0aGlzLCBuW2VdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBnLmNhbGwoYXJndW1lbnRzKSA6IHIsIG4gPT09IHMgPyBvLm5vdGlmeVdpdGgodCwgbikgOiAtLWkgfHwgby5yZXNvbHZlV2l0aCh0LCBuKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHMsIGwsIHU7XG4gICAgICAgICAgICBpZiAociA+IDEpXG4gICAgICAgICAgICAgICAgZm9yIChzID0gQXJyYXkociksIGwgPSBBcnJheShyKSwgdSA9IEFycmF5KHIpOyByID4gdDsgdCsrKVxuICAgICAgICAgICAgICAgICAgICBuW3RdICYmIHguaXNGdW5jdGlvbihuW3RdLnByb21pc2UpID8gblt0XS5wcm9taXNlKCkuZG9uZShhKHQsIHUsIG4pKS5mYWlsKG8ucmVqZWN0KS5wcm9ncmVzcyhhKHQsIGwsIHMpKSA6IC0taTtcbiAgICAgICAgICAgIHJldHVybiBpIHx8IG8ucmVzb2x2ZVdpdGgodSwgbiksIG8ucHJvbWlzZSgpXG4gICAgICAgIH19KSwgeC5zdXBwb3J0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIG4sIHIsIG8sIHMsIGwsIHUsIGMsIHAsIGYsIGQgPSBhLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmIChkLnNldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiLCBcInRcIiksIGQuaW5uZXJIVE1MID0gXCIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz5cIiwgbiA9IGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHx8IFtdLCByID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIilbMF0sICFyIHx8ICFyLnN0eWxlIHx8ICFuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICBzID0gYS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLCB1ID0gcy5hcHBlbmRDaGlsZChhLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpLCBvID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdLCByLnN0eWxlLmNzc1RleHQgPSBcInRvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCIsIHQuZ2V0U2V0QXR0cmlidXRlID0gXCJ0XCIgIT09IGQuY2xhc3NOYW1lLCB0LmxlYWRpbmdXaGl0ZXNwYWNlID0gMyA9PT0gZC5maXJzdENoaWxkLm5vZGVUeXBlLCB0LnRib2R5ID0gIWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKS5sZW5ndGgsIHQuaHRtbFNlcmlhbGl6ZSA9ICEhZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIikubGVuZ3RoLCB0LnN0eWxlID0gL3RvcC8udGVzdChyLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSwgdC5ocmVmTm9ybWFsaXplZCA9IFwiL2FcIiA9PT0gci5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLCB0Lm9wYWNpdHkgPSAvXjAuNS8udGVzdChyLnN0eWxlLm9wYWNpdHkpLCB0LmNzc0Zsb2F0ID0gISFyLnN0eWxlLmNzc0Zsb2F0LCB0LmNoZWNrT24gPSAhIW8udmFsdWUsIHQub3B0U2VsZWN0ZWQgPSB1LnNlbGVjdGVkLCB0LmVuY3R5cGUgPSAhIWEuY3JlYXRlRWxlbWVudChcImZvcm1cIikuZW5jdHlwZSwgdC5odG1sNUNsb25lID0gXCI8Om5hdj48LzpuYXY+XCIgIT09IGEuY3JlYXRlRWxlbWVudChcIm5hdlwiKS5jbG9uZU5vZGUoITApLm91dGVySFRNTCwgdC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gITEsIHQuc2hyaW5rV3JhcEJsb2NrcyA9ICExLCB0LnBpeGVsUG9zaXRpb24gPSAhMSwgdC5kZWxldGVFeHBhbmRvID0gITAsIHQubm9DbG9uZUV2ZW50ID0gITAsIHQucmVsaWFibGVNYXJnaW5SaWdodCA9ICEwLCB0LmJveFNpemluZ1JlbGlhYmxlID0gITAsIG8uY2hlY2tlZCA9ICEwLCB0Lm5vQ2xvbmVDaGVja2VkID0gby5jbG9uZU5vZGUoITApLmNoZWNrZWQsIHMuZGlzYWJsZWQgPSAhMCwgdC5vcHREaXNhYmxlZCA9ICF1LmRpc2FibGVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIGQudGVzdFxuICAgICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgICAgICB0LmRlbGV0ZUV4cGFuZG8gPSAhMVxuICAgICAgICB9XG4gICAgICAgIG8gPSBhLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSwgby5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBcIlwiKSwgdC5pbnB1dCA9IFwiXCIgPT09IG8uZ2V0QXR0cmlidXRlKFwidmFsdWVcIiksIG8udmFsdWUgPSBcInRcIiwgby5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwicmFkaW9cIiksIHQucmFkaW9WYWx1ZSA9IFwidFwiID09PSBvLnZhbHVlLCBvLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJ0XCIpLCBvLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJ0XCIpLCBsID0gYS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGwuYXBwZW5kQ2hpbGQobyksIHQuYXBwZW5kQ2hlY2tlZCA9IG8uY2hlY2tlZCwgdC5jaGVja0Nsb25lID0gbC5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQsIGQuYXR0YWNoRXZlbnQgJiYgKGQuYXR0YWNoRXZlbnQoXCJvbmNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQubm9DbG9uZUV2ZW50ID0gITFcbiAgICAgICAgfSksIGQuY2xvbmVOb2RlKCEwKS5jbGljaygpKTtcbiAgICAgICAgZm9yIChmIGlue3N1Ym1pdDohMCwgY2hhbmdlOiEwLCBmb2N1c2luOiEwfSlcbiAgICAgICAgICAgIGQuc2V0QXR0cmlidXRlKGMgPSBcIm9uXCIgKyBmLCBcInRcIiksIHRbZiArIFwiQnViYmxlc1wiXSA9IGMgaW4gZSB8fCBkLmF0dHJpYnV0ZXNbY10uZXhwYW5kbyA9PT0gITE7XG4gICAgICAgIGQuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCIsIGQuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCIsIHQuY2xlYXJDbG9uZVN0eWxlID0gXCJjb250ZW50LWJveFwiID09PSBkLnN0eWxlLmJhY2tncm91bmRDbGlwO1xuICAgICAgICBmb3IgKGYgaW4geCh0KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXR1cm4gdC5vd25MYXN0ID0gXCIwXCIgIT09IGYsIHgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG4sIHIsIG8sIHMgPSBcInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtcIiwgbCA9IGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuICAgICAgICAgICAgbCAmJiAobiA9IGEuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbi5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweFwiLCBsLmFwcGVuZENoaWxkKG4pLmFwcGVuZENoaWxkKGQpLCBkLmlubmVySFRNTCA9IFwiPHRhYmxlPjx0cj48dGQ+PC90ZD48dGQ+dDwvdGQ+PC90cj48L3RhYmxlPlwiLCBvID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRkXCIpLCBvWzBdLnN0eWxlLmNzc1RleHQgPSBcInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5Om5vbmVcIiwgcCA9IDAgPT09IG9bMF0ub2Zmc2V0SGVpZ2h0LCBvWzBdLnN0eWxlLmRpc3BsYXkgPSBcIlwiLCBvWzFdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgdC5yZWxpYWJsZUhpZGRlbk9mZnNldHMgPSBwICYmIDAgPT09IG9bMF0ub2Zmc2V0SGVpZ2h0LCBkLmlubmVySFRNTCA9IFwiXCIsIGQuc3R5bGUuY3NzVGV4dCA9IFwiYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MXB4O2JvcmRlcjoxcHg7ZGlzcGxheTpibG9jazt3aWR0aDo0cHg7bWFyZ2luLXRvcDoxJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MSU7XCIsIHguc3dhcChsLCBudWxsICE9IGwuc3R5bGUuem9vbSA/IHt6b29tOiAxfSA6IHt9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdC5ib3hTaXppbmcgPSA0ID09PSBkLm9mZnNldFdpZHRoXG4gICAgICAgICAgICB9KSwgZS5nZXRDb21wdXRlZFN0eWxlICYmICh0LnBpeGVsUG9zaXRpb24gPSBcIjElXCIgIT09IChlLmdldENvbXB1dGVkU3R5bGUoZCwgbnVsbCkgfHwge30pLnRvcCwgdC5ib3hTaXppbmdSZWxpYWJsZSA9IFwiNHB4XCIgPT09IChlLmdldENvbXB1dGVkU3R5bGUoZCwgbnVsbCkgfHwge3dpZHRoOiBcIjRweFwifSkud2lkdGgsIHIgPSBkLmFwcGVuZENoaWxkKGEuY3JlYXRlRWxlbWVudChcImRpdlwiKSksIHIuc3R5bGUuY3NzVGV4dCA9IGQuc3R5bGUuY3NzVGV4dCA9IHMsIHIuc3R5bGUubWFyZ2luUmlnaHQgPSByLnN0eWxlLndpZHRoID0gXCIwXCIsIGQuc3R5bGUud2lkdGggPSBcIjFweFwiLCB0LnJlbGlhYmxlTWFyZ2luUmlnaHQgPSAhcGFyc2VGbG9hdCgoZS5nZXRDb21wdXRlZFN0eWxlKHIsIG51bGwpIHx8IHt9KS5tYXJnaW5SaWdodCkpLCB0eXBlb2YgZC5zdHlsZS56b29tICE9PSBpICYmIChkLmlubmVySFRNTCA9IFwiXCIsIGQuc3R5bGUuY3NzVGV4dCA9IHMgKyBcIndpZHRoOjFweDtwYWRkaW5nOjFweDtkaXNwbGF5OmlubGluZTt6b29tOjFcIiwgdC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gMyA9PT0gZC5vZmZzZXRXaWR0aCwgZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCBkLmlubmVySFRNTCA9IFwiPGRpdj48L2Rpdj5cIiwgZC5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gXCI1cHhcIiwgdC5zaHJpbmtXcmFwQmxvY2tzID0gMyAhPT0gZC5vZmZzZXRXaWR0aCwgdC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ICYmIChsLnN0eWxlLnpvb20gPSAxKSksIGwucmVtb3ZlQ2hpbGQobiksIG4gPSBkID0gbyA9IHIgPSBudWxsKVxuICAgICAgICB9KSwgbiA9IHMgPSBsID0gdSA9IHIgPSBvID0gbnVsbCwgdFxuICAgIH0oe30pO1xuICAgIHZhciBCID0gLyg/Olxce1tcXHNcXFNdKlxcfXxcXFtbXFxzXFxTXSpcXF0pJC8sIFAgPSAvKFtBLVpdKS9nO1xuICAgIGZ1bmN0aW9uIFIoZSwgbiwgciwgaSkge1xuICAgICAgICBpZiAoeC5hY2NlcHREYXRhKGUpKSB7XG4gICAgICAgICAgICB2YXIgbywgYSwgcyA9IHguZXhwYW5kbywgbCA9IGUubm9kZVR5cGUsIHUgPSBsID8geC5jYWNoZSA6IGUsIGMgPSBsID8gZVtzXSA6IGVbc10gJiYgcztcbiAgICAgICAgICAgIGlmIChjICYmIHVbY10gJiYgKGkgfHwgdVtjXS5kYXRhKSB8fCByICE9PSB0IHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgfHwgKGMgPSBsID8gZVtzXSA9IHAucG9wKCkgfHwgeC5ndWlkKysgOiBzKSwgdVtjXSB8fCAodVtjXSA9IGwgPyB7fSA6IHt0b0pTT046IHgubm9vcH0pLCAoXCJvYmplY3RcIiA9PSB0eXBlb2YgbiB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4pICYmIChpID8gdVtjXSA9IHguZXh0ZW5kKHVbY10sIG4pIDogdVtjXS5kYXRhID0geC5leHRlbmQodVtjXS5kYXRhLCBuKSksIGEgPSB1W2NdLCBpIHx8IChhLmRhdGEgfHwgKGEuZGF0YSA9IHt9KSwgYSA9IGEuZGF0YSksIHIgIT09IHQgJiYgKGFbeC5jYW1lbENhc2UobildID0gciksIFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gPyAobyA9IGFbbl0sIG51bGwgPT0gbyAmJiAobyA9IGFbeC5jYW1lbENhc2UobildKSkgOiBvID0gYSwgb1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFcoZSwgdCwgbikge1xuICAgICAgICBpZiAoeC5hY2NlcHREYXRhKGUpKSB7XG4gICAgICAgICAgICB2YXIgciwgaSwgbyA9IGUubm9kZVR5cGUsIGEgPSBvID8geC5jYWNoZSA6IGUsIHMgPSBvID8gZVt4LmV4cGFuZG9dIDogeC5leHBhbmRvO1xuICAgICAgICAgICAgaWYgKGFbc10pIHtcbiAgICAgICAgICAgICAgICBpZiAodCAmJiAociA9IG4gPyBhW3NdIDogYVtzXS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICB4LmlzQXJyYXkodCkgPyB0ID0gdC5jb25jYXQoeC5tYXAodCwgeC5jYW1lbENhc2UpKSA6IHQgaW4gciA/IHQgPSBbdF0gOiAodCA9IHguY2FtZWxDYXNlKHQpLCB0ID0gdCBpbiByID8gW3RdIDogdC5zcGxpdChcIiBcIikpLCBpID0gdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgclt0W2ldXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPyAhSShyKSA6ICF4LmlzRW1wdHlPYmplY3QocikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKG4gfHwgKGRlbGV0ZSBhW3NdLmRhdGEsIEkoYVtzXSkpKSAmJiAobyA/IHguY2xlYW5EYXRhKFtlXSwgITApIDogeC5zdXBwb3J0LmRlbGV0ZUV4cGFuZG8gfHwgYSAhPSBhLndpbmRvdyA/IGRlbGV0ZSBhW3NdIDogYVtzXSA9IG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgeC5leHRlbmQoe2NhY2hlOiB7fSwgbm9EYXRhOiB7YXBwbGV0OiAhMCwgZW1iZWQ6ICEwLCBvYmplY3Q6IFwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCJ9LCBoYXNEYXRhOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgPSBlLm5vZGVUeXBlID8geC5jYWNoZVtlW3guZXhwYW5kb11dIDogZVt4LmV4cGFuZG9dLCAhIWUgJiYgIUkoZSlcbiAgICAgICAgfSwgZGF0YTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHJldHVybiBSKGUsIHQsIG4pXG4gICAgICAgIH0sIHJlbW92ZURhdGE6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gVyhlLCB0KVxuICAgICAgICB9LCBfZGF0YTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHJldHVybiBSKGUsIHQsIG4sICEwKVxuICAgICAgICB9LCBfcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiBXKGUsIHQsICEwKVxuICAgICAgICB9LCBhY2NlcHREYXRhOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUubm9kZVR5cGUgJiYgMSAhPT0gZS5ub2RlVHlwZSAmJiA5ICE9PSBlLm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiExO1xuICAgICAgICAgICAgdmFyIHQgPSBlLm5vZGVOYW1lICYmIHgubm9EYXRhW2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICByZXR1cm4hdCB8fCB0ICE9PSAhMCAmJiBlLmdldEF0dHJpYnV0ZShcImNsYXNzaWRcIikgPT09IHRcbiAgICAgICAgfX0pLCB4LmZuLmV4dGVuZCh7ZGF0YTogZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgIHZhciByLCBpLCBvID0gbnVsbCwgYSA9IDAsIHMgPSB0aGlzWzBdO1xuICAgICAgICAgICAgaWYgKGUgPT09IHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggJiYgKG8gPSB4LmRhdGEocyksIDEgPT09IHMubm9kZVR5cGUgJiYgIXguX2RhdGEocywgXCJwYXJzZWRBdHRyc1wiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyID0gcy5hdHRyaWJ1dGVzOyByLmxlbmd0aCA+IGE7IGErKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSByW2FdLm5hbWUsIDAgPT09IGkuaW5kZXhPZihcImRhdGEtXCIpICYmIChpID0geC5jYW1lbENhc2UoaS5zbGljZSg1KSksICQocywgaSwgb1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB4Ll9kYXRhKHMsIFwicGFyc2VkQXR0cnNcIiwgITApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5cIm9iamVjdFwiID09IHR5cGVvZiBlID8gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB4LmRhdGEodGhpcywgZSlcbiAgICAgICAgICAgIH0pIDogYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHguZGF0YSh0aGlzLCBlLCBuKVxuICAgICAgICAgICAgfSkgOiBzID8gJChzLCBlLCB4LmRhdGEocywgZSkpIDogbnVsbFxuICAgICAgICB9LCByZW1vdmVEYXRhOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeC5yZW1vdmVEYXRhKHRoaXMsIGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9fSk7XG4gICAgZnVuY3Rpb24gJChlLCBuLCByKSB7XG4gICAgICAgIGlmIChyID09PSB0ICYmIDEgPT09IGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBpID0gXCJkYXRhLVwiICsgbi5yZXBsYWNlKFAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAociA9IGUuZ2V0QXR0cmlidXRlKGkpLCBcInN0cmluZ1wiID09IHR5cGVvZiByKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgciA9IFwidHJ1ZVwiID09PSByID8gITAgOiBcImZhbHNlXCIgPT09IHIgPyAhMSA6IFwibnVsbFwiID09PSByID8gbnVsbCA6ICtyICsgXCJcIiA9PT0gciA/ICtyIDogQi50ZXN0KHIpID8geC5wYXJzZUpTT04ocikgOiByXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4LmRhdGEoZSwgbiwgcilcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHIgPSB0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJcbiAgICB9XG4gICAgZnVuY3Rpb24gSShlKSB7XG4gICAgICAgIHZhciB0O1xuICAgICAgICBmb3IgKHQgaW4gZSlcbiAgICAgICAgICAgIGlmICgoXCJkYXRhXCIgIT09IHQgfHwgIXguaXNFbXB0eU9iamVjdChlW3RdKSkgJiYgXCJ0b0pTT05cIiAhPT0gdClcbiAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgcmV0dXJuITBcbiAgICB9XG4gICAgeC5leHRlbmQoe3F1ZXVlOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICByZXR1cm4gZSA/IChuID0gKG4gfHwgXCJmeFwiKSArIFwicXVldWVcIiwgaSA9IHguX2RhdGEoZSwgbiksIHIgJiYgKCFpIHx8IHguaXNBcnJheShyKSA/IGkgPSB4Ll9kYXRhKGUsIG4sIHgubWFrZUFycmF5KHIpKSA6IGkucHVzaChyKSksIGkgfHwgW10pIDogdFxuICAgICAgICB9LCBkZXF1ZXVlOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgdCA9IHQgfHwgXCJmeFwiO1xuICAgICAgICAgICAgdmFyIG4gPSB4LnF1ZXVlKGUsIHQpLCByID0gbi5sZW5ndGgsIGkgPSBuLnNoaWZ0KCksIG8gPSB4Ll9xdWV1ZUhvb2tzKGUsIHQpLCBhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHguZGVxdWV1ZShlLCB0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFwiaW5wcm9ncmVzc1wiID09PSBpICYmIChpID0gbi5zaGlmdCgpLCByLS0pLCBpICYmIChcImZ4XCIgPT09IHQgJiYgbi51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKSwgZGVsZXRlIG8uc3RvcCwgaS5jYWxsKGUsIGEsIG8pKSwgIXIgJiYgbyAmJiBvLmVtcHR5LmZpcmUoKVxuICAgICAgICB9LCBfcXVldWVIb29rczogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gdCArIFwicXVldWVIb29rc1wiO1xuICAgICAgICAgICAgcmV0dXJuIHguX2RhdGEoZSwgbikgfHwgeC5fZGF0YShlLCBuLCB7ZW1wdHk6IHguQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgeC5fcmVtb3ZlRGF0YShlLCB0ICsgXCJxdWV1ZVwiKSwgeC5fcmVtb3ZlRGF0YShlLCBuKVxuICAgICAgICAgICAgICAgIH0pfSlcbiAgICAgICAgfX0pLCB4LmZuLmV4dGVuZCh7cXVldWU6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICB2YXIgciA9IDI7XG4gICAgICAgICAgICByZXR1cm5cInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIChuID0gZSwgZSA9IFwiZnhcIiwgci0tKSwgciA+IGFyZ3VtZW50cy5sZW5ndGggPyB4LnF1ZXVlKHRoaXNbMF0sIGUpIDogbiA9PT0gdCA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0geC5xdWV1ZSh0aGlzLCBlLCBuKTtcbiAgICAgICAgICAgICAgICB4Ll9xdWV1ZUhvb2tzKHRoaXMsIGUpLCBcImZ4XCIgPT09IGUgJiYgXCJpbnByb2dyZXNzXCIgIT09IHRbMF0gJiYgeC5kZXF1ZXVlKHRoaXMsIGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBkZXF1ZXVlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeC5kZXF1ZXVlKHRoaXMsIGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBkZWxheTogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlID0geC5meCA/IHguZnguc3BlZWRzW2VdIHx8IGUgOiBlLCB0ID0gdCB8fCBcImZ4XCIsIHRoaXMucXVldWUodCwgZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHNldFRpbWVvdXQodCwgZSk7XG4gICAgICAgICAgICAgICAgbi5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBjbGVhclF1ZXVlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUoZSB8fCBcImZ4XCIsIFtdKVxuICAgICAgICB9LCBwcm9taXNlOiBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgdmFyIHIsIGkgPSAxLCBvID0geC5EZWZlcnJlZCgpLCBhID0gdGhpcywgcyA9IHRoaXMubGVuZ3RoLCBsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC0taSB8fCBvLnJlc29sdmVXaXRoKGEsIFthXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIChuID0gZSwgZSA9IHQpLCBlID0gZSB8fCBcImZ4XCI7XG4gICAgICAgICAgICB3aGlsZSAocy0tKVxuICAgICAgICAgICAgICAgIHIgPSB4Ll9kYXRhKGFbc10sIGUgKyBcInF1ZXVlSG9va3NcIiksIHIgJiYgci5lbXB0eSAmJiAoaSsrLCByLmVtcHR5LmFkZChsKSk7XG4gICAgICAgICAgICByZXR1cm4gbCgpLCBvLnByb21pc2UobilcbiAgICAgICAgfX0pO1xuICAgIHZhciB6LCBYLCBVID0gL1tcXHRcXHJcXG5cXGZdL2csIFYgPSAvXFxyL2csIFkgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaSwgSiA9IC9eKD86YXxhcmVhKSQvaSwgRyA9IC9eKD86Y2hlY2tlZHxzZWxlY3RlZCkkL2ksIFEgPSB4LnN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlLCBLID0geC5zdXBwb3J0LmlucHV0O1xuICAgIHguZm4uZXh0ZW5kKHthdHRyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWNjZXNzKHRoaXMsIHguYXR0ciwgZSwgdCwgYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICAgIH0sIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB4LnJlbW92ZUF0dHIodGhpcywgZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHByb3A6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgeC5wcm9wLCBlLCB0LCBhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgICAgfSwgcmVtb3ZlUHJvcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlID0geC5wcm9wRml4W2VdIHx8IGUsIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tlXSA9IHQsIGRlbGV0ZSB0aGlzW2VdXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGFkZENsYXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQsIG4sIHIsIGksIG8sIGEgPSAwLCBzID0gdGhpcy5sZW5ndGgsIGwgPSBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIGU7XG4gICAgICAgICAgICBpZiAoeC5pc0Z1bmN0aW9uKGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgeCh0aGlzKS5hZGRDbGFzcyhlLmNhbGwodGhpcywgdCwgdGhpcy5jbGFzc05hbWUpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGwpXG4gICAgICAgICAgICAgICAgZm9yICh0ID0gKGUgfHwgXCJcIikubWF0Y2goVCkgfHwgW107IHMgPiBhOyBhKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChuID0gdGhpc1thXSwgciA9IDEgPT09IG4ubm9kZVR5cGUgJiYgKG4uY2xhc3NOYW1lID8gKFwiIFwiICsgbi5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZShVLCBcIiBcIikgOiBcIiBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPSB0W28rK10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA+IHIuaW5kZXhPZihcIiBcIiArIGkgKyBcIiBcIikgJiYgKHIgKz0gaSArIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uY2xhc3NOYW1lID0geC50cmltKHIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0sIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQsIG4sIHIsIGksIG8sIGEgPSAwLCBzID0gdGhpcy5sZW5ndGgsIGwgPSAwID09PSBhcmd1bWVudHMubGVuZ3RoIHx8IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgZTtcbiAgICAgICAgICAgIGlmICh4LmlzRnVuY3Rpb24oZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB4KHRoaXMpLnJlbW92ZUNsYXNzKGUuY2FsbCh0aGlzLCB0LCB0aGlzLmNsYXNzTmFtZSkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobClcbiAgICAgICAgICAgICAgICBmb3IgKHQgPSAoZSB8fCBcIlwiKS5tYXRjaChUKSB8fCBbXTsgcyA+IGE7IGErKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPSB0aGlzW2FdLCByID0gMSA9PT0gbi5ub2RlVHlwZSAmJiAobi5jbGFzc05hbWUgPyAoXCIgXCIgKyBuLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKFUsIFwiIFwiKSA6IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpID0gdFtvKytdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyLmluZGV4T2YoXCIgXCIgKyBpICsgXCIgXCIpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByLnJlcGxhY2UoXCIgXCIgKyBpICsgXCIgXCIsIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uY2xhc3NOYW1lID0gZSA/IHgudHJpbShyKSA6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSwgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IHR5cGVvZiBlO1xuICAgICAgICAgICAgcmV0dXJuXCJib29sZWFuXCIgPT0gdHlwZW9mIHQgJiYgXCJzdHJpbmdcIiA9PT0gbiA/IHQgPyB0aGlzLmFkZENsYXNzKGUpIDogdGhpcy5yZW1vdmVDbGFzcyhlKSA6IHguaXNGdW5jdGlvbihlKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHgodGhpcykudG9nZ2xlQ2xhc3MoZS5jYWxsKHRoaXMsIG4sIHRoaXMuY2xhc3NOYW1lLCB0KSwgdClcbiAgICAgICAgICAgIH0pIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCwgciA9IDAsIG8gPSB4KHRoaXMpLCBhID0gZS5tYXRjaChUKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPSBhW3IrK10pXG4gICAgICAgICAgICAgICAgICAgICAgICBvLmhhc0NsYXNzKHQpID8gby5yZW1vdmVDbGFzcyh0KSA6IG8uYWRkQ2xhc3ModClcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKG4gPT09IGkgfHwgXCJib29sZWFuXCIgPT09IG4pICYmICh0aGlzLmNsYXNzTmFtZSAmJiB4Ll9kYXRhKHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCB0aGlzLmNsYXNzTmFtZSksIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgZSA9PT0gITEgPyBcIlwiIDogeC5fZGF0YSh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIikgfHwgXCJcIilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGhhc0NsYXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQgPSBcIiBcIiArIGUgKyBcIiBcIiwgbiA9IDAsIHIgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyByID4gbjsgbisrKVxuICAgICAgICAgICAgICAgIGlmICgxID09PSB0aGlzW25dLm5vZGVUeXBlICYmIChcIiBcIiArIHRoaXNbbl0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoVSwgXCIgXCIpLmluZGV4T2YodCkgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuITA7XG4gICAgICAgICAgICByZXR1cm4hMVxuICAgICAgICB9LCB2YWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgbiwgciwgaSwgbyA9IHRoaXNbMF07XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpID0geC5pc0Z1bmN0aW9uKGUpLCB0aGlzLmVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgMSA9PT0gdGhpcy5ub2RlVHlwZSAmJiAobyA9IGkgPyBlLmNhbGwodGhpcywgbiwgeCh0aGlzKS52YWwoKSkgOiBlLCBudWxsID09IG8gPyBvID0gXCJcIiA6IFwibnVtYmVyXCIgPT0gdHlwZW9mIG8gPyBvICs9IFwiXCIgOiB4LmlzQXJyYXkobykgJiYgKG8gPSB4Lm1hcChvLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09IGUgPyBcIlwiIDogZSArIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgciA9IHgudmFsSG9va3NbdGhpcy50eXBlXSB8fCB4LnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sIHIgJiYgXCJzZXRcImluIHIgJiYgci5zZXQodGhpcywgbywgXCJ2YWx1ZVwiKSAhPT0gdCB8fCAodGhpcy52YWx1ZSA9IG8pKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPSB4LnZhbEhvb2tzW28udHlwZV0gfHwgeC52YWxIb29rc1tvLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLCByICYmIFwiZ2V0XCJpbiByICYmIChuID0gci5nZXQobywgXCJ2YWx1ZVwiKSkgIT09IHQgPyBuIDogKG4gPSBvLnZhbHVlLCBcInN0cmluZ1wiID09IHR5cGVvZiBuID8gbi5yZXBsYWNlKFYsIFwiXCIpIDogbnVsbCA9PSBuID8gXCJcIiA6IG4pXG4gICAgICAgICAgICB9XG4gICAgICAgIH19KSwgeC5leHRlbmQoe3ZhbEhvb2tzOiB7b3B0aW9uOiB7Z2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHguZmluZC5hdHRyKGUsIFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsICE9IHQgPyB0IDogZS50ZXh0XG4gICAgICAgICAgICAgICAgfX0sIHNlbGVjdDoge2dldDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQsIG4sIHIgPSBlLm9wdGlvbnMsIGkgPSBlLnNlbGVjdGVkSW5kZXgsIG8gPSBcInNlbGVjdC1vbmVcIiA9PT0gZS50eXBlIHx8IDAgPiBpLCBhID0gbyA/IG51bGwgOiBbXSwgcyA9IG8gPyBpICsgMSA6IHIubGVuZ3RoLCBsID0gMCA+IGkgPyBzIDogbyA/IGkgOiAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcyA+IGw7IGwrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID0gcltsXSwgISghbi5zZWxlY3RlZCAmJiBsICE9PSBpIHx8ICh4LnN1cHBvcnQub3B0RGlzYWJsZWQgPyBuLmRpc2FibGVkIDogbnVsbCAhPT0gbi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkgfHwgbi5wYXJlbnROb2RlLmRpc2FibGVkICYmIHgubm9kZU5hbWUobi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID0geChuKS52YWwoKSwgbylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiwgciwgaSA9IGUub3B0aW9ucywgbyA9IHgubWFrZUFycmF5KHQpLCBhID0gaS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gaVthXSwgKHIuc2VsZWN0ZWQgPSB4LmluQXJyYXkoeChyKS52YWwoKSwgbykgPj0gMCkgJiYgKG4gPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuIHx8IChlLnNlbGVjdGVkSW5kZXggPSAtMSksIG9cbiAgICAgICAgICAgICAgICB9fX0sIGF0dHI6IGZ1bmN0aW9uIChlLCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgbywgYSwgcyA9IGUubm9kZVR5cGU7XG4gICAgICAgICAgICBpZiAoZSAmJiAzICE9PSBzICYmIDggIT09IHMgJiYgMiAhPT0gcylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGUuZ2V0QXR0cmlidXRlID09PSBpID8geC5wcm9wKGUsIG4sIHIpIDogKDEgPT09IHMgJiYgeC5pc1hNTERvYyhlKSB8fCAobiA9IG4udG9Mb3dlckNhc2UoKSwgbyA9IHguYXR0ckhvb2tzW25dIHx8ICh4LmV4cHIubWF0Y2guYm9vbC50ZXN0KG4pID8gWCA6IHopKSwgciA9PT0gdCA/IG8gJiYgXCJnZXRcImluIG8gJiYgbnVsbCAhPT0gKGEgPSBvLmdldChlLCBuKSkgPyBhIDogKGEgPSB4LmZpbmQuYXR0cihlLCBuKSwgbnVsbCA9PSBhID8gdCA6IGEpIDogbnVsbCAhPT0gciA/IG8gJiYgXCJzZXRcImluIG8gJiYgKGEgPSBvLnNldChlLCByLCBuKSkgIT09IHQgPyBhIDogKGUuc2V0QXR0cmlidXRlKG4sIHIgKyBcIlwiKSwgcikgOiAoeC5yZW1vdmVBdHRyKGUsIG4pLCB0KSlcbiAgICAgICAgfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuLCByLCBpID0gMCwgbyA9IHQgJiYgdC5tYXRjaChUKTtcbiAgICAgICAgICAgIGlmIChvICYmIDEgPT09IGUubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPSBvW2krK10pXG4gICAgICAgICAgICAgICAgICAgIHIgPSB4LnByb3BGaXhbbl0gfHwgbiwgeC5leHByLm1hdGNoLmJvb2wudGVzdChuKSA/IEsgJiYgUSB8fCAhRy50ZXN0KG4pID8gZVtyXSA9ICExIDogZVt4LmNhbWVsQ2FzZShcImRlZmF1bHQtXCIgKyBuKV0gPSBlW3JdID0gITEgOiB4LmF0dHIoZSwgbiwgXCJcIiksIGUucmVtb3ZlQXR0cmlidXRlKFEgPyBuIDogcilcbiAgICAgICAgfSwgYXR0ckhvb2tzOiB7dHlwZToge3NldDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF4LnN1cHBvcnQucmFkaW9WYWx1ZSAmJiBcInJhZGlvXCIgPT09IHQgJiYgeC5ub2RlTmFtZShlLCBcImlucHV0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHQpLCBuICYmIChlLnZhbHVlID0gbiksIHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH19fSwgcHJvcEZpeDoge1wiZm9yXCI6IFwiaHRtbEZvclwiLCBcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJ9LCBwcm9wOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGksIG8sIGEsIHMgPSBlLm5vZGVUeXBlO1xuICAgICAgICAgICAgaWYgKGUgJiYgMyAhPT0gcyAmJiA4ICE9PSBzICYmIDIgIT09IHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPSAxICE9PSBzIHx8ICF4LmlzWE1MRG9jKGUpLCBhICYmIChuID0geC5wcm9wRml4W25dIHx8IG4sIG8gPSB4LnByb3BIb29rc1tuXSksIHIgIT09IHQgPyBvICYmIFwic2V0XCJpbiBvICYmIChpID0gby5zZXQoZSwgciwgbikpICE9PSB0ID8gaSA6IGVbbl0gPSByIDogbyAmJiBcImdldFwiaW4gbyAmJiBudWxsICE9PSAoaSA9IG8uZ2V0KGUsIG4pKSA/IGkgOiBlW25dXG4gICAgICAgIH0sIHByb3BIb29rczoge3RhYkluZGV4OiB7Z2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHguZmluZC5hdHRyKGUsIFwidGFiaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID8gcGFyc2VJbnQodCwgMTApIDogWS50ZXN0KGUubm9kZU5hbWUpIHx8IEoudGVzdChlLm5vZGVOYW1lKSAmJiBlLmhyZWYgPyAwIDogLTFcbiAgICAgICAgICAgICAgICB9fX19KSwgWCA9IHtzZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gdCA9PT0gITEgPyB4LnJlbW92ZUF0dHIoZSwgbikgOiBLICYmIFEgfHwgIUcudGVzdChuKSA/IGUuc2V0QXR0cmlidXRlKCFRICYmIHgucHJvcEZpeFtuXSB8fCBuLCBuKSA6IGVbeC5jYW1lbENhc2UoXCJkZWZhdWx0LVwiICsgbildID0gZVtuXSA9ICEwLCBuXG4gICAgICAgIH19LCB4LmVhY2goeC5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cXHcrL2cpLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICB2YXIgciA9IHguZXhwci5hdHRySGFuZGxlW25dIHx8IHguZmluZC5hdHRyO1xuICAgICAgICB4LmV4cHIuYXR0ckhhbmRsZVtuXSA9IEsgJiYgUSB8fCAhRy50ZXN0KG4pID8gZnVuY3Rpb24gKGUsIG4sIGkpIHtcbiAgICAgICAgICAgIHZhciBvID0geC5leHByLmF0dHJIYW5kbGVbbl0sIGEgPSBpID8gdCA6ICh4LmV4cHIuYXR0ckhhbmRsZVtuXSA9IHQpICE9IHIoZSwgbiwgaSkgPyBuLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHguZXhwci5hdHRySGFuZGxlW25dID0gbywgYVxuICAgICAgICB9IDogZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiByID8gdCA6IGVbeC5jYW1lbENhc2UoXCJkZWZhdWx0LVwiICsgbildID8gbi50b0xvd2VyQ2FzZSgpIDogbnVsbFxuICAgICAgICB9XG4gICAgfSksIEsgJiYgUSB8fCAoeC5hdHRySG9va3MudmFsdWUgPSB7c2V0OiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgcmV0dXJuIHgubm9kZU5hbWUoZSwgXCJpbnB1dFwiKSA/IChlLmRlZmF1bHRWYWx1ZSA9IG4sIHQpIDogeiAmJiB6LnNldChlLCBuLCByKVxuICAgICAgICB9fSksIFEgfHwgKHogPSB7c2V0OiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGkgPSBlLmdldEF0dHJpYnV0ZU5vZGUocik7XG4gICAgICAgICAgICByZXR1cm4gaSB8fCBlLnNldEF0dHJpYnV0ZU5vZGUoaSA9IGUub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUocikpLCBpLnZhbHVlID0gbiArPSBcIlwiLCBcInZhbHVlXCIgPT09IHIgfHwgbiA9PT0gZS5nZXRBdHRyaWJ1dGUocikgPyBuIDogdFxuICAgICAgICB9fSwgeC5leHByLmF0dHJIYW5kbGUuaWQgPSB4LmV4cHIuYXR0ckhhbmRsZS5uYW1lID0geC5leHByLmF0dHJIYW5kbGUuY29vcmRzID0gZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHJldHVybiByID8gdCA6IChpID0gZS5nZXRBdHRyaWJ1dGVOb2RlKG4pKSAmJiBcIlwiICE9PSBpLnZhbHVlID8gaS52YWx1ZSA6IG51bGxcbiAgICB9LCB4LnZhbEhvb2tzLmJ1dHRvbiA9IHtnZXQ6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICB2YXIgciA9IGUuZ2V0QXR0cmlidXRlTm9kZShuKTtcbiAgICAgICAgICAgIHJldHVybiByICYmIHIuc3BlY2lmaWVkID8gci52YWx1ZSA6IHRcbiAgICAgICAgfSwgc2V0OiB6LnNldH0sIHguYXR0ckhvb2tzLmNvbnRlbnRlZGl0YWJsZSA9IHtzZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICB6LnNldChlLCBcIlwiID09PSB0ID8gITEgOiB0LCBuKVxuICAgICAgICB9fSwgeC5lYWNoKFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICB4LmF0dHJIb29rc1tuXSA9IHtzZXQ6IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXCJcIiA9PT0gciA/IChlLnNldEF0dHJpYnV0ZShuLCBcImF1dG9cIiksIHIpIDogdFxuICAgICAgICAgICAgfX1cbiAgICB9KSksIHguc3VwcG9ydC5ocmVmTm9ybWFsaXplZCB8fCB4LmVhY2goW1wiaHJlZlwiLCBcInNyY1wiXSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgeC5wcm9wSG9va3NbdF0gPSB7Z2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmdldEF0dHJpYnV0ZSh0LCA0KVxuICAgICAgICAgICAgfX1cbiAgICB9KSwgeC5zdXBwb3J0LnN0eWxlIHx8ICh4LmF0dHJIb29rcy5zdHlsZSA9IHtnZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5zdHlsZS5jc3NUZXh0IHx8IHRcbiAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIGUuc3R5bGUuY3NzVGV4dCA9IHQgKyBcIlwiXG4gICAgICAgIH19KSwgeC5zdXBwb3J0Lm9wdFNlbGVjdGVkIHx8ICh4LnByb3BIb29rcy5zZWxlY3RlZCA9IHtnZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiB0ICYmICh0LnNlbGVjdGVkSW5kZXgsIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCksIG51bGxcbiAgICAgICAgfX0pLCB4LmVhY2goW1widGFiSW5kZXhcIiwgXCJyZWFkT25seVwiLCBcIm1heExlbmd0aFwiLCBcImNlbGxTcGFjaW5nXCIsIFwiY2VsbFBhZGRpbmdcIiwgXCJyb3dTcGFuXCIsIFwiY29sU3BhblwiLCBcInVzZU1hcFwiLCBcImZyYW1lQm9yZGVyXCIsIFwiY29udGVudEVkaXRhYmxlXCJdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHgucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldID0gdGhpc1xuICAgIH0pLCB4LnN1cHBvcnQuZW5jdHlwZSB8fCAoeC5wcm9wRml4LmVuY3R5cGUgPSBcImVuY29kaW5nXCIpLCB4LmVhY2goW1wicmFkaW9cIiwgXCJjaGVja2JveFwiXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB4LnZhbEhvb2tzW3RoaXNdID0ge3NldDogZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5pc0FycmF5KG4pID8gZS5jaGVja2VkID0geC5pbkFycmF5KHgoZSkudmFsKCksIG4pID49IDAgOiB0XG4gICAgICAgICAgICB9fSwgeC5zdXBwb3J0LmNoZWNrT24gfHwgKHgudmFsSG9va3NbdGhpc10uZ2V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsID09PSBlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID8gXCJvblwiIDogZS52YWx1ZVxuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHZhciBaID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWEpJC9pLCBldCA9IC9ea2V5LywgdHQgPSAvXig/Om1vdXNlfGNvbnRleHRtZW51KXxjbGljay8sIG50ID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLCBydCA9IC9eKFteLl0qKSg/OlxcLiguKyl8KSQvO1xuICAgIGZ1bmN0aW9uIGl0KCkge1xuICAgICAgICByZXR1cm4hMFxuICAgIH1cbiAgICBmdW5jdGlvbiBvdCgpIHtcbiAgICAgICAgcmV0dXJuITFcbiAgICB9XG4gICAgZnVuY3Rpb24gYXQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYS5hY3RpdmVFbGVtZW50XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICB4LmV2ZW50ID0ge2dsb2JhbDoge30sIGFkZDogZnVuY3Rpb24gKGUsIG4sIHIsIG8sIGEpIHtcbiAgICAgICAgICAgIHZhciBzLCBsLCB1LCBjLCBwLCBmLCBkLCBoLCBnLCBtLCB5LCB2ID0geC5fZGF0YShlKTtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgci5oYW5kbGVyICYmIChjID0gciwgciA9IGMuaGFuZGxlciwgYSA9IGMuc2VsZWN0b3IpLCByLmd1aWQgfHwgKHIuZ3VpZCA9IHguZ3VpZCsrKSwgKGwgPSB2LmV2ZW50cykgfHwgKGwgPSB2LmV2ZW50cyA9IHt9KSwgKGYgPSB2LmhhbmRsZSkgfHwgKGYgPSB2LmhhbmRsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gaSB8fCBlICYmIHguZXZlbnQudHJpZ2dlcmVkID09PSBlLnR5cGUgPyB0IDogeC5ldmVudC5kaXNwYXRjaC5hcHBseShmLmVsZW0sIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9LCBmLmVsZW0gPSBlKSwgbiA9IChuIHx8IFwiXCIpLm1hdGNoKFQpIHx8IFtcIlwiXSwgdSA9IG4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICh1LS0pXG4gICAgICAgICAgICAgICAgICAgIHMgPSBydC5leGVjKG5bdV0pIHx8IFtdLCBnID0geSA9IHNbMV0sIG0gPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBnICYmIChwID0geC5ldmVudC5zcGVjaWFsW2ddIHx8IHt9LCBnID0gKGEgPyBwLmRlbGVnYXRlVHlwZSA6IHAuYmluZFR5cGUpIHx8IGcsIHAgPSB4LmV2ZW50LnNwZWNpYWxbZ10gfHwge30sIGQgPSB4LmV4dGVuZCh7dHlwZTogZywgb3JpZ1R5cGU6IHksIGRhdGE6IG8sIGhhbmRsZXI6IHIsIGd1aWQ6IHIuZ3VpZCwgc2VsZWN0b3I6IGEsIG5lZWRzQ29udGV4dDogYSAmJiB4LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoYSksIG5hbWVzcGFjZTogbS5qb2luKFwiLlwiKX0sIGMpLCAoaCA9IGxbZ10pIHx8IChoID0gbFtnXSA9IFtdLCBoLmRlbGVnYXRlQ291bnQgPSAwLCBwLnNldHVwICYmIHAuc2V0dXAuY2FsbChlLCBvLCBtLCBmKSAhPT0gITEgfHwgKGUuYWRkRXZlbnRMaXN0ZW5lciA/IGUuYWRkRXZlbnRMaXN0ZW5lcihnLCBmLCAhMSkgOiBlLmF0dGFjaEV2ZW50ICYmIGUuYXR0YWNoRXZlbnQoXCJvblwiICsgZywgZikpKSwgcC5hZGQgJiYgKHAuYWRkLmNhbGwoZSwgZCksIGQuaGFuZGxlci5ndWlkIHx8IChkLmhhbmRsZXIuZ3VpZCA9IHIuZ3VpZCkpLCBhID8gaC5zcGxpY2UoaC5kZWxlZ2F0ZUNvdW50KyssIDAsIGQpIDogaC5wdXNoKGQpLCB4LmV2ZW50Lmdsb2JhbFtnXSA9ICEwKTtcbiAgICAgICAgICAgICAgICBlID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIChlLCB0LCBuLCByLCBpKSB7XG4gICAgICAgICAgICB2YXIgbywgYSwgcywgbCwgdSwgYywgcCwgZiwgZCwgaCwgZywgbSA9IHguaGFzRGF0YShlKSAmJiB4Ll9kYXRhKGUpO1xuICAgICAgICAgICAgaWYgKG0gJiYgKGMgPSBtLmV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICB0ID0gKHQgfHwgXCJcIikubWF0Y2goVCkgfHwgW1wiXCJdLCB1ID0gdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHUtLSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPSBydC5leGVjKHRbdV0pIHx8IFtdLCBkID0gZyA9IHNbMV0sIGggPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0geC5ldmVudC5zcGVjaWFsW2RdIHx8IHt9LCBkID0gKHIgPyBwLmRlbGVnYXRlVHlwZSA6IHAuYmluZFR5cGUpIHx8IGQsIGYgPSBjW2RdIHx8IFtdLCBzID0gc1syXSAmJiBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGguam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiksIGwgPSBvID0gZi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoby0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBmW29dLCAhaSAmJiBnICE9PSBhLm9yaWdUeXBlIHx8IG4gJiYgbi5ndWlkICE9PSBhLmd1aWQgfHwgcyAmJiAhcy50ZXN0KGEubmFtZXNwYWNlKSB8fCByICYmIHIgIT09IGEuc2VsZWN0b3IgJiYgKFwiKipcIiAhPT0gciB8fCAhYS5zZWxlY3RvcikgfHwgKGYuc3BsaWNlKG8sIDEpLCBhLnNlbGVjdG9yICYmIGYuZGVsZWdhdGVDb3VudC0tLCBwLnJlbW92ZSAmJiBwLnJlbW92ZS5jYWxsKGUsIGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgJiYgIWYubGVuZ3RoICYmIChwLnRlYXJkb3duICYmIHAudGVhcmRvd24uY2FsbChlLCBoLCBtLmhhbmRsZSkgIT09ICExIHx8IHgucmVtb3ZlRXZlbnQoZSwgZCwgbS5oYW5kbGUpLCBkZWxldGUgY1tkXSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGQgaW4gYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmV2ZW50LnJlbW92ZShlLCBkICsgdFt1XSwgbiwgciwgITApO1xuICAgICAgICAgICAgICAgIHguaXNFbXB0eU9iamVjdChjKSAmJiAoZGVsZXRlIG0uaGFuZGxlLCB4Ll9yZW1vdmVEYXRhKGUsIFwiZXZlbnRzXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cmlnZ2VyOiBmdW5jdGlvbiAobiwgciwgaSwgbykge1xuICAgICAgICAgICAgdmFyIHMsIGwsIHUsIGMsIHAsIGYsIGQsIGggPSBbaSB8fCBhXSwgZyA9IHYuY2FsbChuLCBcInR5cGVcIikgPyBuLnR5cGUgOiBuLCBtID0gdi5jYWxsKG4sIFwibmFtZXNwYWNlXCIpID8gbi5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpIDogW107XG4gICAgICAgICAgICBpZiAodSA9IGYgPSBpID0gaSB8fCBhLCAzICE9PSBpLm5vZGVUeXBlICYmIDggIT09IGkubm9kZVR5cGUgJiYgIW50LnRlc3QoZyArIHguZXZlbnQudHJpZ2dlcmVkKSAmJiAoZy5pbmRleE9mKFwiLlwiKSA+PSAwICYmIChtID0gZy5zcGxpdChcIi5cIiksIGcgPSBtLnNoaWZ0KCksIG0uc29ydCgpKSwgbCA9IDAgPiBnLmluZGV4T2YoXCI6XCIpICYmIFwib25cIiArIGcsIG4gPSBuW3guZXhwYW5kb10gPyBuIDogbmV3IHguRXZlbnQoZywgXCJvYmplY3RcIiA9PSB0eXBlb2YgbiAmJiBuKSwgbi5pc1RyaWdnZXIgPSBvID8gMiA6IDMsIG4ubmFtZXNwYWNlID0gbS5qb2luKFwiLlwiKSwgbi5uYW1lc3BhY2VfcmUgPSBuLm5hbWVzcGFjZSA/IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbS5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKSA6IG51bGwsIG4ucmVzdWx0ID0gdCwgbi50YXJnZXQgfHwgKG4udGFyZ2V0ID0gaSksIHIgPSBudWxsID09IHIgPyBbbl0gOiB4Lm1ha2VBcnJheShyLCBbbl0pLCBwID0geC5ldmVudC5zcGVjaWFsW2ddIHx8IHt9LCBvIHx8ICFwLnRyaWdnZXIgfHwgcC50cmlnZ2VyLmFwcGx5KGksIHIpICE9PSAhMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW8gJiYgIXAubm9CdWJibGUgJiYgIXguaXNXaW5kb3coaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjID0gcC5kZWxlZ2F0ZVR5cGUgfHwgZywgbnQudGVzdChjICsgZykgfHwgKHUgPSB1LnBhcmVudE5vZGUpOyB1OyB1ID0gdS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaC5wdXNoKHUpLCBmID0gdTtcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gKGkub3duZXJEb2N1bWVudCB8fCBhKSAmJiBoLnB1c2goZi5kZWZhdWx0VmlldyB8fCBmLnBhcmVudFdpbmRvdyB8fCBlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHUgPSBoW2QrK10pICYmICFuLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpXG4gICAgICAgICAgICAgICAgICAgIG4udHlwZSA9IGQgPiAxID8gYyA6IHAuYmluZFR5cGUgfHwgZywgcyA9ICh4Ll9kYXRhKHUsIFwiZXZlbnRzXCIpIHx8IHt9KVtuLnR5cGVdICYmIHguX2RhdGEodSwgXCJoYW5kbGVcIiksIHMgJiYgcy5hcHBseSh1LCByKSwgcyA9IGwgJiYgdVtsXSwgcyAmJiB4LmFjY2VwdERhdGEodSkgJiYgcy5hcHBseSAmJiBzLmFwcGx5KHUsIHIpID09PSAhMSAmJiBuLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9IGcsICFvICYmICFuLmlzRGVmYXVsdFByZXZlbnRlZCgpICYmICghcC5fZGVmYXVsdCB8fCBwLl9kZWZhdWx0LmFwcGx5KGgucG9wKCksIHIpID09PSAhMSkgJiYgeC5hY2NlcHREYXRhKGkpICYmIGwgJiYgaVtnXSAmJiAheC5pc1dpbmRvdyhpKSkge1xuICAgICAgICAgICAgICAgICAgICBmID0gaVtsXSwgZiAmJiAoaVtsXSA9IG51bGwpLCB4LmV2ZW50LnRyaWdnZXJlZCA9IGc7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpW2ddKClcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeSkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHguZXZlbnQudHJpZ2dlcmVkID0gdCwgZiAmJiAoaVtsXSA9IGYpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuLnJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkaXNwYXRjaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUgPSB4LmV2ZW50LmZpeChlKTtcbiAgICAgICAgICAgIHZhciBuLCByLCBpLCBvLCBhLCBzID0gW10sIGwgPSBnLmNhbGwoYXJndW1lbnRzKSwgdSA9ICh4Ll9kYXRhKHRoaXMsIFwiZXZlbnRzXCIpIHx8IHt9KVtlLnR5cGVdIHx8IFtdLCBjID0geC5ldmVudC5zcGVjaWFsW2UudHlwZV0gfHwge307XG4gICAgICAgICAgICBpZiAobFswXSA9IGUsIGUuZGVsZWdhdGVUYXJnZXQgPSB0aGlzLCAhYy5wcmVEaXNwYXRjaCB8fCBjLnByZURpc3BhdGNoLmNhbGwodGhpcywgZSkgIT09ICExKSB7XG4gICAgICAgICAgICAgICAgcyA9IHguZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBlLCB1KSwgbiA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChvID0gc1tuKytdKSAmJiAhZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldCA9IG8uZWxlbSwgYSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaSA9IG8uaGFuZGxlcnNbYSsrXSkgJiYgIWUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICghZS5uYW1lc3BhY2VfcmUgfHwgZS5uYW1lc3BhY2VfcmUudGVzdChpLm5hbWVzcGFjZSkpICYmIChlLmhhbmRsZU9iaiA9IGksIGUuZGF0YSA9IGkuZGF0YSwgciA9ICgoeC5ldmVudC5zcGVjaWFsW2kub3JpZ1R5cGVdIHx8IHt9KS5oYW5kbGUgfHwgaS5oYW5kbGVyKS5hcHBseShvLmVsZW0sIGwpLCByICE9PSB0ICYmIChlLnJlc3VsdCA9IHIpID09PSAhMSAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMucG9zdERpc3BhdGNoICYmIGMucG9zdERpc3BhdGNoLmNhbGwodGhpcywgZSksIGUucmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXJzOiBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgdmFyIHIsIGksIG8sIGEsIHMgPSBbXSwgbCA9IG4uZGVsZWdhdGVDb3VudCwgdSA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGwgJiYgdS5ub2RlVHlwZSAmJiAoIWUuYnV0dG9uIHx8IFwiY2xpY2tcIiAhPT0gZS50eXBlKSlcbiAgICAgICAgICAgICAgICBmb3IgKDsgdSAhPSB0aGlzOyB1ID0gdS5wYXJlbnROb2RlIHx8IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIGlmICgxID09PSB1Lm5vZGVUeXBlICYmICh1LmRpc2FibGVkICE9PSAhMCB8fCBcImNsaWNrXCIgIT09IGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobyA9IFtdLCBhID0gMDsgbCA+IGE7IGErKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gblthXSwgciA9IGkuc2VsZWN0b3IgKyBcIiBcIiwgb1tyXSA9PT0gdCAmJiAob1tyXSA9IGkubmVlZHNDb250ZXh0ID8geChyLCB0aGlzKS5pbmRleCh1KSA+PSAwIDogeC5maW5kKHIsIHRoaXMsIG51bGwsIFt1XSkubGVuZ3RoKSwgb1tyXSAmJiBvLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmxlbmd0aCAmJiBzLnB1c2goe2VsZW06IHUsIGhhbmRsZXJzOiBvfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG4ubGVuZ3RoID4gbCAmJiBzLnB1c2goe2VsZW06IHRoaXMsIGhhbmRsZXJzOiBuLnNsaWNlKGwpfSksIHNcbiAgICAgICAgfSwgZml4OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGVbeC5leHBhbmRvXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIHZhciB0LCBuLCByLCBpID0gZS50eXBlLCBvID0gZSwgcyA9IHRoaXMuZml4SG9va3NbaV07XG4gICAgICAgICAgICBzIHx8ICh0aGlzLmZpeEhvb2tzW2ldID0gcyA9IHR0LnRlc3QoaSkgPyB0aGlzLm1vdXNlSG9va3MgOiBldC50ZXN0KGkpID8gdGhpcy5rZXlIb29rcyA6IHt9KSwgciA9IHMucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdChzLnByb3BzKSA6IHRoaXMucHJvcHMsIGUgPSBuZXcgeC5FdmVudChvKSwgdCA9IHIubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHQtLSlcbiAgICAgICAgICAgICAgICBuID0gclt0XSwgZVtuXSA9IG9bbl07XG4gICAgICAgICAgICByZXR1cm4gZS50YXJnZXQgfHwgKGUudGFyZ2V0ID0gby5zcmNFbGVtZW50IHx8IGEpLCAzID09PSBlLnRhcmdldC5ub2RlVHlwZSAmJiAoZS50YXJnZXQgPSBlLnRhcmdldC5wYXJlbnROb2RlKSwgZS5tZXRhS2V5ID0gISFlLm1ldGFLZXksIHMuZmlsdGVyID8gcy5maWx0ZXIoZSwgbykgOiBlXG4gICAgICAgIH0sIHByb3BzOiBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiLnNwbGl0KFwiIFwiKSwgZml4SG9va3M6IHt9LCBrZXlIb29rczoge3Byb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksIGZpbHRlcjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBlLndoaWNoICYmIChlLndoaWNoID0gbnVsbCAhPSB0LmNoYXJDb2RlID8gdC5jaGFyQ29kZSA6IHQua2V5Q29kZSksIGVcbiAgICAgICAgICAgIH19LCBtb3VzZUhvb2tzOiB7cHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLCBmaWx0ZXI6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIsIGksIG8sIHMgPSBuLmJ1dHRvbiwgbCA9IG4uZnJvbUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZS5wYWdlWCAmJiBudWxsICE9IG4uY2xpZW50WCAmJiAoaSA9IGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgYSwgbyA9IGkuZG9jdW1lbnRFbGVtZW50LCByID0gaS5ib2R5LCBlLnBhZ2VYID0gbi5jbGllbnRYICsgKG8gJiYgby5zY3JvbGxMZWZ0IHx8IHIgJiYgci5zY3JvbGxMZWZ0IHx8IDApIC0gKG8gJiYgby5jbGllbnRMZWZ0IHx8IHIgJiYgci5jbGllbnRMZWZ0IHx8IDApLCBlLnBhZ2VZID0gbi5jbGllbnRZICsgKG8gJiYgby5zY3JvbGxUb3AgfHwgciAmJiByLnNjcm9sbFRvcCB8fCAwKSAtIChvICYmIG8uY2xpZW50VG9wIHx8IHIgJiYgci5jbGllbnRUb3AgfHwgMCkpLCAhZS5yZWxhdGVkVGFyZ2V0ICYmIGwgJiYgKGUucmVsYXRlZFRhcmdldCA9IGwgPT09IGUudGFyZ2V0ID8gbi50b0VsZW1lbnQgOiBsKSwgZS53aGljaCB8fCBzID09PSB0IHx8IChlLndoaWNoID0gMSAmIHMgPyAxIDogMiAmIHMgPyAzIDogNCAmIHMgPyAyIDogMCksIGVcbiAgICAgICAgICAgIH19LCBzcGVjaWFsOiB7bG9hZDoge25vQnViYmxlOiAhMH0sIGZvY3VzOiB7dHJpZ2dlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcyAhPT0gYXQoKSAmJiB0aGlzLmZvY3VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb2N1cygpLCAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJ9LCBibHVyOiB7dHJpZ2dlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcyA9PT0gYXQoKSAmJiB0aGlzLmJsdXIgPyAodGhpcy5ibHVyKCksICExKSA6IHRcbiAgICAgICAgICAgICAgICB9LCBkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIn0sIGNsaWNrOiB7dHJpZ2dlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5ub2RlTmFtZSh0aGlzLCBcImlucHV0XCIpICYmIFwiY2hlY2tib3hcIiA9PT0gdGhpcy50eXBlICYmIHRoaXMuY2xpY2sgPyAodGhpcy5jbGljaygpLCAhMSkgOiB0XG4gICAgICAgICAgICAgICAgfSwgX2RlZmF1bHQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4Lm5vZGVOYW1lKGUudGFyZ2V0LCBcImFcIilcbiAgICAgICAgICAgICAgICB9fSwgYmVmb3JldW5sb2FkOiB7cG9zdERpc3BhdGNoOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnJlc3VsdCAhPT0gdCAmJiAoZS5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZS5yZXN1bHQpXG4gICAgICAgICAgICAgICAgfX19LCBzaW11bGF0ZTogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgIHZhciBpID0geC5leHRlbmQobmV3IHguRXZlbnQsIG4sIHt0eXBlOiBlLCBpc1NpbXVsYXRlZDogITAsIG9yaWdpbmFsRXZlbnQ6IHt9fSk7XG4gICAgICAgICAgICByID8geC5ldmVudC50cmlnZ2VyKGksIG51bGwsIHQpIDogeC5ldmVudC5kaXNwYXRjaC5jYWxsKHQsIGkpLCBpLmlzRGVmYXVsdFByZXZlbnRlZCgpICYmIG4ucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9fSwgeC5yZW1vdmVFdmVudCA9IGEucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgbiwgITEpXG4gICAgfSA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgIHZhciByID0gXCJvblwiICsgdDtcbiAgICAgICAgZS5kZXRhY2hFdmVudCAmJiAodHlwZW9mIGVbcl0gPT09IGkgJiYgKGVbcl0gPSBudWxsKSwgZS5kZXRhY2hFdmVudChyLCBuKSlcbiAgICB9LCB4LkV2ZW50ID0gZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiB4LkV2ZW50ID8gKGUgJiYgZS50eXBlID8gKHRoaXMub3JpZ2luYWxFdmVudCA9IGUsIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgZS5yZXR1cm5WYWx1ZSA9PT0gITEgfHwgZS5nZXRQcmV2ZW50RGVmYXVsdCAmJiBlLmdldFByZXZlbnREZWZhdWx0KCkgPyBpdCA6IG90KSA6IHRoaXMudHlwZSA9IGUsIG4gJiYgeC5leHRlbmQodGhpcywgbiksIHRoaXMudGltZVN0YW1wID0gZSAmJiBlLnRpbWVTdGFtcCB8fCB4Lm5vdygpLCB0aGlzW3guZXhwYW5kb10gPSAhMCwgdCkgOiBuZXcgeC5FdmVudChlLCBuKVxuICAgIH0sIHguRXZlbnQucHJvdG90eXBlID0ge2lzRGVmYXVsdFByZXZlbnRlZDogb3QsIGlzUHJvcGFnYXRpb25TdG9wcGVkOiBvdCwgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IG90LCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGl0LCBlICYmIChlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9ICExKVxuICAgICAgICB9LCBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGl0LCBlICYmIChlLnN0b3BQcm9wYWdhdGlvbiAmJiBlLnN0b3BQcm9wYWdhdGlvbigpLCBlLmNhbmNlbEJ1YmJsZSA9ICEwKVxuICAgICAgICB9LCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBpdCwgdGhpcy5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9fSwgeC5lYWNoKHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9LCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB4LmV2ZW50LnNwZWNpYWxbZV0gPSB7ZGVsZWdhdGVUeXBlOiB0LCBiaW5kVHlwZTogdCwgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBuLCByID0gdGhpcywgaSA9IGUucmVsYXRlZFRhcmdldCwgbyA9IGUuaGFuZGxlT2JqO1xuICAgICAgICAgICAgICAgIHJldHVybighaSB8fCBpICE9PSByICYmICF4LmNvbnRhaW5zKHIsIGkpKSAmJiAoZS50eXBlID0gby5vcmlnVHlwZSwgbiA9IG8uaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBlLnR5cGUgPSB0KSwgblxuICAgICAgICAgICAgfX1cbiAgICB9KSwgeC5zdXBwb3J0LnN1Ym1pdEJ1YmJsZXMgfHwgKHguZXZlbnQuc3BlY2lhbC5zdWJtaXQgPSB7c2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4Lm5vZGVOYW1lKHRoaXMsIFwiZm9ybVwiKSA/ICExIDogKHguZXZlbnQuYWRkKHRoaXMsIFwiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBlLnRhcmdldCwgciA9IHgubm9kZU5hbWUobiwgXCJpbnB1dFwiKSB8fCB4Lm5vZGVOYW1lKG4sIFwiYnV0dG9uXCIpID8gbi5mb3JtIDogdDtcbiAgICAgICAgICAgICAgICByICYmICF4Ll9kYXRhKHIsIFwic3VibWl0QnViYmxlc1wiKSAmJiAoeC5ldmVudC5hZGQociwgXCJzdWJtaXQuX3N1Ym1pdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLl9zdWJtaXRfYnViYmxlID0gITBcbiAgICAgICAgICAgICAgICB9KSwgeC5fZGF0YShyLCBcInN1Ym1pdEJ1YmJsZXNcIiwgITApKVxuICAgICAgICAgICAgfSksIHQpXG4gICAgICAgIH0sIHBvc3REaXNwYXRjaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuX3N1Ym1pdF9idWJibGUgJiYgKGRlbGV0ZSBlLl9zdWJtaXRfYnViYmxlLCB0aGlzLnBhcmVudE5vZGUgJiYgIWUuaXNUcmlnZ2VyICYmIHguZXZlbnQuc2ltdWxhdGUoXCJzdWJtaXRcIiwgdGhpcy5wYXJlbnROb2RlLCBlLCAhMCkpXG4gICAgICAgIH0sIHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geC5ub2RlTmFtZSh0aGlzLCBcImZvcm1cIikgPyAhMSA6ICh4LmV2ZW50LnJlbW92ZSh0aGlzLCBcIi5fc3VibWl0XCIpLCB0KVxuICAgICAgICB9fSksIHguc3VwcG9ydC5jaGFuZ2VCdWJibGVzIHx8ICh4LmV2ZW50LnNwZWNpYWwuY2hhbmdlID0ge3NldHVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gWi50ZXN0KHRoaXMubm9kZU5hbWUpID8gKChcImNoZWNrYm94XCIgPT09IHRoaXMudHlwZSB8fCBcInJhZGlvXCIgPT09IHRoaXMudHlwZSkgJiYgKHguZXZlbnQuYWRkKHRoaXMsIFwicHJvcGVydHljaGFuZ2UuX2NoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIFwiY2hlY2tlZFwiID09PSBlLm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lICYmICh0aGlzLl9qdXN0X2NoYW5nZWQgPSAhMClcbiAgICAgICAgICAgIH0pLCB4LmV2ZW50LmFkZCh0aGlzLCBcImNsaWNrLl9jaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0X2NoYW5nZWQgJiYgIWUuaXNUcmlnZ2VyICYmICh0aGlzLl9qdXN0X2NoYW5nZWQgPSAhMSksIHguZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIiwgdGhpcywgZSwgITApXG4gICAgICAgICAgICB9KSksICExKSA6ICh4LmV2ZW50LmFkZCh0aGlzLCBcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIFoudGVzdCh0Lm5vZGVOYW1lKSAmJiAheC5fZGF0YSh0LCBcImNoYW5nZUJ1YmJsZXNcIikgJiYgKHguZXZlbnQuYWRkKHQsIFwiY2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMucGFyZW50Tm9kZSB8fCBlLmlzU2ltdWxhdGVkIHx8IGUuaXNUcmlnZ2VyIHx8IHguZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIiwgdGhpcy5wYXJlbnROb2RlLCBlLCAhMClcbiAgICAgICAgICAgICAgICB9KSwgeC5fZGF0YSh0LCBcImNoYW5nZUJ1YmJsZXNcIiwgITApKVxuICAgICAgICAgICAgfSksIHQpXG4gICAgICAgIH0sIGhhbmRsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBuID0gZS50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcyAhPT0gbiB8fCBlLmlzU2ltdWxhdGVkIHx8IGUuaXNUcmlnZ2VyIHx8IFwicmFkaW9cIiAhPT0gbi50eXBlICYmIFwiY2hlY2tib3hcIiAhPT0gbi50eXBlID8gZS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdFxuICAgICAgICB9LCB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHguZXZlbnQucmVtb3ZlKHRoaXMsIFwiLl9jaGFuZ2VcIiksICFaLnRlc3QodGhpcy5ub2RlTmFtZSlcbiAgICAgICAgfX0pLCB4LnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgfHwgeC5lYWNoKHtmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIn0sIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciBuID0gMCwgciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB4LmV2ZW50LnNpbXVsYXRlKHQsIGUudGFyZ2V0LCB4LmV2ZW50LmZpeChlKSwgITApXG4gICAgICAgIH07XG4gICAgICAgIHguZXZlbnQuc3BlY2lhbFt0XSA9IHtzZXR1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIDAgPT09IG4rKyAmJiBhLmFkZEV2ZW50TGlzdGVuZXIoZSwgciwgITApXG4gICAgICAgICAgICB9LCB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIDAgPT09IC0tbiAmJiBhLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgciwgITApXG4gICAgICAgICAgICB9fVxuICAgIH0pLCB4LmZuLmV4dGVuZCh7b246IGZ1bmN0aW9uIChlLCBuLCByLCBpLCBvKSB7XG4gICAgICAgICAgICB2YXIgYSwgcztcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPSB0eXBlb2YgbiAmJiAociA9IHIgfHwgbiwgbiA9IHQpO1xuICAgICAgICAgICAgICAgIGZvciAoYSBpbiBlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKGEsIG4sIHIsIGVbYV0sIG8pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCA9PSByICYmIG51bGwgPT0gaSA/IChpID0gbiwgciA9IG4gPSB0KSA6IG51bGwgPT0gaSAmJiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiA/IChpID0gciwgciA9IHQpIDogKGkgPSByLCByID0gbiwgbiA9IHQpKSwgaSA9PT0gITEpXG4gICAgICAgICAgICAgICAgaSA9IG90O1xuICAgICAgICAgICAgZWxzZSBpZiAoIWkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gMSA9PT0gbyAmJiAocyA9IGksIGkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4KCkub2ZmKGUpLCBzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIH0sIGkuZ3VpZCA9IHMuZ3VpZCB8fCAocy5ndWlkID0geC5ndWlkKyspKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB4LmV2ZW50LmFkZCh0aGlzLCBlLCBpLCByLCBuKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgb25lOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oZSwgdCwgbiwgciwgMSlcbiAgICAgICAgfSwgb2ZmOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGksIG87XG4gICAgICAgICAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGUuaGFuZGxlT2JqKVxuICAgICAgICAgICAgICAgIHJldHVybiBpID0gZS5oYW5kbGVPYmosIHgoZS5kZWxlZ2F0ZVRhcmdldCkub2ZmKGkubmFtZXNwYWNlID8gaS5vcmlnVHlwZSArIFwiLlwiICsgaS5uYW1lc3BhY2UgOiBpLm9yaWdUeXBlLCBpLnNlbGVjdG9yLCBpLmhhbmRsZXIpLCB0aGlzO1xuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKG8gaW4gZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYobywgbiwgZVtvXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybihuID09PSAhMSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4pICYmIChyID0gbiwgbiA9IHQpLCByID09PSAhMSAmJiAociA9IG90KSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB4LmV2ZW50LnJlbW92ZSh0aGlzLCBlLCByLCBuKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgdHJpZ2dlcjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHguZXZlbnQudHJpZ2dlcihlLCB0LCB0aGlzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXNbMF07XG4gICAgICAgICAgICByZXR1cm4gciA/IHguZXZlbnQudHJpZ2dlcihlLCBuLCByLCAhMCkgOiB0XG4gICAgICAgIH19KTtcbiAgICB2YXIgc3QgPSAvXi5bXjojXFxbXFwuLF0qJC8sIGx0ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sIHV0ID0geC5leHByLm1hdGNoLm5lZWRzQ29udGV4dCwgY3QgPSB7Y2hpbGRyZW46ICEwLCBjb250ZW50czogITAsIG5leHQ6ICEwLCBwcmV2OiAhMH07XG4gICAgeC5mbi5leHRlbmQoe2ZpbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCwgbiA9IFtdLCByID0gdGhpcywgaSA9IHIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHgoZSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0ID0gMDsgaSA+IHQ7IHQrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmNvbnRhaW5zKHJbdF0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiEwXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgZm9yICh0ID0gMDsgaSA+IHQ7IHQrKylcbiAgICAgICAgICAgICAgICB4LmZpbmQoZSwgclt0XSwgbik7XG4gICAgICAgICAgICByZXR1cm4gbiA9IHRoaXMucHVzaFN0YWNrKGkgPiAxID8geC51bmlxdWUobikgOiBuKSwgbi5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXCIgXCIgKyBlIDogZSwgblxuICAgICAgICB9LCBoYXM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCwgbiA9IHgoZSwgdGhpcyksIHIgPSBuLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh0ID0gMDsgciA+IHQ7IHQrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHguY29udGFpbnModGhpcywgblt0XSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgbm90OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGZ0KHRoaXMsIGUgfHwgW10sICEwKSlcbiAgICAgICAgfSwgZmlsdGVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGZ0KHRoaXMsIGUgfHwgW10sICExKSlcbiAgICAgICAgfSwgaXM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4hIWZ0KHRoaXMsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgdXQudGVzdChlKSA/IHgoZSkgOiBlIHx8IFtdLCAhMSkubGVuZ3RoXG4gICAgICAgIH0sIGNsb3Nlc3Q6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiwgciA9IDAsIGkgPSB0aGlzLmxlbmd0aCwgbyA9IFtdLCBhID0gdXQudGVzdChlKSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBlID8geChlLCB0IHx8IHRoaXMuY29udGV4dCkgOiAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPiByOyByKyspXG4gICAgICAgICAgICAgICAgZm9yIChuID0gdGhpc1tyXTsgbiAmJiBuICE9PSB0OyBuID0gbi5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoMTEgPiBuLm5vZGVUeXBlICYmIChhID8gYS5pbmRleChuKSA+IC0xIDogMSA9PT0gbi5ub2RlVHlwZSAmJiB4LmZpbmQubWF0Y2hlc1NlbGVjdG9yKG4sIGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG8ucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhvLmxlbmd0aCA+IDEgPyB4LnVuaXF1ZShvKSA6IG8pXG4gICAgICAgIH0sIGluZGV4OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgPyBcInN0cmluZ1wiID09IHR5cGVvZiBlID8geC5pbkFycmF5KHRoaXNbMF0sIHgoZSkpIDogeC5pbkFycmF5KGUuanF1ZXJ5ID8gZVswXSA6IGUsIHRoaXMpIDogdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xXG4gICAgICAgIH0sIGFkZDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IHgoZSwgdCkgOiB4Lm1ha2VBcnJheShlICYmIGUubm9kZVR5cGUgPyBbZV0gOiBlKSwgciA9IHgubWVyZ2UodGhpcy5nZXQoKSwgbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soeC51bmlxdWUocikpXG4gICAgICAgIH0sIGFkZEJhY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobnVsbCA9PSBlID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihlKSlcbiAgICAgICAgfX0pO1xuICAgIGZ1bmN0aW9uIHB0KGUsIHQpIHtcbiAgICAgICAgZG9cbiAgICAgICAgICAgIGUgPSBlW3RdO1xuICAgICAgICB3aGlsZSAoZSAmJiAxICE9PSBlLm5vZGVUeXBlKTtcbiAgICAgICAgcmV0dXJuIGVcbiAgICB9XG4gICAgeC5lYWNoKHtwYXJlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiB0ICYmIDExICE9PSB0Lm5vZGVUeXBlID8gdCA6IG51bGxcbiAgICAgICAgfSwgcGFyZW50czogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmRpcihlLCBcInBhcmVudE5vZGVcIilcbiAgICAgICAgfSwgcGFyZW50c1VudGlsOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgcmV0dXJuIHguZGlyKGUsIFwicGFyZW50Tm9kZVwiLCBuKVxuICAgICAgICB9LCBuZXh0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHB0KGUsIFwibmV4dFNpYmxpbmdcIilcbiAgICAgICAgfSwgcHJldjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwdChlLCBcInByZXZpb3VzU2libGluZ1wiKVxuICAgICAgICB9LCBuZXh0QWxsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHguZGlyKGUsIFwibmV4dFNpYmxpbmdcIilcbiAgICAgICAgfSwgcHJldkFsbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmRpcihlLCBcInByZXZpb3VzU2libGluZ1wiKVxuICAgICAgICB9LCBuZXh0VW50aWw6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4geC5kaXIoZSwgXCJuZXh0U2libGluZ1wiLCBuKVxuICAgICAgICB9LCBwcmV2VW50aWw6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4geC5kaXIoZSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgbilcbiAgICAgICAgfSwgc2libGluZ3M6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4geC5zaWJsaW5nKChlLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGUpXG4gICAgICAgIH0sIGNoaWxkcmVuOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHguc2libGluZyhlLmZpcnN0Q2hpbGQpXG4gICAgICAgIH0sIGNvbnRlbnRzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHgubm9kZU5hbWUoZSwgXCJpZnJhbWVcIikgPyBlLmNvbnRlbnREb2N1bWVudCB8fCBlLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQgOiB4Lm1lcmdlKFtdLCBlLmNoaWxkTm9kZXMpXG4gICAgICAgIH19LCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB4LmZuW2VdID0gZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgICAgIHZhciBpID0geC5tYXAodGhpcywgdCwgbik7XG4gICAgICAgICAgICByZXR1cm5cIlVudGlsXCIgIT09IGUuc2xpY2UoLTUpICYmIChyID0gbiksIHIgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgciAmJiAoaSA9IHguZmlsdGVyKHIsIGkpKSwgdGhpcy5sZW5ndGggPiAxICYmIChjdFtlXSB8fCAoaSA9IHgudW5pcXVlKGkpKSwgbHQudGVzdChlKSAmJiAoaSA9IGkucmV2ZXJzZSgpKSksIHRoaXMucHVzaFN0YWNrKGkpXG4gICAgICAgIH1cbiAgICB9KSwgeC5leHRlbmQoe2ZpbHRlcjogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHZhciByID0gdFswXTtcbiAgICAgICAgICAgIHJldHVybiBuICYmIChlID0gXCI6bm90KFwiICsgZSArIFwiKVwiKSwgMSA9PT0gdC5sZW5ndGggJiYgMSA9PT0gci5ub2RlVHlwZSA/IHguZmluZC5tYXRjaGVzU2VsZWN0b3IociwgZSkgPyBbcl0gOiBbXSA6IHguZmluZC5tYXRjaGVzKGUsIHguZ3JlcCh0LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxID09PSBlLm5vZGVUeXBlXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfSwgZGlyOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGkgPSBbXSwgbyA9IGVbbl07XG4gICAgICAgICAgICB3aGlsZSAobyAmJiA5ICE9PSBvLm5vZGVUeXBlICYmIChyID09PSB0IHx8IDEgIT09IG8ubm9kZVR5cGUgfHwgIXgobykuaXMocikpKVxuICAgICAgICAgICAgICAgIDEgPT09IG8ubm9kZVR5cGUgJiYgaS5wdXNoKG8pLCBvID0gb1tuXTtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgIH0sIHNpYmxpbmc6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IFtdO1xuICAgICAgICAgICAgZm9yICg7IGU7IGUgPSBlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIDEgPT09IGUubm9kZVR5cGUgJiYgZSAhPT0gdCAmJiBuLnB1c2goZSk7XG4gICAgICAgICAgICByZXR1cm4gblxuICAgICAgICB9fSk7XG4gICAgZnVuY3Rpb24gZnQoZSwgdCwgbikge1xuICAgICAgICBpZiAoeC5pc0Z1bmN0aW9uKHQpKVxuICAgICAgICAgICAgcmV0dXJuIHguZ3JlcChlLCBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgICAgICAgIHJldHVybiEhdC5jYWxsKGUsIHIsIGUpICE9PSBuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHQubm9kZVR5cGUpXG4gICAgICAgICAgICByZXR1cm4geC5ncmVwKGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IHQgIT09IG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgICAgaWYgKHN0LnRlc3QodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHguZmlsdGVyKHQsIGUsIG4pO1xuICAgICAgICAgICAgdCA9IHguZmlsdGVyKHQsIGUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHguZ3JlcChlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHguaW5BcnJheShlLCB0KSA+PSAwICE9PSBuXG4gICAgICAgIH0pXG4gICAgfVxuICAgIGZ1bmN0aW9uIGR0KGUpIHtcbiAgICAgICAgdmFyIHQgPSBodC5zcGxpdChcInxcIiksIG4gPSBlLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgaWYgKG4uY3JlYXRlRWxlbWVudClcbiAgICAgICAgICAgIHdoaWxlICh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBuLmNyZWF0ZUVsZW1lbnQodC5wb3AoKSk7XG4gICAgICAgIHJldHVybiBuXG4gICAgfVxuICAgIHZhciBodCA9IFwiYWJicnxhcnRpY2xlfGFzaWRlfGF1ZGlvfGJkaXxjYW52YXN8ZGF0YXxkYXRhbGlzdHxkZXRhaWxzfGZpZ2NhcHRpb258ZmlndXJlfGZvb3RlcnxoZWFkZXJ8aGdyb3VwfG1hcmt8bWV0ZXJ8bmF2fG91dHB1dHxwcm9ncmVzc3xzZWN0aW9ufHN1bW1hcnl8dGltZXx2aWRlb1wiLCBndCA9IC8galF1ZXJ5XFxkKz1cIig/Om51bGx8XFxkKylcIi9nLCBtdCA9IFJlZ0V4cChcIjwoPzpcIiArIGh0ICsgXCIpW1xcXFxzLz5dXCIsIFwiaVwiKSwgeXQgPSAvXlxccysvLCB2dCA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSwgYnQgPSAvPChbXFx3Ol0rKS8sIHh0ID0gLzx0Ym9keS9pLCB3dCA9IC88fCYjP1xcdys7LywgVHQgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLCBDdCA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLCBOdCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksIGt0ID0gL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSwgRXQgPSAvXnRydWVcXC8oLiopLywgU3QgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csIEF0ID0ge29wdGlvbjogWzEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiXSwgbGVnZW5kOiBbMSwgXCI8ZmllbGRzZXQ+XCIsIFwiPC9maWVsZHNldD5cIl0sIGFyZWE6IFsxLCBcIjxtYXA+XCIsIFwiPC9tYXA+XCJdLCBwYXJhbTogWzEsIFwiPG9iamVjdD5cIiwgXCI8L29iamVjdD5cIl0sIHRoZWFkOiBbMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIl0sIHRyOiBbMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sIGNvbDogWzIsIFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLCB0ZDogWzMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCJdLCBfZGVmYXVsdDogeC5zdXBwb3J0Lmh0bWxTZXJpYWxpemUgPyBbMCwgXCJcIiwgXCJcIl0gOiBbMSwgXCJYPGRpdj5cIiwgXCI8L2Rpdj5cIl19LCBqdCA9IGR0KGEpLCBEdCA9IGp0LmFwcGVuZENoaWxkKGEuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgQXQub3B0Z3JvdXAgPSBBdC5vcHRpb24sIEF0LnRib2R5ID0gQXQudGZvb3QgPSBBdC5jb2xncm91cCA9IEF0LmNhcHRpb24gPSBBdC50aGVhZCwgQXQudGggPSBBdC50ZCwgeC5mbi5leHRlbmQoe3RleHQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA9PT0gdCA/IHgudGV4dCh0aGlzKSA6IHRoaXMuZW1wdHkoKS5hcHBlbmQoKHRoaXNbMF0gJiYgdGhpc1swXS5vd25lckRvY3VtZW50IHx8IGEpLmNyZWF0ZVRleHROb2RlKGUpKVxuICAgICAgICAgICAgfSwgbnVsbCwgZSwgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgfSwgYXBwZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IEx0KHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgICB0LmFwcGVuZENoaWxkKGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgcHJlcGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICgxID09PSB0aGlzLm5vZGVUeXBlIHx8IDExID09PSB0aGlzLm5vZGVUeXBlIHx8IDkgPT09IHRoaXMubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBMdCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgdC5pbnNlcnRCZWZvcmUoZSwgdC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGJlZm9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBhZnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiwgciA9IGUgPyB4LmZpbHRlcihlLCB0aGlzKSA6IHRoaXMsIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IG51bGwgIT0gKG4gPSByW2ldKTsgaSsrKVxuICAgICAgICAgICAgICAgIHQgfHwgMSAhPT0gbi5ub2RlVHlwZSB8fCB4LmNsZWFuRGF0YShGdChuKSksIG4ucGFyZW50Tm9kZSAmJiAodCAmJiB4LmNvbnRhaW5zKG4ub3duZXJEb2N1bWVudCwgbikgJiYgX3QoRnQobiwgXCJzY3JpcHRcIikpLCBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobikpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSwgZW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlLCB0ID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBudWxsICE9IChlID0gdGhpc1t0XSk7IHQrKykge1xuICAgICAgICAgICAgICAgIDEgPT09IGUubm9kZVR5cGUgJiYgeC5jbGVhbkRhdGEoRnQoZSwgITEpKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5vcHRpb25zICYmIHgubm9kZU5hbWUoZSwgXCJzZWxlY3RcIikgJiYgKGUub3B0aW9ucy5sZW5ndGggPSAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gZSA9IG51bGwgPT0gZSA/ICExIDogZSwgdCA9IG51bGwgPT0gdCA/IGUgOiB0LCB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguY2xvbmUodGhpcywgZSwgdClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGh0bWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXNbMF0gfHwge30sIHIgPSAwLCBpID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxID09PSBuLm5vZGVUeXBlID8gbi5pbm5lckhUTUwucmVwbGFjZShndCwgXCJcIikgOiB0O1xuICAgICAgICAgICAgICAgIGlmICghKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgfHwgVHQudGVzdChlKSB8fCAheC5zdXBwb3J0Lmh0bWxTZXJpYWxpemUgJiYgbXQudGVzdChlKSB8fCAheC5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHl0LnRlc3QoZSkgfHwgQXRbKGJ0LmV4ZWMoZSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUucmVwbGFjZSh2dCwgXCI8JDE+PC8kMj5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA+IHI7IHIrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gdGhpc1tyXSB8fCB7fSwgMSA9PT0gbi5ub2RlVHlwZSAmJiAoeC5jbGVhbkRhdGEoRnQobiwgITEpKSwgbi5pbm5lckhUTUwgPSBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAwXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuICYmIHRoaXMuZW1wdHkoKS5hcHBlbmQoZSlcbiAgICAgICAgICAgIH0sIG51bGwsIGUsIGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIH0sIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHgubWFwKHRoaXMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuW2UubmV4dFNpYmxpbmcsIGUucGFyZW50Tm9kZV1cbiAgICAgICAgICAgIH0pLCB0ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGVbdCsrXSwgaSA9IGVbdCsrXTtcbiAgICAgICAgICAgICAgICBpICYmIChyICYmIHIucGFyZW50Tm9kZSAhPT0gaSAmJiAociA9IHRoaXMubmV4dFNpYmxpbmcpLCB4KHRoaXMpLnJlbW92ZSgpLCBpLmluc2VydEJlZm9yZShuLCByKSlcbiAgICAgICAgICAgIH0sICEwKSwgdCA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpXG4gICAgICAgIH0sIGRldGFjaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZShlLCAhMClcbiAgICAgICAgfSwgZG9tTWFuaXA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICBlID0gZC5hcHBseShbXSwgZSk7XG4gICAgICAgICAgICB2YXIgciwgaSwgbywgYSwgcywgbCwgdSA9IDAsIGMgPSB0aGlzLmxlbmd0aCwgcCA9IHRoaXMsIGYgPSBjIC0gMSwgaCA9IGVbMF0sIGcgPSB4LmlzRnVuY3Rpb24oaCk7XG4gICAgICAgICAgICBpZiAoZyB8fCAhKDEgPj0gYyB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBoIHx8IHguc3VwcG9ydC5jaGVja0Nsb25lKSAmJiBOdC50ZXN0KGgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBwLmVxKHIpO1xuICAgICAgICAgICAgICAgICAgICBnICYmIChlWzBdID0gaC5jYWxsKHRoaXMsIHIsIGkuaHRtbCgpKSksIGkuZG9tTWFuaXAoZSwgdCwgbilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjICYmIChsID0geC5idWlsZEZyYWdtZW50KGUsIHRoaXNbMF0ub3duZXJEb2N1bWVudCwgITEsICFuICYmIHRoaXMpLCByID0gbC5maXJzdENoaWxkLCAxID09PSBsLmNoaWxkTm9kZXMubGVuZ3RoICYmIChsID0gciksIHIpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChhID0geC5tYXAoRnQobCwgXCJzY3JpcHRcIiksIEh0KSwgbyA9IGEubGVuZ3RoOyBjID4gdTsgdSsrKVxuICAgICAgICAgICAgICAgICAgICBpID0gbCwgdSAhPT0gZiAmJiAoaSA9IHguY2xvbmUoaSwgITAsICEwKSwgbyAmJiB4Lm1lcmdlKGEsIEZ0KGksIFwic2NyaXB0XCIpKSksIHQuY2FsbCh0aGlzW3VdLCBpLCB1KTtcbiAgICAgICAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChzID0gYVthLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQsIHgubWFwKGEsIHF0KSwgdSA9IDA7IG8gPiB1OyB1KyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gYVt1XSwga3QudGVzdChpLnR5cGUgfHwgXCJcIikgJiYgIXguX2RhdGEoaSwgXCJnbG9iYWxFdmFsXCIpICYmIHguY29udGFpbnMocywgaSkgJiYgKGkuc3JjID8geC5fZXZhbFVybChpLnNyYykgOiB4Lmdsb2JhbEV2YWwoKGkudGV4dCB8fCBpLnRleHRDb250ZW50IHx8IGkuaW5uZXJIVE1MIHx8IFwiXCIpLnJlcGxhY2UoU3QsIFwiXCIpKSk7XG4gICAgICAgICAgICAgICAgbCA9IHIgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9fSk7XG4gICAgZnVuY3Rpb24gTHQoZSwgdCkge1xuICAgICAgICByZXR1cm4geC5ub2RlTmFtZShlLCBcInRhYmxlXCIpICYmIHgubm9kZU5hbWUoMSA9PT0gdC5ub2RlVHlwZSA/IHQgOiB0LmZpcnN0Q2hpbGQsIFwidHJcIikgPyBlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHwgZS5hcHBlbmRDaGlsZChlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKSA6IGVcbiAgICB9XG4gICAgZnVuY3Rpb24gSHQoZSkge1xuICAgICAgICByZXR1cm4gZS50eXBlID0gKG51bGwgIT09IHguZmluZC5hdHRyKGUsIFwidHlwZVwiKSkgKyBcIi9cIiArIGUudHlwZSwgZVxuICAgIH1cbiAgICBmdW5jdGlvbiBxdChlKSB7XG4gICAgICAgIHZhciB0ID0gRXQuZXhlYyhlLnR5cGUpO1xuICAgICAgICByZXR1cm4gdCA/IGUudHlwZSA9IHRbMV0gOiBlLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIiksIGVcbiAgICB9XG4gICAgZnVuY3Rpb24gX3QoZSwgdCkge1xuICAgICAgICB2YXIgbiwgciA9IDA7XG4gICAgICAgIGZvciAoOyBudWxsICE9IChuID0gZVtyXSk7IHIrKylcbiAgICAgICAgICAgIHguX2RhdGEobiwgXCJnbG9iYWxFdmFsXCIsICF0IHx8IHguX2RhdGEodFtyXSwgXCJnbG9iYWxFdmFsXCIpKVxuICAgIH1cbiAgICBmdW5jdGlvbiBNdChlLCB0KSB7XG4gICAgICAgIGlmICgxID09PSB0Lm5vZGVUeXBlICYmIHguaGFzRGF0YShlKSkge1xuICAgICAgICAgICAgdmFyIG4sIHIsIGksIG8gPSB4Ll9kYXRhKGUpLCBhID0geC5fZGF0YSh0LCBvKSwgcyA9IG8uZXZlbnRzO1xuICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYS5oYW5kbGUsIGEuZXZlbnRzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChuIGluIHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAociA9IDAsIGkgPSBzW25dLmxlbmd0aDsgaSA+IHI7IHIrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHguZXZlbnQuYWRkKHQsIG4sIHNbbl1bcl0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLmRhdGEgJiYgKGEuZGF0YSA9IHguZXh0ZW5kKHt9LCBhLmRhdGEpKVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIE90KGUsIHQpIHtcbiAgICAgICAgdmFyIG4sIHIsIGk7XG4gICAgICAgIGlmICgxID09PSB0Lm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBpZiAobiA9IHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgIXguc3VwcG9ydC5ub0Nsb25lRXZlbnQgJiYgdFt4LmV4cGFuZG9dKSB7XG4gICAgICAgICAgICAgICAgaSA9IHguX2RhdGEodCk7XG4gICAgICAgICAgICAgICAgZm9yIChyIGluIGkuZXZlbnRzKVxuICAgICAgICAgICAgICAgICAgICB4LnJlbW92ZUV2ZW50KHQsIHIsIGkuaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB0LnJlbW92ZUF0dHJpYnV0ZSh4LmV4cGFuZG8pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcInNjcmlwdFwiID09PSBuICYmIHQudGV4dCAhPT0gZS50ZXh0ID8gKEh0KHQpLnRleHQgPSBlLnRleHQsIHF0KHQpKSA6IFwib2JqZWN0XCIgPT09IG4gPyAodC5wYXJlbnROb2RlICYmICh0Lm91dGVySFRNTCA9IGUub3V0ZXJIVE1MKSwgeC5zdXBwb3J0Lmh0bWw1Q2xvbmUgJiYgZS5pbm5lckhUTUwgJiYgIXgudHJpbSh0LmlubmVySFRNTCkgJiYgKHQuaW5uZXJIVE1MID0gZS5pbm5lckhUTUwpKSA6IFwiaW5wdXRcIiA9PT0gbiAmJiBDdC50ZXN0KGUudHlwZSkgPyAodC5kZWZhdWx0Q2hlY2tlZCA9IHQuY2hlY2tlZCA9IGUuY2hlY2tlZCwgdC52YWx1ZSAhPT0gZS52YWx1ZSAmJiAodC52YWx1ZSA9IGUudmFsdWUpKSA6IFwib3B0aW9uXCIgPT09IG4gPyB0LmRlZmF1bHRTZWxlY3RlZCA9IHQuc2VsZWN0ZWQgPSBlLmRlZmF1bHRTZWxlY3RlZCA6IChcImlucHV0XCIgPT09IG4gfHwgXCJ0ZXh0YXJlYVwiID09PSBuKSAmJiAodC5kZWZhdWx0VmFsdWUgPSBlLmRlZmF1bHRWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cbiAgICB4LmVhY2goe2FwcGVuZFRvOiBcImFwcGVuZFwiLCBwcmVwZW5kVG86IFwicHJlcGVuZFwiLCBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsIGluc2VydEFmdGVyOiBcImFmdGVyXCIsIHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIn0sIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHguZm5bZV0gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIG4sIHIgPSAwLCBpID0gW10sIG8gPSB4KGUpLCBhID0gby5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm9yICg7IGEgPj0gcjsgcisrKVxuICAgICAgICAgICAgICAgIG4gPSByID09PSBhID8gdGhpcyA6IHRoaXMuY2xvbmUoITApLCB4KG9bcl0pW3RdKG4pLCBoLmFwcGx5KGksIG4uZ2V0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGkpXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBGdChlLCBuKSB7XG4gICAgICAgIHZhciByLCBvLCBhID0gMCwgcyA9IHR5cGVvZiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBpID8gZS5nZXRFbGVtZW50c0J5VGFnTmFtZShuIHx8IFwiKlwiKSA6IHR5cGVvZiBlLnF1ZXJ5U2VsZWN0b3JBbGwgIT09IGkgPyBlLnF1ZXJ5U2VsZWN0b3JBbGwobiB8fCBcIipcIikgOiB0O1xuICAgICAgICBpZiAoIXMpXG4gICAgICAgICAgICBmb3IgKHMgPSBbXSwgciA9IGUuY2hpbGROb2RlcyB8fCBlOyBudWxsICE9IChvID0gclthXSk7IGErKylcbiAgICAgICAgICAgICAgICAhbiB8fCB4Lm5vZGVOYW1lKG8sIG4pID8gcy5wdXNoKG8pIDogeC5tZXJnZShzLCBGdChvLCBuKSk7XG4gICAgICAgIHJldHVybiBuID09PSB0IHx8IG4gJiYgeC5ub2RlTmFtZShlLCBuKSA/IHgubWVyZ2UoW2VdLCBzKSA6IHNcbiAgICB9XG4gICAgZnVuY3Rpb24gQnQoZSkge1xuICAgICAgICBDdC50ZXN0KGUudHlwZSkgJiYgKGUuZGVmYXVsdENoZWNrZWQgPSBlLmNoZWNrZWQpXG4gICAgfVxuICAgIHguZXh0ZW5kKHtjbG9uZTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHZhciByLCBpLCBvLCBhLCBzLCBsID0geC5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsIGUpO1xuICAgICAgICAgICAgaWYgKHguc3VwcG9ydC5odG1sNUNsb25lIHx8IHguaXNYTUxEb2MoZSkgfHwgIW10LnRlc3QoXCI8XCIgKyBlLm5vZGVOYW1lICsgXCI+XCIpID8gbyA9IGUuY2xvbmVOb2RlKCEwKSA6IChEdC5pbm5lckhUTUwgPSBlLm91dGVySFRNTCwgRHQucmVtb3ZlQ2hpbGQobyA9IER0LmZpcnN0Q2hpbGQpKSwgISh4LnN1cHBvcnQubm9DbG9uZUV2ZW50ICYmIHguc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCB8fCAxICE9PSBlLm5vZGVUeXBlICYmIDExICE9PSBlLm5vZGVUeXBlIHx8IHguaXNYTUxEb2MoZSkpKVxuICAgICAgICAgICAgICAgIGZvciAociA9IEZ0KG8pLCBzID0gRnQoZSksIGEgPSAwOyBudWxsICE9IChpID0gc1thXSk7ICsrYSlcbiAgICAgICAgICAgICAgICAgICAgclthXSAmJiBPdChpLCByW2FdKTtcbiAgICAgICAgICAgIGlmICh0KVxuICAgICAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHMgPSBzIHx8IEZ0KGUpLCByID0gciB8fCBGdChvKSwgYSA9IDA7IG51bGwgIT0gKGkgPSBzW2FdKTsgYSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgTXQoaSwgclthXSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBNdChlLCBvKTtcbiAgICAgICAgICAgIHJldHVybiByID0gRnQobywgXCJzY3JpcHRcIiksIHIubGVuZ3RoID4gMCAmJiBfdChyLCAhbCAmJiBGdChlLCBcInNjcmlwdFwiKSksIHIgPSBzID0gaSA9IG51bGwsIG9cbiAgICAgICAgfSwgYnVpbGRGcmFnbWVudDogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgIHZhciBpLCBvLCBhLCBzLCBsLCB1LCBjLCBwID0gZS5sZW5ndGgsIGYgPSBkdCh0KSwgZCA9IFtdLCBoID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBwID4gaDsgaCsrKVxuICAgICAgICAgICAgICAgIGlmIChvID0gZVtoXSwgbyB8fCAwID09PSBvKVxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0geC50eXBlKG8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgeC5tZXJnZShkLCBvLm5vZGVUeXBlID8gW29dIDogbyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHd0LnRlc3QobykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzIHx8IGYuYXBwZW5kQ2hpbGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwgbCA9IChidC5leGVjKG8pIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSwgYyA9IEF0W2xdIHx8IEF0Ll9kZWZhdWx0LCBzLmlubmVySFRNTCA9IGNbMV0gKyBvLnJlcGxhY2UodnQsIFwiPCQxPjwvJDI+XCIpICsgY1syXSwgaSA9IGNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgheC5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHl0LnRlc3QobykgJiYgZC5wdXNoKHQuY3JlYXRlVGV4dE5vZGUoeXQuZXhlYyhvKVswXSkpLCAheC5zdXBwb3J0LnRib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IFwidGFibGVcIiAhPT0gbCB8fCB4dC50ZXN0KG8pID8gXCI8dGFibGU+XCIgIT09IGNbMV0gfHwgeHQudGVzdChvKSA/IDAgOiBzIDogcy5maXJzdENoaWxkLCBpID0gbyAmJiBvLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgubm9kZU5hbWUodSA9IG8uY2hpbGROb2Rlc1tpXSwgXCJ0Ym9keVwiKSAmJiAhdS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBvLnJlbW92ZUNoaWxkKHUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4Lm1lcmdlKGQsIHMuY2hpbGROb2RlcyksIHMudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHMuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnJlbW92ZUNoaWxkKHMuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gZi5sYXN0Q2hpbGRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnB1c2godC5jcmVhdGVUZXh0Tm9kZShvKSk7XG4gICAgICAgICAgICBzICYmIGYucmVtb3ZlQ2hpbGQocyksIHguc3VwcG9ydC5hcHBlbmRDaGVja2VkIHx8IHguZ3JlcChGdChkLCBcImlucHV0XCIpLCBCdCksIGggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG8gPSBkW2grK10pXG4gICAgICAgICAgICAgICAgaWYgKCghciB8fCAtMSA9PT0geC5pbkFycmF5KG8sIHIpKSAmJiAoYSA9IHguY29udGFpbnMoby5vd25lckRvY3VtZW50LCBvKSwgcyA9IEZ0KGYuYXBwZW5kQ2hpbGQobyksIFwic2NyaXB0XCIpLCBhICYmIF90KHMpLCBuKSkge1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG8gPSBzW2krK10pXG4gICAgICAgICAgICAgICAgICAgICAgICBrdC50ZXN0KG8udHlwZSB8fCBcIlwiKSAmJiBuLnB1c2gobylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcyA9IG51bGwsIGZcbiAgICAgICAgfSwgY2xlYW5EYXRhOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4sIHIsIG8sIGEsIHMgPSAwLCBsID0geC5leHBhbmRvLCB1ID0geC5jYWNoZSwgYyA9IHguc3VwcG9ydC5kZWxldGVFeHBhbmRvLCBmID0geC5ldmVudC5zcGVjaWFsO1xuICAgICAgICAgICAgZm9yICg7IG51bGwgIT0gKG4gPSBlW3NdKTsgcysrKVxuICAgICAgICAgICAgICAgIGlmICgodCB8fCB4LmFjY2VwdERhdGEobikpICYmIChvID0gbltsXSwgYSA9IG8gJiYgdVtvXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEuZXZlbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChyIGluIGEuZXZlbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZbcl0gPyB4LmV2ZW50LnJlbW92ZShuLCByKSA6IHgucmVtb3ZlRXZlbnQobiwgciwgYS5oYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICB1W29dICYmIChkZWxldGUgdVtvXSwgYyA/IGRlbGV0ZSBuW2xdIDogdHlwZW9mIG4ucmVtb3ZlQXR0cmlidXRlICE9PSBpID8gbi5yZW1vdmVBdHRyaWJ1dGUobCkgOiBuW2xdID0gbnVsbCwgcC5wdXNoKG8pKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSwgX2V2YWxVcmw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hamF4KHt1cmw6IGUsIHR5cGU6IFwiR0VUXCIsIGRhdGFUeXBlOiBcInNjcmlwdFwiLCBhc3luYzogITEsIGdsb2JhbDogITEsIFwidGhyb3dzXCI6ICEwfSlcbiAgICAgICAgfX0pLCB4LmZuLmV4dGVuZCh7d3JhcEFsbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh4LmlzRnVuY3Rpb24oZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB4KHRoaXMpLndyYXBBbGwoZS5jYWxsKHRoaXMsIHQpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHgoZSwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCk7XG4gICAgICAgICAgICAgICAgdGhpc1swXS5wYXJlbnROb2RlICYmIHQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLCB0Lm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGUuZmlyc3RDaGlsZCAmJiAxID09PSBlLmZpcnN0Q2hpbGQubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgIH0pLmFwcGVuZCh0aGlzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSwgd3JhcElubmVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHguaXNGdW5jdGlvbihlKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHgodGhpcykud3JhcElubmVyKGUuY2FsbCh0aGlzLCB0KSlcbiAgICAgICAgICAgIH0pIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHgodGhpcyksIG4gPSB0LmNvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgbi5sZW5ndGggPyBuLndyYXBBbGwoZSkgOiB0LmFwcGVuZChlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgd3JhcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0geC5pc0Z1bmN0aW9uKGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHgodGhpcykud3JhcEFsbCh0ID8gZS5jYWxsKHRoaXMsIG4pIDogZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHVud3JhcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeC5ub2RlTmFtZSh0aGlzLCBcImJvZHlcIikgfHwgeCh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpXG4gICAgICAgICAgICB9KS5lbmQoKVxuICAgICAgICB9fSk7XG4gICAgdmFyIFB0LCBSdCwgV3QsICR0ID0gL2FscGhhXFwoW14pXSpcXCkvaSwgSXQgPSAvb3BhY2l0eVxccyo9XFxzKihbXildKikvLCB6dCA9IC9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkLywgWHQgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sIFV0ID0gL15tYXJnaW4vLCBWdCA9IFJlZ0V4cChcIl4oXCIgKyB3ICsgXCIpKC4qKSRcIiwgXCJpXCIpLCBZdCA9IFJlZ0V4cChcIl4oXCIgKyB3ICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpLCBKdCA9IFJlZ0V4cChcIl4oWystXSk9KFwiICsgdyArIFwiKVwiLCBcImlcIiksIEd0ID0ge0JPRFk6IFwiYmxvY2tcIn0sIFF0ID0ge3Bvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIn0sIEt0ID0ge2xldHRlclNwYWNpbmc6IDAsIGZvbnRXZWlnaHQ6IDQwMH0sIFp0ID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdLCBlbiA9IFtcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiXTtcbiAgICBmdW5jdGlvbiB0bihlLCB0KSB7XG4gICAgICAgIGlmICh0IGluIGUpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgdmFyIG4gPSB0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdC5zbGljZSgxKSwgciA9IHQsIGkgPSBlbi5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICBpZiAodCA9IGVuW2ldICsgbiwgdCBpbiBlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICByZXR1cm4gclxuICAgIH1cbiAgICBmdW5jdGlvbiBubihlLCB0KSB7XG4gICAgICAgIHJldHVybiBlID0gdCB8fCBlLCBcIm5vbmVcIiA9PT0geC5jc3MoZSwgXCJkaXNwbGF5XCIpIHx8ICF4LmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCwgZSlcbiAgICB9XG4gICAgZnVuY3Rpb24gcm4oZSwgdCkge1xuICAgICAgICB2YXIgbiwgciwgaSwgbyA9IFtdLCBhID0gMCwgcyA9IGUubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgcyA+IGE7IGErKylcbiAgICAgICAgICAgIHIgPSBlW2FdLCByLnN0eWxlICYmIChvW2FdID0geC5fZGF0YShyLCBcIm9sZGRpc3BsYXlcIiksIG4gPSByLnN0eWxlLmRpc3BsYXksIHQgPyAob1thXSB8fCBcIm5vbmVcIiAhPT0gbiB8fCAoci5zdHlsZS5kaXNwbGF5ID0gXCJcIiksIFwiXCIgPT09IHIuc3R5bGUuZGlzcGxheSAmJiBubihyKSAmJiAob1thXSA9IHguX2RhdGEociwgXCJvbGRkaXNwbGF5XCIsIGxuKHIubm9kZU5hbWUpKSkpIDogb1thXSB8fCAoaSA9IG5uKHIpLCAobiAmJiBcIm5vbmVcIiAhPT0gbiB8fCAhaSkgJiYgeC5fZGF0YShyLCBcIm9sZGRpc3BsYXlcIiwgaSA/IG4gOiB4LmNzcyhyLCBcImRpc3BsYXlcIikpKSk7XG4gICAgICAgIGZvciAoYSA9IDA7IHMgPiBhOyBhKyspXG4gICAgICAgICAgICByID0gZVthXSwgci5zdHlsZSAmJiAodCAmJiBcIm5vbmVcIiAhPT0gci5zdHlsZS5kaXNwbGF5ICYmIFwiXCIgIT09IHIuc3R5bGUuZGlzcGxheSB8fCAoci5zdHlsZS5kaXNwbGF5ID0gdCA/IG9bYV0gfHwgXCJcIiA6IFwibm9uZVwiKSk7XG4gICAgICAgIHJldHVybiBlXG4gICAgfVxuICAgIHguZm4uZXh0ZW5kKHtjc3M6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbywgYSA9IHt9LCBzID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoeC5pc0FycmF5KG4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobyA9IFJ0KGUpLCBpID0gbi5sZW5ndGg7IGkgPiBzOyBzKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBhW25bc11dID0geC5jc3MoZSwgbltzXSwgITEsIG8pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gciAhPT0gdCA/IHguc3R5bGUoZSwgbiwgcikgOiB4LmNzcyhlLCBuKVxuICAgICAgICAgICAgfSwgZSwgbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICAgIH0sIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBybih0aGlzLCAhMClcbiAgICAgICAgfSwgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJuKHRoaXMpXG4gICAgICAgIH0sIHRvZ2dsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVyblwiYm9vbGVhblwiID09IHR5cGVvZiBlID8gZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5uKHRoaXMpID8geCh0aGlzKS5zaG93KCkgOiB4KHRoaXMpLmhpZGUoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfX0pLCB4LmV4dGVuZCh7Y3NzSG9va3M6IHtvcGFjaXR5OiB7Z2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBXdChlLCBcIm9wYWNpdHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cIlwiID09PSBuID8gXCIxXCIgOiBuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fX0sIGNzc051bWJlcjoge2NvbHVtbkNvdW50OiAhMCwgZmlsbE9wYWNpdHk6ICEwLCBmb250V2VpZ2h0OiAhMCwgbGluZUhlaWdodDogITAsIG9wYWNpdHk6ICEwLCBvcmRlcjogITAsIG9ycGhhbnM6ICEwLCB3aWRvd3M6ICEwLCB6SW5kZXg6ICEwLCB6b29tOiAhMH0sIGNzc1Byb3BzOiB7XCJmbG9hdFwiOiB4LnN1cHBvcnQuY3NzRmxvYXQgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIn0sIHN0eWxlOiBmdW5jdGlvbiAoZSwgbiwgciwgaSkge1xuICAgICAgICAgICAgaWYgKGUgJiYgMyAhPT0gZS5ub2RlVHlwZSAmJiA4ICE9PSBlLm5vZGVUeXBlICYmIGUuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbywgYSwgcywgbCA9IHguY2FtZWxDYXNlKG4pLCB1ID0gZS5zdHlsZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9IHguY3NzUHJvcHNbbF0gfHwgKHguY3NzUHJvcHNbbF0gPSB0bih1LCBsKSksIHMgPSB4LmNzc0hvb2tzW25dIHx8IHguY3NzSG9va3NbbF0sIHIgPT09IHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzICYmIFwiZ2V0XCJpbiBzICYmIChvID0gcy5nZXQoZSwgITEsIGkpKSAhPT0gdCA/IG8gOiB1W25dO1xuICAgICAgICAgICAgICAgIGlmIChhID0gdHlwZW9mIHIsIFwic3RyaW5nXCIgPT09IGEgJiYgKG8gPSBKdC5leGVjKHIpKSAmJiAociA9IChvWzFdICsgMSkgKiBvWzJdICsgcGFyc2VGbG9hdCh4LmNzcyhlLCBuKSksIGEgPSBcIm51bWJlclwiKSwgIShudWxsID09IHIgfHwgXCJudW1iZXJcIiA9PT0gYSAmJiBpc05hTihyKSB8fCAoXCJudW1iZXJcIiAhPT0gYSB8fCB4LmNzc051bWJlcltsXSB8fCAociArPSBcInB4XCIpLCB4LnN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlIHx8IFwiXCIgIT09IHIgfHwgMCAhPT0gbi5pbmRleE9mKFwiYmFja2dyb3VuZFwiKSB8fCAodVtuXSA9IFwiaW5oZXJpdFwiKSwgcyAmJiBcInNldFwiaW4gcyAmJiAociA9IHMuc2V0KGUsIHIsIGkpKSA9PT0gdCkpKVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdVtuXSA9IHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNzczogZnVuY3Rpb24gKGUsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgIHZhciBvLCBhLCBzLCBsID0geC5jYW1lbENhc2Uobik7XG4gICAgICAgICAgICByZXR1cm4gbiA9IHguY3NzUHJvcHNbbF0gfHwgKHguY3NzUHJvcHNbbF0gPSB0bihlLnN0eWxlLCBsKSksIHMgPSB4LmNzc0hvb2tzW25dIHx8IHguY3NzSG9va3NbbF0sIHMgJiYgXCJnZXRcImluIHMgJiYgKGEgPSBzLmdldChlLCAhMCwgcikpLCBhID09PSB0ICYmIChhID0gV3QoZSwgbiwgaSkpLCBcIm5vcm1hbFwiID09PSBhICYmIG4gaW4gS3QgJiYgKGEgPSBLdFtuXSksIFwiXCIgPT09IHIgfHwgciA/IChvID0gcGFyc2VGbG9hdChhKSwgciA9PT0gITAgfHwgeC5pc051bWVyaWMobykgPyBvIHx8IDAgOiBhKSA6IGFcbiAgICAgICAgfX0pLCBlLmdldENvbXB1dGVkU3R5bGUgPyAoUnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gZS5nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpXG4gICAgfSwgV3QgPSBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICB2YXIgaSwgbywgYSwgcyA9IHIgfHwgUnQoZSksIGwgPSBzID8gcy5nZXRQcm9wZXJ0eVZhbHVlKG4pIHx8IHNbbl0gOiB0LCB1ID0gZS5zdHlsZTtcbiAgICAgICAgcmV0dXJuIHMgJiYgKFwiXCIgIT09IGwgfHwgeC5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsIGUpIHx8IChsID0geC5zdHlsZShlLCBuKSksIFl0LnRlc3QobCkgJiYgVXQudGVzdChuKSAmJiAoaSA9IHUud2lkdGgsIG8gPSB1Lm1pbldpZHRoLCBhID0gdS5tYXhXaWR0aCwgdS5taW5XaWR0aCA9IHUubWF4V2lkdGggPSB1LndpZHRoID0gbCwgbCA9IHMud2lkdGgsIHUud2lkdGggPSBpLCB1Lm1pbldpZHRoID0gbywgdS5tYXhXaWR0aCA9IGEpKSwgbFxuICAgIH0pIDogYS5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlICYmIChSdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmN1cnJlbnRTdHlsZVxuICAgIH0sIFd0ID0gZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgdmFyIGksIG8sIGEsIHMgPSByIHx8IFJ0KGUpLCBsID0gcyA/IHNbbl0gOiB0LCB1ID0gZS5zdHlsZTtcbiAgICAgICAgcmV0dXJuIG51bGwgPT0gbCAmJiB1ICYmIHVbbl0gJiYgKGwgPSB1W25dKSwgWXQudGVzdChsKSAmJiAhenQudGVzdChuKSAmJiAoaSA9IHUubGVmdCwgbyA9IGUucnVudGltZVN0eWxlLCBhID0gbyAmJiBvLmxlZnQsIGEgJiYgKG8ubGVmdCA9IGUuY3VycmVudFN0eWxlLmxlZnQpLCB1LmxlZnQgPSBcImZvbnRTaXplXCIgPT09IG4gPyBcIjFlbVwiIDogbCwgbCA9IHUucGl4ZWxMZWZ0ICsgXCJweFwiLCB1LmxlZnQgPSBpLCBhICYmIChvLmxlZnQgPSBhKSksIFwiXCIgPT09IGwgPyBcImF1dG9cIiA6IGxcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBvbihlLCB0LCBuKSB7XG4gICAgICAgIHZhciByID0gVnQuZXhlYyh0KTtcbiAgICAgICAgcmV0dXJuIHIgPyBNYXRoLm1heCgwLCByWzFdIC0gKG4gfHwgMCkpICsgKHJbMl0gfHwgXCJweFwiKSA6IHRcbiAgICB9XG4gICAgZnVuY3Rpb24gYW4oZSwgdCwgbiwgciwgaSkge1xuICAgICAgICB2YXIgbyA9IG4gPT09IChyID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSA/IDQgOiBcIndpZHRoXCIgPT09IHQgPyAxIDogMCwgYSA9IDA7XG4gICAgICAgIGZvciAoOyA0ID4gbzsgbyArPSAyKVxuICAgICAgICAgICAgXCJtYXJnaW5cIiA9PT0gbiAmJiAoYSArPSB4LmNzcyhlLCBuICsgWnRbb10sICEwLCBpKSksIHIgPyAoXCJjb250ZW50XCIgPT09IG4gJiYgKGEgLT0geC5jc3MoZSwgXCJwYWRkaW5nXCIgKyBadFtvXSwgITAsIGkpKSwgXCJtYXJnaW5cIiAhPT0gbiAmJiAoYSAtPSB4LmNzcyhlLCBcImJvcmRlclwiICsgWnRbb10gKyBcIldpZHRoXCIsICEwLCBpKSkpIDogKGEgKz0geC5jc3MoZSwgXCJwYWRkaW5nXCIgKyBadFtvXSwgITAsIGkpLCBcInBhZGRpbmdcIiAhPT0gbiAmJiAoYSArPSB4LmNzcyhlLCBcImJvcmRlclwiICsgWnRbb10gKyBcIldpZHRoXCIsICEwLCBpKSkpO1xuICAgICAgICByZXR1cm4gYVxuICAgIH1cbiAgICBmdW5jdGlvbiBzbihlLCB0LCBuKSB7XG4gICAgICAgIHZhciByID0gITAsIGkgPSBcIndpZHRoXCIgPT09IHQgPyBlLm9mZnNldFdpZHRoIDogZS5vZmZzZXRIZWlnaHQsIG8gPSBSdChlKSwgYSA9IHguc3VwcG9ydC5ib3hTaXppbmcgJiYgXCJib3JkZXItYm94XCIgPT09IHguY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCBvKTtcbiAgICAgICAgaWYgKDAgPj0gaSB8fCBudWxsID09IGkpIHtcbiAgICAgICAgICAgIGlmIChpID0gV3QoZSwgdCwgbyksICgwID4gaSB8fCBudWxsID09IGkpICYmIChpID0gZS5zdHlsZVt0XSksIFl0LnRlc3QoaSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICByID0gYSAmJiAoeC5zdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlIHx8IGkgPT09IGUuc3R5bGVbdF0pLCBpID0gcGFyc2VGbG9hdChpKSB8fCAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGkgKyBhbihlLCB0LCBuIHx8IChhID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSwgciwgbykgKyBcInB4XCJcbiAgICB9XG4gICAgZnVuY3Rpb24gbG4oZSkge1xuICAgICAgICB2YXIgdCA9IGEsIG4gPSBHdFtlXTtcbiAgICAgICAgcmV0dXJuIG4gfHwgKG4gPSB1bihlLCB0KSwgXCJub25lXCIgIT09IG4gJiYgbiB8fCAoUHQgPSAoUHQgfHwgeChcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIikuY3NzKFwiY3NzVGV4dFwiLCBcImRpc3BsYXk6YmxvY2sgIWltcG9ydGFudFwiKSkuYXBwZW5kVG8odC5kb2N1bWVudEVsZW1lbnQpLCB0ID0gKFB0WzBdLmNvbnRlbnRXaW5kb3cgfHwgUHRbMF0uY29udGVudERvY3VtZW50KS5kb2N1bWVudCwgdC53cml0ZShcIjwhZG9jdHlwZSBodG1sPjxodG1sPjxib2R5PlwiKSwgdC5jbG9zZSgpLCBuID0gdW4oZSwgdCksIFB0LmRldGFjaCgpKSwgR3RbZV0gPSBuKSwgblxuICAgIH1cbiAgICBmdW5jdGlvbiB1bihlLCB0KSB7XG4gICAgICAgIHZhciBuID0geCh0LmNyZWF0ZUVsZW1lbnQoZSkpLmFwcGVuZFRvKHQuYm9keSksIHIgPSB4LmNzcyhuWzBdLCBcImRpc3BsYXlcIik7XG4gICAgICAgIHJldHVybiBuLnJlbW92ZSgpLCByXG4gICAgfVxuICAgIHguZWFjaChbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXSwgZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgeC5jc3NIb29rc1tuXSA9IHtnZXQ6IGZ1bmN0aW9uIChlLCByLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgPyAwID09PSBlLm9mZnNldFdpZHRoICYmIFh0LnRlc3QoeC5jc3MoZSwgXCJkaXNwbGF5XCIpKSA/IHguc3dhcChlLCBRdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc24oZSwgbiwgaSlcbiAgICAgICAgICAgICAgICB9KSA6IHNuKGUsIG4sIGkpIDogdFxuICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgICAgICAgICAgIHZhciBpID0gciAmJiBSdChlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb24oZSwgdCwgciA/IGFuKGUsIG4sIHIsIHguc3VwcG9ydC5ib3hTaXppbmcgJiYgXCJib3JkZXItYm94XCIgPT09IHguY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCBpKSwgaSkgOiAwKVxuICAgICAgICAgICAgfX1cbiAgICB9KSwgeC5zdXBwb3J0Lm9wYWNpdHkgfHwgKHguY3NzSG9va3Mub3BhY2l0eSA9IHtnZXQ6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gSXQudGVzdCgodCAmJiBlLmN1cnJlbnRTdHlsZSA/IGUuY3VycmVudFN0eWxlLmZpbHRlciA6IGUuc3R5bGUuZmlsdGVyKSB8fCBcIlwiKSA/IC4wMSAqIHBhcnNlRmxvYXQoUmVnRXhwLiQxKSArIFwiXCIgOiB0ID8gXCIxXCIgOiBcIlwiXG4gICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gZS5zdHlsZSwgciA9IGUuY3VycmVudFN0eWxlLCBpID0geC5pc051bWVyaWModCkgPyBcImFscGhhKG9wYWNpdHk9XCIgKyAxMDAgKiB0ICsgXCIpXCIgOiBcIlwiLCBvID0gciAmJiByLmZpbHRlciB8fCBuLmZpbHRlciB8fCBcIlwiO1xuICAgICAgICAgICAgbi56b29tID0gMSwgKHQgPj0gMSB8fCBcIlwiID09PSB0KSAmJiBcIlwiID09PSB4LnRyaW0oby5yZXBsYWNlKCR0LCBcIlwiKSkgJiYgbi5yZW1vdmVBdHRyaWJ1dGUgJiYgKG4ucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpLCBcIlwiID09PSB0IHx8IHIgJiYgIXIuZmlsdGVyKSB8fCAobi5maWx0ZXIgPSAkdC50ZXN0KG8pID8gby5yZXBsYWNlKCR0LCBpKSA6IG8gKyBcIiBcIiArIGkpXG4gICAgICAgIH19KSwgeChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHguc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0IHx8ICh4LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0ge2dldDogZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbiA/IHguc3dhcChlLCB7ZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIn0sIFd0LCBbZSwgXCJtYXJnaW5SaWdodFwiXSkgOiB0XG4gICAgICAgICAgICB9fSksICF4LnN1cHBvcnQucGl4ZWxQb3NpdGlvbiAmJiB4LmZuLnBvc2l0aW9uICYmIHguZWFjaChbXCJ0b3BcIiwgXCJsZWZ0XCJdLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgeC5jc3NIb29rc1tuXSA9IHtnZXQ6IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByID8gKHIgPSBXdChlLCBuKSwgWXQudGVzdChyKSA/IHgoZSkucG9zaXRpb24oKVtuXSArIFwicHhcIiA6IHIpIDogdFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgIH0pXG4gICAgfSksIHguZXhwciAmJiB4LmV4cHIuZmlsdGVycyAmJiAoeC5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIDAgPj0gZS5vZmZzZXRXaWR0aCAmJiAwID49IGUub2Zmc2V0SGVpZ2h0IHx8ICF4LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzICYmIFwibm9uZVwiID09PSAoZS5zdHlsZSAmJiBlLnN0eWxlLmRpc3BsYXkgfHwgeC5jc3MoZSwgXCJkaXNwbGF5XCIpKVxuICAgIH0sIHguZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4heC5leHByLmZpbHRlcnMuaGlkZGVuKGUpXG4gICAgfSksIHguZWFjaCh7bWFyZ2luOiBcIlwiLCBwYWRkaW5nOiBcIlwiLCBib3JkZXI6IFwiV2lkdGhcIn0sIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHguY3NzSG9va3NbZSArIHRdID0ge2V4cGFuZDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IDAsIGkgPSB7fSwgbyA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gPyBuLnNwbGl0KFwiIFwiKSA6IFtuXTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgNCA+IHI7IHIrKylcbiAgICAgICAgICAgICAgICAgICAgaVtlICsgWnRbcl0gKyB0XSA9IG9bcl0gfHwgb1tyIC0gMl0gfHwgb1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgfX0sIFV0LnRlc3QoZSkgfHwgKHguY3NzSG9va3NbZSArIHRdLnNldCA9IG9uKVxuICAgIH0pO1xuICAgIHZhciBjbiA9IC8lMjAvZywgcG4gPSAvXFxbXFxdJC8sIGZuID0gL1xccj9cXG4vZywgZG4gPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksIGhuID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuICAgIHguZm4uZXh0ZW5kKHtzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4LnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSlcbiAgICAgICAgfSwgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB4LnByb3AodGhpcywgXCJlbGVtZW50c1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA/IHgubWFrZUFycmF5KGUpIDogdGhpc1xuICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMudHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICYmICF4KHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpICYmIGhuLnRlc3QodGhpcy5ub2RlTmFtZSkgJiYgIWRuLnRlc3QoZSkgJiYgKHRoaXMuY2hlY2tlZCB8fCAhQ3QudGVzdChlKSlcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0geCh0aGlzKS52YWwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBuID8gbnVsbCA6IHguaXNBcnJheShuKSA/IHgubWFwKG4sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybntuYW1lOiB0Lm5hbWUsIHZhbHVlOiBlLnJlcGxhY2UoZm4sIFwiXFxyXFxuXCIpfVxuICAgICAgICAgICAgICAgIH0pIDoge25hbWU6IHQubmFtZSwgdmFsdWU6IG4ucmVwbGFjZShmbiwgXCJcXHJcXG5cIil9XG4gICAgICAgICAgICB9KS5nZXQoKVxuICAgICAgICB9fSksIHgucGFyYW0gPSBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICB2YXIgciwgaSA9IFtdLCBvID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHQgPSB4LmlzRnVuY3Rpb24odCkgPyB0KCkgOiBudWxsID09IHQgPyBcIlwiIDogdCwgaVtpLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoZSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh0KVxuICAgICAgICB9O1xuICAgICAgICBpZiAobiA9PT0gdCAmJiAobiA9IHguYWpheFNldHRpbmdzICYmIHguYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKSwgeC5pc0FycmF5KGUpIHx8IGUuanF1ZXJ5ICYmICF4LmlzUGxhaW5PYmplY3QoZSkpXG4gICAgICAgICAgICB4LmVhY2goZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG8odGhpcy5uYW1lLCB0aGlzLnZhbHVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAociBpbiBlKVxuICAgICAgICAgICAgICAgIGduKHIsIGVbcl0sIG4sIG8pO1xuICAgICAgICByZXR1cm4gaS5qb2luKFwiJlwiKS5yZXBsYWNlKGNuLCBcIitcIilcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGduKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmICh4LmlzQXJyYXkodCkpXG4gICAgICAgICAgICB4LmVhY2godCwgZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICAgICAgICBuIHx8IHBuLnRlc3QoZSkgPyByKGUsIGkpIDogZ24oZSArIFwiW1wiICsgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGkgPyB0IDogXCJcIikgKyBcIl1cIiwgaSwgbiwgcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBlbHNlIGlmIChuIHx8IFwib2JqZWN0XCIgIT09IHgudHlwZSh0KSlcbiAgICAgICAgICAgIHIoZSwgdCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAoaSBpbiB0KVxuICAgICAgICAgICAgICAgIGduKGUgKyBcIltcIiArIGkgKyBcIl1cIiwgdFtpXSwgbiwgcilcbiAgICB9XG4gICAgeC5lYWNoKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgeC5mblt0XSA9IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKHQsIG51bGwsIGUsIG4pIDogdGhpcy50cmlnZ2VyKHQpXG4gICAgICAgIH1cbiAgICB9KSwgeC5mbi5leHRlbmQoe2hvdmVyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW91c2VlbnRlcihlKS5tb3VzZWxlYXZlKHQgfHwgZSlcbiAgICAgICAgfSwgYmluZDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKGUsIG51bGwsIHQsIG4pXG4gICAgICAgIH0sIHVuYmluZDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZihlLCBudWxsLCB0KVxuICAgICAgICB9LCBkZWxlZ2F0ZTogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKHQsIGUsIG4sIHIpXG4gICAgICAgIH0sIHVuZGVsZWdhdGU6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMub2ZmKGUsIFwiKipcIikgOiB0aGlzLm9mZih0LCBlIHx8IFwiKipcIiwgbilcbiAgICAgICAgfX0pO1xuICAgIHZhciBtbiwgeW4sIHZuID0geC5ub3coKSwgYm4gPSAvXFw/LywgeG4gPSAvIy4qJC8sIHduID0gLyhbPyZdKV89W14mXSovLCBUbiA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKVxccj8kL2dtLCBDbiA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLCBObiA9IC9eKD86R0VUfEhFQUQpJC8sIGtuID0gL15cXC9cXC8vLCBFbiA9IC9eKFtcXHcuKy1dKzopKD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLCBTbiA9IHguZm4ubG9hZCwgQW4gPSB7fSwgam4gPSB7fSwgRG4gPSBcIiovXCIuY29uY2F0KFwiKlwiKTtcbiAgICB0cnkge1xuICAgICAgICB5biA9IG8uaHJlZlxuICAgIH0gY2F0Y2ggKExuKSB7XG4gICAgICAgIHluID0gYS5jcmVhdGVFbGVtZW50KFwiYVwiKSwgeW4uaHJlZiA9IFwiXCIsIHluID0geW4uaHJlZlxuICAgIH1cbiAgICBtbiA9IEVuLmV4ZWMoeW4udG9Mb3dlckNhc2UoKSkgfHwgW107XG4gICAgZnVuY3Rpb24gSG4oZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT0gdHlwZW9mIHQgJiYgKG4gPSB0LCB0ID0gXCIqXCIpO1xuICAgICAgICAgICAgdmFyIHIsIGkgPSAwLCBvID0gdC50b0xvd2VyQ2FzZSgpLm1hdGNoKFQpIHx8IFtdO1xuICAgICAgICAgICAgaWYgKHguaXNGdW5jdGlvbihuKSlcbiAgICAgICAgICAgICAgICB3aGlsZSAociA9IG9baSsrXSlcbiAgICAgICAgICAgICAgICAgICAgXCIrXCIgPT09IHJbMF0gPyAociA9IHIuc2xpY2UoMSkgfHwgXCIqXCIsIChlW3JdID0gZVtyXSB8fCBbXSkudW5zaGlmdChuKSkgOiAoZVtyXSA9IGVbcl0gfHwgW10pLnB1c2gobilcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBxbihlLCBuLCByLCBpKSB7XG4gICAgICAgIHZhciBvID0ge30sIGEgPSBlID09PSBqbjtcbiAgICAgICAgZnVuY3Rpb24gcyhsKSB7XG4gICAgICAgICAgICB2YXIgdTtcbiAgICAgICAgICAgIHJldHVybiBvW2xdID0gITAsIHguZWFjaChlW2xdIHx8IFtdLCBmdW5jdGlvbiAoZSwgbCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gbChuLCByLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm5cInN0cmluZ1wiICE9IHR5cGVvZiBjIHx8IGEgfHwgb1tjXSA/IGEgPyAhKHUgPSBjKSA6IHQgOiAobi5kYXRhVHlwZXMudW5zaGlmdChjKSwgcyhjKSwgITEpXG4gICAgICAgICAgICB9KSwgdVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzKG4uZGF0YVR5cGVzWzBdKSB8fCAhb1tcIipcIl0gJiYgcyhcIipcIilcbiAgICB9XG4gICAgZnVuY3Rpb24gX24oZSwgbikge1xuICAgICAgICB2YXIgciwgaSwgbyA9IHguYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuICAgICAgICBmb3IgKGkgaW4gbilcbiAgICAgICAgICAgIG5baV0gIT09IHQgJiYgKChvW2ldID8gZSA6IHIgfHwgKHIgPSB7fSkpW2ldID0gbltpXSk7XG4gICAgICAgIHJldHVybiByICYmIHguZXh0ZW5kKCEwLCBlLCByKSwgZVxuICAgIH1cbiAgICB4LmZuLmxvYWQgPSBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSAmJiBTbilcbiAgICAgICAgICAgIHJldHVybiBTbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgaSwgbywgYSwgcyA9IHRoaXMsIGwgPSBlLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICByZXR1cm4gbCA+PSAwICYmIChpID0gZS5zbGljZShsLCBlLmxlbmd0aCksIGUgPSBlLnNsaWNlKDAsIGwpKSwgeC5pc0Z1bmN0aW9uKG4pID8gKHIgPSBuLCBuID0gdCkgOiBuICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG4gJiYgKGEgPSBcIlBPU1RcIiksIHMubGVuZ3RoID4gMCAmJiB4LmFqYXgoe3VybDogZSwgdHlwZTogYSwgZGF0YVR5cGU6IFwiaHRtbFwiLCBkYXRhOiBufSkuZG9uZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgbyA9IGFyZ3VtZW50cywgcy5odG1sKGkgPyB4KFwiPGRpdj5cIikuYXBwZW5kKHgucGFyc2VIVE1MKGUpKS5maW5kKGkpIDogZSlcbiAgICAgICAgfSkuY29tcGxldGUociAmJiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcy5lYWNoKHIsIG8gfHwgW2UucmVzcG9uc2VUZXh0LCB0LCBlXSlcbiAgICAgICAgfSksIHRoaXNcbiAgICB9LCB4LmVhY2goW1wiYWpheFN0YXJ0XCIsIFwiYWpheFN0b3BcIiwgXCJhamF4Q29tcGxldGVcIiwgXCJhamF4RXJyb3JcIiwgXCJhamF4U3VjY2Vzc1wiLCBcImFqYXhTZW5kXCJdLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB4LmZuW3RdID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKHQsIGUpXG4gICAgICAgIH1cbiAgICB9KSwgeC5leHRlbmQoe2FjdGl2ZTogMCwgbGFzdE1vZGlmaWVkOiB7fSwgZXRhZzoge30sIGFqYXhTZXR0aW5nczoge3VybDogeW4sIHR5cGU6IFwiR0VUXCIsIGlzTG9jYWw6IENuLnRlc3QobW5bMV0pLCBnbG9iYWw6ICEwLCBwcm9jZXNzRGF0YTogITAsIGFzeW5jOiAhMCwgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsIGFjY2VwdHM6IHtcIipcIjogRG4sIHRleHQ6IFwidGV4dC9wbGFpblwiLCBodG1sOiBcInRleHQvaHRtbFwiLCB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLCBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwifSwgY29udGVudHM6IHt4bWw6IC94bWwvLCBodG1sOiAvaHRtbC8sIGpzb246IC9qc29uL30sIHJlc3BvbnNlRmllbGRzOiB7eG1sOiBcInJlc3BvbnNlWE1MXCIsIHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsIGpzb246IFwicmVzcG9uc2VKU09OXCJ9LCBjb252ZXJ0ZXJzOiB7XCIqIHRleHRcIjogU3RyaW5nLCBcInRleHQgaHRtbFwiOiAhMCwgXCJ0ZXh0IGpzb25cIjogeC5wYXJzZUpTT04sIFwidGV4dCB4bWxcIjogeC5wYXJzZVhNTH0sIGZsYXRPcHRpb25zOiB7dXJsOiAhMCwgY29udGV4dDogITB9fSwgYWpheFNldHVwOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgPyBfbihfbihlLCB4LmFqYXhTZXR0aW5ncyksIHQpIDogX24oeC5hamF4U2V0dGluZ3MsIGUpXG4gICAgICAgIH0sIGFqYXhQcmVmaWx0ZXI6IEhuKEFuKSwgYWpheFRyYW5zcG9ydDogSG4oam4pLCBhamF4OiBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiAobiA9IGUsIGUgPSB0KSwgbiA9IG4gfHwge307XG4gICAgICAgICAgICB2YXIgciwgaSwgbywgYSwgcywgbCwgdSwgYywgcCA9IHguYWpheFNldHVwKHt9LCBuKSwgZiA9IHAuY29udGV4dCB8fCBwLCBkID0gcC5jb250ZXh0ICYmIChmLm5vZGVUeXBlIHx8IGYuanF1ZXJ5KSA/IHgoZikgOiB4LmV2ZW50LCBoID0geC5EZWZlcnJlZCgpLCBnID0geC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgbSA9IHAuc3RhdHVzQ29kZSB8fCB7fSwgeSA9IHt9LCB2ID0ge30sIGIgPSAwLCB3ID0gXCJjYW5jZWxlZFwiLCBDID0ge3JlYWR5U3RhdGU6IDAsIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDIgPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IFRuLmV4ZWMoYSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbdFsxXS50b0xvd2VyQ2FzZSgpXSA9IHRbMl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBjW2UudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSB0ID8gbnVsbCA6IHRcbiAgICAgICAgICAgICAgICB9LCBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgPT09IGIgPyBhIDogbnVsbFxuICAgICAgICAgICAgICAgIH0sIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYiB8fCAoZSA9IHZbbl0gPSB2W25dIHx8IGUsIHlbZV0gPSB0KSwgdGhpc1xuICAgICAgICAgICAgICAgIH0sIG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiIHx8IChwLm1pbWVUeXBlID0gZSksIHRoaXNcbiAgICAgICAgICAgICAgICB9LCBzdGF0dXNDb2RlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMiA+IGIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh0IGluIGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1bdF0gPSBbbVt0XSwgZVt0XV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQy5hbHdheXMoZVtDLnN0YXR1c10pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIH0sIGFib3J0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUgfHwgdztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHUgJiYgdS5hYm9ydCh0KSwgaygwLCB0KSwgdGhpc1xuICAgICAgICAgICAgICAgIH19O1xuICAgICAgICAgICAgaWYgKGgucHJvbWlzZShDKS5jb21wbGV0ZSA9IGcuYWRkLCBDLnN1Y2Nlc3MgPSBDLmRvbmUsIEMuZXJyb3IgPSBDLmZhaWwsIHAudXJsID0gKChlIHx8IHAudXJsIHx8IHluKSArIFwiXCIpLnJlcGxhY2UoeG4sIFwiXCIpLnJlcGxhY2Uoa24sIG1uWzFdICsgXCIvL1wiKSwgcC50eXBlID0gbi5tZXRob2QgfHwgbi50eXBlIHx8IHAubWV0aG9kIHx8IHAudHlwZSwgcC5kYXRhVHlwZXMgPSB4LnRyaW0ocC5kYXRhVHlwZSB8fCBcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChUKSB8fCBbXCJcIl0sIG51bGwgPT0gcC5jcm9zc0RvbWFpbiAmJiAociA9IEVuLmV4ZWMocC51cmwudG9Mb3dlckNhc2UoKSksIHAuY3Jvc3NEb21haW4gPSAhKCFyIHx8IHJbMV0gPT09IG1uWzFdICYmIHJbMl0gPT09IG1uWzJdICYmIChyWzNdIHx8IChcImh0dHA6XCIgPT09IHJbMV0gPyBcIjgwXCIgOiBcIjQ0M1wiKSkgPT09IChtblszXSB8fCAoXCJodHRwOlwiID09PSBtblsxXSA/IFwiODBcIiA6IFwiNDQzXCIpKSkpLCBwLmRhdGEgJiYgcC5wcm9jZXNzRGF0YSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBwLmRhdGEgJiYgKHAuZGF0YSA9IHgucGFyYW0ocC5kYXRhLCBwLnRyYWRpdGlvbmFsKSksIHFuKEFuLCBwLCBuLCBDKSwgMiA9PT0gYilcbiAgICAgICAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgICAgIGwgPSBwLmdsb2JhbCwgbCAmJiAwID09PSB4LmFjdGl2ZSsrICYmIHguZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSwgcC50eXBlID0gcC50eXBlLnRvVXBwZXJDYXNlKCksIHAuaGFzQ29udGVudCA9ICFObi50ZXN0KHAudHlwZSksIG8gPSBwLnVybCwgcC5oYXNDb250ZW50IHx8IChwLmRhdGEgJiYgKG8gPSBwLnVybCArPSAoYm4udGVzdChvKSA/IFwiJlwiIDogXCI/XCIpICsgcC5kYXRhLCBkZWxldGUgcC5kYXRhKSwgcC5jYWNoZSA9PT0gITEgJiYgKHAudXJsID0gd24udGVzdChvKSA/IG8ucmVwbGFjZSh3biwgXCIkMV89XCIgKyB2bisrKSA6IG8gKyAoYm4udGVzdChvKSA/IFwiJlwiIDogXCI/XCIpICsgXCJfPVwiICsgdm4rKykpLCBwLmlmTW9kaWZpZWQgJiYgKHgubGFzdE1vZGlmaWVkW29dICYmIEMuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsIHgubGFzdE1vZGlmaWVkW29dKSwgeC5ldGFnW29dICYmIEMuc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIiwgeC5ldGFnW29dKSksIChwLmRhdGEgJiYgcC5oYXNDb250ZW50ICYmIHAuY29udGVudFR5cGUgIT09ICExIHx8IG4uY29udGVudFR5cGUpICYmIEMuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBwLmNvbnRlbnRUeXBlKSwgQy5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIHAuZGF0YVR5cGVzWzBdICYmIHAuYWNjZXB0c1twLmRhdGFUeXBlc1swXV0gPyBwLmFjY2VwdHNbcC5kYXRhVHlwZXNbMF1dICsgKFwiKlwiICE9PSBwLmRhdGFUeXBlc1swXSA/IFwiLCBcIiArIERuICsgXCI7IHE9MC4wMVwiIDogXCJcIikgOiBwLmFjY2VwdHNbXCIqXCJdKTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBwLmhlYWRlcnMpXG4gICAgICAgICAgICAgICAgQy5zZXRSZXF1ZXN0SGVhZGVyKGksIHAuaGVhZGVyc1tpXSk7XG4gICAgICAgICAgICBpZiAocC5iZWZvcmVTZW5kICYmIChwLmJlZm9yZVNlbmQuY2FsbChmLCBDLCBwKSA9PT0gITEgfHwgMiA9PT0gYikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEMuYWJvcnQoKTtcbiAgICAgICAgICAgIHcgPSBcImFib3J0XCI7XG4gICAgICAgICAgICBmb3IgKGkgaW57c3VjY2VzczoxLCBlcnJvcjoxLCBjb21wbGV0ZToxfSlcbiAgICAgICAgICAgICAgICBDW2ldKHBbaV0pO1xuICAgICAgICAgICAgaWYgKHUgPSBxbihqbiwgcCwgbiwgQykpIHtcbiAgICAgICAgICAgICAgICBDLnJlYWR5U3RhdGUgPSAxLCBsICYmIGQudHJpZ2dlcihcImFqYXhTZW5kXCIsIFtDLCBwXSksIHAuYXN5bmMgJiYgcC50aW1lb3V0ID4gMCAmJiAocyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBDLmFib3J0KFwidGltZW91dFwiKVxuICAgICAgICAgICAgICAgIH0sIHAudGltZW91dCkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGIgPSAxLCB1LnNlbmQoeSwgaylcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChOKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDIgPiBiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IE47XG4gICAgICAgICAgICAgICAgICAgIGsoLTEsIE4pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgaygtMSwgXCJObyBUcmFuc3BvcnRcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBrKGUsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYywgeSwgdiwgdywgVCwgTiA9IG47XG4gICAgICAgICAgICAgICAgMiAhPT0gYiAmJiAoYiA9IDIsIHMgJiYgY2xlYXJUaW1lb3V0KHMpLCB1ID0gdCwgYSA9IGkgfHwgXCJcIiwgQy5yZWFkeVN0YXRlID0gZSA+IDAgPyA0IDogMCwgYyA9IGUgPj0gMjAwICYmIDMwMCA+IGUgfHwgMzA0ID09PSBlLCByICYmICh3ID0gTW4ocCwgQywgcikpLCB3ID0gT24ocCwgdywgQywgYyksIGMgPyAocC5pZk1vZGlmaWVkICYmIChUID0gQy5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIiksIFQgJiYgKHgubGFzdE1vZGlmaWVkW29dID0gVCksIFQgPSBDLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKSwgVCAmJiAoeC5ldGFnW29dID0gVCkpLCAyMDQgPT09IGUgfHwgXCJIRUFEXCIgPT09IHAudHlwZSA/IE4gPSBcIm5vY29udGVudFwiIDogMzA0ID09PSBlID8gTiA9IFwibm90bW9kaWZpZWRcIiA6IChOID0gdy5zdGF0ZSwgeSA9IHcuZGF0YSwgdiA9IHcuZXJyb3IsIGMgPSAhdikpIDogKHYgPSBOLCAoZSB8fCAhTikgJiYgKE4gPSBcImVycm9yXCIsIDAgPiBlICYmIChlID0gMCkpKSwgQy5zdGF0dXMgPSBlLCBDLnN0YXR1c1RleHQgPSAobiB8fCBOKSArIFwiXCIsIGMgPyBoLnJlc29sdmVXaXRoKGYsIFt5LCBOLCBDXSkgOiBoLnJlamVjdFdpdGgoZiwgW0MsIE4sIHZdKSwgQy5zdGF0dXNDb2RlKG0pLCBtID0gdCwgbCAmJiBkLnRyaWdnZXIoYyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsIFtDLCBwLCBjID8geSA6IHZdKSwgZy5maXJlV2l0aChmLCBbQywgTl0pLCBsICYmIChkLnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIiwgW0MsIHBdKSwgLS14LmFjdGl2ZSB8fCB4LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ1xuICAgICAgICB9LCBnZXRKU09OOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgcmV0dXJuIHguZ2V0KGUsIHQsIG4sIFwianNvblwiKVxuICAgICAgICB9LCBnZXRTY3JpcHQ6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICByZXR1cm4geC5nZXQoZSwgdCwgbiwgXCJzY3JpcHRcIilcbiAgICAgICAgfX0pLCB4LmVhY2goW1wiZ2V0XCIsIFwicG9zdFwiXSwgZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgeFtuXSA9IGZ1bmN0aW9uIChlLCByLCBpLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4geC5pc0Z1bmN0aW9uKHIpICYmIChvID0gbyB8fCBpLCBpID0gciwgciA9IHQpLCB4LmFqYXgoe3VybDogZSwgdHlwZTogbiwgZGF0YVR5cGU6IG8sIGRhdGE6IHIsIHN1Y2Nlc3M6IGl9KVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gTW4oZSwgbiwgcikge1xuICAgICAgICB2YXIgaSwgbywgYSwgcywgbCA9IGUuY29udGVudHMsIHUgPSBlLmRhdGFUeXBlcztcbiAgICAgICAgd2hpbGUgKFwiKlwiID09PSB1WzBdKVxuICAgICAgICAgICAgdS5zaGlmdCgpLCBvID09PSB0ICYmIChvID0gZS5taW1lVHlwZSB8fCBuLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpKTtcbiAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICBmb3IgKHMgaW4gbClcbiAgICAgICAgICAgICAgICBpZiAobFtzXSAmJiBsW3NdLnRlc3QobykpIHtcbiAgICAgICAgICAgICAgICAgICAgdS51bnNoaWZ0KHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKHVbMF1pbiByKVxuICAgICAgICAgICAgYSA9IHVbMF07XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChzIGluIHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVbMF0gfHwgZS5jb252ZXJ0ZXJzW3MgKyBcIiBcIiArIHVbMF1dKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBzO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpIHx8IChpID0gcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBhIHx8IGlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYSA/IChhICE9PSB1WzBdICYmIHUudW5zaGlmdChhKSwgclthXSkgOiB0XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9uKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgdmFyIGksIG8sIGEsIHMsIGwsIHUgPSB7fSwgYyA9IGUuZGF0YVR5cGVzLnNsaWNlKCk7XG4gICAgICAgIGlmIChjWzFdKVxuICAgICAgICAgICAgZm9yIChhIGluIGUuY29udmVydGVycylcbiAgICAgICAgICAgICAgICB1W2EudG9Mb3dlckNhc2UoKV0gPSBlLmNvbnZlcnRlcnNbYV07XG4gICAgICAgIG8gPSBjLnNoaWZ0KCk7XG4gICAgICAgIHdoaWxlIChvKVxuICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VGaWVsZHNbb10gJiYgKG5bZS5yZXNwb25zZUZpZWxkc1tvXV0gPSB0KSwgIWwgJiYgciAmJiBlLmRhdGFGaWx0ZXIgJiYgKHQgPSBlLmRhdGFGaWx0ZXIodCwgZS5kYXRhVHlwZSkpLCBsID0gbywgbyA9IGMuc2hpZnQoKSlcbiAgICAgICAgICAgICAgICBpZiAoXCIqXCIgPT09IG8pXG4gICAgICAgICAgICAgICAgICAgIG8gPSBsO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiKlwiICE9PSBsICYmIGwgIT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPSB1W2wgKyBcIiBcIiArIG9dIHx8IHVbXCIqIFwiICsgb10sICFhKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIHUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPSBpLnNwbGl0KFwiIFwiKSwgc1sxXSA9PT0gbyAmJiAoYSA9IHVbbCArIFwiIFwiICsgc1swXV0gfHwgdVtcIiogXCIgKyBzWzBdXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9PT0gITAgPyBhID0gdVtpXSA6IHVbaV0gIT09ICEwICYmIChvID0gc1swXSwgYy51bnNoaWZ0KHNbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhICE9PSAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhICYmIGVbXCJ0aHJvd3NcIl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGEodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGEodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybntzdGF0ZTogXCJwYXJzZXJlcnJvclwiLCBlcnJvcjogYSA/IHAgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIGwgKyBcIiB0byBcIiArIG99XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJue3N0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogdH1cbiAgICB9XG4gICAgeC5hamF4U2V0dXAoe2FjY2VwdHM6IHtzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIn0sIGNvbnRlbnRzOiB7c2NyaXB0OiAvKD86amF2YXxlY21hKXNjcmlwdC99LCBjb252ZXJ0ZXJzOiB7XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4Lmdsb2JhbEV2YWwoZSksIGVcbiAgICAgICAgICAgIH19fSksIHguYWpheFByZWZpbHRlcihcInNjcmlwdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmNhY2hlID09PSB0ICYmIChlLmNhY2hlID0gITEpLCBlLmNyb3NzRG9tYWluICYmIChlLnR5cGUgPSBcIkdFVFwiLCBlLmdsb2JhbCA9ICExKVxuICAgIH0pLCB4LmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuY3Jvc3NEb21haW4pIHtcbiAgICAgICAgICAgIHZhciBuLCByID0gYS5oZWFkIHx8IHgoXCJoZWFkXCIpWzBdIHx8IGEuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJue3NlbmQ6IGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBhLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksIG4uYXN5bmMgPSAhMCwgZS5zY3JpcHRDaGFyc2V0ICYmIChuLmNoYXJzZXQgPSBlLnNjcmlwdENoYXJzZXQpLCBuLnNyYyA9IGUudXJsLCBuLm9ubG9hZCA9IG4ub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0IHx8ICFuLnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdChuLnJlYWR5U3RhdGUpKSAmJiAobi5vbmxvYWQgPSBuLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGwsIG4ucGFyZW50Tm9kZSAmJiBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobiksIG4gPSBudWxsLCB0IHx8IGkoMjAwLCBcInN1Y2Nlc3NcIikpXG4gICAgICAgICAgICAgICAgICAgIH0sIHIuaW5zZXJ0QmVmb3JlKG4sIHIuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICB9LCBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBuICYmIG4ub25sb2FkKHQsICEwKVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgRm4gPSBbXSwgQm4gPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuICAgIHguYWpheFNldHVwKHtqc29ucDogXCJjYWxsYmFja1wiLCBqc29ucENhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IEZuLnBvcCgpIHx8IHguZXhwYW5kbyArIFwiX1wiICsgdm4rKztcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2VdID0gITAsIGVcbiAgICAgICAgfX0pLCB4LmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uIChuLCByLCBpKSB7XG4gICAgICAgIHZhciBvLCBhLCBzLCBsID0gbi5qc29ucCAhPT0gITEgJiYgKEJuLnRlc3Qobi51cmwpID8gXCJ1cmxcIiA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIG4uZGF0YSAmJiAhKG4uY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiBCbi50ZXN0KG4uZGF0YSkgJiYgXCJkYXRhXCIpO1xuICAgICAgICByZXR1cm4gbCB8fCBcImpzb25wXCIgPT09IG4uZGF0YVR5cGVzWzBdID8gKG8gPSBuLmpzb25wQ2FsbGJhY2sgPSB4LmlzRnVuY3Rpb24obi5qc29ucENhbGxiYWNrKSA/IG4uanNvbnBDYWxsYmFjaygpIDogbi5qc29ucENhbGxiYWNrLCBsID8gbltsXSA9IG5bbF0ucmVwbGFjZShCbiwgXCIkMVwiICsgbykgOiBuLmpzb25wICE9PSAhMSAmJiAobi51cmwgKz0gKGJuLnRlc3Qobi51cmwpID8gXCImXCIgOiBcIj9cIikgKyBuLmpzb25wICsgXCI9XCIgKyBvKSwgbi5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcyB8fCB4LmVycm9yKG8gKyBcIiB3YXMgbm90IGNhbGxlZFwiKSwgc1swXVxuICAgICAgICB9LCBuLmRhdGFUeXBlc1swXSA9IFwianNvblwiLCBhID0gZVtvXSwgZVtvXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNcbiAgICAgICAgfSwgaS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZVtvXSA9IGEsIG5bb10gJiYgKG4uanNvbnBDYWxsYmFjayA9IHIuanNvbnBDYWxsYmFjaywgRm4ucHVzaChvKSksIHMgJiYgeC5pc0Z1bmN0aW9uKGEpICYmIGEoc1swXSksIHMgPSBhID0gdFxuICAgICAgICB9KSwgXCJzY3JpcHRcIikgOiB0XG4gICAgfSk7XG4gICAgdmFyIFBuLCBSbiwgV24gPSAwLCAkbiA9IGUuQWN0aXZlWE9iamVjdCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBmb3IgKGUgaW4gUG4pXG4gICAgICAgICAgICBQbltlXSh0LCAhMClcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEluKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBlLlhNTEh0dHBSZXF1ZXN0XG4gICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB6bigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZS5BY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIilcbiAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICB9XG4gICAgfVxuICAgIHguYWpheFNldHRpbmdzLnhociA9IGUuQWN0aXZlWE9iamVjdCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIXRoaXMuaXNMb2NhbCAmJiBJbigpIHx8IHpuKClcbiAgICB9IDogSW4sIFJuID0geC5hamF4U2V0dGluZ3MueGhyKCksIHguc3VwcG9ydC5jb3JzID0gISFSbiAmJiBcIndpdGhDcmVkZW50aWFsc1wiaW4gUm4sIFJuID0geC5zdXBwb3J0LmFqYXggPSAhIVJuLCBSbiAmJiB4LmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKCFuLmNyb3NzRG9tYWluIHx8IHguc3VwcG9ydC5jb3JzKSB7XG4gICAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICAgIHJldHVybntzZW5kOiBmdW5jdGlvbiAoaSwgbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSwgcywgbCA9IG4ueGhyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnVzZXJuYW1lID8gbC5vcGVuKG4udHlwZSwgbi51cmwsIG4uYXN5bmMsIG4udXNlcm5hbWUsIG4ucGFzc3dvcmQpIDogbC5vcGVuKG4udHlwZSwgbi51cmwsIG4uYXN5bmMpLCBuLnhockZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocyBpbiBuLnhockZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsW3NdID0gbi54aHJGaWVsZHNbc107XG4gICAgICAgICAgICAgICAgICAgIG4ubWltZVR5cGUgJiYgbC5vdmVycmlkZU1pbWVUeXBlICYmIGwub3ZlcnJpZGVNaW1lVHlwZShuLm1pbWVUeXBlKSwgbi5jcm9zc0RvbWFpbiB8fCBpW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSB8fCAoaVtcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzIGluIGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbC5zZXRSZXF1ZXN0SGVhZGVyKHMsIGlbc10pXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsLnNlbmQobi5oYXNDb250ZW50ICYmIG4uZGF0YSB8fCBudWxsKSwgciA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcywgdSwgYywgcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgJiYgKGkgfHwgNCA9PT0gbC5yZWFkeVN0YXRlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSB0LCBhICYmIChsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHgubm9vcCwgJG4gJiYgZGVsZXRlIFBuW2FdKSwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgIT09IGwucmVhZHlTdGF0ZSAmJiBsLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHt9LCBzID0gbC5zdGF0dXMsIHUgPSBsLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLCBcInN0cmluZ1wiID09IHR5cGVvZiBsLnJlc3BvbnNlVGV4dCAmJiAocC50ZXh0ID0gbC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gbC5zdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgfHwgIW4uaXNMb2NhbCB8fCBuLmNyb3NzRG9tYWluID8gMTIyMyA9PT0gcyAmJiAocyA9IDIwNCkgOiBzID0gcC50ZXh0ID8gMjAwIDogNDA0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIHx8IG8oLTEsIGQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwICYmIG8ocywgYywgcCwgdSlcbiAgICAgICAgICAgICAgICAgICAgfSwgbi5hc3luYyA/IDQgPT09IGwucmVhZHlTdGF0ZSA/IHNldFRpbWVvdXQocikgOiAoYSA9ICsrV24sICRuICYmIChQbiB8fCAoUG4gPSB7fSwgeChlKS51bmxvYWQoJG4pKSwgUG5bYV0gPSByKSwgbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByKSA6IHIoKVxuICAgICAgICAgICAgICAgIH0sIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgJiYgcih0LCAhMClcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIFhuLCBVbiwgVm4gPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sIFluID0gUmVnRXhwKFwiXig/OihbKy1dKT18KShcIiArIHcgKyBcIikoW2EteiVdKikkXCIsIFwiaVwiKSwgSm4gPSAvcXVldWVIb29rcyQvLCBHbiA9IFtucl0sIFFuID0ge1wiKlwiOiBbZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuY3JlYXRlVHdlZW4oZSwgdCksIHIgPSBuLmN1cigpLCBpID0gWW4uZXhlYyh0KSwgbyA9IGkgJiYgaVszXSB8fCAoeC5jc3NOdW1iZXJbZV0gPyBcIlwiIDogXCJweFwiKSwgYSA9ICh4LmNzc051bWJlcltlXSB8fCBcInB4XCIgIT09IG8gJiYgK3IpICYmIFluLmV4ZWMoeC5jc3Mobi5lbGVtLCBlKSksIHMgPSAxLCBsID0gMjA7XG4gICAgICAgICAgICAgICAgaWYgKGEgJiYgYVszXSAhPT0gbykge1xuICAgICAgICAgICAgICAgICAgICBvID0gbyB8fCBhWzNdLCBpID0gaSB8fCBbXSwgYSA9ICtyIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcyB8fCBcIi41XCIsIGEgLz0gcywgeC5zdHlsZShuLmVsZW0sIGUsIGEgKyBvKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHMgIT09IChzID0gbi5jdXIoKSAvIHIpICYmIDEgIT09IHMgJiYgLS1sKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaSAmJiAoYSA9IG4uc3RhcnQgPSArYSB8fCArciB8fCAwLCBuLnVuaXQgPSBvLCBuLmVuZCA9IGlbMV0gPyBhICsgKGlbMV0gKyAxKSAqIGlbMl0gOiAraVsyXSksIG5cbiAgICAgICAgICAgIH1dfTtcbiAgICBmdW5jdGlvbiBLbigpIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgWG4gPSB0XG4gICAgICAgIH0pLCBYbiA9IHgubm93KClcbiAgICB9XG4gICAgZnVuY3Rpb24gWm4oZSwgdCwgbikge1xuICAgICAgICB2YXIgciwgaSA9IChRblt0XSB8fCBbXSkuY29uY2F0KFFuW1wiKlwiXSksIG8gPSAwLCBhID0gaS5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBhID4gbzsgbysrKVxuICAgICAgICAgICAgaWYgKHIgPSBpW29dLmNhbGwobiwgdCwgZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICB9XG4gICAgZnVuY3Rpb24gZXIoZSwgdCwgbikge1xuICAgICAgICB2YXIgciwgaSwgbyA9IDAsIGEgPSBHbi5sZW5ndGgsIHMgPSB4LkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsLmVsZW1cbiAgICAgICAgfSksIGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgICAgIHZhciB0ID0gWG4gfHwgS24oKSwgbiA9IE1hdGgubWF4KDAsIHUuc3RhcnRUaW1lICsgdS5kdXJhdGlvbiAtIHQpLCByID0gbiAvIHUuZHVyYXRpb24gfHwgMCwgbyA9IDEgLSByLCBhID0gMCwgbCA9IHUudHdlZW5zLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBsID4gYTsgYSsrKVxuICAgICAgICAgICAgICAgIHUudHdlZW5zW2FdLnJ1bihvKTtcbiAgICAgICAgICAgIHJldHVybiBzLm5vdGlmeVdpdGgoZSwgW3UsIG8sIG5dKSwgMSA+IG8gJiYgbCA/IG4gOiAocy5yZXNvbHZlV2l0aChlLCBbdV0pLCAhMSlcbiAgICAgICAgfSwgdSA9IHMucHJvbWlzZSh7ZWxlbTogZSwgcHJvcHM6IHguZXh0ZW5kKHt9LCB0KSwgb3B0czogeC5leHRlbmQoITAsIHtzcGVjaWFsRWFzaW5nOiB7fX0sIG4pLCBvcmlnaW5hbFByb3BlcnRpZXM6IHQsIG9yaWdpbmFsT3B0aW9uczogbiwgc3RhcnRUaW1lOiBYbiB8fCBLbigpLCBkdXJhdGlvbjogbi5kdXJhdGlvbiwgdHdlZW5zOiBbXSwgY3JlYXRlVHdlZW46IGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB4LlR3ZWVuKGUsIHUub3B0cywgdCwgbiwgdS5vcHRzLnNwZWNpYWxFYXNpbmdbdF0gfHwgdS5vcHRzLmVhc2luZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHUudHdlZW5zLnB1c2gociksIHJcbiAgICAgICAgICAgIH0sIHN0b3A6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSAwLCByID0gdCA/IHUudHdlZW5zLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9ICEwOyByID4gbjsgbisrKVxuICAgICAgICAgICAgICAgICAgICB1LnR3ZWVuc1tuXS5ydW4oMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQgPyBzLnJlc29sdmVXaXRoKGUsIFt1LCB0XSkgOiBzLnJlamVjdFdpdGgoZSwgW3UsIHRdKSwgdGhpc1xuICAgICAgICAgICAgfX0pLCBjID0gdS5wcm9wcztcbiAgICAgICAgZm9yICh0cihjLCB1Lm9wdHMuc3BlY2lhbEVhc2luZyk7IGEgPiBvOyBvKyspXG4gICAgICAgICAgICBpZiAociA9IEduW29dLmNhbGwodSwgZSwgYywgdS5vcHRzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgcmV0dXJuIHgubWFwKGMsIFpuLCB1KSwgeC5pc0Z1bmN0aW9uKHUub3B0cy5zdGFydCkgJiYgdS5vcHRzLnN0YXJ0LmNhbGwoZSwgdSksIHguZngudGltZXIoeC5leHRlbmQobCwge2VsZW06IGUsIGFuaW06IHUsIHF1ZXVlOiB1Lm9wdHMucXVldWV9KSksIHUucHJvZ3Jlc3ModS5vcHRzLnByb2dyZXNzKS5kb25lKHUub3B0cy5kb25lLCB1Lm9wdHMuY29tcGxldGUpLmZhaWwodS5vcHRzLmZhaWwpLmFsd2F5cyh1Lm9wdHMuYWx3YXlzKVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cihlLCB0KSB7XG4gICAgICAgIHZhciBuLCByLCBpLCBvLCBhO1xuICAgICAgICBmb3IgKG4gaW4gZSlcbiAgICAgICAgICAgIGlmIChyID0geC5jYW1lbENhc2UobiksIGkgPSB0W3JdLCBvID0gZVtuXSwgeC5pc0FycmF5KG8pICYmIChpID0gb1sxXSwgbyA9IGVbbl0gPSBvWzBdKSwgbiAhPT0gciAmJiAoZVtyXSA9IG8sIGRlbGV0ZSBlW25dKSwgYSA9IHguY3NzSG9va3Nbcl0sIGEgJiYgXCJleHBhbmRcImluIGEpIHtcbiAgICAgICAgICAgICAgICBvID0gYS5leHBhbmQobyksIGRlbGV0ZSBlW3JdO1xuICAgICAgICAgICAgICAgIGZvciAobiBpbiBvKVxuICAgICAgICAgICAgICAgICAgICBuIGluIGUgfHwgKGVbbl0gPSBvW25dLCB0W25dID0gaSlcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRbcl0gPSBpXG4gICAgfVxuICAgIHguQW5pbWF0aW9uID0geC5leHRlbmQoZXIsIHt0d2VlbmVyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgeC5pc0Z1bmN0aW9uKGUpID8gKHQgPSBlLCBlID0gW1wiKlwiXSkgOiBlID0gZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICB2YXIgbiwgciA9IDAsIGkgPSBlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpID4gcjsgcisrKVxuICAgICAgICAgICAgICAgIG4gPSBlW3JdLCBRbltuXSA9IFFuW25dIHx8IFtdLCBRbltuXS51bnNoaWZ0KHQpXG4gICAgICAgIH0sIHByZWZpbHRlcjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHQgPyBHbi51bnNoaWZ0KGUpIDogR24ucHVzaChlKVxuICAgICAgICB9fSk7XG4gICAgZnVuY3Rpb24gbnIoZSwgdCwgbikge1xuICAgICAgICB2YXIgciwgaSwgbywgYSwgcywgbCwgdSA9IHRoaXMsIGMgPSB7fSwgcCA9IGUuc3R5bGUsIGYgPSBlLm5vZGVUeXBlICYmIG5uKGUpLCBkID0geC5fZGF0YShlLCBcImZ4c2hvd1wiKTtcbiAgICAgICAgbi5xdWV1ZSB8fCAocyA9IHguX3F1ZXVlSG9va3MoZSwgXCJmeFwiKSwgbnVsbCA9PSBzLnVucXVldWVkICYmIChzLnVucXVldWVkID0gMCwgbCA9IHMuZW1wdHkuZmlyZSwgcy5lbXB0eS5maXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcy51bnF1ZXVlZCB8fCBsKClcbiAgICAgICAgfSksIHMudW5xdWV1ZWQrKywgdS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHMudW5xdWV1ZWQtLSwgeC5xdWV1ZShlLCBcImZ4XCIpLmxlbmd0aCB8fCBzLmVtcHR5LmZpcmUoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSkpLCAxID09PSBlLm5vZGVUeXBlICYmIChcImhlaWdodFwiaW4gdCB8fCBcIndpZHRoXCJpbiB0KSAmJiAobi5vdmVyZmxvdyA9IFtwLm92ZXJmbG93LCBwLm92ZXJmbG93WCwgcC5vdmVyZmxvd1ldLCBcImlubGluZVwiID09PSB4LmNzcyhlLCBcImRpc3BsYXlcIikgJiYgXCJub25lXCIgPT09IHguY3NzKGUsIFwiZmxvYXRcIikgJiYgKHguc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ICYmIFwiaW5saW5lXCIgIT09IGxuKGUubm9kZU5hbWUpID8gcC56b29tID0gMSA6IHAuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpKSwgbi5vdmVyZmxvdyAmJiAocC5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIHguc3VwcG9ydC5zaHJpbmtXcmFwQmxvY2tzIHx8IHUuYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHAub3ZlcmZsb3cgPSBuLm92ZXJmbG93WzBdLCBwLm92ZXJmbG93WCA9IG4ub3ZlcmZsb3dbMV0sIHAub3ZlcmZsb3dZID0gbi5vdmVyZmxvd1syXVxuICAgICAgICB9KSk7XG4gICAgICAgIGZvciAociBpbiB0KVxuICAgICAgICAgICAgaWYgKGkgPSB0W3JdLCBWbi5leGVjKGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZSB0W3JdLCBvID0gbyB8fCBcInRvZ2dsZVwiID09PSBpLCBpID09PSAoZiA/IFwiaGlkZVwiIDogXCJzaG93XCIpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjW3JdID0gZCAmJiBkW3JdIHx8IHguc3R5bGUoZSwgcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKCF4LmlzRW1wdHlPYmplY3QoYykpIHtcbiAgICAgICAgICAgIGQgPyBcImhpZGRlblwiaW4gZCAmJiAoZiA9IGQuaGlkZGVuKSA6IGQgPSB4Ll9kYXRhKGUsIFwiZnhzaG93XCIsIHt9KSwgbyAmJiAoZC5oaWRkZW4gPSAhZiksIGYgPyB4KGUpLnNob3coKSA6IHUuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeChlKS5oaWRlKClcbiAgICAgICAgICAgIH0pLCB1LmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgICAgIHguX3JlbW92ZURhdGEoZSwgXCJmeHNob3dcIik7XG4gICAgICAgICAgICAgICAgZm9yICh0IGluIGMpXG4gICAgICAgICAgICAgICAgICAgIHguc3R5bGUoZSwgdCwgY1t0XSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChyIGluIGMpXG4gICAgICAgICAgICAgICAgYSA9IFpuKGYgPyBkW3JdIDogMCwgciwgdSksIHIgaW4gZCB8fCAoZFtyXSA9IGEuc3RhcnQsIGYgJiYgKGEuZW5kID0gYS5zdGFydCwgYS5zdGFydCA9IFwid2lkdGhcIiA9PT0gciB8fCBcImhlaWdodFwiID09PSByID8gMSA6IDApKVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJyKGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByci5wcm90b3R5cGUuaW5pdChlLCB0LCBuLCByLCBpKVxuICAgIH1cbiAgICB4LlR3ZWVuID0gcnIsIHJyLnByb3RvdHlwZSA9IHtjb25zdHJ1Y3RvcjogcnIsIGluaXQ6IGZ1bmN0aW9uIChlLCB0LCBuLCByLCBpLCBvKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW0gPSBlLCB0aGlzLnByb3AgPSBuLCB0aGlzLmVhc2luZyA9IGkgfHwgXCJzd2luZ1wiLCB0aGlzLm9wdGlvbnMgPSB0LCB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpLCB0aGlzLmVuZCA9IHIsIHRoaXMudW5pdCA9IG8gfHwgKHguY3NzTnVtYmVyW25dID8gXCJcIiA6IFwicHhcIilcbiAgICAgICAgfSwgY3VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHJyLnByb3BIb29rc1t0aGlzLnByb3BdO1xuICAgICAgICAgICAgcmV0dXJuIGUgJiYgZS5nZXQgPyBlLmdldCh0aGlzKSA6IHJyLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcylcbiAgICAgICAgfSwgcnVuOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQsIG4gPSByci5wcm9wSG9va3NbdGhpcy5wcm9wXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcyA9IHQgPSB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPyB4LmVhc2luZ1t0aGlzLmVhc2luZ10oZSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogZSwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uKSA6IGUsIHRoaXMubm93ID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiB0ICsgdGhpcy5zdGFydCwgdGhpcy5vcHRpb25zLnN0ZXAgJiYgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKSwgbiAmJiBuLnNldCA/IG4uc2V0KHRoaXMpIDogcnIucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSwgdGhpc1xuICAgICAgICB9fSwgcnIucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gcnIucHJvdG90eXBlLCByci5wcm9wSG9va3MgPSB7X2RlZmF1bHQ6IHtnZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZS5lbGVtW2UucHJvcF0gfHwgZS5lbGVtLnN0eWxlICYmIG51bGwgIT0gZS5lbGVtLnN0eWxlW2UucHJvcF0gPyAodCA9IHguY3NzKGUuZWxlbSwgZS5wcm9wLCBcIlwiKSwgdCAmJiBcImF1dG9cIiAhPT0gdCA/IHQgOiAwKSA6IGUuZWxlbVtlLnByb3BdXG4gICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgeC5meC5zdGVwW2UucHJvcF0gPyB4LmZ4LnN0ZXBbZS5wcm9wXShlKSA6IGUuZWxlbS5zdHlsZSAmJiAobnVsbCAhPSBlLmVsZW0uc3R5bGVbeC5jc3NQcm9wc1tlLnByb3BdXSB8fCB4LmNzc0hvb2tzW2UucHJvcF0pID8geC5zdHlsZShlLmVsZW0sIGUucHJvcCwgZS5ub3cgKyBlLnVuaXQpIDogZS5lbGVtW2UucHJvcF0gPSBlLm5vd1xuICAgICAgICAgICAgfX19LCByci5wcm9wSG9va3Muc2Nyb2xsVG9wID0gcnIucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7c2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5lbGVtLm5vZGVUeXBlICYmIGUuZWxlbS5wYXJlbnROb2RlICYmIChlLmVsZW1bZS5wcm9wXSA9IGUubm93KVxuICAgICAgICB9fSwgeC5lYWNoKFtcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCJdLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB2YXIgbiA9IHguZm5bdF07XG4gICAgICAgIHguZm5bdF0gPSBmdW5jdGlvbiAoZSwgciwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSB8fCBcImJvb2xlYW5cIiA9PSB0eXBlb2YgZSA/IG4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXMuYW5pbWF0ZShpcih0LCAhMCksIGUsIHIsIGkpXG4gICAgICAgIH1cbiAgICB9KSwgeC5mbi5leHRlbmQoe2ZhZGVUbzogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihubikuY3NzKFwib3BhY2l0eVwiLCAwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7b3BhY2l0eTogdH0sIGUsIG4sIHIpXG4gICAgICAgIH0sIGFuaW1hdGU6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHguaXNFbXB0eU9iamVjdChlKSwgbyA9IHguc3BlZWQodCwgbiwgciksIGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlcih0aGlzLCB4LmV4dGVuZCh7fSwgZSksIG8pO1xuICAgICAgICAgICAgICAgIChpIHx8IHguX2RhdGEodGhpcywgXCJmaW5pc2hcIikpICYmIHQuc3RvcCghMClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYS5maW5pc2ggPSBhLCBpIHx8IG8ucXVldWUgPT09ICExID8gdGhpcy5lYWNoKGEpIDogdGhpcy5xdWV1ZShvLnF1ZXVlLCBhKVxuICAgICAgICB9LCBzdG9wOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5zdG9wO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlLnN0b3AsIHQocilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm5cInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIChyID0gbiwgbiA9IGUsIGUgPSB0KSwgbiAmJiBlICE9PSAhMSAmJiB0aGlzLnF1ZXVlKGUgfHwgXCJmeFwiLCBbXSksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSAhMCwgbiA9IG51bGwgIT0gZSAmJiBlICsgXCJxdWV1ZUhvb2tzXCIsIG8gPSB4LnRpbWVycywgYSA9IHguX2RhdGEodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKG4pXG4gICAgICAgICAgICAgICAgICAgIGFbbl0gJiYgYVtuXS5zdG9wICYmIGkoYVtuXSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKG4gaW4gYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbbl0gJiYgYVtuXS5zdG9wICYmIEpuLnRlc3QobikgJiYgaShhW25dKTtcbiAgICAgICAgICAgICAgICBmb3IgKG4gPSBvLmxlbmd0aDsgbi0tOyApXG4gICAgICAgICAgICAgICAgICAgIG9bbl0uZWxlbSAhPT0gdGhpcyB8fCBudWxsICE9IGUgJiYgb1tuXS5xdWV1ZSAhPT0gZSB8fCAob1tuXS5hbmltLnN0b3AociksIHQgPSAhMSwgby5zcGxpY2UobiwgMSkpO1xuICAgICAgICAgICAgICAgICh0IHx8ICFyKSAmJiB4LmRlcXVldWUodGhpcywgZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGZpbmlzaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlICE9PSAhMSAmJiAoZSA9IGUgfHwgXCJmeFwiKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCwgbiA9IHguX2RhdGEodGhpcyksIHIgPSBuW2UgKyBcInF1ZXVlXCJdLCBpID0gbltlICsgXCJxdWV1ZUhvb2tzXCJdLCBvID0geC50aW1lcnMsIGEgPSByID8gci5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgIGZvciAobi5maW5pc2ggPSAhMCwgeC5xdWV1ZSh0aGlzLCBlLCBbXSksIGkgJiYgaS5zdG9wICYmIGkuc3RvcC5jYWxsKHRoaXMsICEwKSwgdCA9IG8ubGVuZ3RoOyB0LS07IClcbiAgICAgICAgICAgICAgICAgICAgb1t0XS5lbGVtID09PSB0aGlzICYmIG9bdF0ucXVldWUgPT09IGUgJiYgKG9bdF0uYW5pbS5zdG9wKCEwKSwgby5zcGxpY2UodCwgMSkpO1xuICAgICAgICAgICAgICAgIGZvciAodCA9IDA7IGEgPiB0OyB0KyspXG4gICAgICAgICAgICAgICAgICAgIHJbdF0gJiYgclt0XS5maW5pc2ggJiYgclt0XS5maW5pc2guY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbi5maW5pc2hcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH19KTtcbiAgICBmdW5jdGlvbiBpcihlLCB0KSB7XG4gICAgICAgIHZhciBuLCByID0ge2hlaWdodDogZX0sIGkgPSAwO1xuICAgICAgICBmb3IgKHQgPSB0PzE6MDsgNCA+IGk7IGkgKz0gMiAtIHQpXG4gICAgICAgICAgICBuID0gWnRbaV0sIHJbXCJtYXJnaW5cIiArIG5dID0gcltcInBhZGRpbmdcIiArIG5dID0gZTtcbiAgICAgICAgcmV0dXJuIHQgJiYgKHIub3BhY2l0eSA9IHIud2lkdGggPSBlKSwgclxuICAgIH1cbiAgICB4LmVhY2goe3NsaWRlRG93bjogaXIoXCJzaG93XCIpLCBzbGlkZVVwOiBpcihcImhpZGVcIiksIHNsaWRlVG9nZ2xlOiBpcihcInRvZ2dsZVwiKSwgZmFkZUluOiB7b3BhY2l0eTogXCJzaG93XCJ9LCBmYWRlT3V0OiB7b3BhY2l0eTogXCJoaWRlXCJ9LCBmYWRlVG9nZ2xlOiB7b3BhY2l0eTogXCJ0b2dnbGVcIn19LCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB4LmZuW2VdID0gZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUodCwgZSwgbiwgcilcbiAgICAgICAgfVxuICAgIH0pLCB4LnNwZWVkID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgdmFyIHIgPSBlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgPyB4LmV4dGVuZCh7fSwgZSkgOiB7Y29tcGxldGU6IG4gfHwgIW4gJiYgdCB8fCB4LmlzRnVuY3Rpb24oZSkgJiYgZSwgZHVyYXRpb246IGUsIGVhc2luZzogbiAmJiB0IHx8IHQgJiYgIXguaXNGdW5jdGlvbih0KSAmJiB0fTtcbiAgICAgICAgcmV0dXJuIHIuZHVyYXRpb24gPSB4LmZ4Lm9mZiA/IDAgOiBcIm51bWJlclwiID09IHR5cGVvZiByLmR1cmF0aW9uID8gci5kdXJhdGlvbiA6IHIuZHVyYXRpb24gaW4geC5meC5zcGVlZHMgPyB4LmZ4LnNwZWVkc1tyLmR1cmF0aW9uXSA6IHguZnguc3BlZWRzLl9kZWZhdWx0LCAobnVsbCA9PSByLnF1ZXVlIHx8IHIucXVldWUgPT09ICEwKSAmJiAoci5xdWV1ZSA9IFwiZnhcIiksIHIub2xkID0gci5jb21wbGV0ZSwgci5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHguaXNGdW5jdGlvbihyLm9sZCkgJiYgci5vbGQuY2FsbCh0aGlzKSwgci5xdWV1ZSAmJiB4LmRlcXVldWUodGhpcywgci5xdWV1ZSlcbiAgICAgICAgfSwgclxuICAgIH0sIHguZWFzaW5nID0ge2xpbmVhcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgIH0sIHN3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuLjUgLSBNYXRoLmNvcyhlICogTWF0aC5QSSkgLyAyXG4gICAgICAgIH19LCB4LnRpbWVycyA9IFtdLCB4LmZ4ID0gcnIucHJvdG90eXBlLmluaXQsIHguZngudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsIG4gPSB4LnRpbWVycywgciA9IDA7XG4gICAgICAgIGZvciAoWG4gPSB4Lm5vdygpOyBuLmxlbmd0aCA+IHI7IHIrKylcbiAgICAgICAgICAgIGUgPSBuW3JdLCBlKCkgfHwgbltyXSAhPT0gZSB8fCBuLnNwbGljZShyLS0sIDEpO1xuICAgICAgICBuLmxlbmd0aCB8fCB4LmZ4LnN0b3AoKSwgWG4gPSB0XG4gICAgfSwgeC5meC50aW1lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUoKSAmJiB4LnRpbWVycy5wdXNoKGUpICYmIHguZnguc3RhcnQoKVxuICAgIH0sIHguZnguaW50ZXJ2YWwgPSAxMywgeC5meC5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVW4gfHwgKFVuID0gc2V0SW50ZXJ2YWwoeC5meC50aWNrLCB4LmZ4LmludGVydmFsKSlcbiAgICB9LCB4LmZ4LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoVW4pLCBVbiA9IG51bGxcbiAgICB9LCB4LmZ4LnNwZWVkcyA9IHtzbG93OiA2MDAsIGZhc3Q6IDIwMCwgX2RlZmF1bHQ6IDQwMH0sIHguZnguc3RlcCA9IHt9LCB4LmV4cHIgJiYgeC5leHByLmZpbHRlcnMgJiYgKHguZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHguZ3JlcCh4LnRpbWVycywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlID09PSB0LmVsZW1cbiAgICAgICAgfSkubGVuZ3RoXG4gICAgfSksIHguZm4ub2Zmc2V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZSA9PT0gdCA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB4Lm9mZnNldC5zZXRPZmZzZXQodGhpcywgZSwgdClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgbiwgciwgbyA9IHt0b3A6IDAsIGxlZnQ6IDB9LCBhID0gdGhpc1swXSwgcyA9IGEgJiYgYS5vd25lckRvY3VtZW50O1xuICAgICAgICBpZiAocylcbiAgICAgICAgICAgIHJldHVybiBuID0gcy5kb2N1bWVudEVsZW1lbnQsIHguY29udGFpbnMobiwgYSkgPyAodHlwZW9mIGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSBpICYmIChvID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksIHIgPSBvcihzKSwge3RvcDogby50b3AgKyAoci5wYWdlWU9mZnNldCB8fCBuLnNjcm9sbFRvcCkgLSAobi5jbGllbnRUb3AgfHwgMCksIGxlZnQ6IG8ubGVmdCArIChyLnBhZ2VYT2Zmc2V0IHx8IG4uc2Nyb2xsTGVmdCkgLSAobi5jbGllbnRMZWZ0IHx8IDApfSkgOiBvXG4gICAgfSwgeC5vZmZzZXQgPSB7c2V0T2Zmc2V0OiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIgPSB4LmNzcyhlLCBcInBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgXCJzdGF0aWNcIiA9PT0gciAmJiAoZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIik7XG4gICAgICAgICAgICB2YXIgaSA9IHgoZSksIG8gPSBpLm9mZnNldCgpLCBhID0geC5jc3MoZSwgXCJ0b3BcIiksIHMgPSB4LmNzcyhlLCBcImxlZnRcIiksIGwgPSAoXCJhYnNvbHV0ZVwiID09PSByIHx8IFwiZml4ZWRcIiA9PT0gcikgJiYgeC5pbkFycmF5KFwiYXV0b1wiLCBbYSwgc10pID4gLTEsIHUgPSB7fSwgYyA9IHt9LCBwLCBmO1xuICAgICAgICAgICAgbCA/IChjID0gaS5wb3NpdGlvbigpLCBwID0gYy50b3AsIGYgPSBjLmxlZnQpIDogKHAgPSBwYXJzZUZsb2F0KGEpIHx8IDAsIGYgPSBwYXJzZUZsb2F0KHMpIHx8IDApLCB4LmlzRnVuY3Rpb24odCkgJiYgKHQgPSB0LmNhbGwoZSwgbiwgbykpLCBudWxsICE9IHQudG9wICYmICh1LnRvcCA9IHQudG9wIC0gby50b3AgKyBwKSwgbnVsbCAhPSB0LmxlZnQgJiYgKHUubGVmdCA9IHQubGVmdCAtIG8ubGVmdCArIGYpLCBcInVzaW5nXCJpbiB0ID8gdC51c2luZy5jYWxsKGUsIHUpIDogaS5jc3ModSlcbiAgICAgICAgfX0sIHguZm4uZXh0ZW5kKHtwb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZSwgdCwgbiA9IHt0b3A6IDAsIGxlZnQ6IDB9LCByID0gdGhpc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm5cImZpeGVkXCIgPT09IHguY3NzKHIsIFwicG9zaXRpb25cIikgPyB0ID0gci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IChlID0gdGhpcy5vZmZzZXRQYXJlbnQoKSwgdCA9IHRoaXMub2Zmc2V0KCksIHgubm9kZU5hbWUoZVswXSwgXCJodG1sXCIpIHx8IChuID0gZS5vZmZzZXQoKSksIG4udG9wICs9IHguY3NzKGVbMF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgITApLCBuLmxlZnQgKz0geC5jc3MoZVswXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgITApKSwge3RvcDogdC50b3AgLSBuLnRvcCAtIHguY3NzKHIsIFwibWFyZ2luVG9wXCIsICEwKSwgbGVmdDogdC5sZWZ0IC0gbi5sZWZ0IC0geC5jc3MociwgXCJtYXJnaW5MZWZ0XCIsICEwKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgcztcbiAgICAgICAgICAgICAgICB3aGlsZSAoZSAmJiAheC5ub2RlTmFtZShlLCBcImh0bWxcIikgJiYgXCJzdGF0aWNcIiA9PT0geC5jc3MoZSwgXCJwb3NpdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBlIHx8IHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH19KSwgeC5lYWNoKHtzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwifSwgZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgdmFyIHIgPSAvWS8udGVzdChuKTtcbiAgICAgICAgeC5mbltlXSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG9yKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvID09PSB0ID8gYSA/IG4gaW4gYSA/IGFbbl0gOiBhLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtpXSA6IGVbaV0gOiAoYSA/IGEuc2Nyb2xsVG8ociA/IHgoYSkuc2Nyb2xsTGVmdCgpIDogbywgciA/IG8gOiB4KGEpLnNjcm9sbFRvcCgpKSA6IGVbaV0gPSBvLCB0KVxuICAgICAgICAgICAgfSwgZSwgaSwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbClcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG9yKGUpIHtcbiAgICAgICAgcmV0dXJuIHguaXNXaW5kb3coZSkgPyBlIDogOSA9PT0gZS5ub2RlVHlwZSA/IGUuZGVmYXVsdFZpZXcgfHwgZS5wYXJlbnRXaW5kb3cgOiAhMVxuICAgIH1cbiAgICB4LmVhY2goe0hlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIn0sIGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgIHguZWFjaCh7cGFkZGluZzogXCJpbm5lclwiICsgZSwgY29udGVudDogbiwgXCJcIjogXCJvdXRlclwiICsgZX0sIGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICAgICAgICB4LmZuW2ldID0gZnVuY3Rpb24gKGksIG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKHIgfHwgXCJib29sZWFuXCIgIT0gdHlwZW9mIGkpLCBzID0gciB8fCAoaSA9PT0gITAgfHwgbyA9PT0gITAgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguYWNjZXNzKHRoaXMsIGZ1bmN0aW9uIChuLCByLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5pc1dpbmRvdyhuKSA/IG4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIgKyBlXSA6IDkgPT09IG4ubm9kZVR5cGUgPyAobyA9IG4uZG9jdW1lbnRFbGVtZW50LCBNYXRoLm1heChuLmJvZHlbXCJzY3JvbGxcIiArIGVdLCBvW1wic2Nyb2xsXCIgKyBlXSwgbi5ib2R5W1wib2Zmc2V0XCIgKyBlXSwgb1tcIm9mZnNldFwiICsgZV0sIG9bXCJjbGllbnRcIiArIGVdKSkgOiBpID09PSB0ID8geC5jc3MobiwgciwgcykgOiB4LnN0eWxlKG4sIHIsIGksIHMpXG4gICAgICAgICAgICAgICAgfSwgbiwgYSA/IGkgOiB0LCBhLCBudWxsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pLCB4LmZuLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aFxuICAgIH0sIHguZm4uYW5kU2VsZiA9IHguZm4uYWRkQmFjaywgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlICYmIG1vZHVsZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzID0geCA6IChlLmpRdWVyeSA9IGUuJCA9IHgsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lKFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB4XG4gICAgfSkpXG59KSh3aW5kb3cpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2Fzc2V0cy9qcy92ZW5kb3IvanF1ZXJ5Lm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMlxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=');
},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.6.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function () {\n\n    // Baseline setup\n    // --------------\n\n    // Establish the root object, `window` in the browser, or `exports` on the server.\n    var root = this;\n\n    // Save the previous value of the `_` variable.\n    var previousUnderscore = root._;\n\n    // Establish the object that gets returned to break out of a loop iteration.\n    var breaker = {};\n\n    // Save bytes in the minified (but not gzipped) version:\n    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n    // Create quick reference variables for speed access to core prototypes.\n    var\n        push = ArrayProto.push,\n        slice = ArrayProto.slice,\n        concat = ArrayProto.concat,\n        toString = ObjProto.toString,\n        hasOwnProperty = ObjProto.hasOwnProperty;\n\n    // All **ECMAScript 5** native function implementations that we hope to use\n    // are declared here.\n    var\n        nativeForEach = ArrayProto.forEach,\n        nativeMap = ArrayProto.map,\n        nativeReduce = ArrayProto.reduce,\n        nativeReduceRight = ArrayProto.reduceRight,\n        nativeFilter = ArrayProto.filter,\n        nativeEvery = ArrayProto.every,\n        nativeSome = ArrayProto.some,\n        nativeIndexOf = ArrayProto.indexOf,\n        nativeLastIndexOf = ArrayProto.lastIndexOf,\n        nativeIsArray = Array.isArray,\n        nativeKeys = Object.keys,\n        nativeBind = FuncProto.bind;\n\n    // Create a safe reference to the Underscore object for use below.\n    var _ = function (obj) {\n        if (obj instanceof _)\n            return obj;\n        if (!(this instanceof _))\n            return new _(obj);\n        this._wrapped = obj;\n    };\n\n    // Export the Underscore object for **Node.js**, with\n    // backwards-compatibility for the old `require()` API. If we're in\n    // the browser, add `_` as a global object via a string identifier,\n    // for Closure Compiler \"advanced\" mode.\n    if (true) {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = _;\n        }\n        exports._ = _;\n    } else {\n        root._ = _;\n    }\n\n    // Current version.\n    _.VERSION = '1.6.0';\n\n    // Collection Functions\n    // --------------------\n\n    // The cornerstone, an `each` implementation, aka `forEach`.\n    // Handles objects with the built-in `forEach`, arrays, and raw objects.\n    // Delegates to **ECMAScript 5**'s native `forEach` if available.\n    var each = _.each = _.forEach = function (obj, iterator, context) {\n        if (obj == null)\n            return obj;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, length = obj.length; i < length; i++) {\n                if (iterator.call(context, obj[i], i, obj) === breaker)\n                    return;\n            }\n        } else {\n            var keys = _.keys(obj);\n            for (var i = 0, length = keys.length; i < length; i++) {\n                if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker)\n                    return;\n            }\n        }\n        return obj;\n    };\n\n    // Return the results of applying the iterator to each element.\n    // Delegates to **ECMAScript 5**'s native `map` if available.\n    _.map = _.collect = function (obj, iterator, context) {\n        var results = [];\n        if (obj == null)\n            return results;\n        if (nativeMap && obj.map === nativeMap)\n            return obj.map(iterator, context);\n        each(obj, function (value, index, list) {\n            results.push(iterator.call(context, value, index, list));\n        });\n        return results;\n    };\n\n    var reduceError = 'Reduce of empty array with no initial value';\n\n    // **Reduce** builds up a single result from a list of values, aka `inject`,\n    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n    _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {\n        var initial = arguments.length > 2;\n        if (obj == null)\n            obj = [];\n        if (nativeReduce && obj.reduce === nativeReduce) {\n            if (context)\n                iterator = _.bind(iterator, context);\n            return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n        }\n        each(obj, function (value, index, list) {\n            if (!initial) {\n                memo = value;\n                initial = true;\n            } else {\n                memo = iterator.call(context, memo, value, index, list);\n            }\n        });\n        if (!initial)\n            throw new TypeError(reduceError);\n        return memo;\n    };\n\n    // The right-associative version of reduce, also known as `foldr`.\n    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n    _.reduceRight = _.foldr = function (obj, iterator, memo, context) {\n        var initial = arguments.length > 2;\n        if (obj == null)\n            obj = [];\n        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n            if (context)\n                iterator = _.bind(iterator, context);\n            return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n        }\n        var length = obj.length;\n        if (length !== +length) {\n            var keys = _.keys(obj);\n            length = keys.length;\n        }\n        each(obj, function (value, index, list) {\n            index = keys ? keys[--length] : --length;\n            if (!initial) {\n                memo = obj[index];\n                initial = true;\n            } else {\n                memo = iterator.call(context, memo, obj[index], index, list);\n            }\n        });\n        if (!initial)\n            throw new TypeError(reduceError);\n        return memo;\n    };\n\n    // Return the first value which passes a truth test. Aliased as `detect`.\n    _.find = _.detect = function (obj, predicate, context) {\n        var result;\n        any(obj, function (value, index, list) {\n            if (predicate.call(context, value, index, list)) {\n                result = value;\n                return true;\n            }\n        });\n        return result;\n    };\n\n    // Return all the elements that pass a truth test.\n    // Delegates to **ECMAScript 5**'s native `filter` if available.\n    // Aliased as `select`.\n    _.filter = _.select = function (obj, predicate, context) {\n        var results = [];\n        if (obj == null)\n            return results;\n        if (nativeFilter && obj.filter === nativeFilter)\n            return obj.filter(predicate, context);\n        each(obj, function (value, index, list) {\n            if (predicate.call(context, value, index, list))\n                results.push(value);\n        });\n        return results;\n    };\n\n    // Return all the elements for which a truth test fails.\n    _.reject = function (obj, predicate, context) {\n        return _.filter(obj, function (value, index, list) {\n            return !predicate.call(context, value, index, list);\n        }, context);\n    };\n\n    // Determine whether all of the elements match a truth test.\n    // Delegates to **ECMAScript 5**'s native `every` if available.\n    // Aliased as `all`.\n    _.every = _.all = function (obj, predicate, context) {\n        predicate || (predicate = _.identity);\n        var result = true;\n        if (obj == null)\n            return result;\n        if (nativeEvery && obj.every === nativeEvery)\n            return obj.every(predicate, context);\n        each(obj, function (value, index, list) {\n            if (!(result = result && predicate.call(context, value, index, list)))\n                return breaker;\n        });\n        return !!result;\n    };\n\n    // Determine if at least one element in the object matches a truth test.\n    // Delegates to **ECMAScript 5**'s native `some` if available.\n    // Aliased as `any`.\n    var any = _.some = _.any = function (obj, predicate, context) {\n        predicate || (predicate = _.identity);\n        var result = false;\n        if (obj == null)\n            return result;\n        if (nativeSome && obj.some === nativeSome)\n            return obj.some(predicate, context);\n        each(obj, function (value, index, list) {\n            if (result || (result = predicate.call(context, value, index, list)))\n                return breaker;\n        });\n        return !!result;\n    };\n\n    // Determine if the array or object contains a given value (using `===`).\n    // Aliased as `include`.\n    _.contains = _.include = function (obj, target) {\n        if (obj == null)\n            return false;\n        if (nativeIndexOf && obj.indexOf === nativeIndexOf)\n            return obj.indexOf(target) != -1;\n        return any(obj, function (value) {\n            return value === target;\n        });\n    };\n\n    // Invoke a method (with arguments) on every item in a collection.\n    _.invoke = function (obj, method) {\n        var args = slice.call(arguments, 2);\n        var isFunc = _.isFunction(method);\n        return _.map(obj, function (value) {\n            return (isFunc ? method : value[method]).apply(value, args);\n        });\n    };\n\n    // Convenience version of a common use case of `map`: fetching a property.\n    _.pluck = function (obj, key) {\n        return _.map(obj, _.property(key));\n    };\n\n    // Convenience version of a common use case of `filter`: selecting only objects\n    // containing specific `key:value` pairs.\n    _.where = function (obj, attrs) {\n        return _.filter(obj, _.matches(attrs));\n    };\n\n    // Convenience version of a common use case of `find`: getting the first object\n    // containing specific `key:value` pairs.\n    _.findWhere = function (obj, attrs) {\n        return _.find(obj, _.matches(attrs));\n    };\n\n    // Return the maximum element or (element-based computation).\n    // Can't optimize arrays of integers longer than 65,535 elements.\n    // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n    _.max = function (obj, iterator, context) {\n        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n            return Math.max.apply(Math, obj);\n        }\n        var result = -Infinity, lastComputed = -Infinity;\n        each(obj, function (value, index, list) {\n            var computed = iterator ? iterator.call(context, value, index, list) : value;\n            if (computed > lastComputed) {\n                result = value;\n                lastComputed = computed;\n            }\n        });\n        return result;\n    };\n\n    // Return the minimum element (or element-based computation).\n    _.min = function (obj, iterator, context) {\n        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n            return Math.min.apply(Math, obj);\n        }\n        var result = Infinity, lastComputed = Infinity;\n        each(obj, function (value, index, list) {\n            var computed = iterator ? iterator.call(context, value, index, list) : value;\n            if (computed < lastComputed) {\n                result = value;\n                lastComputed = computed;\n            }\n        });\n        return result;\n    };\n\n    // Shuffle an array, using the modern version of the\n    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n    _.shuffle = function (obj) {\n        var rand;\n        var index = 0;\n        var shuffled = [];\n        each(obj, function (value) {\n            rand = _.random(index++);\n            shuffled[index - 1] = shuffled[rand];\n            shuffled[rand] = value;\n        });\n        return shuffled;\n    };\n\n    // Sample **n** random values from a collection.\n    // If **n** is not specified, returns a single random element.\n    // The internal `guard` argument allows it to work with `map`.\n    _.sample = function (obj, n, guard) {\n        if (n == null || guard) {\n            if (obj.length !== +obj.length)\n                obj = _.values(obj);\n            return obj[_.random(obj.length - 1)];\n        }\n        return _.shuffle(obj).slice(0, Math.max(0, n));\n    };\n\n    // An internal function to generate lookup iterators.\n    var lookupIterator = function (value) {\n        if (value == null)\n            return _.identity;\n        if (_.isFunction(value))\n            return value;\n        return _.property(value);\n    };\n\n    // Sort the object's values by a criterion produced by an iterator.\n    _.sortBy = function (obj, iterator, context) {\n        iterator = lookupIterator(iterator);\n        return _.pluck(_.map(obj, function (value, index, list) {\n            return {\n                value: value,\n                index: index,\n                criteria: iterator.call(context, value, index, list)\n            };\n        }).sort(function (left, right) {\n            var a = left.criteria;\n            var b = right.criteria;\n            if (a !== b) {\n                if (a > b || a === void 0)\n                    return 1;\n                if (a < b || b === void 0)\n                    return -1;\n            }\n            return left.index - right.index;\n        }), 'value');\n    };\n\n    // An internal function used for aggregate \"group by\" operations.\n    var group = function (behavior) {\n        return function (obj, iterator, context) {\n            var result = {};\n            iterator = lookupIterator(iterator);\n            each(obj, function (value, index) {\n                var key = iterator.call(context, value, index, obj);\n                behavior(result, key, value);\n            });\n            return result;\n        };\n    };\n\n    // Groups the object's values by a criterion. Pass either a string attribute\n    // to group by, or a function that returns the criterion.\n    _.groupBy = group(function (result, key, value) {\n        _.has(result, key) ? result[key].push(value) : result[key] = [value];\n    });\n\n    // Indexes the object's values by a criterion, similar to `groupBy`, but for\n    // when you know that your index values will be unique.\n    _.indexBy = group(function (result, key, value) {\n        result[key] = value;\n    });\n\n    // Counts instances of an object that group by a certain criterion. Pass\n    // either a string attribute to count by, or a function that returns the\n    // criterion.\n    _.countBy = group(function (result, key) {\n        _.has(result, key) ? result[key]++ : result[key] = 1;\n    });\n\n    // Use a comparator function to figure out the smallest index at which\n    // an object should be inserted so as to maintain order. Uses binary search.\n    _.sortedIndex = function (array, obj, iterator, context) {\n        iterator = lookupIterator(iterator);\n        var value = iterator.call(context, obj);\n        var low = 0, high = array.length;\n        while (low < high) {\n            var mid = (low + high) >>> 1;\n            iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n        }\n        return low;\n    };\n\n    // Safely create a real, live array from anything iterable.\n    _.toArray = function (obj) {\n        if (!obj)\n            return [];\n        if (_.isArray(obj))\n            return slice.call(obj);\n        if (obj.length === +obj.length)\n            return _.map(obj, _.identity);\n        return _.values(obj);\n    };\n\n    // Return the number of elements in an object.\n    _.size = function (obj) {\n        if (obj == null)\n            return 0;\n        return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n    };\n\n    // Array Functions\n    // ---------------\n\n    // Get the first element of an array. Passing **n** will return the first N\n    // values in the array. Aliased as `head` and `take`. The **guard** check\n    // allows it to work with `_.map`.\n    _.first = _.head = _.take = function (array, n, guard) {\n        if (array == null)\n            return void 0;\n        if ((n == null) || guard)\n            return array[0];\n        if (n < 0)\n            return [];\n        return slice.call(array, 0, n);\n    };\n\n    // Returns everything but the last entry of the array. Especially useful on\n    // the arguments object. Passing **n** will return all the values in\n    // the array, excluding the last N. The **guard** check allows it to work with\n    // `_.map`.\n    _.initial = function (array, n, guard) {\n        return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n    };\n\n    // Get the last element of an array. Passing **n** will return the last N\n    // values in the array. The **guard** check allows it to work with `_.map`.\n    _.last = function (array, n, guard) {\n        if (array == null)\n            return void 0;\n        if ((n == null) || guard)\n            return array[array.length - 1];\n        return slice.call(array, Math.max(array.length - n, 0));\n    };\n\n    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n    // Especially useful on the arguments object. Passing an **n** will return\n    // the rest N values in the array. The **guard**\n    // check allows it to work with `_.map`.\n    _.rest = _.tail = _.drop = function (array, n, guard) {\n        return slice.call(array, (n == null) || guard ? 1 : n);\n    };\n\n    // Trim out all falsy values from an array.\n    _.compact = function (array) {\n        return _.filter(array, _.identity);\n    };\n\n    // Internal implementation of a recursive `flatten` function.\n    var flatten = function (input, shallow, output) {\n        if (shallow && _.every(input, _.isArray)) {\n            return concat.apply(output, input);\n        }\n        each(input, function (value) {\n            if (_.isArray(value) || _.isArguments(value)) {\n                shallow ? push.apply(output, value) : flatten(value, shallow, output);\n            } else {\n                output.push(value);\n            }\n        });\n        return output;\n    };\n\n    // Flatten out an array, either recursively (by default), or just one level.\n    _.flatten = function (array, shallow) {\n        return flatten(array, shallow, []);\n    };\n\n    // Return a version of the array that does not contain the specified value(s).\n    _.without = function (array) {\n        return _.difference(array, slice.call(arguments, 1));\n    };\n\n    // Split an array into two arrays: one whose elements all satisfy the given\n    // predicate, and one whose elements all do not satisfy the predicate.\n    _.partition = function (array, predicate) {\n        var pass = [], fail = [];\n        each(array, function (elem) {\n            (predicate(elem) ? pass : fail).push(elem);\n        });\n        return [pass, fail];\n    };\n\n    // Produce a duplicate-free version of the array. If the array has already\n    // been sorted, you have the option of using a faster algorithm.\n    // Aliased as `unique`.\n    _.uniq = _.unique = function (array, isSorted, iterator, context) {\n        if (_.isFunction(isSorted)) {\n            context = iterator;\n            iterator = isSorted;\n            isSorted = false;\n        }\n        var initial = iterator ? _.map(array, iterator, context) : array;\n        var results = [];\n        var seen = [];\n        each(initial, function (value, index) {\n            if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n                seen.push(value);\n                results.push(array[index]);\n            }\n        });\n        return results;\n    };\n\n    // Produce an array that contains the union: each distinct element from all of\n    // the passed-in arrays.\n    _.union = function () {\n        return _.uniq(_.flatten(arguments, true));\n    };\n\n    // Produce an array that contains every item shared between all the\n    // passed-in arrays.\n    _.intersection = function (array) {\n        var rest = slice.call(arguments, 1);\n        return _.filter(_.uniq(array), function (item) {\n            return _.every(rest, function (other) {\n                return _.contains(other, item);\n            });\n        });\n    };\n\n    // Take the difference between one array and a number of other arrays.\n    // Only the elements present in just the first array will remain.\n    _.difference = function (array) {\n        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n        return _.filter(array, function (value) {\n            return !_.contains(rest, value);\n        });\n    };\n\n    // Zip together multiple lists into a single array -- elements that share\n    // an index go together.\n    _.zip = function () {\n        var length = _.max(_.pluck(arguments, 'length').concat(0));\n        var results = new Array(length);\n        for (var i = 0; i < length; i++) {\n            results[i] = _.pluck(arguments, '' + i);\n        }\n        return results;\n    };\n\n    // Converts lists into objects. Pass either a single array of `[key, value]`\n    // pairs, or two parallel arrays of the same length -- one of keys, and one of\n    // the corresponding values.\n    _.object = function (list, values) {\n        if (list == null)\n            return {};\n        var result = {};\n        for (var i = 0, length = list.length; i < length; i++) {\n            if (values) {\n                result[list[i]] = values[i];\n            } else {\n                result[list[i][0]] = list[i][1];\n            }\n        }\n        return result;\n    };\n\n    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n    // we need this function. Return the position of the first occurrence of an\n    // item in an array, or -1 if the item is not included in the array.\n    // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n    // If the array is large and already in sort order, pass `true`\n    // for **isSorted** to use binary search.\n    _.indexOf = function (array, item, isSorted) {\n        if (array == null)\n            return -1;\n        var i = 0, length = array.length;\n        if (isSorted) {\n            if (typeof isSorted == 'number') {\n                i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n            } else {\n                i = _.sortedIndex(array, item);\n                return array[i] === item ? i : -1;\n            }\n        }\n        if (nativeIndexOf && array.indexOf === nativeIndexOf)\n            return array.indexOf(item, isSorted);\n        for (; i < length; i++)\n            if (array[i] === item)\n                return i;\n        return -1;\n    };\n\n    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n    _.lastIndexOf = function (array, item, from) {\n        if (array == null)\n            return -1;\n        var hasIndex = from != null;\n        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n            return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n        }\n        var i = (hasIndex ? from : array.length);\n        while (i--)\n            if (array[i] === item)\n                return i;\n        return -1;\n    };\n\n    // Generate an integer Array containing an arithmetic progression. A port of\n    // the native Python `range()` function. See\n    // [the Python documentation](http://docs.python.org/library/functions.html#range).\n    _.range = function (start, stop, step) {\n        if (arguments.length <= 1) {\n            stop = start || 0;\n            start = 0;\n        }\n        step = arguments[2] || 1;\n\n        var length = Math.max(Math.ceil((stop - start) / step), 0);\n        var idx = 0;\n        var range = new Array(length);\n\n        while (idx < length) {\n            range[idx++] = start;\n            start += step;\n        }\n\n        return range;\n    };\n\n    // Function (ahem) Functions\n    // ------------------\n\n    // Reusable constructor function for prototype setting.\n    var ctor = function () {\n    };\n\n    // Create a function bound to a given object (assigning `this`, and arguments,\n    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n    // available.\n    _.bind = function (func, context) {\n        var args, bound;\n        if (nativeBind && func.bind === nativeBind)\n            return nativeBind.apply(func, slice.call(arguments, 1));\n        if (!_.isFunction(func))\n            throw new TypeError;\n        args = slice.call(arguments, 2);\n        return bound = function () {\n            if (!(this instanceof bound))\n                return func.apply(context, args.concat(slice.call(arguments)));\n            ctor.prototype = func.prototype;\n            var self = new ctor;\n            ctor.prototype = null;\n            var result = func.apply(self, args.concat(slice.call(arguments)));\n            if (Object(result) === result)\n                return result;\n            return self;\n        };\n    };\n\n    // Partially apply a function by creating a version that has had some of its\n    // arguments pre-filled, without changing its dynamic `this` context. _ acts\n    // as a placeholder, allowing any combination of arguments to be pre-filled.\n    _.partial = function (func) {\n        var boundArgs = slice.call(arguments, 1);\n        return function () {\n            var position = 0;\n            var args = boundArgs.slice();\n            for (var i = 0, length = args.length; i < length; i++) {\n                if (args[i] === _)\n                    args[i] = arguments[position++];\n            }\n            while (position < arguments.length)\n                args.push(arguments[position++]);\n            return func.apply(this, args);\n        };\n    };\n\n    // Bind a number of an object's methods to that object. Remaining arguments\n    // are the method names to be bound. Useful for ensuring that all callbacks\n    // defined on an object belong to it.\n    _.bindAll = function (obj) {\n        var funcs = slice.call(arguments, 1);\n        if (funcs.length === 0)\n            throw new Error('bindAll must be passed function names');\n        each(funcs, function (f) {\n            obj[f] = _.bind(obj[f], obj);\n        });\n        return obj;\n    };\n\n    // Memoize an expensive function by storing its results.\n    _.memoize = function (func, hasher) {\n        var memo = {};\n        hasher || (hasher = _.identity);\n        return function () {\n            var key = hasher.apply(this, arguments);\n            return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n        };\n    };\n\n    // Delays a function for the given number of milliseconds, and then calls\n    // it with the arguments supplied.\n    _.delay = function (func, wait) {\n        var args = slice.call(arguments, 2);\n        return setTimeout(function () {\n            return func.apply(null, args);\n        }, wait);\n    };\n\n    // Defers a function, scheduling it to run after the current call stack has\n    // cleared.\n    _.defer = function (func) {\n        return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n    };\n\n    // Returns a function, that, when invoked, will only be triggered at most once\n    // during a given window of time. Normally, the throttled function will run\n    // as much as it can, without ever going more than once per `wait` duration;\n    // but if you'd like to disable the execution on the leading edge, pass\n    // `{leading: false}`. To disable execution on the trailing edge, ditto.\n    _.throttle = function (func, wait, options) {\n        var context, args, result;\n        var timeout = null;\n        var previous = 0;\n        options || (options = {});\n        var later = function () {\n            previous = options.leading === false ? 0 : _.now();\n            timeout = null;\n            result = func.apply(context, args);\n            context = args = null;\n        };\n        return function () {\n            var now = _.now();\n            if (!previous && options.leading === false)\n                previous = now;\n            var remaining = wait - (now - previous);\n            context = this;\n            args = arguments;\n            if (remaining <= 0) {\n                clearTimeout(timeout);\n                timeout = null;\n                previous = now;\n                result = func.apply(context, args);\n                context = args = null;\n            } else if (!timeout && options.trailing !== false) {\n                timeout = setTimeout(later, remaining);\n            }\n            return result;\n        };\n    };\n\n    // Returns a function, that, as long as it continues to be invoked, will not\n    // be triggered. The function will be called after it stops being called for\n    // N milliseconds. If `immediate` is passed, trigger the function on the\n    // leading edge, instead of the trailing.\n    _.debounce = function (func, wait, immediate) {\n        var timeout, args, context, timestamp, result;\n\n        var later = function () {\n            var last = _.now() - timestamp;\n            if (last < wait) {\n                timeout = setTimeout(later, wait - last);\n            } else {\n                timeout = null;\n                if (!immediate) {\n                    result = func.apply(context, args);\n                    context = args = null;\n                }\n            }\n        };\n\n        return function () {\n            context = this;\n            args = arguments;\n            timestamp = _.now();\n            var callNow = immediate && !timeout;\n            if (!timeout) {\n                timeout = setTimeout(later, wait);\n            }\n            if (callNow) {\n                result = func.apply(context, args);\n                context = args = null;\n            }\n\n            return result;\n        };\n    };\n\n    // Returns a function that will be executed at most one time, no matter how\n    // often you call it. Useful for lazy initialization.\n    _.once = function (func) {\n        var ran = false, memo;\n        return function () {\n            if (ran)\n                return memo;\n            ran = true;\n            memo = func.apply(this, arguments);\n            func = null;\n            return memo;\n        };\n    };\n\n    // Returns the first function passed as an argument to the second,\n    // allowing you to adjust arguments, run code before and after, and\n    // conditionally execute the original function.\n    _.wrap = function (func, wrapper) {\n        return _.partial(wrapper, func);\n    };\n\n    // Returns a function that is the composition of a list of functions, each\n    // consuming the return value of the function that follows.\n    _.compose = function () {\n        var funcs = arguments;\n        return function () {\n            var args = arguments;\n            for (var i = funcs.length - 1; i >= 0; i--) {\n                args = [funcs[i].apply(this, args)];\n            }\n            return args[0];\n        };\n    };\n\n    // Returns a function that will only be executed after being called N times.\n    _.after = function (times, func) {\n        return function () {\n            if (--times < 1) {\n                return func.apply(this, arguments);\n            }\n        };\n    };\n\n    // Object Functions\n    // ----------------\n\n    // Retrieve the names of an object's properties.\n    // Delegates to **ECMAScript 5**'s native `Object.keys`\n    _.keys = function (obj) {\n        if (!_.isObject(obj))\n            return [];\n        if (nativeKeys)\n            return nativeKeys(obj);\n        var keys = [];\n        for (var key in obj)\n            if (_.has(obj, key))\n                keys.push(key);\n        return keys;\n    };\n\n    // Retrieve the values of an object's properties.\n    _.values = function (obj) {\n        var keys = _.keys(obj);\n        var length = keys.length;\n        var values = new Array(length);\n        for (var i = 0; i < length; i++) {\n            values[i] = obj[keys[i]];\n        }\n        return values;\n    };\n\n    // Convert an object into a list of `[key, value]` pairs.\n    _.pairs = function (obj) {\n        var keys = _.keys(obj);\n        var length = keys.length;\n        var pairs = new Array(length);\n        for (var i = 0; i < length; i++) {\n            pairs[i] = [keys[i], obj[keys[i]]];\n        }\n        return pairs;\n    };\n\n    // Invert the keys and values of an object. The values must be serializable.\n    _.invert = function (obj) {\n        var result = {};\n        var keys = _.keys(obj);\n        for (var i = 0, length = keys.length; i < length; i++) {\n            result[obj[keys[i]]] = keys[i];\n        }\n        return result;\n    };\n\n    // Return a sorted list of the function names available on the object.\n    // Aliased as `methods`\n    _.functions = _.methods = function (obj) {\n        var names = [];\n        for (var key in obj) {\n            if (_.isFunction(obj[key]))\n                names.push(key);\n        }\n        return names.sort();\n    };\n\n    // Extend a given object with all the properties in passed-in object(s).\n    _.extend = function (obj) {\n        each(slice.call(arguments, 1), function (source) {\n            if (source) {\n                for (var prop in source) {\n                    obj[prop] = source[prop];\n                }\n            }\n        });\n        return obj;\n    };\n\n    // Return a copy of the object only containing the whitelisted properties.\n    _.pick = function (obj) {\n        var copy = {};\n        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n        each(keys, function (key) {\n            if (key in obj)\n                copy[key] = obj[key];\n        });\n        return copy;\n    };\n\n    // Return a copy of the object without the blacklisted properties.\n    _.omit = function (obj) {\n        var copy = {};\n        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n        for (var key in obj) {\n            if (!_.contains(keys, key))\n                copy[key] = obj[key];\n        }\n        return copy;\n    };\n\n    // Fill in a given object with default properties.\n    _.defaults = function (obj) {\n        each(slice.call(arguments, 1), function (source) {\n            if (source) {\n                for (var prop in source) {\n                    if (obj[prop] === void 0)\n                        obj[prop] = source[prop];\n                }\n            }\n        });\n        return obj;\n    };\n\n    // Create a (shallow-cloned) duplicate of an object.\n    _.clone = function (obj) {\n        if (!_.isObject(obj))\n            return obj;\n        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n    };\n\n    // Invokes interceptor with the obj, and then returns obj.\n    // The primary purpose of this method is to \"tap into\" a method chain, in\n    // order to perform operations on intermediate results within the chain.\n    _.tap = function (obj, interceptor) {\n        interceptor(obj);\n        return obj;\n    };\n\n    // Internal recursive comparison function for `isEqual`.\n    var eq = function (a, b, aStack, bStack) {\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n        if (a === b)\n            return a !== 0 || 1 / a == 1 / b;\n        // A strict comparison is necessary because `null == undefined`.\n        if (a == null || b == null)\n            return a === b;\n        // Unwrap any wrapped objects.\n        if (a instanceof _)\n            a = a._wrapped;\n        if (b instanceof _)\n            b = b._wrapped;\n        // Compare `[[Class]]` names.\n        var className = toString.call(a);\n        if (className != toString.call(b))\n            return false;\n        switch (className) {\n            // Strings, numbers, dates, and booleans are compared by value.\n            case '[object String]':\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n                // equivalent to `new String(\"5\")`.\n                return a == String(b);\n            case '[object Number]':\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n                // other numeric values.\n                return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n            case '[object Date]':\n            case '[object Boolean]':\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n                // millisecond representations. Note that invalid dates with millisecond representations\n                // of `NaN` are not equivalent.\n                return +a == +b;\n                // RegExps are compared by their source patterns and flags.\n            case '[object RegExp]':\n                return a.source == b.source &&\n                    a.global == b.global &&\n                    a.multiline == b.multiline &&\n                    a.ignoreCase == b.ignoreCase;\n        }\n        if (typeof a != 'object' || typeof b != 'object')\n            return false;\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n        var length = aStack.length;\n        while (length--) {\n            // Linear search. Performance is inversely proportional to the number of\n            // unique nested structures.\n            if (aStack[length] == a)\n                return bStack[length] == b;\n        }\n        // Objects with different constructors are not equivalent, but `Object`s\n        // from different frames are.\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n            _.isFunction(bCtor) && (bCtor instanceof bCtor))\n            && ('constructor' in a && 'constructor' in b)) {\n            return false;\n        }\n        // Add the first object to the stack of traversed objects.\n        aStack.push(a);\n        bStack.push(b);\n        var size = 0, result = true;\n        // Recursively compare objects and arrays.\n        if (className == '[object Array]') {\n            // Compare array lengths to determine if a deep comparison is necessary.\n            size = a.length;\n            result = size == b.length;\n            if (result) {\n                // Deep compare the contents, ignoring non-numeric properties.\n                while (size--) {\n                    if (!(result = eq(a[size], b[size], aStack, bStack)))\n                        break;\n                }\n            }\n        } else {\n            // Deep compare objects.\n            for (var key in a) {\n                if (_.has(a, key)) {\n                    // Count the expected number of properties.\n                    size++;\n                    // Deep compare each member.\n                    if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)))\n                        break;\n                }\n            }\n            // Ensure that both objects contain the same number of properties.\n            if (result) {\n                for (key in b) {\n                    if (_.has(b, key) && !(size--))\n                        break;\n                }\n                result = !size;\n            }\n        }\n        // Remove the first object from the stack of traversed objects.\n        aStack.pop();\n        bStack.pop();\n        return result;\n    };\n\n    // Perform a deep comparison to check if two objects are equal.\n    _.isEqual = function (a, b) {\n        return eq(a, b, [], []);\n    };\n\n    // Is a given array, string, or object empty?\n    // An \"empty\" object has no enumerable own-properties.\n    _.isEmpty = function (obj) {\n        if (obj == null)\n            return true;\n        if (_.isArray(obj) || _.isString(obj))\n            return obj.length === 0;\n        for (var key in obj)\n            if (_.has(obj, key))\n                return false;\n        return true;\n    };\n\n    // Is a given value a DOM element?\n    _.isElement = function (obj) {\n        return !!(obj && obj.nodeType === 1);\n    };\n\n    // Is a given value an array?\n    // Delegates to ECMA5's native Array.isArray\n    _.isArray = nativeIsArray || function (obj) {\n        return toString.call(obj) == '[object Array]';\n    };\n\n    // Is a given variable an object?\n    _.isObject = function (obj) {\n        return obj === Object(obj);\n    };\n\n    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {\n        _['is' + name] = function (obj) {\n            return toString.call(obj) == '[object ' + name + ']';\n        };\n    });\n\n    // Define a fallback version of the method in browsers (ahem, IE), where\n    // there isn't any inspectable \"Arguments\" type.\n    if (!_.isArguments(arguments)) {\n        _.isArguments = function (obj) {\n            return !!(obj && _.has(obj, 'callee'));\n        };\n    }\n\n    // Optimize `isFunction` if appropriate.\n    if (true) {\n        _.isFunction = function (obj) {\n            return typeof obj === 'function';\n        };\n    }\n\n    // Is a given object a finite number?\n    _.isFinite = function (obj) {\n        return isFinite(obj) && !isNaN(parseFloat(obj));\n    };\n\n    // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n    _.isNaN = function (obj) {\n        return _.isNumber(obj) && obj != +obj;\n    };\n\n    // Is a given value a boolean?\n    _.isBoolean = function (obj) {\n        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n    };\n\n    // Is a given value equal to null?\n    _.isNull = function (obj) {\n        return obj === null;\n    };\n\n    // Is a given variable undefined?\n    _.isUndefined = function (obj) {\n        return obj === void 0;\n    };\n\n    // Shortcut function for checking if an object has a given property directly\n    // on itself (in other words, not on a prototype).\n    _.has = function (obj, key) {\n        return hasOwnProperty.call(obj, key);\n    };\n\n    // Utility Functions\n    // -----------------\n\n    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n    // previous owner. Returns a reference to the Underscore object.\n    _.noConflict = function () {\n        root._ = previousUnderscore;\n        return this;\n    };\n\n    // Keep the identity function around for default iterators.\n    _.identity = function (value) {\n        return value;\n    };\n\n    _.constant = function (value) {\n        return function () {\n            return value;\n        };\n    };\n\n    _.property = function (key) {\n        return function (obj) {\n            return obj[key];\n        };\n    };\n\n    // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n    _.matches = function (attrs) {\n        return function (obj) {\n            if (obj === attrs)\n                return true; //avoid comparing an object to itself.\n            for (var key in attrs) {\n                if (attrs[key] !== obj[key])\n                    return false;\n            }\n            return true;\n        }\n    };\n\n    // Run a function **n** times.\n    _.times = function (n, iterator, context) {\n        var accum = Array(Math.max(0, n));\n        for (var i = 0; i < n; i++)\n            accum[i] = iterator.call(context, i);\n        return accum;\n    };\n\n    // Return a random integer between min and max (inclusive).\n    _.random = function (min, max) {\n        if (max == null) {\n            max = min;\n            min = 0;\n        }\n        return min + Math.floor(Math.random() * (max - min + 1));\n    };\n\n    // A (possibly faster) way to get the current timestamp as an integer.\n    _.now = Date.now || function () {\n        return new Date().getTime();\n    };\n\n    // List of HTML entities for escaping.\n    var entityMap = {\n        escape: {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#x27;'\n        }\n    };\n    entityMap.unescape = _.invert(entityMap.escape);\n\n    // Regexes containing the keys and values listed immediately above.\n    var entityRegexes = {\n        escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n        unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n    };\n\n    // Functions for escaping and unescaping strings to/from HTML interpolation.\n    _.each(['escape', 'unescape'], function (method) {\n        _[method] = function (string) {\n            if (string == null)\n                return '';\n            return ('' + string).replace(entityRegexes[method], function (match) {\n                return entityMap[method][match];\n            });\n        };\n    });\n\n    // If the value of the named `property` is a function then invoke it with the\n    // `object` as context; otherwise, return it.\n    _.result = function (object, property) {\n        if (object == null)\n            return void 0;\n        var value = object[property];\n        return _.isFunction(value) ? value.call(object) : value;\n    };\n\n    // Add your own custom functions to the Underscore object.\n    _.mixin = function (obj) {\n        each(_.functions(obj), function (name) {\n            var func = _[name] = obj[name];\n            _.prototype[name] = function () {\n                var args = [this._wrapped];\n                push.apply(args, arguments);\n                return result.call(this, func.apply(_, args));\n            };\n        });\n    };\n\n    // Generate a unique integer id (unique within the entire client session).\n    // Useful for temporary DOM ids.\n    var idCounter = 0;\n    _.uniqueId = function (prefix) {\n        var id = ++idCounter + '';\n        return prefix ? prefix + id : id;\n    };\n\n    // By default, Underscore uses ERB-style template delimiters, change the\n    // following template settings to use alternative delimiters.\n    _.templateSettings = {\n        evaluate: /<%([\\s\\S]+?)%>/g,\n        interpolate: /<%=([\\s\\S]+?)%>/g,\n        escape: /<%-([\\s\\S]+?)%>/g\n    };\n\n    // When customizing `templateSettings`, if you don't want to define an\n    // interpolation, evaluation or escaping regex, we need one that is\n    // guaranteed not to match.\n    var noMatch = /(.)^/;\n\n    // Certain characters need to be escaped so that they can be put into a\n    // string literal.\n    var escapes = {\n        \"'\": \"'\",\n        '\\\\': '\\\\',\n        '\\r': 'r',\n        '\\n': 'n',\n        '\\t': 't',\n        '\\u2028': 'u2028',\n        '\\u2029': 'u2029'\n    };\n\n    var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n    // JavaScript micro-templating, similar to John Resig's implementation.\n    // Underscore templating handles arbitrary delimiters, preserves whitespace,\n    // and correctly escapes quotes within interpolated code.\n    _.template = function (text, data, settings) {\n        var render;\n        settings = _.defaults({}, settings, _.templateSettings);\n\n        // Combine delimiters into one regular expression via alternation.\n        var matcher = new RegExp([\n            (settings.escape || noMatch).source,\n            (settings.interpolate || noMatch).source,\n            (settings.evaluate || noMatch).source\n        ].join('|') + '|$', 'g');\n\n        // Compile the template source, escaping string literals appropriately.\n        var index = 0;\n        var source = \"__p+='\";\n        text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {\n            source += text.slice(index, offset)\n                .replace(escaper, function (match) {\n                    return '\\\\' + escapes[match];\n                });\n\n            if (escape) {\n                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n            }\n            if (interpolate) {\n                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n            }\n            if (evaluate) {\n                source += \"';\\n\" + evaluate + \"\\n__p+='\";\n            }\n            index = offset + match.length;\n            return match;\n        });\n        source += \"';\\n\";\n\n        // If a variable is not specified, place data values in local scope.\n        if (!settings.variable)\n            source = 'with(obj||{}){\\n' + source + '}\\n';\n\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\n            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n            source + \"return __p;\\n\";\n\n        try {\n            render = new Function(settings.variable || 'obj', '_', source);\n        } catch (e) {\n            e.source = source;\n            throw e;\n        }\n\n        if (data)\n            return render(data, _);\n        var template = function (data) {\n            return render.call(this, data, _);\n        };\n\n        // Provide the compiled function source as a convenience for precompilation.\n        template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n        return template;\n    };\n\n    // Add a \"chain\" function, which will delegate to the wrapper.\n    _.chain = function (obj) {\n        return _(obj).chain();\n    };\n\n    // OOP\n    // ---------------\n    // If Underscore is called as a function, it returns a wrapped object that\n    // can be used OO-style. This wrapper holds altered versions of all the\n    // underscore functions. Wrapped objects may be chained.\n\n    // Helper function to continue chaining intermediate results.\n    var result = function (obj) {\n        return this._chain ? _(obj).chain() : obj;\n    };\n\n    // Add all of the Underscore functions to the wrapper object.\n    _.mixin(_);\n\n    // Add all mutator Array functions to the wrapper.\n    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {\n        var method = ArrayProto[name];\n        _.prototype[name] = function () {\n            var obj = this._wrapped;\n            method.apply(obj, arguments);\n            if ((name == 'shift' || name == 'splice') && obj.length === 0)\n                delete obj[0];\n            return result.call(this, obj);\n        };\n    });\n\n    // Add all accessor Array functions to the wrapper.\n    each(['concat', 'join', 'slice'], function (name) {\n        var method = ArrayProto[name];\n        _.prototype[name] = function () {\n            return result.call(this, method.apply(this._wrapped, arguments));\n        };\n    });\n\n    _.extend(_.prototype, {\n        // Start chaining a wrapped Underscore object.\n        chain: function () {\n            this._chain = true;\n            return this;\n        },\n        // Extracts the result from a wrapped and chained object.\n        value: function () {\n            return this._wrapped;\n        }\n\n    });\n\n    // AMD registration happens at the end for compatibility with AMD loaders\n    // that may not enforce next-turn semantics on modules. Even though general\n    // practice for AMD registration is to be anonymous, underscore registers\n    // as a named module because, like jQuery, it is a base library that is\n    // popular enough to be bundled in a third party lib, but not be part of\n    // an AMD load request. Those cases could generate an error when an\n    // anonymous define() is called outside of a loader request.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return _;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n}).call(this);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdmVuZG9yL3VuZGVyc2NvcmUuanM/NjBmNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0Esa0NBQWtDLEVBQUUsaUJBQWlCOztBQUVyRDtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLGlCQUFpQjs7QUFFM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgIFVuZGVyc2NvcmUuanMgMS42LjBcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICAgIHZhciByb290ID0gdGhpcztcblxuICAgIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gICAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAgIC8vIEVzdGFibGlzaCB0aGUgb2JqZWN0IHRoYXQgZ2V0cyByZXR1cm5lZCB0byBicmVhayBvdXQgb2YgYSBsb29wIGl0ZXJhdGlvbi5cbiAgICB2YXIgYnJlYWtlciA9IHt9O1xuXG4gICAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgICB2YXJcbiAgICAgICAgcHVzaCA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICAgICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgICBjb25jYXQgPSBBcnJheVByb3RvLmNvbmNhdCxcbiAgICAgICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAgIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICAgIHZhclxuICAgICAgICBuYXRpdmVGb3JFYWNoID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgICAgICBuYXRpdmVNYXAgPSBBcnJheVByb3RvLm1hcCxcbiAgICAgICAgbmF0aXZlUmVkdWNlID0gQXJyYXlQcm90by5yZWR1Y2UsXG4gICAgICAgIG5hdGl2ZVJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodCxcbiAgICAgICAgbmF0aXZlRmlsdGVyID0gQXJyYXlQcm90by5maWx0ZXIsXG4gICAgICAgIG5hdGl2ZUV2ZXJ5ID0gQXJyYXlQcm90by5ldmVyeSxcbiAgICAgICAgbmF0aXZlU29tZSA9IEFycmF5UHJvdG8uc29tZSxcbiAgICAgICAgbmF0aXZlSW5kZXhPZiA9IEFycmF5UHJvdG8uaW5kZXhPZixcbiAgICAgICAgbmF0aXZlTGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mLFxuICAgICAgICBuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICAgICAgbmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzLFxuICAgICAgICBuYXRpdmVCaW5kID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgICB2YXIgXyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpXG4gICAgICAgICAgICByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICAgICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gICAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAgIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMuXyA9IF87XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5fID0gXztcbiAgICB9XG5cbiAgICAvLyBDdXJyZW50IHZlcnNpb24uXG4gICAgXy5WRVJTSU9OID0gJzEuNi4wJztcblxuICAgIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAgIC8vIEhhbmRsZXMgb2JqZWN0cyB3aXRoIHRoZSBidWlsdC1pbiBgZm9yRWFjaGAsIGFycmF5cywgYW5kIHJhdyBvYmplY3RzLlxuICAgIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmb3JFYWNoYCBpZiBhdmFpbGFibGUuXG4gICAgdmFyIGVhY2ggPSBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAob2JqID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaikgPT09IGJyZWFrZXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuXG4gICAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAob2JqID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApXG4gICAgICAgICAgICByZXR1cm4gb2JqLm1hcChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICAgIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gICAgLy8gb3IgYGZvbGRsYC4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZWAgaWYgYXZhaWxhYmxlLlxuICAgIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKVxuICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dClcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZShpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5pdGlhbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gICAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZVJpZ2h0YCBpZiBhdmFpbGFibGUuXG4gICAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgICAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgICAgICBpZiAob2JqID09IG51bGwpXG4gICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KVxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09ICtsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgaW5kZXggPSBrZXlzID8ga2V5c1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgICAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIG1lbW8gPSBvYmpbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaW5kZXhdLCBpbmRleCwgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWluaXRpYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uIChvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBhbnkob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuXG4gICAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24gKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICBpZiAobmF0aXZlRmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiBvYmouZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICAgIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSlcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gICAgXy5yZWplY3QgPSBmdW5jdGlvbiAob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gICAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGV2ZXJ5YCBpZiBhdmFpbGFibGUuXG4gICAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbiAob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBfLmlkZW50aXR5KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChuYXRpdmVFdmVyeSAmJiBvYmouZXZlcnkgPT09IG5hdGl2ZUV2ZXJ5KVxuICAgICAgICAgICAgcmV0dXJuIG9iai5ldmVyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgaWYgKCEocmVzdWx0ID0gcmVzdWx0ICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBicmVha2VyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgc29tZWAgaWYgYXZhaWxhYmxlLlxuICAgIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gICAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24gKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gXy5pZGVudGl0eSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpXG4gICAgICAgICAgICByZXR1cm4gb2JqLnNvbWUocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgICAgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgfHwgKHJlc3VsdCA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBicmVha2VyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXG4gICAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZWAuXG4gICAgXy5jb250YWlucyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uIChvYmosIHRhcmdldCkge1xuICAgICAgICBpZiAob2JqID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKVxuICAgICAgICAgICAgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgICAgIHJldHVybiBhbnkob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gICAgXy5pbnZva2UgPSBmdW5jdGlvbiAob2JqLCBtZXRob2QpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICAgICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gICAgXy5wbHVjayA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICAgIH07XG5cbiAgICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gICAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgICBfLndoZXJlID0gZnVuY3Rpb24gKG9iaiwgYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XG4gICAgfTtcblxuICAgIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICAgIF8uZmluZFdoZXJlID0gZnVuY3Rpb24gKG9iaiwgYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCBvciAoZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gICAgLy8gQ2FuJ3Qgb3B0aW1pemUgYXJyYXlzIG9mIGludGVnZXJzIGxvbmdlciB0aGFuIDY1LDUzNSBlbGVtZW50cy5cbiAgICAvLyBTZWUgW1dlYktpdCBCdWcgODA3OTddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD04MDc5NylcbiAgICBfLm1heCA9IGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5O1xuICAgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICAgIF8ubWluID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5O1xuICAgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gU2h1ZmZsZSBhbiBhcnJheSwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAgIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgICBfLnNodWZmbGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciByYW5kO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgc2h1ZmZsZWQgPSBbXTtcbiAgICAgICAgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmFuZCA9IF8ucmFuZG9tKGluZGV4KyspO1xuICAgICAgICAgICAgc2h1ZmZsZWRbaW5kZXggLSAxXSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaHVmZmxlZDtcbiAgICB9O1xuXG4gICAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICAgIF8uc2FtcGxlID0gZnVuY3Rpb24gKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgICB9O1xuXG4gICAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbG9va3VwIGl0ZXJhdG9ycy5cbiAgICB2YXIgbG9va3VwSXRlcmF0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXy5pZGVudGl0eTtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdG9yLlxuICAgIF8uc29ydEJ5ID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICAgICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgICAgICB9KSwgJ3ZhbHVlJyk7XG4gICAgfTtcblxuICAgIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgICB2YXIgZ3JvdXAgPSBmdW5jdGlvbiAoYmVoYXZpb3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpdGVyYXRvciA9IGxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbiAocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldLnB1c2godmFsdWUpIDogcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICAgIH0pO1xuXG4gICAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAgIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbiAocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBjcml0ZXJpb24uXG4gICAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgICAgIF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldKysgOiByZXN1bHRba2V5XSA9IDE7XG4gICAgfSk7XG5cbiAgICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gICAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICAgIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqKTtcbiAgICAgICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVttaWRdKSA8IHZhbHVlID8gbG93ID0gbWlkICsgMSA6IGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvdztcbiAgICB9O1xuXG4gICAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgICBfLnRvQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoXy5pc0FycmF5KG9iaikpXG4gICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICAgICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgICBfLnNpemUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gICAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAgIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24gKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIGlmICgobiA9PSBudWxsKSB8fCBndWFyZClcbiAgICAgICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICAgICAgaWYgKG4gPCAwKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgbik7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAgIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gICAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXG4gICAgLy8gYF8ubWFwYC5cbiAgICBfLmluaXRpYWwgPSBmdW5jdGlvbiAoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbikpO1xuICAgIH07XG5cbiAgICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gICAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gICAgXy5sYXN0ID0gZnVuY3Rpb24gKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIGlmICgobiA9PSBudWxsKSB8fCBndWFyZClcbiAgICAgICAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAgIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gICAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqXG4gICAgLy8gY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICAgIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uIChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pO1xuICAgIH07XG5cbiAgICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gICAgXy5jb21wYWN0ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gICAgfTtcblxuICAgIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uIChpbnB1dCwgc2hhbGxvdywgb3V0cHV0KSB7XG4gICAgICAgIGlmIChzaGFsbG93ICYmIF8uZXZlcnkoaW5wdXQsIF8uaXNBcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkob3V0cHV0LCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWFjaChpbnB1dCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHNoYWxsb3cgPyBwdXNoLmFwcGx5KG91dHB1dCwgdmFsdWUpIDogZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgb3V0cHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICAgIF8uZmxhdHRlbiA9IGZ1bmN0aW9uIChhcnJheSwgc2hhbGxvdykge1xuICAgICAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgW10pO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgICBfLndpdGhvdXQgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xuXG4gICAgLy8gU3BsaXQgYW4gYXJyYXkgaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gICAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICAgIF8ucGFydGl0aW9uID0gZnVuY3Rpb24gKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgICAgICBlYWNoKGFycmF5LCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgKHByZWRpY2F0ZShlbGVtKSA/IHBhc3MgOiBmYWlsKS5wdXNoKGVsZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgICB9O1xuXG4gICAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gICAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oaXNTb3J0ZWQpKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gaXRlcmF0b3I7XG4gICAgICAgICAgICBpdGVyYXRvciA9IGlzU29ydGVkO1xuICAgICAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5pdGlhbCA9IGl0ZXJhdG9yID8gXy5tYXAoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSA6IGFycmF5O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgc2VlbiA9IFtdO1xuICAgICAgICBlYWNoKGluaXRpYWwsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpc1NvcnRlZCA/ICghaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSB2YWx1ZSkgOiAhXy5jb250YWlucyhzZWVuLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChhcnJheVtpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAgIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICAgIF8udW5pb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfLnVuaXEoXy5mbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSkpO1xuICAgIH07XG5cbiAgICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gICAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgcmVzdCA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5ldmVyeShyZXN0LCBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5jb250YWlucyhvdGhlciwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICAgIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgICBfLnppcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IF8ubWF4KF8ucGx1Y2soYXJndW1lbnRzLCAnbGVuZ3RoJykuY29uY2F0KDApKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJndW1lbnRzLCAnJyArIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gICAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gICAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgIF8ub2JqZWN0ID0gZnVuY3Rpb24gKGxpc3QsIHZhbHVlcykge1xuICAgICAgICBpZiAobGlzdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcGx5IHVzIHdpdGggaW5kZXhPZiAoSSdtIGxvb2tpbmcgYXQgeW91LCAqKk1TSUUqKiksXG4gICAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuXG4gICAgLy8gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgaW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICAgIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAgIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gICAgXy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGkgPSAoaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpXG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtLCBpc1NvcnRlZCk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGxhc3RJbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gICAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgdmFyIGhhc0luZGV4ID0gZnJvbSAhPSBudWxsO1xuICAgICAgICBpZiAobmF0aXZlTGFzdEluZGV4T2YgJiYgYXJyYXkubGFzdEluZGV4T2YgPT09IG5hdGl2ZUxhc3RJbmRleE9mKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzSW5kZXggPyBhcnJheS5sYXN0SW5kZXhPZihpdGVtLCBmcm9tKSA6IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gKGhhc0luZGV4ID8gZnJvbSA6IGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAgIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gICAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgICBfLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBhcmd1bWVudHNbMl0gfHwgMTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIHJhbmdlID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBSZXVzYWJsZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgcHJvdG90eXBlIHNldHRpbmcuXG4gICAgdmFyIGN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAgIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgICAvLyBhdmFpbGFibGUuXG4gICAgXy5iaW5kID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgICAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpXG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBib3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcjtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gICAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAgIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgICBfLnBhcnRpYWwgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzW2ldID09PSBfKVxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW3Bvc2l0aW9uKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gICAgXy5iaW5kQWxsID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgZnVuY3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGlmIChmdW5jcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICAgICAgZWFjaChmdW5jcywgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICAgIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uIChmdW5jLCBoYXNoZXIpIHtcbiAgICAgICAgdmFyIG1lbW8gPSB7fTtcbiAgICAgICAgaGFzaGVyIHx8IChoYXNoZXIgPSBfLmlkZW50aXR5KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gICAgXy5kZWxheSA9IGZ1bmN0aW9uIChmdW5jLCB3YWl0KSB7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgfTtcblxuICAgIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAgIC8vIGNsZWFyZWQuXG4gICAgXy5kZWZlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAgIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAgIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAgIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICAgIF8udGhyb3R0bGUgPSBmdW5jdGlvbiAoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gICAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAgIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAgIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gICAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICAgICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAgIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gICAgXy5vbmNlID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgdmFyIHJhbiA9IGZhbHNlLCBtZW1vO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJhbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gICAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAgIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gICAgXy53cmFwID0gZnVuY3Rpb24gKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICAgIF8uY29tcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZnVuY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gICAgXy5hZnRlciA9IGZ1bmN0aW9uICh0aW1lcywgZnVuYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAgIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgICBfLmtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghXy5pc09iamVjdChvYmopKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBpZiAobmF0aXZlS2V5cylcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgICBpZiAoXy5oYXMob2JqLCBrZXkpKVxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAgIF8udmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcblxuICAgIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICAgIF8ucGFpcnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgdmFyIHBhaXJzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH07XG5cbiAgICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gICAgXy5pbnZlcnQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gICAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKVxuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgICBfLmV4dGVuZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgICBfLnBpY2sgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBjb3B5ID0ge307XG4gICAgICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIGVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmopXG4gICAgICAgICAgICAgICAgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gICAgXy5vbWl0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgY29weSA9IHt9O1xuICAgICAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoIV8uY29udGFpbnMoa2V5cywga2V5KSlcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9O1xuXG4gICAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICBfLmRlZmF1bHRzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpbcHJvcF0gPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gICAgXy5jbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICAgIH07XG5cbiAgICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gICAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gICAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gICAgXy50YXAgPSBmdW5jdGlvbiAob2JqLCBpbnRlcmNlcHRvcikge1xuICAgICAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICAgIHZhciBlcSA9IGZ1bmN0aW9uIChhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgICAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgICAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgICAgIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiO1xuICAgICAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIF8pXG4gICAgICAgICAgICBhID0gYS5fd3JhcHBlZDtcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBfKVxuICAgICAgICAgICAgYiA9IGIuX3dyYXBwZWQ7XG4gICAgICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLiBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgIT0gK2EgPyBiICE9ICtiIDogKGEgPT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYik7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAgICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgICAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICAgICAgICAgIHJldHVybiArYSA9PSArYjtcbiAgICAgICAgICAgICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLlxuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zb3VyY2UgPT0gYi5zb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgYS5pZ25vcmVDYXNlID09IGIuaWdub3JlQ2FzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAgICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09IGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IpICYmXG4gICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIChiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSlcbiAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgYVN0YWNrLnB1c2goYSk7XG4gICAgICAgIGJTdGFjay5wdXNoKGIpO1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgc2l6ZSA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBiLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzdWx0ID0gZXEoYVtzaXplXSwgYltzaXplXSwgYVN0YWNrLCBiU3RhY2spKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5oYXMoYSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXN1bHQgPSBfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5oYXMoYiwga2V5KSAmJiAhKHNpemUtLSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gIXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgIGFTdGFjay5wb3AoKTtcbiAgICAgICAgYlN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgICBfLmlzRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZXEoYSwgYiwgW10sIFtdKTtcbiAgICB9O1xuXG4gICAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gICAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgICBfLmlzRW1wdHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopKVxuICAgICAgICAgICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgICBpZiAoXy5oYXMob2JqLCBrZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICAgIH07XG5cbiAgICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAgIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gICAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gICAgXy5pc09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gICAgfTtcblxuICAgIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLlxuICAgIGVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICAgIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuXG4gICAgaWYgKHR5cGVvZiAoLy4vKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gICAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gICAgfTtcblxuICAgIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgICBfLmlzTmFOID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPSArb2JqO1xuICAgIH07XG5cbiAgICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG4gICAgfTtcblxuICAgIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgICBfLmlzTnVsbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gICAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICAgIH07XG5cbiAgICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gICAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgICBfLmhhcyA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgfTtcblxuICAgIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gICAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0b3JzLlxuICAgIF8uaWRlbnRpdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBfLmNvbnN0YW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIF8ucHJvcGVydHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgICBfLm1hdGNoZXMgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogPT09IGF0dHJzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvL2F2b2lkIGNvbXBhcmluZyBhbiBvYmplY3QgdG8gaXRzZWxmLlxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgICBfLnRpbWVzID0gZnVuY3Rpb24gKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBhY2N1bVtpXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgICBfLnJhbmRvbSA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gICAgfTtcblxuICAgIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICAgIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgICAgIGVzY2FwZToge1xuICAgICAgICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAgICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgICAgICAgXCInXCI6ICcmI3gyNzsnXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGVudGl0eU1hcC51bmVzY2FwZSA9IF8uaW52ZXJ0KGVudGl0eU1hcC5lc2NhcGUpO1xuXG4gICAgLy8gUmVnZXhlcyBjb250YWluaW5nIHRoZSBrZXlzIGFuZCB2YWx1ZXMgbGlzdGVkIGltbWVkaWF0ZWx5IGFib3ZlLlxuICAgIHZhciBlbnRpdHlSZWdleGVzID0ge1xuICAgICAgICBlc2NhcGU6IG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxuICAgICAgICB1bmVzY2FwZTogbmV3IFJlZ0V4cCgnKCcgKyBfLmtleXMoZW50aXR5TWFwLnVuZXNjYXBlKS5qb2luKCd8JykgKyAnKScsICdnJylcbiAgICB9O1xuXG4gICAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICAgIF8uZWFjaChbJ2VzY2FwZScsICd1bmVzY2FwZSddLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgICBfLnJlc3VsdCA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgICBfLm1peGluID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBlYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICAgICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gICAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcbiAgICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgICAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgICB9O1xuXG4gICAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gICAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICAgICAgZXZhbHVhdGU6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgICAgZXNjYXBlOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICAgIH07XG5cbiAgICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gICAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAgIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICAgIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gICAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgICB2YXIgZXNjYXBlcyA9IHtcbiAgICAgICAgXCInXCI6IFwiJ1wiLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJ1xccic6ICdyJyxcbiAgICAgICAgJ1xcbic6ICduJyxcbiAgICAgICAgJ1xcdCc6ICd0JyxcbiAgICAgICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgICB9O1xuXG4gICAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx0fFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gICAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gICAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0LCBkYXRhLCBzZXR0aW5ncykge1xuICAgICAgICB2YXIgcmVuZGVyO1xuICAgICAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgICAgICB2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoW1xuICAgICAgICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAgICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgICAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAgICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoZXNjYXBlciwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmFsdWF0ZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSk7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICAgICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSlcbiAgICAgICAgICAgIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICAgICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgICAgICAgIHNvdXJjZSArIFwicmV0dXJuIF9fcDtcXG5cIjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcihkYXRhLCBfKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbiBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgZGVsZWdhdGUgdG8gdGhlIHdyYXBwZXIuXG4gICAgXy5jaGFpbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICAgIH07XG5cbiAgICAvLyBPT1BcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAgIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gICAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgIF8ubWl4aW4oXyk7XG5cbiAgICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICAgIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKChuYW1lID09ICdzaGlmdCcgfHwgbmFtZSA9PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG9iaik7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgICBlYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIF8uZXh0ZW5kKF8ucHJvdG90eXBlLCB7XG4gICAgICAgIC8vIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgICAgICAgY2hhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gICAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gICAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF87XG4gICAgICAgIH0pO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXNzZXRzL2pzL3ZlbmRvci91bmRlcnNjb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");
},function(module,exports){eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzPzE3YTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vYW1kLW9wdGlvbnMuanM/NjY4ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3dlYnBhY2svYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMlxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Backbone.js 1.1.2\n\n//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function (root, factory) {\n\n    // Set up Backbone appropriately for the environment. Start with AMD.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(1), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, exports) {\n            // Export global even in AMD case in case this script is loaded with\n            // others that may still expect a global Backbone.\n            root.Backbone = factory(root, exports, _, $);\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n        // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n    } else if (typeof exports !== 'undefined') {\n        var _ = require('underscore');\n        factory(root, exports, _);\n\n        // Finally, as a browser global.\n    } else {\n        root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\n    }\n\n}(this, function (root, Backbone, _, $) {\n\n    // Initial Setup\n    // -------------\n\n    // Save the previous value of the `Backbone` variable, so that it can be\n    // restored later on, if `noConflict` is used.\n    var previousBackbone = root.Backbone;\n\n    // Create local references to array methods we'll want to use later.\n    var array = [];\n    var push = array.push;\n    var slice = array.slice;\n    var splice = array.splice;\n\n    // Current version of the library. Keep in sync with `package.json`.\n    Backbone.VERSION = '1.1.2';\n\n    // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n    // the `$` variable.\n    Backbone.$ = $;\n\n    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n    // to its previous owner. Returns a reference to this Backbone object.\n    Backbone.noConflict = function () {\n        root.Backbone = previousBackbone;\n        return this;\n    };\n\n    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n    // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n    // set a `X-Http-Method-Override` header.\n    Backbone.emulateHTTP = false;\n\n    // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n    // `application/json` requests ... will encode the body as\n    // `application/x-www-form-urlencoded` instead and will send the model in a\n    // form param named `model`.\n    Backbone.emulateJSON = false;\n\n    // Backbone.Events\n    // ---------------\n\n    // A module that can be mixed in to *any object* in order to provide it with\n    // custom events. You may bind with `on` or remove with `off` callback\n    // functions to an event; `trigger`-ing an event fires all callbacks in\n    // succession.\n    //\n    //     var object = {};\n    //     _.extend(object, Backbone.Events);\n    //     object.on('expand', function(){ alert('expanded'); });\n    //     object.trigger('expand');\n    //\n    var Events = Backbone.Events = {\n        // Bind an event to a `callback` function. Passing `\"all\"` will bind\n        // the callback to all events fired.\n        on: function (name, callback, context) {\n            if (!eventsApi(this, 'on', name, [callback, context]) || !callback)\n                return this;\n            this._events || (this._events = {});\n            var events = this._events[name] || (this._events[name] = []);\n            events.push({callback: callback, context: context, ctx: context || this});\n            return this;\n        },\n        // Bind an event to only be triggered a single time. After the first time\n        // the callback is invoked, it will be removed.\n        once: function (name, callback, context) {\n            if (!eventsApi(this, 'once', name, [callback, context]) || !callback)\n                return this;\n            var self = this;\n            var once = _.once(function () {\n                self.off(name, once);\n                callback.apply(this, arguments);\n            });\n            once._callback = callback;\n            return this.on(name, once, context);\n        },\n        // Remove one or many callbacks. If `context` is null, removes all\n        // callbacks with that function. If `callback` is null, removes all\n        // callbacks for the event. If `name` is null, removes all bound\n        // callbacks for all events.\n        off: function (name, callback, context) {\n            var retain, ev, events, names, i, l, j, k;\n            if (!this._events || !eventsApi(this, 'off', name, [callback, context]))\n                return this;\n            if (!name && !callback && !context) {\n                this._events = void 0;\n                return this;\n            }\n            names = name ? [name] : _.keys(this._events);\n            for (i = 0, l = names.length; i < l; i++) {\n                name = names[i];\n                if (events = this._events[name]) {\n                    this._events[name] = retain = [];\n                    if (callback || context) {\n                        for (j = 0, k = events.length; j < k; j++) {\n                            ev = events[j];\n                            if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                                (context && context !== ev.context)) {\n                                retain.push(ev);\n                            }\n                        }\n                    }\n                    if (!retain.length)\n                        delete this._events[name];\n                }\n            }\n\n            return this;\n        },\n        // Trigger one or many events, firing all bound callbacks. Callbacks are\n        // passed the same arguments as `trigger` is, apart from the event name\n        // (unless you're listening on `\"all\"`, which will cause your callback to\n        // receive the true name of the event as the first argument).\n        trigger: function (name) {\n            if (!this._events)\n                return this;\n            var args = slice.call(arguments, 1);\n            if (!eventsApi(this, 'trigger', name, args))\n                return this;\n            var events = this._events[name];\n            var allEvents = this._events.all;\n            if (events)\n                triggerEvents(events, args);\n            if (allEvents)\n                triggerEvents(allEvents, arguments);\n            return this;\n        },\n        // Tell this object to stop listening to either specific events ... or\n        // to every object it's currently listening to.\n        stopListening: function (obj, name, callback) {\n            var listeningTo = this._listeningTo;\n            if (!listeningTo)\n                return this;\n            var remove = !name && !callback;\n            if (!callback && typeof name === 'object')\n                callback = this;\n            if (obj)\n                (listeningTo = {})[obj._listenId] = obj;\n            for (var id in listeningTo) {\n                obj = listeningTo[id];\n                obj.off(name, callback, this);\n                if (remove || _.isEmpty(obj._events))\n                    delete this._listeningTo[id];\n            }\n            return this;\n        }\n\n    };\n\n    // Regular expression used to split event strings.\n    var eventSplitter = /\\s+/;\n\n    // Implement fancy features of the Events API such as multiple event\n    // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n    // in terms of the existing API.\n    var eventsApi = function (obj, action, name, rest) {\n        if (!name)\n            return true;\n\n        // Handle event maps.\n        if (typeof name === 'object') {\n            for (var key in name) {\n                obj[action].apply(obj, [key, name[key]].concat(rest));\n            }\n            return false;\n        }\n\n        // Handle space separated event names.\n        if (eventSplitter.test(name)) {\n            var names = name.split(eventSplitter);\n            for (var i = 0, l = names.length; i < l; i++) {\n                obj[action].apply(obj, [names[i]].concat(rest));\n            }\n            return false;\n        }\n\n        return true;\n    };\n\n    // A difficult-to-believe, but optimized internal dispatch function for\n    // triggering events. Tries to keep the usual cases speedy (most internal\n    // Backbone events have 3 arguments).\n    var triggerEvents = function (events, args) {\n        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n        switch (args.length) {\n            case 0:\n                while (++i < l)\n                    (ev = events[i]).callback.call(ev.ctx);\n                return;\n            case 1:\n                while (++i < l)\n                    (ev = events[i]).callback.call(ev.ctx, a1);\n                return;\n            case 2:\n                while (++i < l)\n                    (ev = events[i]).callback.call(ev.ctx, a1, a2);\n                return;\n            case 3:\n                while (++i < l)\n                    (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n                return;\n            default:\n                while (++i < l)\n                    (ev = events[i]).callback.apply(ev.ctx, args);\n                return;\n        }\n    };\n\n    var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n    // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n    // listen to an event in another object ... keeping track of what it's\n    // listening to.\n    _.each(listenMethods, function (implementation, method) {\n        Events[method] = function (obj, name, callback) {\n            var listeningTo = this._listeningTo || (this._listeningTo = {});\n            var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n            listeningTo[id] = obj;\n            if (!callback && typeof name === 'object')\n                callback = this;\n            obj[implementation](name, callback, this);\n            return this;\n        };\n    });\n\n    // Aliases for backwards compatibility.\n    Events.bind = Events.on;\n    Events.unbind = Events.off;\n\n    // Allow the `Backbone` object to serve as a global event bus, for folks who\n    // want global \"pubsub\" in a convenient place.\n    _.extend(Backbone, Events);\n\n    // Backbone.Model\n    // --------------\n\n    // Backbone **Models** are the basic data object in the framework --\n    // frequently representing a row in a table in a database on your server.\n    // A discrete chunk of data and a bunch of useful, related methods for\n    // performing computations and transformations on that data.\n\n    // Create a new model with the specified attributes. A client id (`cid`)\n    // is automatically generated and assigned for you.\n    var Model = Backbone.Model = function (attributes, options) {\n        var attrs = attributes || {};\n        options || (options = {});\n        this.cid = _.uniqueId('c');\n        this.attributes = {};\n        if (options.collection)\n            this.collection = options.collection;\n        if (options.parse)\n            attrs = this.parse(attrs, options) || {};\n        attrs = _.defaults({}, attrs, _.result(this, 'defaults'));\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    };\n\n    // Attach all inheritable methods to the Model prototype.\n    _.extend(Model.prototype, Events, {\n        // A hash of attributes whose current and previous value differ.\n        changed: null,\n        // The value returned during the last failed validation.\n        validationError: null,\n        // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n        // CouchDB users may want to set this to `\"_id\"`.\n        idAttribute: 'id',\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function () {\n        },\n        // Return a copy of the model's `attributes` object.\n        toJSON: function (options) {\n            return _.clone(this.attributes);\n        },\n        // Proxy `Backbone.sync` by default -- but override this if you need\n        // custom syncing semantics for *this* particular model.\n        sync: function () {\n            return Backbone.sync.apply(this, arguments);\n        },\n        // Get the value of an attribute.\n        get: function (attr) {\n            return this.attributes[attr];\n        },\n        // Get the HTML-escaped value of an attribute.\n        escape: function (attr) {\n            return _.escape(this.get(attr));\n        },\n        // Returns `true` if the attribute contains a value that is not null\n        // or undefined.\n        has: function (attr) {\n            return this.get(attr) != null;\n        },\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\n        // the core primitive operation of a model, updating the data and notifying\n        // anyone who needs to know about the change in state. The heart of the beast.\n        set: function (key, val, options) {\n            var attr, attrs, unset, changes, silent, changing, prev, current;\n            if (key == null)\n                return this;\n\n            // Handle both `\"key\", value` and `{key: value}` -style arguments.\n            if (typeof key === 'object') {\n                attrs = key;\n                options = val;\n            } else {\n                (attrs = {})[key] = val;\n            }\n\n            options || (options = {});\n\n            // Run validation.\n            if (!this._validate(attrs, options))\n                return false;\n\n            // Extract attributes and options.\n            unset = options.unset;\n            silent = options.silent;\n            changes = [];\n            changing = this._changing;\n            this._changing = true;\n\n            if (!changing) {\n                this._previousAttributes = _.clone(this.attributes);\n                this.changed = {};\n            }\n            current = this.attributes, prev = this._previousAttributes;\n\n            // Check for changes of `id`.\n            if (this.idAttribute in attrs)\n                this.id = attrs[this.idAttribute];\n\n            // For each `set` attribute, update or delete the current value.\n            for (attr in attrs) {\n                val = attrs[attr];\n                if (!_.isEqual(current[attr], val))\n                    changes.push(attr);\n                if (!_.isEqual(prev[attr], val)) {\n                    this.changed[attr] = val;\n                } else {\n                    delete this.changed[attr];\n                }\n                unset ? delete current[attr] : current[attr] = val;\n            }\n\n            // Trigger all relevant attribute changes.\n            if (!silent) {\n                if (changes.length)\n                    this._pending = options;\n                for (var i = 0, l = changes.length; i < l; i++) {\n                    this.trigger('change:' + changes[i], this, current[changes[i]], options);\n                }\n            }\n\n            // You might be wondering why there's a `while` loop here. Changes can\n            // be recursively nested within `\"change\"` events.\n            if (changing)\n                return this;\n            if (!silent) {\n                while (this._pending) {\n                    options = this._pending;\n                    this._pending = false;\n                    this.trigger('change', this, options);\n                }\n            }\n            this._pending = false;\n            this._changing = false;\n            return this;\n        },\n        // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n        // if the attribute doesn't exist.\n        unset: function (attr, options) {\n            return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n        },\n        // Clear all attributes on the model, firing `\"change\"`.\n        clear: function (options) {\n            var attrs = {};\n            for (var key in this.attributes)\n                attrs[key] = void 0;\n            return this.set(attrs, _.extend({}, options, {unset: true}));\n        },\n        // Determine if the model has changed since the last `\"change\"` event.\n        // If you specify an attribute name, determine if that attribute has changed.\n        hasChanged: function (attr) {\n            if (attr == null)\n                return !_.isEmpty(this.changed);\n            return _.has(this.changed, attr);\n        },\n        // Return an object containing all the attributes that have changed, or\n        // false if there are no changed attributes. Useful for determining what\n        // parts of a view need to be updated and/or what attributes need to be\n        // persisted to the server. Unset attributes will be set to undefined.\n        // You can also pass an attributes object to diff against the model,\n        // determining if there *would be* a change.\n        changedAttributes: function (diff) {\n            if (!diff)\n                return this.hasChanged() ? _.clone(this.changed) : false;\n            var val, changed = false;\n            var old = this._changing ? this._previousAttributes : this.attributes;\n            for (var attr in diff) {\n                if (_.isEqual(old[attr], (val = diff[attr])))\n                    continue;\n                (changed || (changed = {}))[attr] = val;\n            }\n            return changed;\n        },\n        // Get the previous value of an attribute, recorded at the time the last\n        // `\"change\"` event was fired.\n        previous: function (attr) {\n            if (attr == null || !this._previousAttributes)\n                return null;\n            return this._previousAttributes[attr];\n        },\n        // Get all of the attributes of the model at the time of the previous\n        // `\"change\"` event.\n        previousAttributes: function () {\n            return _.clone(this._previousAttributes);\n        },\n        // Fetch the model from the server. If the server's representation of the\n        // model differs from its current attributes, they will be overridden,\n        // triggering a `\"change\"` event.\n        fetch: function (options) {\n            options = options ? _.clone(options) : {};\n            if (options.parse === void 0)\n                options.parse = true;\n            var model = this;\n            var success = options.success;\n            options.success = function (resp) {\n                if (!model.set(model.parse(resp, options), options))\n                    return false;\n                if (success)\n                    success(model, resp, options);\n                model.trigger('sync', model, resp, options);\n            };\n            wrapError(this, options);\n            return this.sync('read', this, options);\n        },\n        // Set a hash of model attributes, and sync the model to the server.\n        // If the server returns an attributes hash that differs, the model's\n        // state will be `set` again.\n        save: function (key, val, options) {\n            var attrs, method, xhr, attributes = this.attributes;\n\n            // Handle both `\"key\", value` and `{key: value}` -style arguments.\n            if (key == null || typeof key === 'object') {\n                attrs = key;\n                options = val;\n            } else {\n                (attrs = {})[key] = val;\n            }\n\n            options = _.extend({validate: true}, options);\n\n            // If we're not waiting and attributes exist, save acts as\n            // `set(attr).save(null, opts)` with validation. Otherwise, check if\n            // the model will be valid when the attributes, if any, are set.\n            if (attrs && !options.wait) {\n                if (!this.set(attrs, options))\n                    return false;\n            } else {\n                if (!this._validate(attrs, options))\n                    return false;\n            }\n\n            // Set temporary attributes if `{wait: true}`.\n            if (attrs && options.wait) {\n                this.attributes = _.extend({}, attributes, attrs);\n            }\n\n            // After a successful server-side save, the client is (optionally)\n            // updated with the server-side state.\n            if (options.parse === void 0)\n                options.parse = true;\n            var model = this;\n            var success = options.success;\n            options.success = function (resp) {\n                // Ensure attributes are restored during synchronous saves.\n                model.attributes = attributes;\n                var serverAttrs = model.parse(resp, options);\n                if (options.wait)\n                    serverAttrs = _.extend(attrs || {}, serverAttrs);\n                if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {\n                    return false;\n                }\n                if (success)\n                    success(model, resp, options);\n                model.trigger('sync', model, resp, options);\n            };\n            wrapError(this, options);\n\n            method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n            if (method === 'patch')\n                options.attrs = attrs;\n            xhr = this.sync(method, this, options);\n\n            // Restore attributes.\n            if (attrs && options.wait)\n                this.attributes = attributes;\n\n            return xhr;\n        },\n        // Destroy this model on the server if it was already persisted.\n        // Optimistically removes the model from its collection, if it has one.\n        // If `wait: true` is passed, waits for the server to respond before removal.\n        destroy: function (options) {\n            options = options ? _.clone(options) : {};\n            var model = this;\n            var success = options.success;\n\n            var destroy = function () {\n                model.trigger('destroy', model, model.collection, options);\n            };\n\n            options.success = function (resp) {\n                if (options.wait || model.isNew())\n                    destroy();\n                if (success)\n                    success(model, resp, options);\n                if (!model.isNew())\n                    model.trigger('sync', model, resp, options);\n            };\n\n            if (this.isNew()) {\n                options.success();\n                return false;\n            }\n            wrapError(this, options);\n\n            var xhr = this.sync('delete', this, options);\n            if (!options.wait)\n                destroy();\n            return xhr;\n        },\n        // Default URL for the model's representation on the server -- if you're\n        // using Backbone's restful methods, override this to change the endpoint\n        // that will be called.\n        url: function () {\n            var base =\n                _.result(this, 'urlRoot') ||\n                _.result(this.collection, 'url') ||\n                urlError();\n            if (this.isNew())\n                return base;\n            return base.replace(/([^\\/])$/, '$1/') + encodeURIComponent(this.id);\n        },\n        // **parse** converts a response into the hash of attributes to be `set` on\n        // the model. The default implementation is just to pass the response along.\n        parse: function (resp, options) {\n            return resp;\n        },\n        // Create a new model with identical attributes to this one.\n        clone: function () {\n            return new this.constructor(this.attributes);\n        },\n        // A model is new if it has never been saved to the server, and lacks an id.\n        isNew: function () {\n            return !this.has(this.idAttribute);\n        },\n        // Check if the model is currently in a valid state.\n        isValid: function (options) {\n            return this._validate({}, _.extend(options || {}, {validate: true}));\n        },\n        // Run validation against the next complete set of model attributes,\n        // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n        _validate: function (attrs, options) {\n            if (!options.validate || !this.validate)\n                return true;\n            attrs = _.extend({}, this.attributes, attrs);\n            var error = this.validationError = this.validate(attrs, options) || null;\n            if (!error)\n                return true;\n            this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n            return false;\n        }\n\n    });\n\n    // Underscore methods that we want to implement on the Model.\n    var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];\n\n    // Mix in each Underscore method as a proxy to `Model#attributes`.\n    _.each(modelMethods, function (method) {\n        Model.prototype[method] = function () {\n            var args = slice.call(arguments);\n            args.unshift(this.attributes);\n            return _[method].apply(_, args);\n        };\n    });\n\n    // Backbone.Collection\n    // -------------------\n\n    // If models tend to represent a single row of data, a Backbone Collection is\n    // more analagous to a table full of data ... or a small slice or page of that\n    // table, or a collection of rows that belong together for a particular reason\n    // -- all of the messages in this particular folder, all of the documents\n    // belonging to this particular author, and so on. Collections maintain\n    // indexes of their models, both in order, and for lookup by `id`.\n\n    // Create a new **Collection**, perhaps to contain a specific type of `model`.\n    // If a `comparator` is specified, the Collection will maintain\n    // its models in sort order, as they're added and removed.\n    var Collection = Backbone.Collection = function (models, options) {\n        options || (options = {});\n        if (options.model)\n            this.model = options.model;\n        if (options.comparator !== void 0)\n            this.comparator = options.comparator;\n        this._reset();\n        this.initialize.apply(this, arguments);\n        if (models)\n            this.reset(models, _.extend({silent: true}, options));\n    };\n\n    // Default options for `Collection#set`.\n    var setOptions = {add: true, remove: true, merge: true};\n    var addOptions = {add: true, remove: false};\n\n    // Define the Collection's inheritable methods.\n    _.extend(Collection.prototype, Events, {\n        // The default model for a collection is just a **Backbone.Model**.\n        // This should be overridden in most cases.\n        model: Model,\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function () {\n        },\n        // The JSON representation of a Collection is an array of the\n        // models' attributes.\n        toJSON: function (options) {\n            return this.map(function (model) {\n                return model.toJSON(options);\n            });\n        },\n        // Proxy `Backbone.sync` by default.\n        sync: function () {\n            return Backbone.sync.apply(this, arguments);\n        },\n        // Add a model, or list of models to the set.\n        add: function (models, options) {\n            return this.set(models, _.extend({merge: false}, options, addOptions));\n        },\n        // Remove a model, or a list of models from the set.\n        remove: function (models, options) {\n            var singular = !_.isArray(models);\n            models = singular ? [models] : _.clone(models);\n            options || (options = {});\n            var i, l, index, model;\n            for (i = 0, l = models.length; i < l; i++) {\n                model = models[i] = this.get(models[i]);\n                if (!model)\n                    continue;\n                delete this._byId[model.id];\n                delete this._byId[model.cid];\n                index = this.indexOf(model);\n                this.models.splice(index, 1);\n                this.length--;\n                if (!options.silent) {\n                    options.index = index;\n                    model.trigger('remove', model, this, options);\n                }\n                this._removeReference(model, options);\n            }\n            return singular ? models[0] : models;\n        },\n        // Update a collection by `set`-ing a new list of models, adding new ones,\n        // removing models that are no longer present, and merging models that\n        // already exist in the collection, as necessary. Similar to **Model#set**,\n        // the core operation for updating the data contained by the collection.\n        set: function (models, options) {\n            options = _.defaults({}, options, setOptions);\n            if (options.parse)\n                models = this.parse(models, options);\n            var singular = !_.isArray(models);\n            models = singular ? (models ? [models] : []) : _.clone(models);\n            var i, l, id, model, attrs, existing, sort;\n            var at = options.at;\n            var targetModel = this.model;\n            var sortable = this.comparator && (at == null) && options.sort !== false;\n            var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n            var toAdd = [], toRemove = [], modelMap = {};\n            var add = options.add, merge = options.merge, remove = options.remove;\n            var order = !sortable && add && remove ? [] : false;\n\n            // Turn bare objects into model references, and prevent invalid models\n            // from being added.\n            for (i = 0, l = models.length; i < l; i++) {\n                attrs = models[i] || {};\n                if (attrs instanceof Model) {\n                    id = model = attrs;\n                } else {\n                    id = attrs[targetModel.prototype.idAttribute || 'id'];\n                }\n\n                // If a duplicate is found, prevent it from being added and\n                // optionally merge it into the existing model.\n                if (existing = this.get(id)) {\n                    if (remove)\n                        modelMap[existing.cid] = true;\n                    if (merge) {\n                        attrs = attrs === model ? model.attributes : attrs;\n                        if (options.parse)\n                            attrs = existing.parse(attrs, options);\n                        existing.set(attrs, options);\n                        if (sortable && !sort && existing.hasChanged(sortAttr))\n                            sort = true;\n                    }\n                    models[i] = existing;\n\n                    // If this is a new, valid model, push it to the `toAdd` list.\n                } else if (add) {\n                    model = models[i] = this._prepareModel(attrs, options);\n                    if (!model)\n                        continue;\n                    toAdd.push(model);\n                    this._addReference(model, options);\n                }\n\n                // Do not add multiple models with the same `id`.\n                model = existing || model;\n                if (order && (model.isNew() || !modelMap[model.id]))\n                    order.push(model);\n                modelMap[model.id] = true;\n            }\n\n            // Remove nonexistent models if appropriate.\n            if (remove) {\n                for (i = 0, l = this.length; i < l; ++i) {\n                    if (!modelMap[(model = this.models[i]).cid])\n                        toRemove.push(model);\n                }\n                if (toRemove.length)\n                    this.remove(toRemove, options);\n            }\n\n            // See if sorting is needed, update `length` and splice in new models.\n            if (toAdd.length || (order && order.length)) {\n                if (sortable)\n                    sort = true;\n                this.length += toAdd.length;\n                if (at != null) {\n                    for (i = 0, l = toAdd.length; i < l; i++) {\n                        this.models.splice(at + i, 0, toAdd[i]);\n                    }\n                } else {\n                    if (order)\n                        this.models.length = 0;\n                    var orderedModels = order || toAdd;\n                    for (i = 0, l = orderedModels.length; i < l; i++) {\n                        this.models.push(orderedModels[i]);\n                    }\n                }\n            }\n\n            // Silently sort the collection if appropriate.\n            if (sort)\n                this.sort({silent: true});\n\n            // Unless silenced, it's time to fire all appropriate add/sort events.\n            if (!options.silent) {\n                for (i = 0, l = toAdd.length; i < l; i++) {\n                    (model = toAdd[i]).trigger('add', model, this, options);\n                }\n                if (sort || (order && order.length))\n                    this.trigger('sort', this, options);\n            }\n\n            // Return the added (or merged) model (or models).\n            return singular ? models[0] : models;\n        },\n        // When you have more items than you want to add or remove individually,\n        // you can reset the entire set with a new list of models, without firing\n        // any granular `add` or `remove` events. Fires `reset` when finished.\n        // Useful for bulk operations and optimizations.\n        reset: function (models, options) {\n            options || (options = {});\n            for (var i = 0, l = this.models.length; i < l; i++) {\n                this._removeReference(this.models[i], options);\n            }\n            options.previousModels = this.models;\n            this._reset();\n            models = this.add(models, _.extend({silent: true}, options));\n            if (!options.silent)\n                this.trigger('reset', this, options);\n            return models;\n        },\n        // Add a model to the end of the collection.\n        push: function (model, options) {\n            return this.add(model, _.extend({at: this.length}, options));\n        },\n        // Remove a model from the end of the collection.\n        pop: function (options) {\n            var model = this.at(this.length - 1);\n            this.remove(model, options);\n            return model;\n        },\n        // Add a model to the beginning of the collection.\n        unshift: function (model, options) {\n            return this.add(model, _.extend({at: 0}, options));\n        },\n        // Remove a model from the beginning of the collection.\n        shift: function (options) {\n            var model = this.at(0);\n            this.remove(model, options);\n            return model;\n        },\n        // Slice out a sub-array of models from the collection.\n        slice: function () {\n            return slice.apply(this.models, arguments);\n        },\n        // Get a model from the set by id.\n        get: function (obj) {\n            if (obj == null)\n                return void 0;\n            return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];\n        },\n        // Get the model at the given index.\n        at: function (index) {\n            return this.models[index];\n        },\n        // Return models with matching attributes. Useful for simple cases of\n        // `filter`.\n        where: function (attrs, first) {\n            if (_.isEmpty(attrs))\n                return first ? void 0 : [];\n            return this[first ? 'find' : 'filter'](function (model) {\n                for (var key in attrs) {\n                    if (attrs[key] !== model.get(key))\n                        return false;\n                }\n                return true;\n            });\n        },\n        // Return the first model with matching attributes. Useful for simple cases\n        // of `find`.\n        findWhere: function (attrs) {\n            return this.where(attrs, true);\n        },\n        // Force the collection to re-sort itself. You don't need to call this under\n        // normal circumstances, as the set will maintain sort order as each item\n        // is added.\n        sort: function (options) {\n            if (!this.comparator)\n                throw new Error('Cannot sort a set without a comparator');\n            options || (options = {});\n\n            // Run sort based on type of `comparator`.\n            if (_.isString(this.comparator) || this.comparator.length === 1) {\n                this.models = this.sortBy(this.comparator, this);\n            } else {\n                this.models.sort(_.bind(this.comparator, this));\n            }\n\n            if (!options.silent)\n                this.trigger('sort', this, options);\n            return this;\n        },\n        // Pluck an attribute from each model in the collection.\n        pluck: function (attr) {\n            return _.invoke(this.models, 'get', attr);\n        },\n        // Fetch the default set of models for this collection, resetting the\n        // collection when they arrive. If `reset: true` is passed, the response\n        // data will be passed through the `reset` method instead of `set`.\n        fetch: function (options) {\n            options = options ? _.clone(options) : {};\n            if (options.parse === void 0)\n                options.parse = true;\n            var success = options.success;\n            var collection = this;\n            options.success = function (resp) {\n                var method = options.reset ? 'reset' : 'set';\n                collection[method](resp, options);\n                if (success)\n                    success(collection, resp, options);\n                collection.trigger('sync', collection, resp, options);\n            };\n            wrapError(this, options);\n            return this.sync('read', this, options);\n        },\n        // Create a new instance of a model in this collection. Add the model to the\n        // collection immediately, unless `wait: true` is passed, in which case we\n        // wait for the server to agree.\n        create: function (model, options) {\n            options = options ? _.clone(options) : {};\n            if (!(model = this._prepareModel(model, options)))\n                return false;\n            if (!options.wait)\n                this.add(model, options);\n            var collection = this;\n            var success = options.success;\n            options.success = function (model, resp) {\n                if (options.wait)\n                    collection.add(model, options);\n                if (success)\n                    success(model, resp, options);\n            };\n            model.save(null, options);\n            return model;\n        },\n        // **parse** converts a response into a list of models to be added to the\n        // collection. The default implementation is just to pass it through.\n        parse: function (resp, options) {\n            return resp;\n        },\n        // Create a new collection with an identical list of models as this one.\n        clone: function () {\n            return new this.constructor(this.models);\n        },\n        // Private method to reset all internal state. Called when the collection\n        // is first initialized or reset.\n        _reset: function () {\n            this.length = 0;\n            this.models = [];\n            this._byId = {};\n        },\n        // Prepare a hash of attributes (or other model) to be added to this\n        // collection.\n        _prepareModel: function (attrs, options) {\n            if (attrs instanceof Model)\n                return attrs;\n            options = options ? _.clone(options) : {};\n            options.collection = this;\n            var model = new this.model(attrs, options);\n            if (!model.validationError)\n                return model;\n            this.trigger('invalid', this, model.validationError, options);\n            return false;\n        },\n        // Internal method to create a model's ties to a collection.\n        _addReference: function (model, options) {\n            this._byId[model.cid] = model;\n            if (model.id != null)\n                this._byId[model.id] = model;\n            if (!model.collection)\n                model.collection = this;\n            model.on('all', this._onModelEvent, this);\n        },\n        // Internal method to sever a model's ties to a collection.\n        _removeReference: function (model, options) {\n            if (this === model.collection)\n                delete model.collection;\n            model.off('all', this._onModelEvent, this);\n        },\n        // Internal method called every time a model in the set fires an event.\n        // Sets need to update their indexes when models change ids. All other\n        // events simply proxy through. \"add\" and \"remove\" events that originate\n        // in other collections are ignored.\n        _onModelEvent: function (event, model, collection, options) {\n            if ((event === 'add' || event === 'remove') && collection !== this)\n                return;\n            if (event === 'destroy')\n                this.remove(model, options);\n            if (model && event === 'change:' + model.idAttribute) {\n                delete this._byId[model.previous(model.idAttribute)];\n                if (model.id != null)\n                    this._byId[model.id] = model;\n            }\n            this.trigger.apply(this, arguments);\n        }\n\n    });\n\n    // Underscore methods that we want to implement on the Collection.\n    // 90% of the core usefulness of Backbone Collections is actually implemented\n    // right here:\n    var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n        'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n        'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n        'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\n        'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',\n        'lastIndexOf', 'isEmpty', 'chain', 'sample'];\n\n    // Mix in each Underscore method as a proxy to `Collection#models`.\n    _.each(methods, function (method) {\n        Collection.prototype[method] = function () {\n            var args = slice.call(arguments);\n            args.unshift(this.models);\n            return _[method].apply(_, args);\n        };\n    });\n\n    // Underscore methods that take a property name as an argument.\n    var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];\n\n    // Use attributes instead of properties.\n    _.each(attributeMethods, function (method) {\n        Collection.prototype[method] = function (value, context) {\n            var iterator = _.isFunction(value) ? value : function (model) {\n                return model.get(value);\n            };\n            return _[method](this.models, iterator, context);\n        };\n    });\n\n    // Backbone.View\n    // -------------\n\n    // Backbone Views are almost more convention than they are actual code. A View\n    // is simply a JavaScript object that represents a logical chunk of UI in the\n    // DOM. This might be a single item, an entire list, a sidebar or panel, or\n    // even the surrounding frame which wraps your whole app. Defining a chunk of\n    // UI as a **View** allows you to define your DOM events declaratively, without\n    // having to worry about render order ... and makes it easy for the view to\n    // react to specific changes in the state of your models.\n\n    // Creating a Backbone.View creates its initial element outside of the DOM,\n    // if an existing element is not provided...\n    var View = Backbone.View = function (options) {\n        this.cid = _.uniqueId('view');\n        options || (options = {});\n        _.extend(this, _.pick(options, viewOptions));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n        this.delegateEvents();\n    };\n\n    // Cached regex to split keys for `delegate`.\n    var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n    // List of view options to be merged as properties.\n    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n    // Set up all inheritable **Backbone.View** properties and methods.\n    _.extend(View.prototype, Events, {\n        // The default `tagName` of a View's element is `\"div\"`.\n        tagName: 'div',\n        // jQuery delegate for element lookup, scoped to DOM elements within the\n        // current view. This should be preferred to global lookups where possible.\n        $: function (selector) {\n            return this.$el.find(selector);\n        },\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function () {\n        },\n        // **render** is the core function that your view should override, in order\n        // to populate its element (`this.el`), with the appropriate HTML. The\n        // convention is for **render** to always return `this`.\n        render: function () {\n            return this;\n        },\n        // Remove this view by taking the element out of the DOM, and removing any\n        // applicable Backbone.Events listeners.\n        remove: function () {\n            this.$el.remove();\n            this.stopListening();\n            return this;\n        },\n        // Change the view's element (`this.el` property), including event\n        // re-delegation.\n        setElement: function (element, delegate) {\n            if (this.$el)\n                this.undelegateEvents();\n            this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\n            this.el = this.$el[0];\n            if (delegate !== false)\n                this.delegateEvents();\n            return this;\n        },\n        // Set callbacks, where `this.events` is a hash of\n        //\n        // *{\"event selector\": \"callback\"}*\n        //\n        //     {\n        //       'mousedown .title':  'edit',\n        //       'click .button':     'save',\n        //       'click .open':       function(e) { ... }\n        //     }\n        //\n        // pairs. Callbacks will be bound to the view, with `this` set properly.\n        // Uses event delegation for efficiency.\n        // Omitting the selector binds the event to `this.el`.\n        // This only works for delegate-able events: not `focus`, `blur`, and\n        // not `change`, `submit`, and `reset` in Internet Explorer.\n        delegateEvents: function (events) {\n            if (!(events || (events = _.result(this, 'events'))))\n                return this;\n            this.undelegateEvents();\n            for (var key in events) {\n                var method = events[key];\n                if (!_.isFunction(method))\n                    method = this[events[key]];\n                if (!method)\n                    continue;\n\n                var match = key.match(delegateEventSplitter);\n                var eventName = match[1], selector = match[2];\n                method = _.bind(method, this);\n                eventName += '.delegateEvents' + this.cid;\n                if (selector === '') {\n                    this.$el.on(eventName, method);\n                } else {\n                    this.$el.on(eventName, selector, method);\n                }\n            }\n            return this;\n        },\n        // Clears all callbacks previously bound to the view with `delegateEvents`.\n        // You usually don't need to use this, but may wish to if you have multiple\n        // Backbone views attached to the same DOM element.\n        undelegateEvents: function () {\n            this.$el.off('.delegateEvents' + this.cid);\n            return this;\n        },\n        // Ensure that the View has a DOM element to render into.\n        // If `this.el` is a string, pass it through `$()`, take the first\n        // matching element, and re-assign it to `el`. Otherwise, create\n        // an element from the `id`, `className` and `tagName` properties.\n        _ensureElement: function () {\n            if (!this.el) {\n                var attrs = _.extend({}, _.result(this, 'attributes'));\n                if (this.id)\n                    attrs.id = _.result(this, 'id');\n                if (this.className)\n                    attrs['class'] = _.result(this, 'className');\n                var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);\n                this.setElement($el, false);\n            } else {\n                this.setElement(_.result(this, 'el'), false);\n            }\n        }\n\n    });\n\n    // Backbone.sync\n    // -------------\n\n    // Override this function to change the manner in which Backbone persists\n    // models to the server. You will be passed the type of request, and the\n    // model in question. By default, makes a RESTful Ajax request\n    // to the model's `url()`. Some possible customizations could be:\n    //\n    // * Use `setTimeout` to batch rapid-fire updates into a single request.\n    // * Send up the models as XML instead of JSON.\n    // * Persist models via WebSockets instead of Ajax.\n    //\n    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n    // as `POST`, with a `_method` parameter containing the true HTTP method,\n    // as well as all requests with the body as `application/x-www-form-urlencoded`\n    // instead of `application/json` with the model in a param named `model`.\n    // Useful when interfacing with server-side languages like **PHP** that make\n    // it difficult to read the body of `PUT` requests.\n    Backbone.sync = function (method, model, options) {\n        var type = methodMap[method];\n\n        // Default options, unless specified.\n        _.defaults(options || (options = {}), {\n            emulateHTTP: Backbone.emulateHTTP,\n            emulateJSON: Backbone.emulateJSON\n        });\n\n        // Default JSON-request options.\n        var params = {type: type, dataType: 'json'};\n\n        // Ensure that we have a URL.\n        if (!options.url) {\n            params.url = _.result(model, 'url') || urlError();\n        }\n\n        // Ensure that we have the appropriate request data.\n        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n            params.contentType = 'application/json';\n            params.data = JSON.stringify(options.attrs || model.toJSON(options));\n        }\n\n        // For older servers, emulate JSON by encoding the request into an HTML-form.\n        if (options.emulateJSON) {\n            params.contentType = 'application/x-www-form-urlencoded';\n            params.data = params.data ? {model: params.data} : {};\n        }\n\n        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n        // And an `X-HTTP-Method-Override` header.\n        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n            params.type = 'POST';\n            if (options.emulateJSON)\n                params.data._method = type;\n            var beforeSend = options.beforeSend;\n            options.beforeSend = function (xhr) {\n                xhr.setRequestHeader('X-HTTP-Method-Override', type);\n                if (beforeSend)\n                    return beforeSend.apply(this, arguments);\n            };\n        }\n\n        // Don't process data on a non-GET request.\n        if (params.type !== 'GET' && !options.emulateJSON) {\n            params.processData = false;\n        }\n\n        // If we're sending a `PATCH` request, and we're in an old Internet Explorer\n        // that still has ActiveX enabled by default, override jQuery to use that\n        // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.\n        if (params.type === 'PATCH' && noXhrPatch) {\n            params.xhr = function () {\n                return new ActiveXObject(\"Microsoft.XMLHTTP\");\n            };\n        }\n\n        // Make the request, allowing the user to override any Ajax options.\n        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n        model.trigger('request', model, xhr, options);\n        return xhr;\n    };\n\n    var noXhrPatch =\n        typeof window !== 'undefined' && !!window.ActiveXObject &&\n        !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);\n\n    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n    var methodMap = {\n        'create': 'POST',\n        'update': 'PUT',\n        'patch': 'PATCH',\n        'delete': 'DELETE',\n        'read': 'GET'\n    };\n\n    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n    // Override this if you'd like to use a different library.\n    Backbone.ajax = function () {\n        return Backbone.$.ajax.apply(Backbone.$, arguments);\n    };\n\n    // Backbone.Router\n    // ---------------\n\n    // Routers map faux-URLs to actions, and fire events when routes are\n    // matched. Creating a new one sets its `routes` hash, if not set statically.\n    var Router = Backbone.Router = function (options) {\n        options || (options = {});\n        if (options.routes)\n            this.routes = options.routes;\n        this._bindRoutes();\n        this.initialize.apply(this, arguments);\n    };\n\n    // Cached regular expressions for matching named param parts and splatted\n    // parts of route strings.\n    var optionalParam = /\\((.*?)\\)/g;\n    var namedParam = /(\\(\\?)?:\\w+/g;\n    var splatParam = /\\*\\w+/g;\n    var escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n    // Set up all inheritable **Backbone.Router** properties and methods.\n    _.extend(Router.prototype, Events, {\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function () {\n        },\n        // Manually bind a single named route to a callback. For example:\n        //\n        //     this.route('search/:query/p:num', 'search', function(query, num) {\n        //       ...\n        //     });\n        //\n        route: function (route, name, callback) {\n            if (!_.isRegExp(route))\n                route = this._routeToRegExp(route);\n            if (_.isFunction(name)) {\n                callback = name;\n                name = '';\n            }\n            if (!callback)\n                callback = this[name];\n            var router = this;\n            Backbone.history.route(route, function (fragment) {\n                var args = router._extractParameters(route, fragment);\n                router.execute(callback, args);\n                router.trigger.apply(router, ['route:' + name].concat(args));\n                router.trigger('route', name, args);\n                Backbone.history.trigger('route', router, name, args);\n            });\n            return this;\n        },\n        // Execute a route handler with the provided parameters.  This is an\n        // excellent place to do pre-route setup or post-route cleanup.\n        execute: function (callback, args) {\n            if (callback)\n                callback.apply(this, args);\n        },\n        // Simple proxy to `Backbone.history` to save a fragment into the history.\n        navigate: function (fragment, options) {\n            Backbone.history.navigate(fragment, options);\n            return this;\n        },\n        // Bind all defined routes to `Backbone.history`. We have to reverse the\n        // order of the routes here to support behavior where the most general\n        // routes can be defined at the bottom of the route map.\n        _bindRoutes: function () {\n            if (!this.routes)\n                return;\n            this.routes = _.result(this, 'routes');\n            var route, routes = _.keys(this.routes);\n            while ((route = routes.pop()) != null) {\n                this.route(route, this.routes[route]);\n            }\n        },\n        // Convert a route string into a regular expression, suitable for matching\n        // against the current location hash.\n        _routeToRegExp: function (route) {\n            route = route.replace(escapeRegExp, '\\\\$&')\n                .replace(optionalParam, '(?:$1)?')\n                .replace(namedParam, function (match, optional) {\n                    return optional ? match : '([^/?]+)';\n                })\n                .replace(splatParam, '([^?]*?)');\n            return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n        },\n        // Given a route, and a URL fragment that it matches, return the array of\n        // extracted decoded parameters. Empty or unmatched parameters will be\n        // treated as `null` to normalize cross-browser behavior.\n        _extractParameters: function (route, fragment) {\n            var params = route.exec(fragment).slice(1);\n            return _.map(params, function (param, i) {\n                // Don't decode the search params.\n                if (i === params.length - 1)\n                    return param || null;\n                return param ? decodeURIComponent(param) : null;\n            });\n        }\n\n    });\n\n    // Backbone.History\n    // ----------------\n\n    // Handles cross-browser history management, based on either\n    // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n    // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n    // and URL fragments. If the browser supports neither (old IE, natch),\n    // falls back to polling.\n    var History = Backbone.History = function () {\n        this.handlers = [];\n        _.bindAll(this, 'checkUrl');\n\n        // Ensure that `History` can be used outside of the browser.\n        if (typeof window !== 'undefined') {\n            this.location = window.location;\n            this.history = window.history;\n        }\n    };\n\n    // Cached regex for stripping a leading hash/slash and trailing space.\n    var routeStripper = /^[#\\/]|\\s+$/g;\n\n    // Cached regex for stripping leading and trailing slashes.\n    var rootStripper = /^\\/+|\\/+$/g;\n\n    // Cached regex for detecting MSIE.\n    var isExplorer = /msie [\\w.]+/;\n\n    // Cached regex for removing a trailing slash.\n    var trailingSlash = /\\/$/;\n\n    // Cached regex for stripping urls of hash.\n    var pathStripper = /#.*$/;\n\n    // Has the history handling already been started?\n    History.started = false;\n\n    // Set up all inheritable **Backbone.History** properties and methods.\n    _.extend(History.prototype, Events, {\n        // The default interval to poll for hash changes, if necessary, is\n        // twenty times a second.\n        interval: 50,\n        // Are we at the app root?\n        atRoot: function () {\n            return this.location.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n        },\n        // Gets the true hash value. Cannot use location.hash directly due to bug\n        // in Firefox where location.hash will always be decoded.\n        getHash: function (window) {\n            var match = (window || this).location.href.match(/#(.*)$/);\n            return match ? match[1] : '';\n        },\n        // Get the cross-browser normalized URL fragment, either from the URL,\n        // the hash, or the override.\n        getFragment: function (fragment, forcePushState) {\n            if (fragment == null) {\n                if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n                    fragment = decodeURI(this.location.pathname + this.location.search);\n                    var root = this.root.replace(trailingSlash, '');\n                    if (!fragment.indexOf(root))\n                        fragment = fragment.slice(root.length);\n                } else {\n                    fragment = this.getHash();\n                }\n            }\n            return fragment.replace(routeStripper, '');\n        },\n        // Start the hash change handling, returning `true` if the current URL matches\n        // an existing route, and `false` otherwise.\n        start: function (options) {\n            if (History.started)\n                throw new Error(\"Backbone.history has already been started\");\n            History.started = true;\n\n            // Figure out the initial configuration. Do we need an iframe?\n            // Is pushState desired ... is it available?\n            this.options = _.extend({root: '/'}, this.options, options);\n            this.root = this.options.root;\n            this._wantsHashChange = this.options.hashChange !== false;\n            this._wantsPushState = !!this.options.pushState;\n            this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);\n            var fragment = this.getFragment();\n            var docMode = document.documentMode;\n            var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n            // Normalize root to always include a leading and trailing slash.\n            this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n            if (oldIE && this._wantsHashChange) {\n                var frame = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\">');\n                this.iframe = frame.hide().appendTo('body')[0].contentWindow;\n                this.navigate(fragment);\n            }\n\n            // Depending on whether we're using pushState or hashes, and whether\n            // 'onhashchange' is supported, determine how we check the URL state.\n            if (this._hasPushState) {\n                Backbone.$(window).on('popstate', this.checkUrl);\n            } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n                Backbone.$(window).on('hashchange', this.checkUrl);\n            } else if (this._wantsHashChange) {\n                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n            }\n\n            // Determine if we need to change the base url, for a pushState link\n            // opened by a non-pushState browser.\n            this.fragment = fragment;\n            var loc = this.location;\n\n            // Transition from hashChange to pushState or vice versa if both are\n            // requested.\n            if (this._wantsHashChange && this._wantsPushState) {\n\n                // If we've started off with a route from a `pushState`-enabled\n                // browser, but we're currently in a browser that doesn't support it...\n                if (!this._hasPushState && !this.atRoot()) {\n                    this.fragment = this.getFragment(null, true);\n                    this.location.replace(this.root + '#' + this.fragment);\n                    // Return immediately as browser will do redirect to new url\n                    return true;\n\n                    // Or if we've started out with a hash-based route, but we're currently\n                    // in a browser where it could be `pushState`-based instead...\n                } else if (this._hasPushState && this.atRoot() && loc.hash) {\n                    this.fragment = this.getHash().replace(routeStripper, '');\n                    this.history.replaceState({}, document.title, this.root + this.fragment);\n                }\n\n            }\n\n            if (!this.options.silent)\n                return this.loadUrl();\n        },\n        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n        // but possibly useful for unit testing Routers.\n        stop: function () {\n            Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);\n            if (this._checkUrlInterval)\n                clearInterval(this._checkUrlInterval);\n            History.started = false;\n        },\n        // Add a route to be tested when the fragment changes. Routes added later\n        // may override previous routes.\n        route: function (route, callback) {\n            this.handlers.unshift({route: route, callback: callback});\n        },\n        // Checks the current URL to see if it has changed, and if it has,\n        // calls `loadUrl`, normalizing across the hidden iframe.\n        checkUrl: function (e) {\n            var current = this.getFragment();\n            if (current === this.fragment && this.iframe) {\n                current = this.getFragment(this.getHash(this.iframe));\n            }\n            if (current === this.fragment)\n                return false;\n            if (this.iframe)\n                this.navigate(current);\n            this.loadUrl();\n        },\n        // Attempt to load the current URL fragment. If a route succeeds with a\n        // match, returns `true`. If no defined routes matches the fragment,\n        // returns `false`.\n        loadUrl: function (fragment) {\n            fragment = this.fragment = this.getFragment(fragment);\n            return _.any(this.handlers, function (handler) {\n                if (handler.route.test(fragment)) {\n                    handler.callback(fragment);\n                    return true;\n                }\n            });\n        },\n        // Save a fragment into the hash history, or replace the URL state if the\n        // 'replace' option is passed. You are responsible for properly URL-encoding\n        // the fragment in advance.\n        //\n        // The options object can contain `trigger: true` if you wish to have the\n        // route callback be fired (not usually desirable), or `replace: true`, if\n        // you wish to modify the current URL without adding an entry to the history.\n        navigate: function (fragment, options) {\n            if (!History.started)\n                return false;\n            if (!options || options === true)\n                options = {trigger: !!options};\n\n            var url = this.root + (fragment = this.getFragment(fragment || ''));\n\n            // Strip the hash for matching.\n            fragment = fragment.replace(pathStripper, '');\n\n            if (this.fragment === fragment)\n                return;\n            this.fragment = fragment;\n\n            // Don't include a trailing slash on the root.\n            if (fragment === '' && url !== '/')\n                url = url.slice(0, -1);\n\n            // If pushState is available, we use it to set the fragment as a real URL.\n            if (this._hasPushState) {\n                this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n                // If hash changes haven't been explicitly disabled, update the hash\n                // fragment to store history.\n            } else if (this._wantsHashChange) {\n                this._updateHash(this.location, fragment, options.replace);\n                if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\n                    // Opening and closing the iframe tricks IE7 and earlier to push a\n                    // history entry on hash-tag change.  When replace is true, we don't\n                    // want this.\n                    if (!options.replace)\n                        this.iframe.document.open().close();\n                    this._updateHash(this.iframe.location, fragment, options.replace);\n                }\n\n                // If you've told us that you explicitly don't want fallback hashchange-\n                // based history, then `navigate` becomes a page refresh.\n            } else {\n                return this.location.assign(url);\n            }\n            if (options.trigger)\n                return this.loadUrl(fragment);\n        },\n        // Update the hash location, either replacing the current entry, or adding\n        // a new one to the browser history.\n        _updateHash: function (location, fragment, replace) {\n            if (replace) {\n                var href = location.href.replace(/(javascript:|#).*$/, '');\n                location.replace(href + '#' + fragment);\n            } else {\n                // Some browsers require that `hash` contains a leading #.\n                location.hash = '#' + fragment;\n            }\n        }\n\n    });\n\n    // Create the default Backbone.history.\n    Backbone.history = new History;\n\n    // Helpers\n    // -------\n\n    // Helper function to correctly set up the prototype chain, for subclasses.\n    // Similar to `goog.inherits`, but uses a hash of prototype properties and\n    // class properties to be extended.\n    var extend = function (protoProps, staticProps) {\n        var parent = this;\n        var child;\n\n        // The constructor function for the new subclass is either defined by you\n        // (the \"constructor\" property in your `extend` definition), or defaulted\n        // by us to simply call the parent's constructor.\n        if (protoProps && _.has(protoProps, 'constructor')) {\n            child = protoProps.constructor;\n        } else {\n            child = function () {\n                return parent.apply(this, arguments);\n            };\n        }\n\n        // Add static properties to the constructor function, if supplied.\n        _.extend(child, parent, staticProps);\n\n        // Set the prototype chain to inherit from `parent`, without calling\n        // `parent`'s constructor function.\n        var Surrogate = function () {\n            this.constructor = child;\n        };\n        Surrogate.prototype = parent.prototype;\n        child.prototype = new Surrogate;\n\n        // Add prototype properties (instance properties) to the subclass,\n        // if supplied.\n        if (protoProps)\n            _.extend(child.prototype, protoProps);\n\n        // Set a convenience property in case the parent's prototype is needed\n        // later.\n        child.__super__ = parent.prototype;\n\n        return child;\n    };\n\n    // Set up inheritance for the model, collection, router, view and history.\n    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n    // Throw an error when a URL is needed, and none is supplied.\n    var urlError = function () {\n        throw new Error('A \"url\" property or function must be specified');\n    };\n\n    // Wrap an optional error callback with a fallback error event.\n    var wrapError = function (model, options) {\n        var error = options.error;\n        options.error = function (resp) {\n            if (error)\n                error(model, resp, options);\n            model.trigger('error', model, resp, options);\n        };\n    };\n\n    return Backbone;\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdmVuZG9yL2JhY2tib25lLmpzP2M4NTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLHdDQUF3QztBQUN4Qzs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQixFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSx5QkFBeUIsMkRBQTJEO0FBQ3BGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1CQUFtQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlDQUFpQztBQUNwRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtFQUErRTs7QUFFL0U7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAgICAgQmFja2JvbmUuanMgMS4xLjJcblxuLy8gICAgIChjKSAyMDEwLTIwMTQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBCYWNrYm9uZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vICAgICBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4vLyAgICAgaHR0cDovL2JhY2tib25lanMub3JnXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXG4gICAgLy8gU2V0IHVwIEJhY2tib25lIGFwcHJvcHJpYXRlbHkgZm9yIHRoZSBlbnZpcm9ubWVudC4gU3RhcnQgd2l0aCBBTUQuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWyd1bmRlcnNjb3JlJywgJ2pxdWVyeScsICdleHBvcnRzJ10sIGZ1bmN0aW9uIChfLCAkLCBleHBvcnRzKSB7XG4gICAgICAgICAgICAvLyBFeHBvcnQgZ2xvYmFsIGV2ZW4gaW4gQU1EIGNhc2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgd2l0aFxuICAgICAgICAgICAgLy8gb3RoZXJzIHRoYXQgbWF5IHN0aWxsIGV4cGVjdCBhIGdsb2JhbCBCYWNrYm9uZS5cbiAgICAgICAgICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8sICQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBOZXh0IGZvciBOb2RlLmpzIG9yIENvbW1vbkpTLiBqUXVlcnkgbWF5IG5vdCBiZSBuZWVkZWQgYXMgYSBtb2R1bGUuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgICAgIGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgXyk7XG5cbiAgICAgICAgLy8gRmluYWxseSwgYXMgYSBicm93c2VyIGdsb2JhbC5cbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCB7fSwgcm9vdC5fLCAocm9vdC5qUXVlcnkgfHwgcm9vdC5aZXB0byB8fCByb290LmVuZGVyIHx8IHJvb3QuJCkpO1xuICAgIH1cblxufSh0aGlzLCBmdW5jdGlvbiAocm9vdCwgQmFja2JvbmUsIF8sICQpIHtcblxuICAgIC8vIEluaXRpYWwgU2V0dXBcbiAgICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYEJhY2tib25lYCB2YXJpYWJsZSwgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gICAgdmFyIHByZXZpb3VzQmFja2JvbmUgPSByb290LkJhY2tib25lO1xuXG4gICAgLy8gQ3JlYXRlIGxvY2FsIHJlZmVyZW5jZXMgdG8gYXJyYXkgbWV0aG9kcyB3ZSdsbCB3YW50IHRvIHVzZSBsYXRlci5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgcHVzaCA9IGFycmF5LnB1c2g7XG4gICAgdmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG4gICAgdmFyIHNwbGljZSA9IGFycmF5LnNwbGljZTtcblxuICAgIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS4gS2VlcCBpbiBzeW5jIHdpdGggYHBhY2thZ2UuanNvbmAuXG4gICAgQmFja2JvbmUuVkVSU0lPTiA9ICcxLjEuMic7XG5cbiAgICAvLyBGb3IgQmFja2JvbmUncyBwdXJwb3NlcywgalF1ZXJ5LCBaZXB0bywgRW5kZXIsIG9yIE15IExpYnJhcnkgKGtpZGRpbmcpIG93bnNcbiAgICAvLyB0aGUgYCRgIHZhcmlhYmxlLlxuICAgIEJhY2tib25lLiQgPSAkO1xuXG4gICAgLy8gUnVucyBCYWNrYm9uZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlXG4gICAgLy8gdG8gaXRzIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgQmFja2JvbmUgb2JqZWN0LlxuICAgIEJhY2tib25lLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuQmFja2JvbmUgPSBwcmV2aW91c0JhY2tib25lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gVHVybiBvbiBgZW11bGF0ZUhUVFBgIHRvIHN1cHBvcnQgbGVnYWN5IEhUVFAgc2VydmVycy4gU2V0dGluZyB0aGlzIG9wdGlvblxuICAgIC8vIHdpbGwgZmFrZSBgXCJQQVRDSFwiYCwgYFwiUFVUXCJgIGFuZCBgXCJERUxFVEVcImAgcmVxdWVzdHMgdmlhIHRoZSBgX21ldGhvZGAgcGFyYW1ldGVyIGFuZFxuICAgIC8vIHNldCBhIGBYLUh0dHAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gICAgQmFja2JvbmUuZW11bGF0ZUhUVFAgPSBmYWxzZTtcblxuICAgIC8vIFR1cm4gb24gYGVtdWxhdGVKU09OYCB0byBzdXBwb3J0IGxlZ2FjeSBzZXJ2ZXJzIHRoYXQgY2FuJ3QgZGVhbCB3aXRoIGRpcmVjdFxuICAgIC8vIGBhcHBsaWNhdGlvbi9qc29uYCByZXF1ZXN0cyAuLi4gd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgICAvLyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYCBpbnN0ZWFkIGFuZCB3aWxsIHNlbmQgdGhlIG1vZGVsIGluIGFcbiAgICAvLyBmb3JtIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gICAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAgIC8vIEJhY2tib25lLkV2ZW50c1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAgIC8vIGN1c3RvbSBldmVudHMuIFlvdSBtYXkgYmluZCB3aXRoIGBvbmAgb3IgcmVtb3ZlIHdpdGggYG9mZmAgY2FsbGJhY2tcbiAgICAvLyBmdW5jdGlvbnMgdG8gYW4gZXZlbnQ7IGB0cmlnZ2VyYC1pbmcgYW4gZXZlbnQgZmlyZXMgYWxsIGNhbGxiYWNrcyBpblxuICAgIC8vIHN1Y2Nlc3Npb24uXG4gICAgLy9cbiAgICAvLyAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gICAgLy8gICAgIG9iamVjdC5vbignZXhwYW5kJywgZnVuY3Rpb24oKXsgYWxlcnQoJ2V4cGFuZGVkJyk7IH0pO1xuICAgIC8vICAgICBvYmplY3QudHJpZ2dlcignZXhwYW5kJyk7XG4gICAgLy9cbiAgICB2YXIgRXZlbnRzID0gQmFja2JvbmUuRXZlbnRzID0ge1xuICAgICAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi4gUGFzc2luZyBgXCJhbGxcImAgd2lsbCBiaW5kXG4gICAgICAgIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICAgICAgICBvbjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAnb24nLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwgKHRoaXMuX2V2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCB0aGlzfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQmluZCBhbiBldmVudCB0byBvbmx5IGJlIHRyaWdnZXJlZCBhIHNpbmdsZSB0aW1lLiBBZnRlciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAvLyB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZCwgaXQgd2lsbCBiZSByZW1vdmVkLlxuICAgICAgICBvbmNlOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbmNlJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9uY2UuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbihuYW1lLCBvbmNlLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmVtb3ZlIG9uZSBvciBtYW55IGNhbGxiYWNrcy4gSWYgYGNvbnRleHRgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gICAgICAgIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAgICAgICAvLyBjYWxsYmFja3MgZm9yIGFsbCBldmVudHMuXG4gICAgICAgIG9mZjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmV0YWluLCBldiwgZXZlbnRzLCBuYW1lcywgaSwgbCwgaiwgaztcbiAgICAgICAgICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICFldmVudHNBcGkodGhpcywgJ29mZicsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IHJldGFpbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldiA9IGV2ZW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gZXYuY2FsbGJhY2suX2NhbGxiYWNrKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRhaW4ucHVzaChldik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmV0YWluLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVHJpZ2dlciBvbmUgb3IgbWFueSBldmVudHMsIGZpcmluZyBhbGwgYm91bmQgY2FsbGJhY2tzLiBDYWxsYmFja3MgYXJlXG4gICAgICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgICAgIC8vICh1bmxlc3MgeW91J3JlIGxpc3RlbmluZyBvbiBgXCJhbGxcImAsIHdoaWNoIHdpbGwgY2F1c2UgeW91ciBjYWxsYmFjayB0b1xuICAgICAgICAvLyByZWNlaXZlIHRoZSB0cnVlIG5hbWUgb2YgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBhcmd1bWVudCkuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgICAgICB2YXIgYWxsRXZlbnRzID0gdGhpcy5fZXZlbnRzLmFsbDtcbiAgICAgICAgICAgIGlmIChldmVudHMpXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhldmVudHMsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGFsbEV2ZW50cylcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgICAgIC8vIHRvIGV2ZXJ5IG9iamVjdCBpdCdzIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG8uXG4gICAgICAgIHN0b3BMaXN0ZW5pbmc6IGZ1bmN0aW9uIChvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcbiAgICAgICAgICAgIGlmICghbGlzdGVuaW5nVG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlID0gIW5hbWUgJiYgIWNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKG9iailcbiAgICAgICAgICAgICAgICAobGlzdGVuaW5nVG8gPSB7fSlbb2JqLl9saXN0ZW5JZF0gPSBvYmo7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBsaXN0ZW5pbmdUbykge1xuICAgICAgICAgICAgICAgIG9iaiA9IGxpc3RlbmluZ1RvW2lkXTtcbiAgICAgICAgICAgICAgICBvYmoub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlIHx8IF8uaXNFbXB0eShvYmouX2V2ZW50cykpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5pbmdUb1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gICAgdmFyIGV2ZW50U3BsaXR0ZXIgPSAvXFxzKy87XG5cbiAgICAvLyBJbXBsZW1lbnQgZmFuY3kgZmVhdHVyZXMgb2YgdGhlIEV2ZW50cyBBUEkgc3VjaCBhcyBtdWx0aXBsZSBldmVudFxuICAgIC8vIG5hbWVzIGBcImNoYW5nZSBibHVyXCJgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnQgbWFwcyBge2NoYW5nZTogYWN0aW9ufWBcbiAgICAvLyBpbiB0ZXJtcyBvZiB0aGUgZXhpc3RpbmcgQVBJLlxuICAgIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbiAob2JqLCBhY3Rpb24sIG5hbWUsIHJlc3QpIHtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gSGFuZGxlIGV2ZW50IG1hcHMuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgICAgICAgICAgb2JqW2FjdGlvbl0uYXBwbHkob2JqLCBba2V5LCBuYW1lW2tleV1dLmNvbmNhdChyZXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgc3BhY2Ugc2VwYXJhdGVkIGV2ZW50IG5hbWVzLlxuICAgICAgICBpZiAoZXZlbnRTcGxpdHRlci50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KGV2ZW50U3BsaXR0ZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtuYW1lc1tpXV0uY29uY2F0KHJlc3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBBIGRpZmZpY3VsdC10by1iZWxpZXZlLCBidXQgb3B0aW1pemVkIGludGVybmFsIGRpc3BhdGNoIGZ1bmN0aW9uIGZvclxuICAgIC8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbiAgICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gICAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnRzLCBhcmdzKSB7XG4gICAgICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsKVxuICAgICAgICAgICAgICAgICAgICAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGwpXG4gICAgICAgICAgICAgICAgICAgIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGwpXG4gICAgICAgICAgICAgICAgICAgIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsKVxuICAgICAgICAgICAgICAgICAgICAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsKVxuICAgICAgICAgICAgICAgICAgICAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmFwcGx5KGV2LmN0eCwgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW5NZXRob2RzID0ge2xpc3RlblRvOiAnb24nLCBsaXN0ZW5Ub09uY2U6ICdvbmNlJ307XG5cbiAgICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAgIC8vIGxpc3RlbiB0byBhbiBldmVudCBpbiBhbm90aGVyIG9iamVjdCAuLi4ga2VlcGluZyB0cmFjayBvZiB3aGF0IGl0J3NcbiAgICAvLyBsaXN0ZW5pbmcgdG8uXG4gICAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uIChpbXBsZW1lbnRhdGlvbiwgbWV0aG9kKSB7XG4gICAgICAgIEV2ZW50c1ttZXRob2RdID0gZnVuY3Rpb24gKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICAgICAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgICAgICAgbGlzdGVuaW5nVG9baWRdID0gb2JqO1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgICAgICAgb2JqW2ltcGxlbWVudGF0aW9uXShuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgIEV2ZW50cy5iaW5kID0gRXZlbnRzLm9uO1xuICAgIEV2ZW50cy51bmJpbmQgPSBFdmVudHMub2ZmO1xuXG4gICAgLy8gQWxsb3cgdGhlIGBCYWNrYm9uZWAgb2JqZWN0IHRvIHNlcnZlIGFzIGEgZ2xvYmFsIGV2ZW50IGJ1cywgZm9yIGZvbGtzIHdob1xuICAgIC8vIHdhbnQgZ2xvYmFsIFwicHVic3ViXCIgaW4gYSBjb252ZW5pZW50IHBsYWNlLlxuICAgIF8uZXh0ZW5kKEJhY2tib25lLCBFdmVudHMpO1xuXG4gICAgLy8gQmFja2JvbmUuTW9kZWxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gQmFja2JvbmUgKipNb2RlbHMqKiBhcmUgdGhlIGJhc2ljIGRhdGEgb2JqZWN0IGluIHRoZSBmcmFtZXdvcmsgLS1cbiAgICAvLyBmcmVxdWVudGx5IHJlcHJlc2VudGluZyBhIHJvdyBpbiBhIHRhYmxlIGluIGEgZGF0YWJhc2Ugb24geW91ciBzZXJ2ZXIuXG4gICAgLy8gQSBkaXNjcmV0ZSBjaHVuayBvZiBkYXRhIGFuZCBhIGJ1bmNoIG9mIHVzZWZ1bCwgcmVsYXRlZCBtZXRob2RzIGZvclxuICAgIC8vIHBlcmZvcm1pbmcgY29tcHV0YXRpb25zIGFuZCB0cmFuc2Zvcm1hdGlvbnMgb24gdGhhdCBkYXRhLlxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZGVsIHdpdGggdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVzLiBBIGNsaWVudCBpZCAoYGNpZGApXG4gICAgLy8gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGZvciB5b3UuXG4gICAgdmFyIE1vZGVsID0gQmFja2JvbmUuTW9kZWwgPSBmdW5jdGlvbiAoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQoJ2MnKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSBvcHRpb25zLmNvbGxlY3Rpb247XG4gICAgICAgIGlmIChvcHRpb25zLnBhcnNlKVxuICAgICAgICAgICAgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICAgICAgYXR0cnMgPSBfLmRlZmF1bHRzKHt9LCBhdHRycywgXy5yZXN1bHQodGhpcywgJ2RlZmF1bHRzJykpO1xuICAgICAgICB0aGlzLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgLy8gQXR0YWNoIGFsbCBpbmhlcml0YWJsZSBtZXRob2RzIHRvIHRoZSBNb2RlbCBwcm90b3R5cGUuXG4gICAgXy5leHRlbmQoTW9kZWwucHJvdG90eXBlLCBFdmVudHMsIHtcbiAgICAgICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgICAgICBjaGFuZ2VkOiBudWxsLFxuICAgICAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgICAgICB2YWxpZGF0aW9uRXJyb3I6IG51bGwsXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgICAgICAvLyBDb3VjaERCIHVzZXJzIG1heSB3YW50IHRvIHNldCB0aGlzIHRvIGBcIl9pZFwiYC5cbiAgICAgICAgaWRBdHRyaWJ1dGU6ICdpZCcsXG4gICAgICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgICAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgICAgIHRvSlNPTjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByb3h5IGBCYWNrYm9uZS5zeW5jYCBieSBkZWZhdWx0IC0tIGJ1dCBvdmVycmlkZSB0aGlzIGlmIHlvdSBuZWVkXG4gICAgICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gICAgICAgIHN5bmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBCYWNrYm9uZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICB9LFxuICAgICAgICAvLyBHZXQgdGhlIEhUTUwtZXNjYXBlZCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgICAgIGVzY2FwZTogZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmVzY2FwZSh0aGlzLmdldChhdHRyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgICAgIC8vIG9yIHVuZGVmaW5lZC5cbiAgICAgICAgaGFzOiBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0LCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBUaGlzIGlzXG4gICAgICAgIC8vIHRoZSBjb3JlIHByaW1pdGl2ZSBvcGVyYXRpb24gb2YgYSBtb2RlbCwgdXBkYXRpbmcgdGhlIGRhdGEgYW5kIG5vdGlmeWluZ1xuICAgICAgICAvLyBhbnlvbmUgd2hvIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhlIGNoYW5nZSBpbiBzdGF0ZS4gVGhlIGhlYXJ0IG9mIHRoZSBiZWFzdC5cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyLCBhdHRycywgdW5zZXQsIGNoYW5nZXMsIHNpbGVudCwgY2hhbmdpbmcsIHByZXYsIGN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoa2V5ID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgICAgICAgLy8gUnVuIHZhbGlkYXRpb24uXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYXR0cmlidXRlcyBhbmQgb3B0aW9ucy5cbiAgICAgICAgICAgIHVuc2V0ID0gb3B0aW9ucy51bnNldDtcbiAgICAgICAgICAgIHNpbGVudCA9IG9wdGlvbnMuc2lsZW50O1xuICAgICAgICAgICAgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdpbmcgPSB0aGlzLl9jaGFuZ2luZztcbiAgICAgICAgICAgIHRoaXMuX2NoYW5naW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFjaGFuZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA9IF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmF0dHJpYnV0ZXMsIHByZXYgPSB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIG9mIGBpZGAuXG4gICAgICAgICAgICBpZiAodGhpcy5pZEF0dHJpYnV0ZSBpbiBhdHRycylcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gYXR0cnNbdGhpcy5pZEF0dHJpYnV0ZV07XG5cbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgIGZvciAoYXR0ciBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgIHZhbCA9IGF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNFcXVhbChwcmV2W2F0dHJdLCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jaGFuZ2VkW2F0dHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bnNldCA/IGRlbGV0ZSBjdXJyZW50W2F0dHJdIDogY3VycmVudFthdHRyXSA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJpZ2dlciBhbGwgcmVsZXZhbnQgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAgICAgICAvLyBiZSByZWN1cnNpdmVseSBuZXN0ZWQgd2l0aGluIGBcImNoYW5nZVwiYCBldmVudHMuXG4gICAgICAgICAgICBpZiAoY2hhbmdpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wZW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgICAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgIHVuc2V0OiBmdW5jdGlvbiAoYXR0ciwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJzLCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3Vuc2V0OiB0cnVlfSkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAgICAgLy8gSWYgeW91IHNwZWNpZnkgYW4gYXR0cmlidXRlIG5hbWUsIGRldGVybWluZSBpZiB0aGF0IGF0dHJpYnV0ZSBoYXMgY2hhbmdlZC5cbiAgICAgICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuICFfLmlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgICAgICAgIHJldHVybiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgICAgICAvLyBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlZCBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXRcbiAgICAgICAgLy8gcGFydHMgb2YgYSB2aWV3IG5lZWQgdG8gYmUgdXBkYXRlZCBhbmQvb3Igd2hhdCBhdHRyaWJ1dGVzIG5lZWQgdG8gYmVcbiAgICAgICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgICAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0byBkaWZmIGFnYWluc3QgdGhlIG1vZGVsLFxuICAgICAgICAvLyBkZXRlcm1pbmluZyBpZiB0aGVyZSAqd291bGQgYmUqIGEgY2hhbmdlLlxuICAgICAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24gKGRpZmYpIHtcbiAgICAgICAgICAgIGlmICghZGlmZilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgICAgICAgIHZhciB2YWwsIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBvbGQgPSB0aGlzLl9jaGFuZ2luZyA/IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA6IHRoaXMuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gZGlmZikge1xuICAgICAgICAgICAgICAgIGlmIChfLmlzRXF1YWwob2xkW2F0dHJdLCAodmFsID0gZGlmZlthdHRyXSkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAoY2hhbmdlZCB8fCAoY2hhbmdlZCA9IHt9KSlbYXR0cl0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUsIHJlY29yZGVkIGF0IHRoZSB0aW1lIHRoZSBsYXN0XG4gICAgICAgIC8vIGBcImNoYW5nZVwiYCBldmVudCB3YXMgZmlyZWQuXG4gICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIgPT0gbnVsbCB8fCAhdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IGFsbCBvZiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAgICAgcHJldmlvdXNBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBGZXRjaCB0aGUgbW9kZWwgZnJvbSB0aGUgc2VydmVyLiBJZiB0aGUgc2VydmVyJ3MgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIG1vZGVsIGRpZmZlcnMgZnJvbSBpdHMgY3VycmVudCBhdHRyaWJ1dGVzLCB0aGV5IHdpbGwgYmUgb3ZlcnJpZGRlbixcbiAgICAgICAgLy8gdHJpZ2dlcmluZyBhIGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAgICAgZmV0Y2g6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgICAgICAgIGlmICghbW9kZWwuc2V0KG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzLCBhbmQgc3luYyB0aGUgbW9kZWwgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgLy8gSWYgdGhlIHNlcnZlciByZXR1cm5zIGFuIGF0dHJpYnV0ZXMgaGFzaCB0aGF0IGRpZmZlcnMsIHRoZSBtb2RlbCdzXG4gICAgICAgIC8vIHN0YXRlIHdpbGwgYmUgYHNldGAgYWdhaW4uXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uIChrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGF0dHJzLCBtZXRob2QsIHhociwgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgLy8gSGFuZGxlIGJvdGggYFwia2V5XCIsIHZhbHVlYCBhbmQgYHtrZXk6IHZhbHVlfWAgLXN0eWxlIGFyZ3VtZW50cy5cbiAgICAgICAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChhdHRycyA9IHt9KVtrZXldID0gdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb25zID0gXy5leHRlbmQoe3ZhbGlkYXRlOiB0cnVlfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIGFuZCBhdHRyaWJ1dGVzIGV4aXN0LCBzYXZlIGFjdHMgYXNcbiAgICAgICAgICAgIC8vIGBzZXQoYXR0cikuc2F2ZShudWxsLCBvcHRzKWAgd2l0aCB2YWxpZGF0aW9uLiBPdGhlcndpc2UsIGNoZWNrIGlmXG4gICAgICAgICAgICAvLyB0aGUgbW9kZWwgd2lsbCBiZSB2YWxpZCB3aGVuIHRoZSBhdHRyaWJ1dGVzLCBpZiBhbnksIGFyZSBzZXQuXG4gICAgICAgICAgICBpZiAoYXR0cnMgJiYgIW9wdGlvbnMud2FpdCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB0ZW1wb3JhcnkgYXR0cmlidXRlcyBpZiBge3dhaXQ6IHRydWV9YC5cbiAgICAgICAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBfLmV4dGVuZCh7fSwgYXR0cmlidXRlcywgYXR0cnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZnRlciBhIHN1Y2Nlc3NmdWwgc2VydmVyLXNpZGUgc2F2ZSwgdGhlIGNsaWVudCBpcyAob3B0aW9uYWxseSlcbiAgICAgICAgICAgIC8vIHVwZGF0ZWQgd2l0aCB0aGUgc2VydmVyLXNpZGUgc3RhdGUuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgICAgICAgICAgIG1vZGVsLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJBdHRycyA9IG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndhaXQpXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckF0dHJzID0gXy5leHRlbmQoYXR0cnMgfHwge30sIHNlcnZlckF0dHJzKTtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc09iamVjdChzZXJ2ZXJBdHRycykgJiYgIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmF0dHJzID0gYXR0cnM7XG4gICAgICAgICAgICB4aHIgPSB0aGlzLnN5bmMobWV0aG9kLCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gUmVzdG9yZSBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgaWYgKGF0dHJzICYmIG9wdGlvbnMud2FpdClcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBEZXN0cm95IHRoaXMgbW9kZWwgb24gdGhlIHNlcnZlciBpZiBpdCB3YXMgYWxyZWFkeSBwZXJzaXN0ZWQuXG4gICAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHJlbW92ZXMgdGhlIG1vZGVsIGZyb20gaXRzIGNvbGxlY3Rpb24sIGlmIGl0IGhhcyBvbmUuXG4gICAgICAgIC8vIElmIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIHdhaXRzIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgYmVmb3JlIHJlbW92YWwuXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcblxuICAgICAgICAgICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2FpdCB8fCBtb2RlbC5pc05ldygpKVxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICghbW9kZWwuaXNOZXcoKSlcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHZhciB4aHIgPSB0aGlzLnN5bmMoJ2RlbGV0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLndhaXQpXG4gICAgICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICAgICAgcmV0dXJuIHhocjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGVmYXVsdCBVUkwgZm9yIHRoZSBtb2RlbCdzIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzZXJ2ZXIgLS0gaWYgeW91J3JlXG4gICAgICAgIC8vIHVzaW5nIEJhY2tib25lJ3MgcmVzdGZ1bCBtZXRob2RzLCBvdmVycmlkZSB0aGlzIHRvIGNoYW5nZSB0aGUgZW5kcG9pbnRcbiAgICAgICAgLy8gdGhhdCB3aWxsIGJlIGNhbGxlZC5cbiAgICAgICAgdXJsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9XG4gICAgICAgICAgICAgICAgXy5yZXN1bHQodGhpcywgJ3VybFJvb3QnKSB8fFxuICAgICAgICAgICAgICAgIF8ucmVzdWx0KHRoaXMuY29sbGVjdGlvbiwgJ3VybCcpIHx8XG4gICAgICAgICAgICAgICAgdXJsRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmV3KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC8oW15cXC9dKSQvLCAnJDEvJykgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pZCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gdGhlIGhhc2ggb2YgYXR0cmlidXRlcyB0byBiZSBgc2V0YCBvblxuICAgICAgICAvLyB0aGUgbW9kZWwuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyB0aGUgcmVzcG9uc2UgYWxvbmcuXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAocmVzcCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEEgbW9kZWwgaXMgbmV3IGlmIGl0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIHRoZSBzZXJ2ZXIsIGFuZCBsYWNrcyBhbiBpZC5cbiAgICAgICAgaXNOZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5oYXModGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBtb2RlbCBpcyBjdXJyZW50bHkgaW4gYSB2YWxpZCBzdGF0ZS5cbiAgICAgICAgaXNWYWxpZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh7fSwgXy5leHRlbmQob3B0aW9ucyB8fCB7fSwge3ZhbGlkYXRlOiB0cnVlfSkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBuZXh0IGNvbXBsZXRlIHNldCBvZiBtb2RlbCBhdHRyaWJ1dGVzLFxuICAgICAgICAvLyByZXR1cm5pbmcgYHRydWVgIGlmIGFsbCBpcyB3ZWxsLiBPdGhlcndpc2UsIGZpcmUgYW4gYFwiaW52YWxpZFwiYCBldmVudC5cbiAgICAgICAgX3ZhbGlkYXRlOiBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy52YWxpZGF0ZSB8fCAhdGhpcy52YWxpZGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGF0dHJzID0gXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKCFlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIGVycm9yLCBfLmV4dGVuZChvcHRpb25zLCB7dmFsaWRhdGlvbkVycm9yOiBlcnJvcn0pKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgTW9kZWwuXG4gICAgdmFyIG1vZGVsTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAncGFpcnMnLCAnaW52ZXJ0JywgJ3BpY2snLCAnb21pdCddO1xuXG4gICAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgTW9kZWwjYXR0cmlidXRlc2AuXG4gICAgXy5lYWNoKG1vZGVsTWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICBNb2RlbC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICByZXR1cm4gX1ttZXRob2RdLmFwcGx5KF8sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQmFja2JvbmUuQ29sbGVjdGlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIElmIG1vZGVscyB0ZW5kIHRvIHJlcHJlc2VudCBhIHNpbmdsZSByb3cgb2YgZGF0YSwgYSBCYWNrYm9uZSBDb2xsZWN0aW9uIGlzXG4gICAgLy8gbW9yZSBhbmFsYWdvdXMgdG8gYSB0YWJsZSBmdWxsIG9mIGRhdGEgLi4uIG9yIGEgc21hbGwgc2xpY2Ugb3IgcGFnZSBvZiB0aGF0XG4gICAgLy8gdGFibGUsIG9yIGEgY29sbGVjdGlvbiBvZiByb3dzIHRoYXQgYmVsb25nIHRvZ2V0aGVyIGZvciBhIHBhcnRpY3VsYXIgcmVhc29uXG4gICAgLy8gLS0gYWxsIG9mIHRoZSBtZXNzYWdlcyBpbiB0aGlzIHBhcnRpY3VsYXIgZm9sZGVyLCBhbGwgb2YgdGhlIGRvY3VtZW50c1xuICAgIC8vIGJlbG9uZ2luZyB0byB0aGlzIHBhcnRpY3VsYXIgYXV0aG9yLCBhbmQgc28gb24uIENvbGxlY3Rpb25zIG1haW50YWluXG4gICAgLy8gaW5kZXhlcyBvZiB0aGVpciBtb2RlbHMsIGJvdGggaW4gb3JkZXIsIGFuZCBmb3IgbG9va3VwIGJ5IGBpZGAuXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgKipDb2xsZWN0aW9uKiosIHBlcmhhcHMgdG8gY29udGFpbiBhIHNwZWNpZmljIHR5cGUgb2YgYG1vZGVsYC5cbiAgICAvLyBJZiBhIGBjb21wYXJhdG9yYCBpcyBzcGVjaWZpZWQsIHRoZSBDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cbiAgICAvLyBpdHMgbW9kZWxzIGluIHNvcnQgb3JkZXIsIGFzIHRoZXkncmUgYWRkZWQgYW5kIHJlbW92ZWQuXG4gICAgdmFyIENvbGxlY3Rpb24gPSBCYWNrYm9uZS5Db2xsZWN0aW9uID0gZnVuY3Rpb24gKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICBpZiAob3B0aW9ucy5tb2RlbClcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgICAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yICE9PSB2b2lkIDApXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAobW9kZWxzKVxuICAgICAgICAgICAgdGhpcy5yZXNldChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgfTtcblxuICAgIC8vIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbGxlY3Rpb24jc2V0YC5cbiAgICB2YXIgc2V0T3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogdHJ1ZSwgbWVyZ2U6IHRydWV9O1xuICAgIHZhciBhZGRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiBmYWxzZX07XG5cbiAgICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICAgIF8uZXh0ZW5kKENvbGxlY3Rpb24ucHJvdG90eXBlLCBFdmVudHMsIHtcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgbW9kZWwgZm9yIGEgY29sbGVjdGlvbiBpcyBqdXN0IGEgKipCYWNrYm9uZS5Nb2RlbCoqLlxuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIG1vc3QgY2FzZXMuXG4gICAgICAgIG1vZGVsOiBNb2RlbCxcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgICAgLy8gbW9kZWxzJyBhdHRyaWJ1dGVzLlxuICAgICAgICB0b0pTT046IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLnRvSlNPTihvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdC5cbiAgICAgICAgc3luYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRkIGEgbW9kZWwsIG9yIGxpc3Qgb2YgbW9kZWxzIHRvIHRoZSBzZXQuXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5leHRlbmQoe21lcmdlOiBmYWxzZX0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmVtb3ZlIGEgbW9kZWwsIG9yIGEgbGlzdCBvZiBtb2RlbHMgZnJvbSB0aGUgc2V0LlxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgICAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBfLmNsb25lKG1vZGVscyk7XG4gICAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICAgICAgdmFyIGksIGwsIGluZGV4LCBtb2RlbDtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBtb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV0gPSB0aGlzLmdldChtb2RlbHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICghbW9kZWwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmlkXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5jaWRdO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleE9mKG1vZGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlbW92ZScsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVXBkYXRlIGEgY29sbGVjdGlvbiBieSBgc2V0YC1pbmcgYSBuZXcgbGlzdCBvZiBtb2RlbHMsIGFkZGluZyBuZXcgb25lcyxcbiAgICAgICAgLy8gcmVtb3ZpbmcgbW9kZWxzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LCBhbmQgbWVyZ2luZyBtb2RlbHMgdGhhdFxuICAgICAgICAvLyBhbHJlYWR5IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBhcyBuZWNlc3NhcnkuIFNpbWlsYXIgdG8gKipNb2RlbCNzZXQqKixcbiAgICAgICAgLy8gdGhlIGNvcmUgb3BlcmF0aW9uIGZvciB1cGRhdGluZyB0aGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMoe30sIG9wdGlvbnMsIHNldE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyc2UpXG4gICAgICAgICAgICAgICAgbW9kZWxzID0gdGhpcy5wYXJzZShtb2RlbHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIHNpbmd1bGFyID0gIV8uaXNBcnJheShtb2RlbHMpO1xuICAgICAgICAgICAgbW9kZWxzID0gc2luZ3VsYXIgPyAobW9kZWxzID8gW21vZGVsc10gOiBbXSkgOiBfLmNsb25lKG1vZGVscyk7XG4gICAgICAgICAgICB2YXIgaSwgbCwgaWQsIG1vZGVsLCBhdHRycywgZXhpc3RpbmcsIHNvcnQ7XG4gICAgICAgICAgICB2YXIgYXQgPSBvcHRpb25zLmF0O1xuICAgICAgICAgICAgdmFyIHRhcmdldE1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgIHZhciBzb3J0YWJsZSA9IHRoaXMuY29tcGFyYXRvciAmJiAoYXQgPT0gbnVsbCkgJiYgb3B0aW9ucy5zb3J0ICE9PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzb3J0QXR0ciA9IF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSA/IHRoaXMuY29tcGFyYXRvciA6IG51bGw7XG4gICAgICAgICAgICB2YXIgdG9BZGQgPSBbXSwgdG9SZW1vdmUgPSBbXSwgbW9kZWxNYXAgPSB7fTtcbiAgICAgICAgICAgIHZhciBhZGQgPSBvcHRpb25zLmFkZCwgbWVyZ2UgPSBvcHRpb25zLm1lcmdlLCByZW1vdmUgPSBvcHRpb25zLnJlbW92ZTtcbiAgICAgICAgICAgIHZhciBvcmRlciA9ICFzb3J0YWJsZSAmJiBhZGQgJiYgcmVtb3ZlID8gW10gOiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gVHVybiBiYXJlIG9iamVjdHMgaW50byBtb2RlbCByZWZlcmVuY2VzLCBhbmQgcHJldmVudCBpbnZhbGlkIG1vZGVsc1xuICAgICAgICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBtb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMgPSBtb2RlbHNbaV0gfHwge307XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBtb2RlbCA9IGF0dHJzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gYXR0cnNbdGFyZ2V0TW9kZWwucHJvdG90eXBlLmlkQXR0cmlidXRlIHx8ICdpZCddO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGEgZHVwbGljYXRlIGlzIGZvdW5kLCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgYW5kXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxseSBtZXJnZSBpdCBpbnRvIHRoZSBleGlzdGluZyBtb2RlbC5cbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcgPSB0aGlzLmdldChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsTWFwW2V4aXN0aW5nLmNpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzID0gYXR0cnMgPT09IG1vZGVsID8gbW9kZWwuYXR0cmlidXRlcyA6IGF0dHJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSBleGlzdGluZy5wYXJzZShhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRhYmxlICYmICFzb3J0ICYmIGV4aXN0aW5nLmhhc0NoYW5nZWQoc29ydEF0dHIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsc1tpXSA9IGV4aXN0aW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcsIHZhbGlkIG1vZGVsLCBwdXNoIGl0IHRvIHRoZSBgdG9BZGRgIGxpc3QuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV0gPSB0aGlzLl9wcmVwYXJlTW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1vZGVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRvQWRkLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhZGQgbXVsdGlwbGUgbW9kZWxzIHdpdGggdGhlIHNhbWUgYGlkYC5cbiAgICAgICAgICAgICAgICBtb2RlbCA9IGV4aXN0aW5nIHx8IG1vZGVsO1xuICAgICAgICAgICAgICAgIGlmIChvcmRlciAmJiAobW9kZWwuaXNOZXcoKSB8fCAhbW9kZWxNYXBbbW9kZWwuaWRdKSlcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChtb2RlbCk7XG4gICAgICAgICAgICAgICAgbW9kZWxNYXBbbW9kZWwuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIG5vbmV4aXN0ZW50IG1vZGVscyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RlbE1hcFsobW9kZWwgPSB0aGlzLm1vZGVsc1tpXSkuY2lkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgICAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHNvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IHRvQWRkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG9BZGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoYXQgKyBpLCAwLCB0b0FkZFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JkZXJlZE1vZGVscyA9IG9yZGVyIHx8IHRvQWRkO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3JkZXJlZE1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWxzLnB1c2gob3JkZXJlZE1vZGVsc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNpbGVudGx5IHNvcnQgdGhlIGNvbGxlY3Rpb24gaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICBpZiAoc29ydClcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnQoe3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgICAgICAgICAvLyBVbmxlc3Mgc2lsZW5jZWQsIGl0J3MgdGltZSB0byBmaXJlIGFsbCBhcHByb3ByaWF0ZSBhZGQvc29ydCBldmVudHMuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRvQWRkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAobW9kZWwgPSB0b0FkZFtpXSkudHJpZ2dlcignYWRkJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc29ydCB8fCAob3JkZXIgJiYgb3JkZXIubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYWRkZWQgKG9yIG1lcmdlZCkgbW9kZWwgKG9yIG1vZGVscykuXG4gICAgICAgICAgICByZXR1cm4gc2luZ3VsYXIgPyBtb2RlbHNbMF0gOiBtb2RlbHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdoZW4geW91IGhhdmUgbW9yZSBpdGVtcyB0aGFuIHlvdSB3YW50IHRvIGFkZCBvciByZW1vdmUgaW5kaXZpZHVhbGx5LFxuICAgICAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgICAgIC8vIGFueSBncmFudWxhciBgYWRkYCBvciBgcmVtb3ZlYCBldmVudHMuIEZpcmVzIGByZXNldGAgd2hlbiBmaW5pc2hlZC5cbiAgICAgICAgLy8gVXNlZnVsIGZvciBidWxrIG9wZXJhdGlvbnMgYW5kIG9wdGltaXphdGlvbnMuXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAobW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgICAgIG1vZGVscyA9IHRoaXMuYWRkKG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdyZXNldCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVscztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgcHVzaDogZnVuY3Rpb24gKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogdGhpcy5sZW5ndGh9LCBvcHRpb25zKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgcG9wOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiAwfSwgb3B0aW9ucykpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgIHNoaWZ0OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCgwKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2xpY2Ugb3V0IGEgc3ViLWFycmF5IG9mIG1vZGVscyBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICBzbGljZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnlJZFtvYmpdIHx8IHRoaXMuX2J5SWRbb2JqLmlkXSB8fCB0aGlzLl9ieUlkW29iai5jaWRdO1xuICAgICAgICB9LFxuICAgICAgICAvLyBHZXQgdGhlIG1vZGVsIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgICAgYXQ6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzW2luZGV4XTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmV0dXJuIG1vZGVscyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzIG9mXG4gICAgICAgIC8vIGBmaWx0ZXJgLlxuICAgICAgICB3aGVyZTogZnVuY3Rpb24gKGF0dHJzLCBmaXJzdCkge1xuICAgICAgICAgICAgaWYgKF8uaXNFbXB0eShhdHRycykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID8gdm9pZCAwIDogW107XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG1vZGVsLmdldChrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IG1vZGVsIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXNcbiAgICAgICAgLy8gb2YgYGZpbmRgLlxuICAgICAgICBmaW5kV2hlcmU6IGZ1bmN0aW9uIChhdHRycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoYXR0cnMsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBGb3JjZSB0aGUgY29sbGVjdGlvbiB0byByZS1zb3J0IGl0c2VsZi4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIHVuZGVyXG4gICAgICAgIC8vIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBhcyB0aGUgc2V0IHdpbGwgbWFpbnRhaW4gc29ydCBvcmRlciBhcyBlYWNoIGl0ZW1cbiAgICAgICAgLy8gaXMgYWRkZWQuXG4gICAgICAgIHNvcnQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tcGFyYXRvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzb3J0IGEgc2V0IHdpdGhvdXQgYSBjb21wYXJhdG9yJyk7XG4gICAgICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgICAgICAgICAvLyBSdW4gc29ydCBiYXNlZCBvbiB0eXBlIG9mIGBjb21wYXJhdG9yYC5cbiAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgfHwgdGhpcy5jb21wYXJhdG9yLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxzID0gdGhpcy5zb3J0QnkodGhpcy5jb21wYXJhdG9yLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbHMuc29ydChfLmJpbmQodGhpcy5jb21wYXJhdG9yLCB0aGlzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgcGx1Y2s6IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5pbnZva2UodGhpcy5tb2RlbHMsICdnZXQnLCBhdHRyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGRlZmF1bHQgc2V0IG9mIG1vZGVscyBmb3IgdGhpcyBjb2xsZWN0aW9uLCByZXNldHRpbmcgdGhlXG4gICAgICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxuICAgICAgICAvLyBkYXRhIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdGhlIGByZXNldGAgbWV0aG9kIGluc3RlYWQgb2YgYHNldGAuXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zLnJlc2V0ID8gJ3Jlc2V0JyA6ICdzZXQnO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25bbWV0aG9kXShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyhjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnRyaWdnZXIoJ3N5bmMnLCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIG1vZGVsIGluIHRoaXMgY29sbGVjdGlvbi4gQWRkIHRoZSBtb2RlbCB0byB0aGVcbiAgICAgICAgLy8gY29sbGVjdGlvbiBpbW1lZGlhdGVseSwgdW5sZXNzIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIHNlcnZlciB0byBhZ3JlZS5cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgICAgICAgaWYgKCEobW9kZWwgPSB0aGlzLl9wcmVwYXJlTW9kZWwobW9kZWwsIG9wdGlvbnMpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMud2FpdClcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uIChtb2RlbCwgcmVzcCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndhaXQpXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbW9kZWwuc2F2ZShudWxsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gKipwYXJzZSoqIGNvbnZlcnRzIGEgcmVzcG9uc2UgaW50byBhIGxpc3Qgb2YgbW9kZWxzIHRvIGJlIGFkZGVkIHRvIHRoZVxuICAgICAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChyZXNwLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCBhbiBpZGVudGljYWwgbGlzdCBvZiBtb2RlbHMgYXMgdGhpcyBvbmUuXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5tb2RlbHMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBQcml2YXRlIG1ldGhvZCB0byByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGUuIENhbGxlZCB3aGVuIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgIC8vIGlzIGZpcnN0IGluaXRpYWxpemVkIG9yIHJlc2V0LlxuICAgICAgICBfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzID0gW107XG4gICAgICAgICAgICB0aGlzLl9ieUlkID0ge307XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgICAgIC8vIGNvbGxlY3Rpb24uXG4gICAgICAgIF9wcmVwYXJlTW9kZWw6IGZ1bmN0aW9uIChhdHRycywgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGF0dHJzIGluc3RhbmNlb2YgTW9kZWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICAgICAgICBvcHRpb25zLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFtb2RlbC52YWxpZGF0aW9uRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgbW9kZWwudmFsaWRhdGlvbkVycm9yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgICAgIF9hZGRSZWZlcmVuY2U6IGZ1bmN0aW9uIChtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICAgICAgICBpZiAobW9kZWwuaWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLl9ieUlkW21vZGVsLmlkXSA9IG1vZGVsO1xuICAgICAgICAgICAgaWYgKCFtb2RlbC5jb2xsZWN0aW9uKVxuICAgICAgICAgICAgICAgIG1vZGVsLmNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgbW9kZWwub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXZlciBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uIChtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1vZGVsLmNvbGxlY3Rpb247XG4gICAgICAgICAgICBtb2RlbC5vZmYoJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZGVsIGluIHRoZSBzZXQgZmlyZXMgYW4gZXZlbnQuXG4gICAgICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcbiAgICAgICAgLy8gZXZlbnRzIHNpbXBseSBwcm94eSB0aHJvdWdoLiBcImFkZFwiIGFuZCBcInJlbW92ZVwiIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZVxuICAgICAgICAvLyBpbiBvdGhlciBjb2xsZWN0aW9ucyBhcmUgaWdub3JlZC5cbiAgICAgICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24gKGV2ZW50LCBtb2RlbCwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKChldmVudCA9PT0gJ2FkZCcgfHwgZXZlbnQgPT09ICdyZW1vdmUnKSAmJiBjb2xsZWN0aW9uICE9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ2Rlc3Ryb3knKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtb2RlbCAmJiBldmVudCA9PT0gJ2NoYW5nZTonICsgbW9kZWwuaWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5wcmV2aW91cyhtb2RlbC5pZEF0dHJpYnV0ZSldO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5pZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ieUlkW21vZGVsLmlkXSA9IG1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIENvbGxlY3Rpb24uXG4gICAgLy8gOTAlIG9mIHRoZSBjb3JlIHVzZWZ1bG5lc3Mgb2YgQmFja2JvbmUgQ29sbGVjdGlvbnMgaXMgYWN0dWFsbHkgaW1wbGVtZW50ZWRcbiAgICAvLyByaWdodCBoZXJlOlxuICAgIHZhciBtZXRob2RzID0gWydmb3JFYWNoJywgJ2VhY2gnLCAnbWFwJywgJ2NvbGxlY3QnLCAncmVkdWNlJywgJ2ZvbGRsJyxcbiAgICAgICAgJ2luamVjdCcsICdyZWR1Y2VSaWdodCcsICdmb2xkcicsICdmaW5kJywgJ2RldGVjdCcsICdmaWx0ZXInLCAnc2VsZWN0JyxcbiAgICAgICAgJ3JlamVjdCcsICdldmVyeScsICdhbGwnLCAnc29tZScsICdhbnknLCAnaW5jbHVkZScsICdjb250YWlucycsICdpbnZva2UnLFxuICAgICAgICAnbWF4JywgJ21pbicsICd0b0FycmF5JywgJ3NpemUnLCAnZmlyc3QnLCAnaGVhZCcsICd0YWtlJywgJ2luaXRpYWwnLCAncmVzdCcsXG4gICAgICAgICd0YWlsJywgJ2Ryb3AnLCAnbGFzdCcsICd3aXRob3V0JywgJ2RpZmZlcmVuY2UnLCAnaW5kZXhPZicsICdzaHVmZmxlJyxcbiAgICAgICAgJ2xhc3RJbmRleE9mJywgJ2lzRW1wdHknLCAnY2hhaW4nLCAnc2FtcGxlJ107XG5cbiAgICAvLyBNaXggaW4gZWFjaCBVbmRlcnNjb3JlIG1ldGhvZCBhcyBhIHByb3h5IHRvIGBDb2xsZWN0aW9uI21vZGVsc2AuXG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMubW9kZWxzKTtcbiAgICAgICAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB0YWtlIGEgcHJvcGVydHkgbmFtZSBhcyBhbiBhcmd1bWVudC5cbiAgICB2YXIgYXR0cmlidXRlTWV0aG9kcyA9IFsnZ3JvdXBCeScsICdjb3VudEJ5JywgJ3NvcnRCeScsICdpbmRleEJ5J107XG5cbiAgICAvLyBVc2UgYXR0cmlidXRlcyBpbnN0ZWFkIG9mIHByb3BlcnRpZXMuXG4gICAgXy5lYWNoKGF0dHJpYnV0ZU1ldGhvZHMsIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzLm1vZGVscywgaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQmFja2JvbmUuVmlld1xuICAgIC8vIC0tLS0tLS0tLS0tLS1cblxuICAgIC8vIEJhY2tib25lIFZpZXdzIGFyZSBhbG1vc3QgbW9yZSBjb252ZW50aW9uIHRoYW4gdGhleSBhcmUgYWN0dWFsIGNvZGUuIEEgVmlld1xuICAgIC8vIGlzIHNpbXBseSBhIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGxvZ2ljYWwgY2h1bmsgb2YgVUkgaW4gdGhlXG4gICAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gICAgLy8gZXZlbiB0aGUgc3Vycm91bmRpbmcgZnJhbWUgd2hpY2ggd3JhcHMgeW91ciB3aG9sZSBhcHAuIERlZmluaW5nIGEgY2h1bmsgb2ZcbiAgICAvLyBVSSBhcyBhICoqVmlldyoqIGFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgRE9NIGV2ZW50cyBkZWNsYXJhdGl2ZWx5LCB3aXRob3V0XG4gICAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gICAgLy8gcmVhY3QgdG8gc3BlY2lmaWMgY2hhbmdlcyBpbiB0aGUgc3RhdGUgb2YgeW91ciBtb2RlbHMuXG5cbiAgICAvLyBDcmVhdGluZyBhIEJhY2tib25lLlZpZXcgY3JlYXRlcyBpdHMgaW5pdGlhbCBlbGVtZW50IG91dHNpZGUgb2YgdGhlIERPTSxcbiAgICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICAgIHZhciBWaWV3ID0gQmFja2JvbmUuVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgndmlldycpO1xuICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICBfLmV4dGVuZCh0aGlzLCBfLnBpY2sob3B0aW9ucywgdmlld09wdGlvbnMpKTtcbiAgICAgICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgIH07XG5cbiAgICAvLyBDYWNoZWQgcmVnZXggdG8gc3BsaXQga2V5cyBmb3IgYGRlbGVnYXRlYC5cbiAgICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gICAgLy8gTGlzdCBvZiB2aWV3IG9wdGlvbnMgdG8gYmUgbWVyZ2VkIGFzIHByb3BlcnRpZXMuXG4gICAgdmFyIHZpZXdPcHRpb25zID0gWydtb2RlbCcsICdjb2xsZWN0aW9uJywgJ2VsJywgJ2lkJywgJ2F0dHJpYnV0ZXMnLCAnY2xhc3NOYW1lJywgJ3RhZ05hbWUnLCAnZXZlbnRzJ107XG5cbiAgICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gICAgXy5leHRlbmQoVmlldy5wcm90b3R5cGUsIEV2ZW50cywge1xuICAgICAgICAvLyBUaGUgZGVmYXVsdCBgdGFnTmFtZWAgb2YgYSBWaWV3J3MgZWxlbWVudCBpcyBgXCJkaXZcImAuXG4gICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICAvLyBqUXVlcnkgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcbiAgICAgICAgLy8gY3VycmVudCB2aWV3LiBUaGlzIHNob3VsZCBiZSBwcmVmZXJyZWQgdG8gZ2xvYmFsIGxvb2t1cHMgd2hlcmUgcG9zc2libGUuXG4gICAgICAgICQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoc2VsZWN0b3IpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gKipyZW5kZXIqKiBpcyB0aGUgY29yZSBmdW5jdGlvbiB0aGF0IHlvdXIgdmlldyBzaG91bGQgb3ZlcnJpZGUsIGluIG9yZGVyXG4gICAgICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAgICAgLy8gY29udmVudGlvbiBpcyBmb3IgKipyZW5kZXIqKiB0byBhbHdheXMgcmV0dXJuIGB0aGlzYC5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAgICAgLy8gYXBwbGljYWJsZSBCYWNrYm9uZS5FdmVudHMgbGlzdGVuZXJzLlxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSwgaW5jbHVkaW5nIGV2ZW50XG4gICAgICAgIC8vIHJlLWRlbGVnYXRpb24uXG4gICAgICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGVsKVxuICAgICAgICAgICAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy4kZWwgPSBlbGVtZW50IGluc3RhbmNlb2YgQmFja2JvbmUuJCA/IGVsZW1lbnQgOiBCYWNrYm9uZS4kKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbCA9IHRoaXMuJGVsWzBdO1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKntcImV2ZW50IHNlbGVjdG9yXCI6IFwiY2FsbGJhY2tcIn0qXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICdtb3VzZWRvd24gLnRpdGxlJzogICdlZGl0JyxcbiAgICAgICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgICAgICAvLyAgICAgICAnY2xpY2sgLm9wZW4nOiAgICAgICBmdW5jdGlvbihlKSB7IC4uLiB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHBhaXJzLiBDYWxsYmFja3Mgd2lsbCBiZSBib3VuZCB0byB0aGUgdmlldywgd2l0aCBgdGhpc2Agc2V0IHByb3Blcmx5LlxuICAgICAgICAvLyBVc2VzIGV2ZW50IGRlbGVnYXRpb24gZm9yIGVmZmljaWVuY3kuXG4gICAgICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgICAgICAvLyBUaGlzIG9ubHkgd29ya3MgZm9yIGRlbGVnYXRlLWFibGUgZXZlbnRzOiBub3QgYGZvY3VzYCwgYGJsdXJgLCBhbmRcbiAgICAgICAgLy8gbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIShldmVudHMgfHwgKGV2ZW50cyA9IF8ucmVzdWx0KHRoaXMsICdldmVudHMnKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGV2ZW50c1trZXldO1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKG1ldGhvZCkpXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHRoaXNbZXZlbnRzW2tleV1dO1xuICAgICAgICAgICAgICAgIGlmICghbWV0aG9kKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGtleS5tYXRjaChkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIpO1xuICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBtYXRjaFsxXSwgc2VsZWN0b3IgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBfLmJpbmQobWV0aG9kLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBldmVudE5hbWUgKz0gJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLm9uKGV2ZW50TmFtZSwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIHNlbGVjdG9yLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDbGVhcnMgYWxsIGNhbGxiYWNrcyBwcmV2aW91c2x5IGJvdW5kIHRvIHRoZSB2aWV3IHdpdGggYGRlbGVnYXRlRXZlbnRzYC5cbiAgICAgICAgLy8gWW91IHVzdWFsbHkgZG9uJ3QgbmVlZCB0byB1c2UgdGhpcywgYnV0IG1heSB3aXNoIHRvIGlmIHlvdSBoYXZlIG11bHRpcGxlXG4gICAgICAgIC8vIEJhY2tib25lIHZpZXdzIGF0dGFjaGVkIHRvIHRoZSBzYW1lIERPTSBlbGVtZW50LlxuICAgICAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5vZmYoJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgICAgICAvLyBtYXRjaGluZyBlbGVtZW50LCBhbmQgcmUtYXNzaWduIGl0IHRvIGBlbGAuIE90aGVyd2lzZSwgY3JlYXRlXG4gICAgICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgICAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNbJ2NsYXNzJ10gPSBfLnJlc3VsdCh0aGlzLCAnY2xhc3NOYW1lJyk7XG4gICAgICAgICAgICAgICAgdmFyICRlbCA9IEJhY2tib25lLiQoJzwnICsgXy5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKSArICc+JykuYXR0cihhdHRycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KCRlbCwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVsZW1lbnQoXy5yZXN1bHQodGhpcywgJ2VsJyksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyBCYWNrYm9uZS5zeW5jXG4gICAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBjaGFuZ2UgdGhlIG1hbm5lciBpbiB3aGljaCBCYWNrYm9uZSBwZXJzaXN0c1xuICAgIC8vIG1vZGVscyB0byB0aGUgc2VydmVyLiBZb3Ugd2lsbCBiZSBwYXNzZWQgdGhlIHR5cGUgb2YgcmVxdWVzdCwgYW5kIHRoZVxuICAgIC8vIG1vZGVsIGluIHF1ZXN0aW9uLiBCeSBkZWZhdWx0LCBtYWtlcyBhIFJFU1RmdWwgQWpheCByZXF1ZXN0XG4gICAgLy8gdG8gdGhlIG1vZGVsJ3MgYHVybCgpYC4gU29tZSBwb3NzaWJsZSBjdXN0b21pemF0aW9ucyBjb3VsZCBiZTpcbiAgICAvL1xuICAgIC8vICogVXNlIGBzZXRUaW1lb3V0YCB0byBiYXRjaCByYXBpZC1maXJlIHVwZGF0ZXMgaW50byBhIHNpbmdsZSByZXF1ZXN0LlxuICAgIC8vICogU2VuZCB1cCB0aGUgbW9kZWxzIGFzIFhNTCBpbnN0ZWFkIG9mIEpTT04uXG4gICAgLy8gKiBQZXJzaXN0IG1vZGVscyB2aWEgV2ViU29ja2V0cyBpbnN0ZWFkIG9mIEFqYXguXG4gICAgLy9cbiAgICAvLyBUdXJuIG9uIGBCYWNrYm9uZS5lbXVsYXRlSFRUUGAgaW4gb3JkZXIgdG8gc2VuZCBgUFVUYCBhbmQgYERFTEVURWAgcmVxdWVzdHNcbiAgICAvLyBhcyBgUE9TVGAsIHdpdGggYSBgX21ldGhvZGAgcGFyYW1ldGVyIGNvbnRhaW5pbmcgdGhlIHRydWUgSFRUUCBtZXRob2QsXG4gICAgLy8gYXMgd2VsbCBhcyBhbGwgcmVxdWVzdHMgd2l0aCB0aGUgYm9keSBhcyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYFxuICAgIC8vIGluc3RlYWQgb2YgYGFwcGxpY2F0aW9uL2pzb25gIHdpdGggdGhlIG1vZGVsIGluIGEgcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgICAvLyBVc2VmdWwgd2hlbiBpbnRlcmZhY2luZyB3aXRoIHNlcnZlci1zaWRlIGxhbmd1YWdlcyBsaWtlICoqUEhQKiogdGhhdCBtYWtlXG4gICAgLy8gaXQgZGlmZmljdWx0IHRvIHJlYWQgdGhlIGJvZHkgb2YgYFBVVGAgcmVxdWVzdHMuXG4gICAgQmFja2JvbmUuc3luYyA9IGZ1bmN0aW9uIChtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0eXBlID0gbWV0aG9kTWFwW21ldGhvZF07XG5cbiAgICAgICAgLy8gRGVmYXVsdCBvcHRpb25zLCB1bmxlc3Mgc3BlY2lmaWVkLlxuICAgICAgICBfLmRlZmF1bHRzKG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSksIHtcbiAgICAgICAgICAgIGVtdWxhdGVIVFRQOiBCYWNrYm9uZS5lbXVsYXRlSFRUUCxcbiAgICAgICAgICAgIGVtdWxhdGVKU09OOiBCYWNrYm9uZS5lbXVsYXRlSlNPTlxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEZWZhdWx0IEpTT04tcmVxdWVzdCBvcHRpb25zLlxuICAgICAgICB2YXIgcGFyYW1zID0ge3R5cGU6IHR5cGUsIGRhdGFUeXBlOiAnanNvbid9O1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgYSBVUkwuXG4gICAgICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIHBhcmFtcy51cmwgPSBfLnJlc3VsdChtb2RlbCwgJ3VybCcpIHx8IHVybEVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBhcHByb3ByaWF0ZSByZXF1ZXN0IGRhdGEuXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEgPT0gbnVsbCAmJiBtb2RlbCAmJiAobWV0aG9kID09PSAnY3JlYXRlJyB8fCBtZXRob2QgPT09ICd1cGRhdGUnIHx8IG1ldGhvZCA9PT0gJ3BhdGNoJykpIHtcbiAgICAgICAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIHBhcmFtcy5kYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hdHRycyB8fCBtb2RlbC50b0pTT04ob3B0aW9ucykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSlNPTiBieSBlbmNvZGluZyB0aGUgcmVxdWVzdCBpbnRvIGFuIEhUTUwtZm9ybS5cbiAgICAgICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgICAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgcGFyYW1zLmRhdGEgPSBwYXJhbXMuZGF0YSA/IHttb2RlbDogcGFyYW1zLmRhdGF9IDoge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBIVFRQIGJ5IG1pbWlja2luZyB0aGUgSFRUUCBtZXRob2Qgd2l0aCBgX21ldGhvZGBcbiAgICAgICAgLy8gQW5kIGFuIGBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gICAgICAgIGlmIChvcHRpb25zLmVtdWxhdGVIVFRQICYmICh0eXBlID09PSAnUFVUJyB8fCB0eXBlID09PSAnREVMRVRFJyB8fCB0eXBlID09PSAnUEFUQ0gnKSkge1xuICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSAnUE9TVCc7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTilcbiAgICAgICAgICAgICAgICBwYXJhbXMuZGF0YS5fbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgIHZhciBiZWZvcmVTZW5kID0gb3B0aW9ucy5iZWZvcmVTZW5kO1xuICAgICAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kID0gZnVuY3Rpb24gKHhocikge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgdHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZVNlbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmVTZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBkYXRhIG9uIGEgbm9uLUdFVCByZXF1ZXN0LlxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdHRVQnICYmICFvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICAgICAgICBwYXJhbXMucHJvY2Vzc0RhdGEgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlJ3JlIHNlbmRpbmcgYSBgUEFUQ0hgIHJlcXVlc3QsIGFuZCB3ZSdyZSBpbiBhbiBvbGQgSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgLy8gdGhhdCBzdGlsbCBoYXMgQWN0aXZlWCBlbmFibGVkIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGpRdWVyeSB0byB1c2UgdGhhdFxuICAgICAgICAvLyBmb3IgWEhSIGluc3RlYWQuIFJlbW92ZSB0aGlzIGxpbmUgd2hlbiBqUXVlcnkgc3VwcG9ydHMgYFBBVENIYCBvbiBJRTguXG4gICAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ1BBVENIJyAmJiBub1hoclBhdGNoKSB7XG4gICAgICAgICAgICBwYXJhbXMueGhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2UgdGhlIHJlcXVlc3QsIGFsbG93aW5nIHRoZSB1c2VyIHRvIG92ZXJyaWRlIGFueSBBamF4IG9wdGlvbnMuXG4gICAgICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlcXVlc3QnLCBtb2RlbCwgeGhyLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuXG4gICAgdmFyIG5vWGhyUGF0Y2ggPVxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmXG4gICAgICAgICEod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmIChuZXcgWE1MSHR0cFJlcXVlc3QpLmRpc3BhdGNoRXZlbnQpO1xuXG4gICAgLy8gTWFwIGZyb20gQ1JVRCB0byBIVFRQIGZvciBvdXIgZGVmYXVsdCBgQmFja2JvbmUuc3luY2AgaW1wbGVtZW50YXRpb24uXG4gICAgdmFyIG1ldGhvZE1hcCA9IHtcbiAgICAgICAgJ2NyZWF0ZSc6ICdQT1NUJyxcbiAgICAgICAgJ3VwZGF0ZSc6ICdQVVQnLFxuICAgICAgICAncGF0Y2gnOiAnUEFUQ0gnLFxuICAgICAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgICAgICdyZWFkJzogJ0dFVCdcbiAgICB9O1xuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBCYWNrYm9uZS5hamF4YCB0byBwcm94eSB0aHJvdWdoIHRvIGAkYC5cbiAgICAvLyBPdmVycmlkZSB0aGlzIGlmIHlvdSdkIGxpa2UgdG8gdXNlIGEgZGlmZmVyZW50IGxpYnJhcnkuXG4gICAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJhY2tib25lLiQuYWpheC5hcHBseShCYWNrYm9uZS4kLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICAvLyBCYWNrYm9uZS5Sb3V0ZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIFJvdXRlcnMgbWFwIGZhdXgtVVJMcyB0byBhY3Rpb25zLCBhbmQgZmlyZSBldmVudHMgd2hlbiByb3V0ZXMgYXJlXG4gICAgLy8gbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgICB2YXIgUm91dGVyID0gQmFja2JvbmUuUm91dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMucm91dGVzKVxuICAgICAgICAgICAgdGhpcy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICAgICAgdGhpcy5fYmluZFJvdXRlcygpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgLy8gQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIG1hdGNoaW5nIG5hbWVkIHBhcmFtIHBhcnRzIGFuZCBzcGxhdHRlZFxuICAgIC8vIHBhcnRzIG9mIHJvdXRlIHN0cmluZ3MuXG4gICAgdmFyIG9wdGlvbmFsUGFyYW0gPSAvXFwoKC4qPylcXCkvZztcbiAgICB2YXIgbmFtZWRQYXJhbSA9IC8oXFwoXFw/KT86XFx3Ky9nO1xuICAgIHZhciBzcGxhdFBhcmFtID0gL1xcKlxcdysvZztcbiAgICB2YXIgZXNjYXBlUmVnRXhwID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xuXG4gICAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlJvdXRlcioqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gICAgXy5leHRlbmQoUm91dGVyLnByb3RvdHlwZSwgRXZlbnRzLCB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgICAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB9LFxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIGEgc2luZ2xlIG5hbWVkIHJvdXRlIHRvIGEgY2FsbGJhY2suIEZvciBleGFtcGxlOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgdGhpcy5yb3V0ZSgnc2VhcmNoLzpxdWVyeS9wOm51bScsICdzZWFyY2gnLCBmdW5jdGlvbihxdWVyeSwgbnVtKSB7XG4gICAgICAgIC8vICAgICAgIC4uLlxuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vXG4gICAgICAgIHJvdXRlOiBmdW5jdGlvbiAocm91dGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIV8uaXNSZWdFeHAocm91dGUpKVxuICAgICAgICAgICAgICAgIHJvdXRlID0gdGhpcy5fcm91dGVUb1JlZ0V4cChyb3V0ZSk7XG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgdmFyIHJvdXRlciA9IHRoaXM7XG4gICAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnJvdXRlKHJvdXRlLCBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHJvdXRlci5fZXh0cmFjdFBhcmFtZXRlcnMocm91dGUsIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICByb3V0ZXIuZXhlY3V0ZShjYWxsYmFjaywgYXJncyk7XG4gICAgICAgICAgICAgICAgcm91dGVyLnRyaWdnZXIuYXBwbHkocm91dGVyLCBbJ3JvdXRlOicgKyBuYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIHJvdXRlci50cmlnZ2VyKCdyb3V0ZScsIG5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIEJhY2tib25lLmhpc3RvcnkudHJpZ2dlcigncm91dGUnLCByb3V0ZXIsIG5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRXhlY3V0ZSBhIHJvdXRlIGhhbmRsZXIgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy4gIFRoaXMgaXMgYW5cbiAgICAgICAgLy8gZXhjZWxsZW50IHBsYWNlIHRvIGRvIHByZS1yb3V0ZSBzZXR1cCBvciBwb3N0LXJvdXRlIGNsZWFudXAuXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTaW1wbGUgcHJveHkgdG8gYEJhY2tib25lLmhpc3RvcnlgIHRvIHNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoaXN0b3J5LlxuICAgICAgICBuYXZpZ2F0ZTogZnVuY3Rpb24gKGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKGZyYWdtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBCaW5kIGFsbCBkZWZpbmVkIHJvdXRlcyB0byBgQmFja2JvbmUuaGlzdG9yeWAuIFdlIGhhdmUgdG8gcmV2ZXJzZSB0aGVcbiAgICAgICAgLy8gb3JkZXIgb2YgdGhlIHJvdXRlcyBoZXJlIHRvIHN1cHBvcnQgYmVoYXZpb3Igd2hlcmUgdGhlIG1vc3QgZ2VuZXJhbFxuICAgICAgICAvLyByb3V0ZXMgY2FuIGJlIGRlZmluZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcm91dGUgbWFwLlxuICAgICAgICBfYmluZFJvdXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvdXRlcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJvdXRlcyA9IF8ucmVzdWx0KHRoaXMsICdyb3V0ZXMnKTtcbiAgICAgICAgICAgIHZhciByb3V0ZSwgcm91dGVzID0gXy5rZXlzKHRoaXMucm91dGVzKTtcbiAgICAgICAgICAgIHdoaWxlICgocm91dGUgPSByb3V0ZXMucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlKHJvdXRlLCB0aGlzLnJvdXRlc1tyb3V0ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBDb252ZXJ0IGEgcm91dGUgc3RyaW5nIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24sIHN1aXRhYmxlIGZvciBtYXRjaGluZ1xuICAgICAgICAvLyBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGhhc2guXG4gICAgICAgIF9yb3V0ZVRvUmVnRXhwOiBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShlc2NhcGVSZWdFeHAsICdcXFxcJCYnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKG9wdGlvbmFsUGFyYW0sICcoPzokMSk/JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbiAobWF0Y2gsIG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25hbCA/IG1hdGNoIDogJyhbXi8/XSspJztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoW14/XSo/KScpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2l2ZW4gYSByb3V0ZSwgYW5kIGEgVVJMIGZyYWdtZW50IHRoYXQgaXQgbWF0Y2hlcywgcmV0dXJuIHRoZSBhcnJheSBvZlxuICAgICAgICAvLyBleHRyYWN0ZWQgZGVjb2RlZCBwYXJhbWV0ZXJzLiBFbXB0eSBvciB1bm1hdGNoZWQgcGFyYW1ldGVycyB3aWxsIGJlXG4gICAgICAgIC8vIHRyZWF0ZWQgYXMgYG51bGxgIHRvIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICAgICAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uIChyb3V0ZSwgZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSByb3V0ZS5leGVjKGZyYWdtZW50KS5zbGljZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBfLm1hcChwYXJhbXMsIGZ1bmN0aW9uIChwYXJhbSwgaSkge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGRlY29kZSB0aGUgc2VhcmNoIHBhcmFtcy5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gcGFyYW1zLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbSA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSkgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gQmFja2JvbmUuSGlzdG9yeVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIEhhbmRsZXMgY3Jvc3MtYnJvd3NlciBoaXN0b3J5IG1hbmFnZW1lbnQsIGJhc2VkIG9uIGVpdGhlclxuICAgIC8vIFtwdXNoU3RhdGVdKGh0dHA6Ly9kaXZlaW50b2h0bWw1LmluZm8vaGlzdG9yeS5odG1sKSBhbmQgcmVhbCBVUkxzLCBvclxuICAgIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gICAgLy8gYW5kIFVSTCBmcmFnbWVudHMuIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIG5laXRoZXIgKG9sZCBJRSwgbmF0Y2gpLFxuICAgIC8vIGZhbGxzIGJhY2sgdG8gcG9sbGluZy5cbiAgICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgXy5iaW5kQWxsKHRoaXMsICdjaGVja1VybCcpO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGBIaXN0b3J5YCBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBicm93c2VyLlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyBhIGxlYWRpbmcgaGFzaC9zbGFzaCBhbmQgdHJhaWxpbmcgc3BhY2UuXG4gICAgdmFyIHJvdXRlU3RyaXBwZXIgPSAvXlsjXFwvXXxcXHMrJC9nO1xuXG4gICAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcy5cbiAgICB2YXIgcm9vdFN0cmlwcGVyID0gL15cXC8rfFxcLyskL2c7XG5cbiAgICAvLyBDYWNoZWQgcmVnZXggZm9yIGRldGVjdGluZyBNU0lFLlxuICAgIHZhciBpc0V4cGxvcmVyID0gL21zaWUgW1xcdy5dKy87XG5cbiAgICAvLyBDYWNoZWQgcmVnZXggZm9yIHJlbW92aW5nIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgdmFyIHRyYWlsaW5nU2xhc2ggPSAvXFwvJC87XG5cbiAgICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyB1cmxzIG9mIGhhc2guXG4gICAgdmFyIHBhdGhTdHJpcHBlciA9IC8jLiokLztcblxuICAgIC8vIEhhcyB0aGUgaGlzdG9yeSBoYW5kbGluZyBhbHJlYWR5IGJlZW4gc3RhcnRlZD9cbiAgICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5IaXN0b3J5KiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgICBfLmV4dGVuZChIaXN0b3J5LnByb3RvdHlwZSwgRXZlbnRzLCB7XG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGludGVydmFsIHRvIHBvbGwgZm9yIGhhc2ggY2hhbmdlcywgaWYgbmVjZXNzYXJ5LCBpc1xuICAgICAgICAvLyB0d2VudHkgdGltZXMgYSBzZWNvbmQuXG4gICAgICAgIGludGVydmFsOiA1MCxcbiAgICAgICAgLy8gQXJlIHdlIGF0IHRoZSBhcHAgcm9vdD9cbiAgICAgICAgYXRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpID09PSB0aGlzLnJvb3Q7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldHMgdGhlIHRydWUgaGFzaCB2YWx1ZS4gQ2Fubm90IHVzZSBsb2NhdGlvbi5oYXNoIGRpcmVjdGx5IGR1ZSB0byBidWdcbiAgICAgICAgLy8gaW4gRmlyZWZveCB3aGVyZSBsb2NhdGlvbi5oYXNoIHdpbGwgYWx3YXlzIGJlIGRlY29kZWQuXG4gICAgICAgIGdldEhhc2g6IGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9ICh3aW5kb3cgfHwgdGhpcykubG9jYXRpb24uaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgICAgICB9LFxuICAgICAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQsIGVpdGhlciBmcm9tIHRoZSBVUkwsXG4gICAgICAgIC8vIHRoZSBoYXNoLCBvciB0aGUgb3ZlcnJpZGUuXG4gICAgICAgIGdldEZyYWdtZW50OiBmdW5jdGlvbiAoZnJhZ21lbnQsIGZvcmNlUHVzaFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUgfHwgIXRoaXMuX3dhbnRzSGFzaENoYW5nZSB8fCBmb3JjZVB1c2hTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGRlY29kZVVSSSh0aGlzLmxvY2F0aW9uLnBhdGhuYW1lICsgdGhpcy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdC5yZXBsYWNlKHRyYWlsaW5nU2xhc2gsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFnbWVudC5pbmRleE9mKHJvb3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5zbGljZShyb290Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFN0YXJ0IHRoZSBoYXNoIGNoYW5nZSBoYW5kbGluZywgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY3VycmVudCBVUkwgbWF0Y2hlc1xuICAgICAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAgICBzdGFydDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChIaXN0b3J5LnN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2JvbmUuaGlzdG9yeSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWRcIik7XG4gICAgICAgICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24uIERvIHdlIG5lZWQgYW4gaWZyYW1lP1xuICAgICAgICAgICAgLy8gSXMgcHVzaFN0YXRlIGRlc2lyZWQgLi4uIGlzIGl0IGF2YWlsYWJsZT9cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHtyb290OiAnLyd9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5yb290ID0gdGhpcy5vcHRpb25zLnJvb3Q7XG4gICAgICAgICAgICB0aGlzLl93YW50c0hhc2hDaGFuZ2UgPSB0aGlzLm9wdGlvbnMuaGFzaENoYW5nZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl93YW50c1B1c2hTdGF0ZSA9ICEhdGhpcy5vcHRpb25zLnB1c2hTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSA9ICEhKHRoaXMub3B0aW9ucy5wdXNoU3RhdGUgJiYgdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUpO1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuICAgICAgICAgICAgdmFyIGRvY01vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG4gICAgICAgICAgICB2YXIgb2xkSUUgPSAoaXNFeHBsb3Jlci5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkgJiYgKCFkb2NNb2RlIHx8IGRvY01vZGUgPD0gNykpO1xuXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgcm9vdCB0byBhbHdheXMgaW5jbHVkZSBhIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICAgICAgdGhpcy5yb290ID0gKCcvJyArIHRoaXMucm9vdCArICcvJykucmVwbGFjZShyb290U3RyaXBwZXIsICcvJyk7XG5cbiAgICAgICAgICAgIGlmIChvbGRJRSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBCYWNrYm9uZS4kKCc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIHRhYmluZGV4PVwiLTFcIj4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlmcmFtZSA9IGZyYW1lLmhpZGUoKS5hcHBlbmRUbygnYm9keScpWzBdLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZShmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlIHVzaW5nIHB1c2hTdGF0ZSBvciBoYXNoZXMsIGFuZCB3aGV0aGVyXG4gICAgICAgICAgICAvLyAnb25oYXNoY2hhbmdlJyBpcyBzdXBwb3J0ZWQsIGRldGVybWluZSBob3cgd2UgY2hlY2sgdGhlIFVSTCBzdGF0ZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBCYWNrYm9uZS4kKHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiAoJ29uaGFzaGNoYW5nZScgaW4gd2luZG93KSAmJiAhb2xkSUUpIHtcbiAgICAgICAgICAgICAgICBCYWNrYm9uZS4kKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tVcmxJbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMuY2hlY2tVcmwsIHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBjaGFuZ2UgdGhlIGJhc2UgdXJsLCBmb3IgYSBwdXNoU3RhdGUgbGlua1xuICAgICAgICAgICAgLy8gb3BlbmVkIGJ5IGEgbm9uLXB1c2hTdGF0ZSBicm93c2VyLlxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgdmFyIGxvYyA9IHRoaXMubG9jYXRpb247XG5cbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb24gZnJvbSBoYXNoQ2hhbmdlIHRvIHB1c2hTdGF0ZSBvciB2aWNlIHZlcnNhIGlmIGJvdGggYXJlXG4gICAgICAgICAgICAvLyByZXF1ZXN0ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmIHRoaXMuX3dhbnRzUHVzaFN0YXRlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBzdGFydGVkIG9mZiB3aXRoIGEgcm91dGUgZnJvbSBhIGBwdXNoU3RhdGVgLWVuYWJsZWRcbiAgICAgICAgICAgICAgICAvLyBicm93c2VyLCBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFzUHVzaFN0YXRlICYmICF0aGlzLmF0Um9vdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2UodGhpcy5yb290ICsgJyMnICsgdGhpcy5mcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBpbW1lZGlhdGVseSBhcyBicm93c2VyIHdpbGwgZG8gcmVkaXJlY3QgdG8gbmV3IHVybFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5faGFzUHVzaFN0YXRlICYmIHRoaXMuYXRSb290KCkgJiYgbG9jLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpLnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBkb2N1bWVudC50aXRsZSwgdGhpcy5yb290ICsgdGhpcy5mcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNpbGVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkVXJsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIERpc2FibGUgQmFja2JvbmUuaGlzdG9yeSwgcGVyaGFwcyB0ZW1wb3JhcmlseS4gTm90IHVzZWZ1bCBpbiBhIHJlYWwgYXBwLFxuICAgICAgICAvLyBidXQgcG9zc2libHkgdXNlZnVsIGZvciB1bml0IHRlc3RpbmcgUm91dGVycy5cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQmFja2JvbmUuJCh3aW5kb3cpLm9mZigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsKS5vZmYoJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja1VybEludGVydmFsKVxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCk7XG4gICAgICAgICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRkIGEgcm91dGUgdG8gYmUgdGVzdGVkIHdoZW4gdGhlIGZyYWdtZW50IGNoYW5nZXMuIFJvdXRlcyBhZGRlZCBsYXRlclxuICAgICAgICAvLyBtYXkgb3ZlcnJpZGUgcHJldmlvdXMgcm91dGVzLlxuICAgICAgICByb3V0ZTogZnVuY3Rpb24gKHJvdXRlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycy51bnNoaWZ0KHtyb3V0ZTogcm91dGUsIGNhbGxiYWNrOiBjYWxsYmFja30pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDaGVja3MgdGhlIGN1cnJlbnQgVVJMIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZCwgYW5kIGlmIGl0IGhhcyxcbiAgICAgICAgLy8gY2FsbHMgYGxvYWRVcmxgLCBub3JtYWxpemluZyBhY3Jvc3MgdGhlIGhpZGRlbiBpZnJhbWUuXG4gICAgICAgIGNoZWNrVXJsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCAmJiB0aGlzLmlmcmFtZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWZyYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGUoY3VycmVudCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRVcmwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBsb2FkIHRoZSBjdXJyZW50IFVSTCBmcmFnbWVudC4gSWYgYSByb3V0ZSBzdWNjZWVkcyB3aXRoIGFcbiAgICAgICAgLy8gbWF0Y2gsIHJldHVybnMgYHRydWVgLiBJZiBubyBkZWZpbmVkIHJvdXRlcyBtYXRjaGVzIHRoZSBmcmFnbWVudCxcbiAgICAgICAgLy8gcmV0dXJucyBgZmFsc2VgLlxuICAgICAgICBsb2FkVXJsOiBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIF8uYW55KHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucm91dGUudGVzdChmcmFnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGFzaCBoaXN0b3J5LCBvciByZXBsYWNlIHRoZSBVUkwgc3RhdGUgaWYgdGhlXG4gICAgICAgIC8vICdyZXBsYWNlJyBvcHRpb24gaXMgcGFzc2VkLiBZb3UgYXJlIHJlc3BvbnNpYmxlIGZvciBwcm9wZXJseSBVUkwtZW5jb2RpbmdcbiAgICAgICAgLy8gdGhlIGZyYWdtZW50IGluIGFkdmFuY2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBvcHRpb25zIG9iamVjdCBjYW4gY29udGFpbiBgdHJpZ2dlcjogdHJ1ZWAgaWYgeW91IHdpc2ggdG8gaGF2ZSB0aGVcbiAgICAgICAgLy8gcm91dGUgY2FsbGJhY2sgYmUgZmlyZWQgKG5vdCB1c3VhbGx5IGRlc2lyYWJsZSksIG9yIGByZXBsYWNlOiB0cnVlYCwgaWZcbiAgICAgICAgLy8geW91IHdpc2ggdG8gbW9kaWZ5IHRoZSBjdXJyZW50IFVSTCB3aXRob3V0IGFkZGluZyBhbiBlbnRyeSB0byB0aGUgaGlzdG9yeS5cbiAgICAgICAgbmF2aWdhdGU6IGZ1bmN0aW9uIChmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFIaXN0b3J5LnN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt0cmlnZ2VyOiAhIW9wdGlvbnN9O1xuXG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5yb290ICsgKGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCB8fCAnJykpO1xuXG4gICAgICAgICAgICAvLyBTdHJpcCB0aGUgaGFzaCBmb3IgbWF0Y2hpbmcuXG4gICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZyYWdtZW50ID09PSBmcmFnbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGluY2x1ZGUgYSB0cmFpbGluZyBzbGFzaCBvbiB0aGUgcm9vdC5cbiAgICAgICAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgJiYgdXJsICE9PSAnLycpXG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIC0xKTtcblxuICAgICAgICAgICAgLy8gSWYgcHVzaFN0YXRlIGlzIGF2YWlsYWJsZSwgd2UgdXNlIGl0IHRvIHNldCB0aGUgZnJhZ21lbnQgYXMgYSByZWFsIFVSTC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3Rvcnlbb3B0aW9ucy5yZXBsYWNlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJ10oe30sIGRvY3VtZW50LnRpdGxlLCB1cmwpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgaGFzaCBjaGFuZ2VzIGhhdmVuJ3QgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkLCB1cGRhdGUgdGhlIGhhc2hcbiAgICAgICAgICAgICAgICAvLyBmcmFnbWVudCB0byBzdG9yZSBoaXN0b3J5LlxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlmcmFtZSAmJiAoZnJhZ21lbnQgIT09IHRoaXMuZ2V0RnJhZ21lbnQodGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZW5pbmcgYW5kIGNsb3NpbmcgdGhlIGlmcmFtZSB0cmlja3MgSUU3IGFuZCBlYXJsaWVyIHRvIHB1c2ggYVxuICAgICAgICAgICAgICAgICAgICAvLyBoaXN0b3J5IGVudHJ5IG9uIGhhc2gtdGFnIGNoYW5nZS4gIFdoZW4gcmVwbGFjZSBpcyB0cnVlLCB3ZSBkb24ndFxuICAgICAgICAgICAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5yZXBsYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWUuZG9jdW1lbnQub3BlbigpLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhhc2godGhpcy5pZnJhbWUubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHlvdSd2ZSB0b2xkIHVzIHRoYXQgeW91IGV4cGxpY2l0bHkgZG9uJ3Qgd2FudCBmYWxsYmFjayBoYXNoY2hhbmdlLVxuICAgICAgICAgICAgICAgIC8vIGJhc2VkIGhpc3RvcnksIHRoZW4gYG5hdmlnYXRlYCBiZWNvbWVzIGEgcGFnZSByZWZyZXNoLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRyaWdnZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgICAgIC8vIGEgbmV3IG9uZSB0byB0aGUgYnJvd3NlciBoaXN0b3J5LlxuICAgICAgICBfdXBkYXRlSGFzaDogZnVuY3Rpb24gKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IGxvY2F0aW9uLmhyZWYucmVwbGFjZSgvKGphdmFzY3JpcHQ6fCMpLiokLywgJycpO1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoaHJlZiArICcjJyArIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBmcmFnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgQmFja2JvbmUuaGlzdG9yeS5cbiAgICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgICAvLyBIZWxwZXJzXG4gICAgLy8gLS0tLS0tLVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG4gICAgLy8gU2ltaWxhciB0byBgZ29vZy5pbmhlcml0c2AsIGJ1dCB1c2VzIGEgaGFzaCBvZiBwcm90b3R5cGUgcHJvcGVydGllcyBhbmRcbiAgICAvLyBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGV4dGVuZGVkLlxuICAgIHZhciBleHRlbmQgPSBmdW5jdGlvbiAocHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZDtcblxuICAgICAgICAvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XG4gICAgICAgIC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuICAgICAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG4gICAgICAgIGlmIChwcm90b1Byb3BzICYmIF8uaGFzKHByb3RvUHJvcHMsICdjb25zdHJ1Y3RvcicpKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHByb3RvUHJvcHMuY29uc3RydWN0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgICAgIF8uZXh0ZW5kKGNoaWxkLCBwYXJlbnQsIHN0YXRpY1Byb3BzKTtcblxuICAgICAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBpbmhlcml0IGZyb20gYHBhcmVudGAsIHdpdGhvdXQgY2FsbGluZ1xuICAgICAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgICAgICB9O1xuICAgICAgICBTdXJyb2dhdGUucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZTtcblxuICAgICAgICAvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcbiAgICAgICAgLy8gaWYgc3VwcGxpZWQuXG4gICAgICAgIGlmIChwcm90b1Byb3BzKVxuICAgICAgICAgICAgXy5leHRlbmQoY2hpbGQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcblxuICAgICAgICAvLyBTZXQgYSBjb252ZW5pZW5jZSBwcm9wZXJ0eSBpbiBjYXNlIHRoZSBwYXJlbnQncyBwcm90b3R5cGUgaXMgbmVlZGVkXG4gICAgICAgIC8vIGxhdGVyLlxuICAgICAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgLy8gU2V0IHVwIGluaGVyaXRhbmNlIGZvciB0aGUgbW9kZWwsIGNvbGxlY3Rpb24sIHJvdXRlciwgdmlldyBhbmQgaGlzdG9yeS5cbiAgICBNb2RlbC5leHRlbmQgPSBDb2xsZWN0aW9uLmV4dGVuZCA9IFJvdXRlci5leHRlbmQgPSBWaWV3LmV4dGVuZCA9IEhpc3RvcnkuZXh0ZW5kID0gZXh0ZW5kO1xuXG4gICAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiBhIFVSTCBpcyBuZWVkZWQsIGFuZCBub25lIGlzIHN1cHBsaWVkLlxuICAgIHZhciB1cmxFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIFwidXJsXCIgcHJvcGVydHkgb3IgZnVuY3Rpb24gbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgICB9O1xuXG4gICAgLy8gV3JhcCBhbiBvcHRpb25hbCBlcnJvciBjYWxsYmFjayB3aXRoIGEgZmFsbGJhY2sgZXJyb3IgZXZlbnQuXG4gICAgdmFyIHdyYXBFcnJvciA9IGZ1bmN0aW9uIChtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgICAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICBlcnJvcihtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdlcnJvcicsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEJhY2tib25lO1xuXG59KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXNzZXRzL2pzL3ZlbmRvci9iYWNrYm9uZS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMlxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");
},,,,function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function($) {/*\n Highcharts JS v4.2.6 (2016-08-02)\n\n (c) 2009-2016 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function(D,ca){typeof module==="object"&&module.exports?module.exports=D.document?ca(D):ca:D.Highcharts=ca(D)})(typeof window!=="undefined"?window:this,function(D){function ca(a,b){var c="Highcharts error #"+a+": www.highcharts.com/errors/"+a;if(b)throw Error(c);D.console&&console.log(c)}function sb(a,b,c){this.options=b;this.elem=a;this.prop=c}function E(){var a,b=arguments,c,d={},e=function(a,b){var c,d;typeof a!=="object"&&(a={});for(d in b)b.hasOwnProperty(d)&&(c=b[d],a[d]=c&&typeof c==="object"&&\nObject.prototype.toString.call(c)!=="[object Array]"&&d!=="renderTo"&&typeof c.nodeType!=="number"?e(a[d]||{},c):b[d]);return a};b[0]===!0&&(d=b[1],b=Array.prototype.slice.call(b,2));c=b.length;for(a=0;a<c;a++)d=e(d,b[a]);return d}function B(a,b){return parseInt(a,b||10)}function ya(a){return typeof a==="string"}function Fa(a){return Object.prototype.toString.call(a)==="[object Array]"}function ra(a,b){for(var c=a.length;c--;)if(a[c]===b){a.splice(c,1);break}}function s(a){return a!==A&&a!==null}\nfunction P(a,b,c){var d,e;if(ya(b))s(c)?a.setAttribute(b,c):a&&a.getAttribute&&(e=a.getAttribute(b));else if(s(b)&&$(b))for(d in b)a.setAttribute(d,b[d]);return e}function ua(a){return Fa(a)?a:[a]}function Ra(a,b,c){if(b)return setTimeout(a,b,c);a.call(0,c)}function M(a,b){if(za&&!ga&&b&&b.opacity!==A)b.filter="alpha(opacity="+b.opacity*100+")";x(a.style,b)}function da(a,b,c,d,e){a=y.createElement(a);b&&x(a,b);e&&M(a,{padding:0,border:"none",margin:0});c&&M(a,c);d&&d.appendChild(a);return a}function sa(a,\nb){var c=function(){};c.prototype=new a;x(c.prototype,b);return c}function Ga(a,b,c){return Array((b||2)+1-String(a).length).join(c||0)+a}function $a(a){return(ab&&ab(a)||tb||0)*6E4}function Na(a,b){for(var c="{",d=!1,e,f,g,h,i,j=[];(c=a.indexOf(c))!==-1;){e=a.slice(0,c);if(d){f=e.split(":");g=f.shift().split(".");i=g.length;e=b;for(h=0;h<i;h++)e=e[g[h]];if(f.length)f=f.join(":"),g=/\\.([0-9])/,h=U.lang,i=void 0,/f$/.test(f)?(i=(i=f.match(g))?i[1]:-1,e!==null&&(e=u.numberFormat(e,i,h.decimalPoint,\nf.indexOf(",")>-1?h.thousandsSep:""))):e=Sa(f,e)}j.push(e);a=a.slice(c+1);c=(d=!d)?"}":"{"}j.push(a);return j.join("")}function ub(a){return Z.pow(10,V(Z.log(a)/Z.LN10))}function vb(a,b,c,d,e){var f,g=a,c=p(c,1);f=a/c;b||(b=[1,2,2.5,5,10],d===!1&&(c===1?b=[1,2,5,10]:c<=0.1&&(b=[1/c])));for(d=0;d<b.length;d++)if(g=b[d],e&&g*c>=a||!e&&f<=(b[d]+(b[d+1]||b[d]))/2)break;g*=c;return g}function jb(a,b){var c=a.length,d,e;for(e=0;e<c;e++)a[e].safeI=e;a.sort(function(a,c){d=b(a,c);return d===0?a.safeI-c.safeI:\nd});for(e=0;e<c;e++)delete a[e].safeI}function Oa(a){for(var b=a.length,c=a[0];b--;)a[b]<c&&(c=a[b]);return c}function Ha(a){for(var b=a.length,c=a[0];b--;)a[b]>c&&(c=a[b]);return c}function Ta(a,b){for(var c in a)a[c]&&a[c]!==b&&a[c].destroy&&a[c].destroy(),delete a[c]}function Ua(a){kb||(kb=da(Pa));a&&kb.appendChild(a);kb.innerHTML=""}function aa(a,b){return parseFloat(a.toPrecision(b||14))}function Va(a,b){b.renderer.globalAnimation=p(a,b.animation)}function bb(a){return $(a)?E(a):{duration:a?\n500:0}}function Gb(){var a=U.global,b=a.useUTC,c=b?"getUTC":"get",d=b?"setUTC":"set";ma=a.Date||D.Date;tb=b&&a.timezoneOffset;ab=b&&a.getTimezoneOffset;lb=function(a,c,d,h,i,j){var k;b?(k=ma.UTC.apply(0,arguments),k+=$a(k)):k=(new ma(a,c,p(d,1),p(h,0),p(i,0),p(j,0))).getTime();return k};wb=c+"Minutes";xb=c+"Hours";yb=c+"Day";Wa=c+"Date";cb=c+"Month";db=c+"FullYear";Hb=d+"Milliseconds";Ib=d+"Seconds";Jb=d+"Minutes";Kb=d+"Hours";mb=d+"Date";zb=d+"Month";Ab=d+"FullYear"}function na(a){if(!(this instanceof\nna))return new na(a);this.init(a)}function O(){}function Xa(a,b,c,d){this.axis=a;this.pos=b;this.type=c||"";this.isNew=!0;!c&&!d&&this.addLabel()}function Lb(a,b,c,d,e){var f=a.chart.inverted;this.axis=a;this.isNegative=c;this.options=b;this.x=d;this.total=null;this.points={};this.stack=e;this.rightCliff=this.leftCliff=0;this.alignOptions={align:b.align||(f?c?"left":"right":"center"),verticalAlign:b.verticalAlign||(f?"middle":c?"bottom":"top"),y:p(b.y,f?4:c?14:-6),x:p(b.x,f?c?-6:6:0)};this.textAlign=\nb.textAlign||(f?c?"right":"left":"center")}var A,y=D.document,Z=Math,C=Z.round,V=Z.floor,va=Z.ceil,t=Z.max,F=Z.min,Q=Z.abs,W=Z.cos,ea=Z.sin,ta=Z.PI,ka=ta*2/360,Aa=D.navigator&&D.navigator.userAgent||"",Mb=D.opera,za=/(msie|trident|edge)/i.test(Aa)&&!Mb,nb=y&&y.documentMode===8,ob=!za&&/AppleWebKit/.test(Aa),Qa=/Firefox/.test(Aa),Nb=/(Mobile|Android|Windows Phone)/.test(Aa),Ia="http://www.w3.org/2000/svg",ga=y&&y.createElementNS&&!!y.createElementNS(Ia,"svg").createSVGRect,Rb=Qa&&parseInt(Aa.split("Firefox/")[1],\n10)<4,la=y&&!ga&&!za&&!!y.createElement("canvas").getContext,eb,fb,Ob={},Bb=0,kb,U,Sa,H,Ba=function(){},T=[],gb=0,Pa="div",X="M",S="L",Sb=/^[0-9]+$/,pb=["plotTop","marginRight","marginBottom","plotLeft"],ma,lb,tb,ab,wb,xb,yb,Wa,cb,db,Hb,Ib,Jb,Kb,mb,zb,Ab,L={},u;u=D.Highcharts?ca(16,!0):{win:D};u.seriesTypes=L;var Ja=[],oa,pa,q,Ca,Cb,Da,N,Y,I,Ya,Ka;sb.prototype={dSetter:function(){var a=this.paths[0],b=this.paths[1],c=[],d=this.now,e=a.length,f;if(d===1)c=this.toD;else if(e===b.length&&d<1)for(;e--;)f=\nparseFloat(a[e]),c[e]=isNaN(f)?a[e]:d*parseFloat(b[e]-f)+f;else c=b;this.elem.attr("d",c)},update:function(){var a=this.elem,b=this.prop,c=this.now,d=this.options.step;if(this[b+"Setter"])this[b+"Setter"]();else a.attr?a.element&&a.attr(b,c):a.style[b]=c+this.unit;d&&d.call(a,c,this)},run:function(a,b,c){var d=this,e=function(a){return e.stopped?!1:d.step(a)},f;this.startTime=+new ma;this.start=a;this.end=b;this.unit=c;this.now=this.start;this.pos=0;e.elem=this.elem;if(e()&&Ja.push(e)===1)e.timerId=\nsetInterval(function(){for(f=0;f<Ja.length;f++)Ja[f]()||Ja.splice(f--,1);Ja.length||clearInterval(e.timerId)},13)},step:function(a){var b=+new ma,c,d=this.options;c=this.elem;var e=d.complete,f=d.duration,g=d.curAnim,h;if(c.attr&&!c.element)c=!1;else if(a||b>=f+this.startTime){this.now=this.end;this.pos=1;this.update();a=g[this.prop]=!0;for(h in g)g[h]!==!0&&(a=!1);a&&e&&e.call(c);c=!1}else this.pos=d.easing((b-this.startTime)/f),this.now=this.start+(this.end-this.start)*this.pos,this.update(),c=\n!0;return c},initPath:function(a,b,c){function d(a){for(n=a.length;n--;)(a[n]===X||a[n]===S)&&a.splice(n+1,0,a[n+1],a[n+2],a[n+1],a[n+2])}function e(a,b){for(;a.length<l;){a[0]=b[l-a.length];var c=a.slice(0,k);[].splice.apply(a,[0,0].concat(c));o&&(c=a.slice(a.length-k),[].splice.apply(a,[a.length,0].concat(c)),n--)}a[0]="M"}function f(a,b){for(var c=(l-a.length)/k;c>0&&c--;)m=a.slice().splice(a.length/z-k,k*z),m[0]=b[l-k-c*k],j&&(m[k-6]=m[k-2],m[k-5]=m[k-1]),[].splice.apply(a,[a.length/z,0].concat(m)),\no&&c--}var b=b||"",g,h=a.startX,i=a.endX,j=b.indexOf("C")>-1,k=j?7:3,l,m,n,b=b.split(" "),c=c.slice(),o=a.isArea,z=o?2:1,r;j&&(d(b),d(c));if(h&&i){for(n=0;n<h.length;n++)if(h[n]===i[0]){g=n;break}else if(h[0]===i[i.length-h.length+n]){g=n;r=!0;break}g===void 0&&(b=[])}b.length&&u.isNumber(g)&&(l=c.length+g*z*k,r?(e(b,c),f(c,b)):(e(c,b),f(b,c)));return[b,c]}};var x=u.extend=function(a,b){var c;a||(a={});for(c in b)a[c]=b[c];return a},$=u.isObject=function(a,b){return a&&typeof a==="object"&&(!b||!Fa(a))},\nJ=u.isNumber=function(a){return typeof a==="number"&&!isNaN(a)},p=u.pick=function(){var a=arguments,b,c,d=a.length;for(b=0;b<d;b++)if(c=a[b],c!==A&&c!==null)return c},hb=u.wrap=function(a,b,c){var d=a[b];a[b]=function(){var a=Array.prototype.slice.call(arguments);a.unshift(d);return c.apply(this,a)}};Sa=function(a,b,c){if(!s(b)||isNaN(b))return U.lang.invalidDate||"";var a=p(a,"%Y-%m-%d %H:%M:%S"),d=new ma(b-$a(b)),e,f=d[xb](),g=d[yb](),h=d[Wa](),i=d[cb](),j=d[db](),k=U.lang,l=k.weekdays,m=k.shortWeekdays,\nd=x({a:m?m[g]:l[g].substr(0,3),A:l[g],d:Ga(h),e:Ga(h,2," "),w:g,b:k.shortMonths[i],B:k.months[i],m:Ga(i+1),y:j.toString().substr(2,2),Y:j,H:Ga(f),k:f,I:Ga(f%12||12),l:f%12||12,M:Ga(d[wb]()),p:f<12?"AM":"PM",P:f<12?"am":"pm",S:Ga(d.getSeconds()),L:Ga(C(b%1E3),3)},u.dateFormats);for(e in d)for(;a.indexOf("%"+e)!==-1;)a=a.replace("%"+e,typeof d[e]==="function"?d[e](b):d[e]);return c?a.substr(0,1).toUpperCase()+a.substr(1):a};H={millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5,month:24192E5,\nyear:314496E5};u.numberFormat=function(a,b,c,d){var a=+a||0,b=+b,e=U.lang,f=(a.toString().split(".")[1]||"").length,g,h,i=Math.abs(a);b===-1?b=Math.min(f,20):J(b)||(b=2);g=String(B(i.toFixed(b)));h=g.length>3?g.length%3:0;c=p(c,e.decimalPoint);d=p(d,e.thousandsSep);a=a<0?"-":"";a+=h?g.substr(0,h)+d:"";a+=g.substr(h).replace(/(\\d{3})(?=\\d)/g,"$1"+d);b&&(d=Math.abs(i-g+Math.pow(10,-Math.max(b,f)-1)),a+=c+d.toFixed(b).slice(2));return a};Math.easeInOutSine=function(a){return-0.5*(Math.cos(Math.PI*a)-\n1)};oa=function(a,b){var c;if(b==="width")return Math.min(a.offsetWidth,a.scrollWidth)-oa(a,"padding-left")-oa(a,"padding-right");else if(b==="height")return Math.min(a.offsetHeight,a.scrollHeight)-oa(a,"padding-top")-oa(a,"padding-bottom");return(c=D.getComputedStyle(a,void 0))&&B(c.getPropertyValue(b))};pa=function(a,b){return b.indexOf?b.indexOf(a):[].indexOf.call(b,a)};Ca=function(a,b){return[].filter.call(a,b)};Da=function(a,b){for(var c=[],d=0,e=a.length;d<e;d++)c[d]=b.call(a[d],a[d],d,a);return c};\nCb=function(a){var b=y.documentElement,a=a.getBoundingClientRect();return{top:a.top+(D.pageYOffset||b.scrollTop)-(b.clientTop||0),left:a.left+(D.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}};Ka=function(a){for(var b=Ja.length;b--;)if(Ja[b].elem===a)Ja[b].stopped=!0};q=function(a,b){return Array.prototype.forEach.call(a,b)};N=function(a,b,c){function d(b){b.target=b.srcElement||D;c.call(a,b)}var e=a.hcEvents=a.hcEvents||{};if(a.addEventListener)a.addEventListener(b,c,!1);else if(a.attachEvent){if(!a.hcEventsIE)a.hcEventsIE=\n{};a.hcEventsIE[c.toString()]=d;a.attachEvent("on"+b,d)}e[b]||(e[b]=[]);e[b].push(c)};Y=function(a,b,c){function d(b,c){a.removeEventListener?a.removeEventListener(b,c,!1):a.attachEvent&&(c=a.hcEventsIE[c.toString()],a.detachEvent("on"+b,c))}function e(){var c,e,f;if(a.nodeName)for(f in b?(c={},c[b]=!0):c=g,c)if(g[f])for(e=g[f].length;e--;)d(f,g[f][e])}var f,g=a.hcEvents,h;if(g)b?(f=g[b]||[],c?(h=pa(c,f),h>-1&&(f.splice(h,1),g[b]=f),d(b,c)):(e(),g[b]=[])):(e(),a.hcEvents={})};I=function(a,b,c,d){var e;\ne=a.hcEvents;var f,g,c=c||{};if(y.createEvent&&(a.dispatchEvent||a.fireEvent))e=y.createEvent("Events"),e.initEvent(b,!0,!0),e.target=a,x(e,c),a.dispatchEvent?a.dispatchEvent(e):a.fireEvent(b,e);else if(e){e=e[b]||[];f=e.length;if(!c.preventDefault)c.preventDefault=function(){c.defaultPrevented=!0};c.target=a;if(!c.type)c.type=b;for(b=0;b<f;b++)(g=e[b])&&g.call(a,c)===!1&&c.preventDefault()}d&&!c.defaultPrevented&&d(c)};Ya=function(a,b,c){var d,e="",f,g,h;$(c)||(d=arguments,c={duration:d[2],easing:d[3],\ncomplete:d[4]});if(!J(c.duration))c.duration=400;c.easing=typeof c.easing==="function"?c.easing:Math[c.easing]||Math.easeInOutSine;c.curAnim=E(b);for(h in b)g=new sb(a,c,h),f=null,h==="d"?(g.paths=g.initPath(a,a.d,b.d),g.toD=b.d,d=0,f=1):a.attr?d=a.attr(h):(d=parseFloat(oa(a,h))||0,h!=="opacity"&&(e="px")),f||(f=b[h]),f.match&&f.match("px")&&(f=f.replace(/px/g,"")),g.run(d,f,e)};if(D.jQuery)D.jQuery.fn.highcharts=function(){var a=[].slice.call(arguments);if(this[0])return a[0]?(new (u[ya(a[0])?a.shift():\n"Chart"])(this[0],a[0],a[1]),this):T[P(this[0],"data-highcharts-chart")]};y&&!y.defaultView&&(oa=function(a,b){var c;c={width:"clientWidth",height:"clientHeight"}[b];if(a.style[b])return B(a.style[b]);b==="opacity"&&(b="filter");if(c)return a.style.zoom=1,Math.max(a[c]-2*oa(a,"padding"),0);c=a.currentStyle[b.replace(/\\-(\\w)/g,function(a,b){return b.toUpperCase()})];b==="filter"&&(c=c.replace(/alpha\\(opacity=([0-9]+)\\)/,function(a,b){return b/100}));return c===""?1:B(c)});Array.prototype.forEach||\n(q=function(a,b){for(var c=0,d=a.length;c<d;c++)if(b.call(a[c],a[c],c,a)===!1)return c});Array.prototype.indexOf||(pa=function(a,b){var c,d=0;if(b)for(c=b.length;d<c;d++)if(b[d]===a)return d;return-1});Array.prototype.filter||(Ca=function(a,b){for(var c=[],d=0,e=a.length;d<e;d++)b(a[d],d)&&c.push(a[d]);return c});u.Fx=sb;u.inArray=pa;u.each=q;u.grep=Ca;u.offset=Cb;u.map=Da;u.addEvent=N;u.removeEvent=Y;u.fireEvent=I;u.animate=Ya;u.animObject=bb;u.stop=Ka;U={colors:"#7cb5ec,#434348,#90ed7d,#f7a35c,#8085e9,#f15c80,#e4d354,#2b908f,#f45b5b,#91e8e1".split(","),\nsymbols:["circle","diamond","square","triangle","triangle-down"],lang:{loading:"Loading...",months:"January,February,March,April,May,June,July,August,September,October,November,December".split(","),shortMonths:"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),weekdays:"Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),decimalPoint:".",numericSymbols:"k,M,G,T,P,E".split(","),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{useUTC:!0,\ncanvasToolsURL:"http://code.highcharts.com/modules/canvas-tools.js",VMLRadialGradientURL:"http://code.highcharts.com/4.2.6/gfx/vml-radial-gradient.png"},chart:{borderColor:"#4572A7",borderRadius:0,defaultSeriesType:"line",ignoreHiddenSeries:!0,spacing:[10,10,15,10],backgroundColor:"#FFFFFF",plotBorderColor:"#C0C0C0",resetZoomButton:{theme:{zIndex:20},position:{align:"right",x:-10,y:10}},width:null,height:null},title:{text:"Chart title",align:"center",margin:15,style:{color:"#333333",fontSize:"18px"},\nwidthAdjust:-44},subtitle:{text:"",align:"center",style:{color:"#555555"},widthAdjust:-44},plotOptions:{line:{allowPointSelect:!1,showCheckbox:!1,animation:{duration:1E3},events:{},lineWidth:2,marker:{lineWidth:0,radius:4,lineColor:"#FFFFFF",states:{hover:{enabled:!0,lineWidthPlus:1,radiusPlus:2},select:{fillColor:"#FFFFFF",lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{align:"center",formatter:function(){return this.y===null?"":u.numberFormat(this.y,-1)},style:{color:"contrast",\nfontSize:"11px",fontWeight:"bold",textShadow:"0 0 6px contrast, 0 0 3px contrast"},verticalAlign:"bottom",x:0,y:0,padding:5},cropThreshold:300,pointRange:0,softThreshold:!0,states:{hover:{lineWidthPlus:1,marker:{},halo:{size:10,opacity:0.25}},select:{marker:{}}},stickyTracking:!0,turboThreshold:1E3}},labels:{style:{position:"absolute",color:"#3E576F"}},legend:{enabled:!0,align:"center",layout:"horizontal",labelFormatter:function(){return this.name},borderColor:"#909090",borderRadius:0,navigation:{activeColor:"#274b6d",\ninactiveColor:"#CCC"},shadow:!1,itemStyle:{color:"#333333",fontSize:"12px",fontWeight:"bold"},itemHoverStyle:{color:"#000"},itemHiddenStyle:{color:"#CCC"},itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",position:"relative",top:"45%"},style:{position:"absolute",backgroundColor:"white",opacity:0.5,textAlign:"center"}},tooltip:{enabled:!0,animation:ga,backgroundColor:"rgba(249, 249, 249, .85)",\nborderWidth:1,borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L",second:"%A, %b %e, %H:%M:%S",minute:"%A, %b %e, %H:%M",hour:"%A, %b %e, %H:%M",day:"%A, %b %e, %Y",week:"Week from %A, %b %e, %Y",month:"%B %Y",year:"%Y"},footerFormat:"",headerFormat:\'<span style="font-size: 10px">{point.key}</span><br/>\',pointFormat:\'<span style="color:{point.color}">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>\',shadow:!0,snap:Nb?25:10,style:{color:"#333333",cursor:"default",fontSize:"12px",\npadding:"8px",pointerEvents:"none",whiteSpace:"nowrap"}},credits:{enabled:!0,text:"Highcharts.com",href:"http://www.highcharts.com",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#909090",fontSize:"9px"}}};var fa=U.plotOptions,ha=fa.line;Gb();na.prototype={parsers:[{regex:/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,parse:function(a){return[B(a[1]),B(a[2]),B(a[3]),parseFloat(a[4],10)]}},{regex:/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,\nparse:function(a){return[B(a[1],16),B(a[2],16),B(a[3],16),1]}},{regex:/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,parse:function(a){return[B(a[1]),B(a[2]),B(a[3]),1]}}],init:function(a){var b,c,d,e;if((this.input=a)&&a.stops)this.stops=Da(a.stops,function(a){return new na(a[1])});else for(d=this.parsers.length;d--&&!c;)e=this.parsers[d],(b=e.regex.exec(a))&&(c=e.parse(b));this.rgba=c||[]},get:function(a){var b=this.input,c=this.rgba,d;this.stops?(d=E(b),d.stops=[].concat(d.stops),\nq(this.stops,function(b,c){d.stops[c]=[d.stops[c][0],b.get(a)]})):d=c&&J(c[0])?a==="rgb"||!a&&c[3]===1?"rgb("+c[0]+","+c[1]+","+c[2]+")":a==="a"?c[3]:"rgba("+c.join(",")+")":b;return d},brighten:function(a){var b,c=this.rgba;if(this.stops)q(this.stops,function(b){b.brighten(a)});else if(J(a)&&a!==0)for(b=0;b<3;b++)c[b]+=B(a*255),c[b]<0&&(c[b]=0),c[b]>255&&(c[b]=255);return this},setOpacity:function(a){this.rgba[3]=a;return this}};O.prototype={opacity:1,textProps:"direction,fontSize,fontWeight,fontFamily,fontStyle,color,lineHeight,width,textDecoration,textOverflow,textShadow".split(","),\ninit:function(a,b){this.element=b==="span"?da(b):y.createElementNS(Ia,b);this.renderer=a},animate:function(a,b,c){b=p(b,this.renderer.globalAnimation,!0);Ka(this);if(b){if(c)b.complete=c;Ya(this,a,b)}else this.attr(a,null,c);return this},colorGradient:function(a,b,c){var d=this.renderer,e,f,g,h,i,j,k,l,m,n,o,z=[],r;a.linearGradient?f="linearGradient":a.radialGradient&&(f="radialGradient");if(f){g=a[f];i=d.gradients;k=a.stops;n=c.radialReference;Fa(g)&&(a[f]=g={x1:g[0],y1:g[1],x2:g[2],y2:g[3],gradientUnits:"userSpaceOnUse"});\nf==="radialGradient"&&n&&!s(g.gradientUnits)&&(h=g,g=E(g,d.getRadialAttr(n,h),{gradientUnits:"userSpaceOnUse"}));for(o in g)o!=="id"&&z.push(o,g[o]);for(o in k)z.push(k[o]);z=z.join(",");i[z]?n=i[z].attr("id"):(g.id=n="highcharts-"+Bb++,i[z]=j=d.createElement(f).attr(g).add(d.defs),j.radAttr=h,j.stops=[],q(k,function(a){a[1].indexOf("rgba")===0?(e=na(a[1]),l=e.get("rgb"),m=e.get("a")):(l=a[1],m=1);a=d.createElement("stop").attr({offset:a[0],"stop-color":l,"stop-opacity":m}).add(j);j.stops.push(a)}));\nr="url("+d.url+"#"+n+")";c.setAttribute(b,r);c.gradient=z;a.toString=function(){return r}}},applyTextShadow:function(a){var b=this.element,c,d=a.indexOf("contrast")!==-1,e={},f=this.renderer.forExport,g=f||b.style.textShadow!==A&&!za;if(d)e.textShadow=a=a.replace(/contrast/g,this.renderer.getContrast(b.style.fill));if(ob||f)e.textRendering="geometricPrecision";g?this.css(e):(this.fakeTS=!0,this.ySetter=this.xSetter,c=[].slice.call(b.getElementsByTagName("tspan")),q(a.split(/\\s?,\\s?/g),function(a){var d=\nb.firstChild,e,f,a=a.split(" ");e=a[a.length-1];(f=a[a.length-2])&&q(c,function(a,c){var g;c===0&&(a.setAttribute("x",b.getAttribute("x")),c=b.getAttribute("y"),a.setAttribute("y",c||0),c===null&&b.setAttribute("y",0));g=a.cloneNode(1);P(g,{"class":"highcharts-text-shadow",fill:e,stroke:e,"stroke-opacity":1/t(B(f),3),"stroke-width":f,"stroke-linejoin":"round"});b.insertBefore(g,d)})}))},attr:function(a,b,c){var d,e=this.element,f,g=this,h;typeof a==="string"&&b!==A&&(d=a,a={},a[d]=b);if(typeof a===\n"string")g=(this[a+"Getter"]||this._defaultGetter).call(this,a,e);else{for(d in a){b=a[d];h=!1;this.symbolName&&/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(d)&&(f||(this.symbolAttr(a),f=!0),h=!0);if(this.rotation&&(d==="x"||d==="y"))this.doTransform=!0;h||(h=this[d+"Setter"]||this._defaultSetter,h.call(this,b,d,e),this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d)&&this.updateShadows(d,b,h))}if(this.doTransform)this.updateTransform(),this.doTransform=!1}c&&\nc();return g},updateShadows:function(a,b,c){for(var d=this.shadows,e=d.length;e--;)c.call(d[e],a==="height"?Math.max(b-(d[e].cutHeight||0),0):a==="d"?this.d:b,a,d[e])},addClass:function(a){var b=this.element,c=P(b,"class")||"";c.indexOf(a)===-1&&P(b,"class",c+" "+a);return this},symbolAttr:function(a){var b=this;q("x,y,r,start,end,width,height,innerR,anchorX,anchorY".split(","),function(c){b[c]=p(a[c],b[c])});b.attr({d:b.renderer.symbols[b.symbolName](b.x,b.y,b.width,b.height,b)})},clip:function(a){return this.attr("clip-path",\na?"url("+this.renderer.url+"#"+a.id+")":"none")},crisp:function(a){var b,c={},d,e=this.strokeWidth||0;d=C(e)%2/2;a.x=V(a.x||this.x||0)+d;a.y=V(a.y||this.y||0)+d;a.width=V((a.width||this.width||0)-2*d);a.height=V((a.height||this.height||0)-2*d);a.strokeWidth=e;for(b in a)this[b]!==a[b]&&(this[b]=c[b]=a[b]);return c},css:function(a){var b=this.styles,c={},d=this.element,e,f,g="";e=!b;if(a&&a.color)a.fill=a.color;if(b)for(f in a)a[f]!==b[f]&&(c[f]=a[f],e=!0);if(e){e=this.textWidth=a&&a.width&&d.nodeName.toLowerCase()===\n"text"&&B(a.width)||this.textWidth;b&&(a=x(b,c));this.styles=a;e&&(la||!ga&&this.renderer.forExport)&&delete a.width;if(za&&!ga)M(this.element,a);else{b=function(a,b){return"-"+b.toLowerCase()};for(f in a)g+=f.replace(/([A-Z])/g,b)+":"+a[f]+";";P(d,"style",g)}e&&this.added&&this.renderer.buildText(this)}return this},on:function(a,b){var c=this,d=c.element;fb&&a==="click"?(d.ontouchstart=function(a){c.touchEventFired=ma.now();a.preventDefault();b.call(d,a)},d.onclick=function(a){(Aa.indexOf("Android")===\n-1||ma.now()-(c.touchEventFired||0)>1100)&&b.call(d,a)}):d["on"+a]=b;return this},setRadialReference:function(a){var b=this.renderer.gradients[this.element.gradient];this.element.radialReference=a;b&&b.radAttr&&b.animate(this.renderer.getRadialAttr(a,b.radAttr));return this},translate:function(a,b){return this.attr({translateX:a,translateY:b})},invert:function(){this.inverted=!0;this.updateTransform();return this},updateTransform:function(){var a=this.translateX||0,b=this.translateY||0,c=this.scaleX,\nd=this.scaleY,e=this.inverted,f=this.rotation,g=this.element;e&&(a+=this.attr("width"),b+=this.attr("height"));a=["translate("+a+","+b+")"];e?a.push("rotate(90) scale(-1,1)"):f&&a.push("rotate("+f+" "+(g.getAttribute("x")||0)+" "+(g.getAttribute("y")||0)+")");(s(c)||s(d))&&a.push("scale("+p(c,1)+" "+p(d,1)+")");a.length&&g.setAttribute("transform",a.join(" "))},toFront:function(){var a=this.element;a.parentNode.appendChild(a);return this},align:function(a,b,c){var d,e,f,g,h={};e=this.renderer;f=e.alignedObjects;\nif(a){if(this.alignOptions=a,this.alignByTranslate=b,!c||ya(c))this.alignTo=d=c||"renderer",ra(f,this),f.push(this),c=null}else a=this.alignOptions,b=this.alignByTranslate,d=this.alignTo;c=p(c,e[d],e);d=a.align;e=a.verticalAlign;f=(c.x||0)+(a.x||0);g=(c.y||0)+(a.y||0);if(d==="right"||d==="center")f+=(c.width-(a.width||0))/{right:1,center:2}[d];h[b?"translateX":"x"]=C(f);if(e==="bottom"||e==="middle")g+=(c.height-(a.height||0))/({bottom:1,middle:2}[e]||1);h[b?"translateY":"y"]=C(g);this[this.placed?\n"animate":"attr"](h);this.placed=!0;this.alignAttr=h;return this},getBBox:function(a,b){var c,d=this.renderer,e,f,g,h=this.element,i=this.styles;e=this.textStr;var j,k=h.style,l,m=d.cache,n=d.cacheKeys,o;f=p(b,this.rotation);g=f*ka;e!==A&&(o=["",f||0,i&&i.fontSize,h.style.width].join(","),o=e===""||Sb.test(e)?"num:"+e.toString().length+o:e+o);o&&!a&&(c=m[o]);if(!c){if(h.namespaceURI===Ia||d.forExport){try{l=this.fakeTS&&function(a){q(h.querySelectorAll(".highcharts-text-shadow"),function(b){b.style.display=\na})},Qa&&k.textShadow?(j=k.textShadow,k.textShadow=""):l&&l("none"),c=h.getBBox?x({},h.getBBox()):{width:h.offsetWidth,height:h.offsetHeight},j?k.textShadow=j:l&&l("")}catch(z){}if(!c||c.width<0)c={width:0,height:0}}else c=this.htmlGetBBox();if(d.isSVG){d=c.width;e=c.height;if(za&&i&&i.fontSize==="11px"&&e.toPrecision(3)==="16.9")c.height=e=14;if(f)c.width=Q(e*ea(g))+Q(d*W(g)),c.height=Q(e*W(g))+Q(d*ea(g))}if(o){for(;n.length>250;)delete m[n.shift()];m[o]||n.push(o);m[o]=c}}return c},show:function(a){return this.attr({visibility:a?\n"inherit":"visible"})},hide:function(){return this.attr({visibility:"hidden"})},fadeOut:function(a){var b=this;b.animate({opacity:0},{duration:a||150,complete:function(){b.attr({y:-9999})}})},add:function(a){var b=this.renderer,c=this.element,d;if(a)this.parentGroup=a;this.parentInverted=a&&a.inverted;this.textStr!==void 0&&b.buildText(this);this.added=!0;if(!a||a.handleZ||this.zIndex)d=this.zIndexSetter();d||(a?a.element:b.box).appendChild(c);if(this.onAdd)this.onAdd();return this},safeRemoveChild:function(a){var b=\na.parentNode;b&&b.removeChild(a)},destroy:function(){var a=this,b=a.element||{},c=a.shadows,d=a.renderer.isSVG&&b.nodeName==="SPAN"&&a.parentGroup,e,f;b.onclick=b.onmouseout=b.onmouseover=b.onmousemove=b.point=null;Ka(a);if(a.clipPath)a.clipPath=a.clipPath.destroy();if(a.stops){for(f=0;f<a.stops.length;f++)a.stops[f]=a.stops[f].destroy();a.stops=null}a.safeRemoveChild(b);for(c&&q(c,function(b){a.safeRemoveChild(b)});d&&d.div&&d.div.childNodes.length===0;)b=d.parentGroup,a.safeRemoveChild(d.div),delete d.div,\nd=b;a.alignTo&&ra(a.renderer.alignedObjects,a);for(e in a)delete a[e];return null},shadow:function(a,b,c){var d=[],e,f,g=this.element,h,i,j,k;if(a){i=p(a.width,3);j=(a.opacity||0.15)/i;k=this.parentInverted?"(-1,-1)":"("+p(a.offsetX,1)+", "+p(a.offsetY,1)+")";for(e=1;e<=i;e++){f=g.cloneNode(0);h=i*2+1-2*e;P(f,{isShadow:"true",stroke:a.color||"black","stroke-opacity":j*e,"stroke-width":h,transform:"translate"+k,fill:"none"});if(c)P(f,"height",t(P(f,"height")-h,0)),f.cutHeight=h;b?b.element.appendChild(f):\ng.parentNode.insertBefore(f,g);d.push(f)}this.shadows=d}return this},xGetter:function(a){this.element.nodeName==="circle"&&(a={x:"cx",y:"cy"}[a]||a);return this._defaultGetter(a)},_defaultGetter:function(a){a=p(this[a],this.element?this.element.getAttribute(a):null,0);/^[\\-0-9\\.]+$/.test(a)&&(a=parseFloat(a));return a},dSetter:function(a,b,c){a&&a.join&&(a=a.join(" "));/(NaN| {2}|^$)/.test(a)&&(a="M 0 0");c.setAttribute(b,a);this[b]=a},dashstyleSetter:function(a){var b,c=this["stroke-width"];c===\n"inherit"&&(c=1);if(a=a&&a.toLowerCase()){a=a.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(b=a.length;b--;)a[b]=B(a[b])*c;a=a.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",a)}},alignSetter:function(a){this.element.setAttribute("text-anchor",{left:"start",center:"middle",right:"end"}[a])},\nopacitySetter:function(a,b,c){this[b]=a;c.setAttribute(b,a)},titleSetter:function(a){var b=this.element.getElementsByTagName("title")[0];b||(b=y.createElementNS(Ia,"title"),this.element.appendChild(b));b.firstChild&&b.removeChild(b.firstChild);b.appendChild(y.createTextNode(String(p(a),"").replace(/<[^>]*>/g,"")))},textSetter:function(a){if(a!==this.textStr)delete this.bBox,this.textStr=a,this.added&&this.renderer.buildText(this)},fillSetter:function(a,b,c){typeof a==="string"?c.setAttribute(b,a):\na&&this.colorGradient(a,b,c)},visibilitySetter:function(a,b,c){a==="inherit"?c.removeAttribute(b):c.setAttribute(b,a)},zIndexSetter:function(a,b){var c=this.renderer,d=this.parentGroup,c=(d||c).element||c.box,e,f,g=this.element,h;e=this.added;var i;if(s(a))g.zIndex=a,a=+a,this[b]===a&&(e=!1),this[b]=a;if(e){if((a=this.zIndex)&&d)d.handleZ=!0;d=c.childNodes;for(i=0;i<d.length&&!h;i++)if(e=d[i],f=e.zIndex,e!==g&&(B(f)>a||!s(a)&&s(f)))c.insertBefore(g,e),h=!0;h||c.appendChild(g)}return h},_defaultSetter:function(a,\nb,c){c.setAttribute(b,a)}};O.prototype.yGetter=O.prototype.xGetter;O.prototype.translateXSetter=O.prototype.translateYSetter=O.prototype.rotationSetter=O.prototype.verticalAlignSetter=O.prototype.scaleXSetter=O.prototype.scaleYSetter=function(a,b){this[b]=a;this.doTransform=!0};O.prototype["stroke-widthSetter"]=O.prototype.strokeSetter=function(a,b,c){this[b]=a;if(this.stroke&&this["stroke-width"])this.strokeWidth=this["stroke-width"],O.prototype.fillSetter.call(this,this.stroke,"stroke",c),c.setAttribute("stroke-width",\nthis["stroke-width"]),this.hasStroke=!0;else if(b==="stroke-width"&&a===0&&this.hasStroke)c.removeAttribute("stroke"),this.hasStroke=!1};var Ea=function(){this.init.apply(this,arguments)};Ea.prototype={Element:O,init:function(a,b,c,d,e,f){var g,d=this.createElement("svg").attr({version:"1.1"}).css(this.getStyle(d));g=d.element;a.appendChild(g);a.innerHTML.indexOf("xmlns")===-1&&P(g,"xmlns",Ia);this.isSVG=!0;this.box=g;this.boxWrapper=d;this.alignedObjects=[];this.url=(Qa||ob)&&y.getElementsByTagName("base").length?\nD.location.href.replace(/#.*?$/,"").replace(/([\\(\'\\)])/g,"\\\\$1").replace(/ /g,"%20"):"";this.createElement("desc").add().element.appendChild(y.createTextNode("Created with Highcharts 4.2.6"));this.defs=this.createElement("defs").add();this.allowHTML=f;this.forExport=e;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(b,c,!1);var h;if(Qa&&a.getBoundingClientRect)this.subPixelFix=b=function(){M(a,{left:0,top:0});h=a.getBoundingClientRect();M(a,{left:va(h.left)-h.left+"px",\ntop:va(h.top)-h.top+"px"})},b(),N(D,"resize",b)},getStyle:function(a){return this.style=x({fontFamily:\'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif\',fontSize:"12px"},a)},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();Ta(this.gradients||{});this.gradients=null;if(a)this.defs=a.destroy();this.subPixelFix&&Y(D,"resize",this.subPixelFix);return this.alignedObjects=null},createElement:function(a){var b=\nnew this.Element;b.init(this,a);return b},draw:function(){},getRadialAttr:function(a,b){return{cx:a[0]-a[2]/2+b.cx*a[2],cy:a[1]-a[2]/2+b.cy*a[2],r:b.r*a[2]}},buildText:function(a){for(var b=a.element,c=this,d=c.forExport,e=p(a.textStr,"").toString(),f=e.indexOf("<")!==-1,g=b.childNodes,h,i,j,k=P(b,"x"),l=a.styles,m=a.textWidth,n=l&&l.lineHeight,o=l&&l.textShadow,z=l&&l.textOverflow==="ellipsis",r=g.length,G=m&&!a.added&&this.box,w=function(a){return n?B(n):c.fontMetrics(/(px|em)$/.test(a&&a.style.fontSize)?\na.style.fontSize:l&&l.fontSize||c.style.fontSize||12,a).h},v=function(a){return a.replace(/&lt;/g,"<").replace(/&gt;/g,">")};r--;)b.removeChild(g[r]);!f&&!o&&!z&&!m&&e.indexOf(" ")===-1?b.appendChild(y.createTextNode(v(e))):(h=/<.*style="([^"]+)".*>/,i=/<.*href="(http[^"]+)".*>/,G&&G.appendChild(b),e=f?e.replace(/<(b|strong)>/g,\'<span style="font-weight:bold">\').replace(/<(i|em)>/g,\'<span style="font-style:italic">\').replace(/<a/g,"<span").replace(/<\\/(b|strong|i|em|a)>/g,"</span>").split(/<br.*?>/g):\n[e],e=Ca(e,function(a){return a!==""}),q(e,function(e,f){var g,n=0,e=e.replace(/^\\s+|\\s+$/g,"").replace(/<span/g,"|||<span").replace(/<\\/span>/g,"</span>|||");g=e.split("|||");q(g,function(e){if(e!==""||g.length===1){var o={},r=y.createElementNS(Ia,"tspan"),p;h.test(e)&&(p=e.match(h)[1].replace(/(;| |^)color([ :])/,"$1fill$2"),P(r,"style",p));i.test(e)&&!d&&(P(r,"onclick",\'location.href="\'+e.match(i)[1]+\'"\'),M(r,{cursor:"pointer"}));e=v(e.replace(/<(.|\\n)*?>/g,"")||" ");if(e!==" "){r.appendChild(y.createTextNode(e));\nif(n)o.dx=0;else if(f&&k!==null)o.x=k;P(r,o);b.appendChild(r);!n&&f&&(!ga&&d&&M(r,{display:"block"}),P(r,"dy",w(r)));if(m){for(var o=e.replace(/([^\\^])-/g,"$1- ").split(" "),q=g.length>1||f||o.length>1&&l.whiteSpace!=="nowrap",G,s,La=[],t=w(r),x=1,C=a.rotation,A=e,u=A.length;(q||z)&&(o.length||La.length);)a.rotation=0,G=a.getBBox(!0),s=G.width,!ga&&c.forExport&&(s=c.measureSpanWidth(r.firstChild.data,a.styles)),G=s>m,j===void 0&&(j=G),z&&j?(u/=2,A===""||!G&&u<0.5?o=[]:(A=e.substring(0,A.length+(G?\n-1:1)*va(u)),o=[A+(m>3?"\\u2026":"")],r.removeChild(r.firstChild))):!G||o.length===1?(o=La,La=[],o.length&&(x++,r=y.createElementNS(Ia,"tspan"),P(r,{dy:t,x:k}),p&&P(r,"style",p),b.appendChild(r)),s>m&&(m=s)):(r.removeChild(r.firstChild),La.unshift(o.pop())),o.length&&r.appendChild(y.createTextNode(o.join(" ").replace(/- /g,"-")));a.rotation=C}n++}}})}),j&&a.attr("title",a.textStr),G&&G.removeChild(b),o&&a.applyTextShadow&&a.applyTextShadow(o))},getContrast:function(a){a=na(a).rgba;return a[0]+a[1]+\na[2]>384?"#000000":"#FFFFFF"},button:function(a,b,c,d,e,f,g,h,i){var j=this.label(a,b,c,i,null,null,null,null,"button"),k=0,l,m,n,o,z,r,a={x1:0,y1:0,x2:0,y2:1},e=E({"stroke-width":1,stroke:"#CCCCCC",fill:{linearGradient:a,stops:[[0,"#FEFEFE"],[1,"#F6F6F6"]]},r:2,padding:5,style:{color:"black"}},e);n=e.style;delete e.style;f=E(e,{stroke:"#68A",fill:{linearGradient:a,stops:[[0,"#FFF"],[1,"#ACF"]]}},f);o=f.style;delete f.style;g=E(e,{stroke:"#68A",fill:{linearGradient:a,stops:[[0,"#9BD"],[1,"#CDF"]]}},\ng);z=g.style;delete g.style;h=E(e,{style:{color:"#CCC"}},h);r=h.style;delete h.style;N(j.element,za?"mouseover":"mouseenter",function(){k!==3&&j.attr(f).css(o)});N(j.element,za?"mouseout":"mouseleave",function(){k!==3&&(l=[e,f,g][k],m=[n,o,z][k],j.attr(l).css(m))});j.setState=function(a){(j.state=k=a)?a===2?j.attr(g).css(z):a===3&&j.attr(h).css(r):j.attr(e).css(n)};return j.on("click",function(a){k!==3&&d.call(j,a)}).attr(e).css(x({cursor:"default"},n))},crispLine:function(a,b){a[1]===a[4]&&(a[1]=\na[4]=C(a[1])-b%2/2);a[2]===a[5]&&(a[2]=a[5]=C(a[2])+b%2/2);return a},path:function(a){var b={fill:"none"};Fa(a)?b.d=a:$(a)&&x(b,a);return this.createElement("path").attr(b)},circle:function(a,b,c){a=$(a)?a:{x:a,y:b,r:c};b=this.createElement("circle");b.xSetter=b.ySetter=function(a,b,c){c.setAttribute("c"+b,a)};return b.attr(a)},arc:function(a,b,c,d,e,f){if($(a))b=a.y,c=a.r,d=a.innerR,e=a.start,f=a.end,a=a.x;a=this.symbol("arc",a||0,b||0,c||0,c||0,{innerR:d||0,start:e||0,end:f||0});a.r=c;return a},\nrect:function(a,b,c,d,e,f){var e=$(a)?a.r:e,g=this.createElement("rect"),a=$(a)?a:a===A?{}:{x:a,y:b,width:t(c,0),height:t(d,0)};if(f!==A)g.strokeWidth=f,a=g.crisp(a);if(e)a.r=e;g.rSetter=function(a,b,c){P(c,{rx:a,ry:a})};return g.attr(a)},setSize:function(a,b,c){var d=this.alignedObjects,e=d.length;this.width=a;this.height=b;for(this.boxWrapper[p(c,!0)?"animate":"attr"]({width:a,height:b});e--;)d[e].align()},g:function(a){var b=this.createElement("g");return s(a)?b.attr({"class":"highcharts-"+a}):\nb},image:function(a,b,c,d,e){var f={preserveAspectRatio:"none"};arguments.length>1&&x(f,{x:b,y:c,width:d,height:e});f=this.createElement("image").attr(f);f.element.setAttributeNS?f.element.setAttributeNS("http://www.w3.org/1999/xlink","href",a):f.element.setAttribute("hc-svg-href",a);return f},symbol:function(a,b,c,d,e,f){var g=this,h,i=this.symbols[a],i=i&&i(C(b),C(c),d,e,f),j=/^url\\((.*?)\\)$/,k,l;if(i)h=this.path(i),x(h,{symbolName:a,x:b,y:c,width:d,height:e}),f&&x(h,f);else if(j.test(a))l=function(a,\nb){a.element&&(a.attr({width:b[0],height:b[1]}),a.alignByTranslate||a.translate(C((d-b[0])/2),C((e-b[1])/2)))},k=a.match(j)[1],a=Ob[k]||f&&f.width&&f.height&&[f.width,f.height],h=this.image(k).attr({x:b,y:c}),h.isImg=!0,a?l(h,a):(h.attr({width:0,height:0}),da("img",{onload:function(){this.width===0&&(M(this,{position:"absolute",top:"-999em"}),y.body.appendChild(this));l(h,Ob[k]=[this.width,this.height]);this.parentNode&&this.parentNode.removeChild(this);g.imgCount--;if(!g.imgCount&&T[g.chartIndex].onload)T[g.chartIndex].onload()},\nsrc:k}),this.imgCount++);return h},symbols:{circle:function(a,b,c,d){var e=0.166*c;return[X,a+c/2,b,"C",a+c+e,b,a+c+e,b+d,a+c/2,b+d,"C",a-e,b+d,a-e,b,a+c/2,b,"Z"]},square:function(a,b,c,d){return[X,a,b,S,a+c,b,a+c,b+d,a,b+d,"Z"]},triangle:function(a,b,c,d){return[X,a+c/2,b,S,a+c,b+d,a,b+d,"Z"]},"triangle-down":function(a,b,c,d){return[X,a,b,S,a+c,b,a+c/2,b+d,"Z"]},diamond:function(a,b,c,d){return[X,a+c/2,b,S,a+c,b+d/2,a+c/2,b+d,a,b+d/2,"Z"]},arc:function(a,b,c,d,e){var f=e.start,c=e.r||c||d,g=e.end-\n0.001,d=e.innerR,h=e.open,i=W(f),j=ea(f),k=W(g),g=ea(g),e=e.end-f<ta?0:1;return[X,a+c*i,b+c*j,"A",c,c,0,e,1,a+c*k,b+c*g,h?X:S,a+d*k,b+d*g,"A",d,d,0,e,0,a+d*i,b+d*j,h?"":"Z"]},callout:function(a,b,c,d,e){var f=F(e&&e.r||0,c,d),g=f+6,h=e&&e.anchorX,e=e&&e.anchorY,i;i=["M",a+f,b,"L",a+c-f,b,"C",a+c,b,a+c,b,a+c,b+f,"L",a+c,b+d-f,"C",a+c,b+d,a+c,b+d,a+c-f,b+d,"L",a+f,b+d,"C",a,b+d,a,b+d,a,b+d-f,"L",a,b+f,"C",a,b,a,b,a+f,b];h&&h>c&&e>b+g&&e<b+d-g?i.splice(13,3,"L",a+c,e-6,a+c+6,e,a+c,e+6,a+c,b+d-f):h&&\nh<0&&e>b+g&&e<b+d-g?i.splice(33,3,"L",a,e+6,a-6,e,a,e-6,a,b+f):e&&e>d&&h>a+g&&h<a+c-g?i.splice(23,3,"L",h+6,b+d,h,b+d+6,h-6,b+d,a+f,b+d):e&&e<0&&h>a+g&&h<a+c-g&&i.splice(3,3,"L",h-6,b,h,b-6,h+6,b,c-f,b);return i}},clipRect:function(a,b,c,d){var e="highcharts-"+Bb++,f=this.createElement("clipPath").attr({id:e}).add(this.defs),a=this.rect(a,b,c,d,0).add(f);a.id=e;a.clipPath=f;a.count=0;return a},text:function(a,b,c,d){var e=la||!ga&&this.forExport,f={};if(d&&(this.allowHTML||!this.forExport))return this.html(a,\nb,c);f.x=Math.round(b||0);if(c)f.y=Math.round(c);if(a||a===0)f.text=a;a=this.createElement("text").attr(f);e&&a.css({position:"absolute"});if(!d)a.xSetter=function(a,b,c){var d=c.getElementsByTagName("tspan"),e,f=c.getAttribute(b),m;for(m=0;m<d.length;m++)e=d[m],e.getAttribute(b)===f&&e.setAttribute(b,a);c.setAttribute(b,a)};return a},fontMetrics:function(a,b){var c,d,a=a||this.style.fontSize;!a&&b&&D.getComputedStyle&&(b=b.element||b,a=(c=D.getComputedStyle(b,""))&&c.fontSize);a=/px/.test(a)?B(a):\n/em/.test(a)?parseFloat(a)*12:12;c=a<24?a+3:C(a*1.2);d=C(c*0.8);return{h:c,b:d,f:a}},rotCorr:function(a,b,c){var d=a;b&&c&&(d=t(d*W(b*ka),4));return{x:-a/3*ea(b*ka),y:d}},label:function(a,b,c,d,e,f,g,h,i){var j=this,k=j.g(i),l=j.text("",0,0,g).attr({zIndex:1}),m,n,o=0,z=3,r=0,p,w,v,La,qb=0,ba={},t,u,y,F,D;y=function(){var a,b;a=l.element.style;n=(p===void 0||w===void 0||k.styles.textAlign)&&s(l.textStr)&&l.getBBox();k.width=(p||n.width||0)+2*z+r;k.height=(w||n.height||0)+2*z;t=z+j.fontMetrics(a&&\na.fontSize,l).b;if(u){if(!m)a=qb,b=(h?-t:0)+qb,k.box=m=j.symbols[d]?j.symbol(d,a,b,k.width,k.height,ba):j.rect(a,b,k.width,k.height,0,ba["stroke-width"]),m.isImg||m.attr("fill","none"),m.add(k);m.isImg||m.attr(x({width:C(k.width),height:C(k.height)},ba));ba=null}};F=function(){var a=k.styles,a=a&&a.textAlign,b=r+z,c;c=h?0:t;if(s(p)&&n&&(a==="center"||a==="right"))b+={center:0.5,right:1}[a]*(p-n.width);if(b!==l.x||c!==l.y)l.attr("x",b),c!==A&&l.attr("y",c);l.x=b;l.y=c};D=function(a,b){m?m.attr(a,b):\nba[a]=b};k.onAdd=function(){l.add(k);k.attr({text:a||a===0?a:"",x:b,y:c});m&&s(e)&&k.attr({anchorX:e,anchorY:f})};k.widthSetter=function(a){p=a};k.heightSetter=function(a){w=a};k.paddingSetter=function(a){if(s(a)&&a!==z)z=k.padding=a,F()};k.paddingLeftSetter=function(a){s(a)&&a!==r&&(r=a,F())};k.alignSetter=function(a){a={left:0,center:0.5,right:1}[a];a!==o&&(o=a,n&&k.attr({x:v}))};k.textSetter=function(a){a!==A&&l.textSetter(a);y();F()};k["stroke-widthSetter"]=function(a,b){a&&(u=!0);qb=a%2/2;D(b,\na)};k.strokeSetter=k.fillSetter=k.rSetter=function(a,b){b==="fill"&&a&&(u=!0);D(b,a)};k.anchorXSetter=function(a,b){e=a;D(b,C(a)-qb-v)};k.anchorYSetter=function(a,b){f=a;D(b,a-La)};k.xSetter=function(a){k.x=a;o&&(a-=o*((p||n.width)+2*z));v=C(a);k.attr("translateX",v)};k.ySetter=function(a){La=k.y=C(a);k.attr("translateY",La)};var B=k.css;return x(k,{css:function(a){if(a){var b={},a=E(a);q(k.textProps,function(c){a[c]!==A&&(b[c]=a[c],delete a[c])});l.css(b)}return B.call(k,a)},getBBox:function(){return{width:n.width+\n2*z,height:n.height+2*z,x:n.x-z,y:n.y-z}},shadow:function(a){m&&m.shadow(a);return k},destroy:function(){Y(k.element,"mouseenter");Y(k.element,"mouseleave");l&&(l=l.destroy());m&&(m=m.destroy());O.prototype.destroy.call(k);k=j=y=F=D=null}})}};eb=Ea;x(O.prototype,{htmlCss:function(a){var b=this.element;if(b=a&&b.tagName==="SPAN"&&a.width)delete a.width,this.textWidth=b,this.updateTransform();if(a&&a.textOverflow==="ellipsis")a.whiteSpace="nowrap",a.overflow="hidden";this.styles=x(this.styles,a);M(this.element,\na);return this},htmlGetBBox:function(){var a=this.element;if(a.nodeName==="text")a.style.position="absolute";return{x:a.offsetLeft,y:a.offsetTop,width:a.offsetWidth,height:a.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var a=this.renderer,b=this.element,c=this.translateX||0,d=this.translateY||0,e=this.x||0,f=this.y||0,g=this.textAlign||"left",h={left:0,center:0.5,right:1}[g],i=this.shadows,j=this.styles;M(b,{marginLeft:c,marginTop:d});i&&q(i,function(a){M(a,{marginLeft:c+1,marginTop:d+\n1})});this.inverted&&q(b.childNodes,function(c){a.invertChild(c,b)});if(b.tagName==="SPAN"){var i=this.rotation,k=B(this.textWidth),l=j&&j.whiteSpace,m=[i,g,b.innerHTML,this.textWidth,this.textAlign].join(",");if(m!==this.cTT){j=a.fontMetrics(b.style.fontSize).b;s(i)&&this.setSpanRotation(i,h,j);M(b,{width:"",whiteSpace:l||"nowrap"});if(b.offsetWidth>k&&/[ \\-]/.test(b.textContent||b.innerText))M(b,{width:k+"px",display:"block",whiteSpace:l||"normal"});this.getSpanCorrection(b.offsetWidth,j,h,i,g)}M(b,\n{left:e+(this.xCorr||0)+"px",top:f+(this.yCorr||0)+"px"});if(ob)j=b.offsetHeight;this.cTT=m}}else this.alignOnAdd=!0},setSpanRotation:function(a,b,c){var d={},e=za?"-ms-transform":ob?"-webkit-transform":Qa?"MozTransform":Mb?"-o-transform":"";d[e]=d.transform="rotate("+a+"deg)";d[e+(Qa?"Origin":"-origin")]=d.transformOrigin=b*100+"% "+c+"px";M(this.element,d)},getSpanCorrection:function(a,b,c){this.xCorr=-a*c;this.yCorr=-b}});x(Ea.prototype,{html:function(a,b,c){var d=this.createElement("span"),e=\nd.element,f=d.renderer,g=f.isSVG,h=function(a,b){q(["opacity","visibility"],function(c){hb(a,c+"Setter",function(a,c,d,e){a.call(this,c,d,e);b[d]=c})})};d.textSetter=function(a){a!==e.innerHTML&&delete this.bBox;e.innerHTML=this.textStr=a;d.htmlUpdateTransform()};g&&h(d,d.element.style);d.xSetter=d.ySetter=d.alignSetter=d.rotationSetter=function(a,b){b==="align"&&(b="textAlign");d[b]=a;d.htmlUpdateTransform()};d.attr({text:a,x:C(b),y:C(c)}).css({position:"absolute",fontFamily:this.style.fontFamily,\nfontSize:this.style.fontSize});e.style.whiteSpace="nowrap";d.css=d.htmlCss;if(g)d.add=function(a){var b,c=f.box.parentNode,g=[];if(this.parentGroup=a){if(b=a.div,!b){for(;a;)g.push(a),a=a.parentGroup;q(g.reverse(),function(a){var d,e=P(a.element,"class");e&&(e={className:e});b=a.div=a.div||da(Pa,e,{position:"absolute",left:(a.translateX||0)+"px",top:(a.translateY||0)+"px",opacity:a.opacity},b||c);d=b.style;x(a,{translateXSetter:function(b,c){d.left=b+"px";a[c]=b;a.doTransform=!0},translateYSetter:function(b,\nc){d.top=b+"px";a[c]=b;a.doTransform=!0}});h(a,d)})}}else b=c;b.appendChild(e);d.added=!0;d.alignOnAdd&&d.htmlUpdateTransform();return d};return d}});var K;if(!ga&&!la){K={init:function(a,b){var c=["<",b,\' filled="f" stroked="f"\'],d=["position: ","absolute",";"],e=b===Pa;(b==="shape"||e)&&d.push("left:0;top:0;width:1px;height:1px;");d.push("visibility: ",e?"hidden":"visible");c.push(\' style="\',d.join(""),\'"/>\');if(b)c=e||b==="span"||b==="img"?c.join(""):a.prepVML(c),this.element=da(c);this.renderer=\na},add:function(a){var b=this.renderer,c=this.element,d=b.box,e=a&&a.inverted,d=a?a.element||a:d;if(a)this.parentGroup=a;e&&b.invertChild(c,d);d.appendChild(c);this.added=!0;this.alignOnAdd&&!this.deferUpdateTransform&&this.updateTransform();if(this.onAdd)this.onAdd();return this},updateTransform:O.prototype.htmlUpdateTransform,setSpanRotation:function(){var a=this.rotation,b=W(a*ka),c=ea(a*ka);M(this.element,{filter:a?["progid:DXImageTransform.Microsoft.Matrix(M11=",b,", M12=",-c,", M21=",c,", M22=",\nb,", sizingMethod=\'auto expand\')"].join(""):"none"})},getSpanCorrection:function(a,b,c,d,e){var f=d?W(d*ka):1,g=d?ea(d*ka):0,h=p(this.elemHeight,this.element.offsetHeight),i;this.xCorr=f<0&&-a;this.yCorr=g<0&&-h;i=f*g<0;this.xCorr+=g*b*(i?1-c:c);this.yCorr-=f*b*(d?i?c:1-c:1);e&&e!=="left"&&(this.xCorr-=a*c*(f<0?-1:1),d&&(this.yCorr-=h*c*(g<0?-1:1)),M(this.element,{textAlign:e}))},pathToVML:function(a){for(var b=a.length,c=[];b--;)if(J(a[b]))c[b]=C(a[b]*10)-5;else if(a[b]==="Z")c[b]="x";else if(c[b]=\na[b],a.isArc&&(a[b]==="wa"||a[b]==="at"))c[b+5]===c[b+7]&&(c[b+7]+=a[b+7]>a[b+5]?1:-1),c[b+6]===c[b+8]&&(c[b+8]+=a[b+8]>a[b+6]?1:-1);return c.join(" ")||"x"},clip:function(a){var b=this,c;a?(c=a.members,ra(c,b),c.push(b),b.destroyClip=function(){ra(c,b)},a=a.getCSS(b)):(b.destroyClip&&b.destroyClip(),a={clip:nb?"inherit":"rect(auto)"});return b.css(a)},css:O.prototype.htmlCss,safeRemoveChild:function(a){a.parentNode&&Ua(a)},destroy:function(){this.destroyClip&&this.destroyClip();return O.prototype.destroy.apply(this)},\non:function(a,b){this.element["on"+a]=function(){var a=D.event;a.target=a.srcElement;b(a)};return this},cutOffPath:function(a,b){var c,a=a.split(/[ ,]/);c=a.length;if(c===9||c===11)a[c-4]=a[c-2]=B(a[c-2])-10*b;return a.join(" ")},shadow:function(a,b,c){var d=[],e,f=this.element,g=this.renderer,h,i=f.style,j,k=f.path,l,m,n,o;k&&typeof k.value!=="string"&&(k="x");m=k;if(a){n=p(a.width,3);o=(a.opacity||0.15)/n;for(e=1;e<=3;e++){l=n*2+1-2*e;c&&(m=this.cutOffPath(k.value,l+0.5));j=[\'<shape isShadow="true" strokeweight="\',\nl,\'" filled="false" path="\',m,\'" coordsize="10 10" style="\',f.style.cssText,\'" />\'];h=da(g.prepVML(j),null,{left:B(i.left)+p(a.offsetX,1),top:B(i.top)+p(a.offsetY,1)});if(c)h.cutOff=l+1;j=[\'<stroke color="\',a.color||"black",\'" opacity="\',o*e,\'"/>\'];da(g.prepVML(j),null,null,h);b?b.element.appendChild(h):f.parentNode.insertBefore(h,f);d.push(h)}this.shadows=d}return this},updateShadows:Ba,setAttr:function(a,b){nb?this.element[a]=b:this.element.setAttribute(a,b)},classSetter:function(a){this.element.className=\na},dashstyleSetter:function(a,b,c){(c.getElementsByTagName("stroke")[0]||da(this.renderer.prepVML(["<stroke/>"]),null,null,c))[b]=a||"solid";this[b]=a},dSetter:function(a,b,c){var d=this.shadows,a=a||[];this.d=a.join&&a.join(" ");c.path=a=this.pathToVML(a);if(d)for(c=d.length;c--;)d[c].path=d[c].cutOff?this.cutOffPath(a,d[c].cutOff):a;this.setAttr(b,a)},fillSetter:function(a,b,c){var d=c.nodeName;if(d==="SPAN")c.style.color=a;else if(d!=="IMG")c.filled=a!=="none",this.setAttr("fillcolor",this.renderer.color(a,\nc,b,this))},"fill-opacitySetter":function(a,b,c){da(this.renderer.prepVML(["<",b.split("-")[0],\' opacity="\',a,\'"/>\']),null,null,c)},opacitySetter:Ba,rotationSetter:function(a,b,c){c=c.style;this[b]=c[b]=a;c.left=-C(ea(a*ka)+1)+"px";c.top=C(W(a*ka))+"px"},strokeSetter:function(a,b,c){this.setAttr("strokecolor",this.renderer.color(a,c,b,this))},"stroke-widthSetter":function(a,b,c){c.stroked=!!a;this[b]=a;J(a)&&(a+="px");this.setAttr("strokeweight",a)},titleSetter:function(a,b){this.setAttr(b,a)},visibilitySetter:function(a,\nb,c){a==="inherit"&&(a="visible");this.shadows&&q(this.shadows,function(c){c.style[b]=a});c.nodeName==="DIV"&&(a=a==="hidden"?"-999em":0,nb||(c.style[b]=a?"visible":"hidden"),b="top");c.style[b]=a},xSetter:function(a,b,c){this[b]=a;b==="x"?b="left":b==="y"&&(b="top");this.updateClipping?(this[b]=a,this.updateClipping()):c.style[b]=a},zIndexSetter:function(a,b,c){c.style[b]=a}};K["stroke-opacitySetter"]=K["fill-opacitySetter"];u.VMLElement=K=sa(O,K);K.prototype.ySetter=K.prototype.widthSetter=K.prototype.heightSetter=\nK.prototype.xSetter;var Db={Element:K,isIE8:Aa.indexOf("MSIE 8.0")>-1,init:function(a,b,c,d){var e;this.alignedObjects=[];d=this.createElement(Pa).css(x(this.getStyle(d),{position:"relative"}));e=d.element;a.appendChild(d.element);this.isVML=!0;this.box=e;this.boxWrapper=d;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(b,c,!1);if(!y.namespaces.hcv){y.namespaces.add("hcv","urn:schemas-microsoft-com:vml");try{y.createStyleSheet().cssText="hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } "}catch(f){y.styleSheets[0].cssText+=\n"hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } "}}},isHidden:function(){return!this.box.offsetWidth},clipRect:function(a,b,c,d){var e=this.createElement(),f=$(a);return x(e,{members:[],count:0,left:(f?a.x:a)+1,top:(f?a.y:b)+1,width:(f?a.width:c)-1,height:(f?a.height:d)-1,getCSS:function(a){var b=a.element,c=b.nodeName,a=a.inverted,d=this.top-(c==="shape"?b.offsetTop:0),e=this.left,b=e+this.width,f=d+this.height,d={clip:"rect("+C(a?e:d)+"px,"+\nC(a?f:b)+"px,"+C(a?b:f)+"px,"+C(a?d:e)+"px)"};!a&&nb&&c==="DIV"&&x(d,{width:b+"px",height:f+"px"});return d},updateClipping:function(){q(e.members,function(a){a.element&&a.css(e.getCSS(a))})}})},color:function(a,b,c,d){var e=this,f,g=/^rgba/,h,i,j="none";a&&a.linearGradient?i="gradient":a&&a.radialGradient&&(i="pattern");if(i){var k,l,m=a.linearGradient||a.radialGradient,n,o,z,r,p,w="",a=a.stops,v,s=[],t=function(){h=[\'<fill colors="\'+s.join(",")+\'" opacity="\',z,\'" o:opacity2="\',o,\'" type="\',i,\'" \',\nw,\'focus="100%" method="any" />\'];da(e.prepVML(h),null,null,b)};n=a[0];v=a[a.length-1];n[0]>0&&a.unshift([0,n[1]]);v[0]<1&&a.push([1,v[1]]);q(a,function(a,b){g.test(a[1])?(f=na(a[1]),k=f.get("rgb"),l=f.get("a")):(k=a[1],l=1);s.push(a[0]*100+"% "+k);b?(z=l,r=k):(o=l,p=k)});if(c==="fill")if(i==="gradient")c=m.x1||m[0]||0,a=m.y1||m[1]||0,n=m.x2||m[2]||0,m=m.y2||m[3]||0,w=\'angle="\'+(90-Z.atan((m-a)/(n-c))*180/ta)+\'"\',t();else{var j=m.r,ba=j*2,x=j*2,u=m.cx,A=m.cy,C=b.radialReference,y,j=function(){C&&\n(y=d.getBBox(),u+=(C[0]-y.x)/y.width-0.5,A+=(C[1]-y.y)/y.height-0.5,ba*=C[2]/y.width,x*=C[2]/y.height);w=\'src="\'+U.global.VMLRadialGradientURL+\'" size="\'+ba+","+x+\'" origin="0.5,0.5" position="\'+u+","+A+\'" color2="\'+p+\'" \';t()};d.added?j():d.onAdd=j;j=r}else j=k}else if(g.test(a)&&b.tagName!=="IMG")f=na(a),d[c+"-opacitySetter"](f.get("a"),c,b),j=f.get("rgb");else{j=b.getElementsByTagName(c);if(j.length)j[0].opacity=1,j[0].type="solid";j=a}return j},prepVML:function(a){var b=this.isIE8,a=a.join("");\nb?(a=a.replace("/>",\' xmlns="urn:schemas-microsoft-com:vml" />\'),a=a.indexOf(\'style="\')===-1?a.replace("/>",\' style="display:inline-block;behavior:url(#default#VML);" />\'):a.replace(\'style="\',\'style="display:inline-block;behavior:url(#default#VML);\')):a=a.replace("<","<hcv:");return a},text:Ea.prototype.html,path:function(a){var b={coordsize:"10 10"};Fa(a)?b.d=a:$(a)&&x(b,a);return this.createElement("shape").attr(b)},circle:function(a,b,c){var d=this.symbol("circle");if($(a))c=a.r,b=a.y,a=a.x;d.isCircle=\n!0;d.r=c;return d.attr({x:a,y:b})},g:function(a){var b;a&&(b={className:"highcharts-"+a,"class":"highcharts-"+a});return this.createElement(Pa).attr(b)},image:function(a,b,c,d,e){var f=this.createElement("img").attr({src:a});arguments.length>1&&f.attr({x:b,y:c,width:d,height:e});return f},createElement:function(a){return a==="rect"?this.symbol(a):Ea.prototype.createElement.call(this,a)},invertChild:function(a,b){var c=this,d=b.style,e=a.tagName==="IMG"&&a.style;M(a,{flip:"x",left:B(d.width)-(e?B(e.top):\n1),top:B(d.height)-(e?B(e.left):1),rotation:-90});q(a.childNodes,function(b){c.invertChild(b,a)})},symbols:{arc:function(a,b,c,d,e){var f=e.start,g=e.end,h=e.r||c||d,c=e.innerR,d=W(f),i=ea(f),j=W(g),k=ea(g);if(g-f===0)return["x"];f=["wa",a-h,b-h,a+h,b+h,a+h*d,b+h*i,a+h*j,b+h*k];e.open&&!c&&f.push("e",X,a,b);f.push("at",a-c,b-c,a+c,b+c,a+c*j,b+c*k,a+c*d,b+c*i,"x","e");f.isArc=!0;return f},circle:function(a,b,c,d,e){e&&(c=d=2*e.r);e&&e.isCircle&&(a-=c/2,b-=d/2);return["wa",a,b,a+c,b+d,a+c,b+d/2,a+c,\nb+d/2,"e"]},rect:function(a,b,c,d,e){return Ea.prototype.symbols[!s(e)||!e.r?"square":"callout"].call(0,a,b,c,d,e)}}};u.VMLRenderer=K=function(){this.init.apply(this,arguments)};K.prototype=E(Ea.prototype,Db);eb=K}Ea.prototype.measureSpanWidth=function(a,b){var c=y.createElement("span"),d;d=y.createTextNode(a);c.appendChild(d);M(c,b);this.box.appendChild(c);d=c.offsetWidth;Ua(c);return d};var Pb;if(la)u.CanVGRenderer=K=function(){Ia="http://www.w3.org/1999/xhtml"},K.prototype.symbols={},Pb=function(){function a(){var a=\nb.length,d;for(d=0;d<a;d++)b[d]();b=[]}var b=[];return{push:function(c,d){if(b.length===0){var e=y.getElementsByTagName("head")[0],f=y.createElement("script");f.type="text/javascript";f.src=d;f.onload=a;e.appendChild(f)}b.push(c)}}}(),eb=K;Xa.prototype={addLabel:function(){var a=this.axis,b=a.options,c=a.chart,d=a.categories,e=a.names,f=this.pos,g=b.labels,h=a.tickPositions,i=f===h[0],j=f===h[h.length-1],e=d?p(d[f],e[f],f):f,d=this.label,h=h.info,k;a.isDatetimeAxis&&h&&(k=b.dateTimeLabelFormats[h.higherRanks[f]||\nh.unitName]);this.isFirst=i;this.isLast=j;b=a.labelFormatter.call({axis:a,chart:c,isFirst:i,isLast:j,dateTimeLabelFormat:k,value:a.isLog?aa(a.lin2log(e)):e});s(d)?d&&d.attr({text:b}):(this.labelLength=(this.label=d=s(b)&&g.enabled?c.renderer.text(b,0,0,g.useHTML).css(E(g.style)).add(a.labelGroup):null)&&d.getBBox().width,this.rotation=0)},getLabelSize:function(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0},handleOverflow:function(a){var b=this.axis,c=a.x,d=b.chart.chartWidth,\ne=b.chart.spacing,f=p(b.labelLeft,F(b.pos,e[3])),e=p(b.labelRight,t(b.pos+b.len,d-e[1])),g=this.label,h=this.rotation,i={left:0,center:0.5,right:1}[b.labelAlign],j=g.getBBox().width,k=b.getSlotWidth(),l=k,m=1,n,o={};if(h)h<0&&c-i*j<f?n=C(c/W(h*ka)-f):h>0&&c+i*j>e&&(n=C((d-c)/W(h*ka)));else if(d=c+(1-i)*j,c-i*j<f?l=a.x+l*(1-i)-f:d>e&&(l=e-a.x+l*i,m=-1),l=F(k,l),l<k&&b.labelAlign==="center"&&(a.x+=m*(k-l-i*(k-F(j,l)))),j>l||b.autoRotation&&g.styles.width)n=l;if(n){o.width=n;if(!b.options.labels.style.textOverflow)o.textOverflow=\n"ellipsis";g.css(o)}},getPosition:function(a,b,c,d){var e=this.axis,f=e.chart,g=d&&f.oldChartHeight||f.chartHeight;return{x:a?e.translate(b+c,null,null,d)+e.transB:e.left+e.offset+(e.opposite?(d&&f.oldChartWidth||f.chartWidth)-e.right-e.left:0),y:a?g-e.bottom+e.offset-(e.opposite?e.height:0):g-e.translate(b+c,null,null,d)-e.transB}},getLabelPosition:function(a,b,c,d,e,f,g,h){var i=this.axis,j=i.transA,k=i.reversed,l=i.staggerLines,m=i.tickRotCorr||{x:0,y:0},n=e.y;s(n)||(n=i.side===0?c.rotation?-8:\n-c.getBBox().height:i.side===2?m.y+8:W(c.rotation*ka)*(m.y-c.getBBox(!1,0).height/2));a=a+e.x+m.x-(f&&d?f*j*(k?-1:1):0);b=b+n-(f&&!d?f*j*(k?1:-1):0);l&&(c=g/(h||1)%l,i.opposite&&(c=l-c-1),b+=c*(i.labelOffset/l));return{x:a,y:C(b)}},getMarkPath:function(a,b,c,d,e,f){return f.crispLine([X,a,b,S,a+(e?0:-c),b+(e?c:0)],d)},render:function(a,b,c){var d=this.axis,e=d.options,f=d.chart.renderer,g=d.horiz,h=this.type,i=this.label,j=this.pos,k=e.labels,l=this.gridLine,m=h?h+"Grid":"grid",n=h?h+"Tick":"tick",\no=e[m+"LineWidth"],z=e[m+"LineColor"],r=e[m+"LineDashStyle"],m=d.tickSize(n),n=e[n+"Color"],q=this.mark,w=k.step,v=!0,s=d.tickmarkOffset,t=this.getPosition(g,j,s,b),ba=t.x,t=t.y,x=g&&ba===d.pos+d.len||!g&&t===d.pos?-1:1,c=p(c,1);this.isActive=!0;if(o){j=d.getPlotLinePath(j+s,o*x,b,!0);if(l===A){l={stroke:z,"stroke-width":o};if(r)l.dashstyle=r;if(!h)l.zIndex=1;if(b)l.opacity=0;this.gridLine=l=o?f.path(j).attr(l).add(d.gridGroup):null}if(!b&&l&&j)l[this.isNew?"attr":"animate"]({d:j,opacity:c})}if(m)d.opposite&&\n(m[0]=-m[0]),h=this.getMarkPath(ba,t,m[0],m[1]*x,g,f),q?q.animate({d:h,opacity:c}):this.mark=f.path(h).attr({stroke:n,"stroke-width":m[1],opacity:c}).add(d.axisGroup);if(i&&J(ba))i.xy=t=this.getLabelPosition(ba,t,i,g,k,s,a,w),this.isFirst&&!this.isLast&&!p(e.showFirstLabel,1)||this.isLast&&!this.isFirst&&!p(e.showLastLabel,1)?v=!1:g&&!d.isRadial&&!k.step&&!k.rotation&&!b&&c!==0&&this.handleOverflow(t),w&&a%w&&(v=!1),v&&J(t.y)?(t.opacity=c,i[this.isNew?"attr":"animate"](t)):(Ka(i),i.attr("y",-9999)),\nthis.isNew=!1},destroy:function(){Ta(this,this.axis)}};u.PlotLineOrBand=function(a,b){this.axis=a;if(b)this.options=b,this.id=b.id};u.PlotLineOrBand.prototype={render:function(){var a=this,b=a.axis,c=b.horiz,d=a.options,e=d.label,f=a.label,g=d.width,h=d.to,i=d.from,j=s(i)&&s(h),k=d.value,l=d.dashStyle,m=a.svgElem,n=[],o,z=d.color,r=p(d.zIndex,0),q=d.events,w={},v=b.chart.renderer,n=b.log2lin;b.isLog&&(i=n(i),h=n(h),k=n(k));if(g){if(n=b.getPlotLinePath(k,g),w={stroke:z,"stroke-width":g},l)w.dashstyle=\nl}else if(j){n=b.getPlotBandPath(i,h,d);if(z)w.fill=z;if(d.borderWidth)w.stroke=d.borderColor,w["stroke-width"]=d.borderWidth}else return;w.zIndex=r;if(m)if(n)m.show(),m.animate({d:n});else{if(m.hide(),f)a.label=f=f.destroy()}else if(n&&n.length&&(a.svgElem=m=v.path(n).attr(w).add(),q))for(o in d=function(b){m.on(b,function(c){q[b].apply(a,[c])})},q)d(o);e&&s(e.text)&&n&&n.length&&b.width>0&&b.height>0&&!n.flat?(e=E({align:c&&j&&"center",x:c?!j&&4:10,verticalAlign:!c&&j&&"middle",y:c?j?16:10:j?6:\n-4,rotation:c&&!j&&90},e),this.renderLabel(e,n,j,r)):f&&f.hide();return a},renderLabel:function(a,b,c,d){var e=this.label,f=this.axis.chart.renderer;if(!e)e={align:a.textAlign||a.align,rotation:a.rotation},e.zIndex=d,this.label=e=f.text(a.text,0,0,a.useHTML).attr(e).css(a.style).add();d=[b[1],b[4],c?b[6]:b[1]];b=[b[2],b[5],c?b[7]:b[2]];c=Oa(d);f=Oa(b);e.align(a,!1,{x:c,y:f,width:Ha(d)-c,height:Ha(b)-f});e.show()},destroy:function(){ra(this.axis.plotLinesAndBands,this);delete this.axis;Ta(this)}};\nvar ia=u.Axis=function(){this.init.apply(this,arguments)};ia.prototype={defaultOptions:{dateTimeLabelFormats:{millisecond:"%H:%M:%S.%L",second:"%H:%M:%S",minute:"%H:%M",hour:"%H:%M",day:"%e. %b",week:"%e. %b",month:"%b \'%y",year:"%Y"},endOnTick:!1,gridLineColor:"#D8D8D8",labels:{enabled:!0,style:{color:"#606060",cursor:"default",fontSize:"11px"},x:0},lineColor:"#C0D0E0",lineWidth:1,minPadding:0.01,maxPadding:0.01,minorGridLineColor:"#E0E0E0",minorGridLineWidth:1,minorTickColor:"#A0A0A0",minorTickLength:2,\nminorTickPosition:"outside",startOfWeek:1,startOnTick:!1,tickColor:"#C0D0E0",tickLength:10,tickmarkPlacement:"between",tickPixelInterval:100,tickPosition:"outside",title:{align:"middle",style:{color:"#707070"}},type:"linear"},defaultYAxisOptions:{endOnTick:!0,gridLineWidth:1,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8},lineWidth:0,maxPadding:0.05,minPadding:0.05,startOnTick:!0,title:{rotation:270,text:"Values"},stackLabels:{enabled:!1,formatter:function(){return u.numberFormat(this.total,-1)},\nstyle:E(fa.line.dataLabels.style,{color:"#000000"})}},defaultLeftAxisOptions:{labels:{x:-15},title:{rotation:270}},defaultRightAxisOptions:{labels:{x:15},title:{rotation:90}},defaultBottomAxisOptions:{labels:{autoRotation:[-45],x:0},title:{rotation:0}},defaultTopAxisOptions:{labels:{autoRotation:[-45],x:0},title:{rotation:0}},init:function(a,b){var c=b.isX;this.chart=a;this.horiz=a.inverted?!c:c;this.coll=(this.isXAxis=c)?"xAxis":"yAxis";this.opposite=b.opposite;this.side=b.side||(this.horiz?this.opposite?\n0:2:this.opposite?1:3);this.setOptions(b);var d=this.options,e=d.type;this.labelFormatter=d.labels.formatter||this.defaultLabelFormatter;this.userOptions=b;this.minPixelPadding=0;this.reversed=d.reversed;this.visible=d.visible!==!1;this.zoomEnabled=d.zoomEnabled!==!1;this.categories=d.categories||e==="category";this.names=this.names||[];this.isLog=e==="logarithmic";this.isDatetimeAxis=e==="datetime";this.isLinked=s(d.linkedTo);this.ticks={};this.labelEdge=[];this.minorTicks={};this.plotLinesAndBands=\n[];this.alternateBands={};this.len=0;this.minRange=this.userMinRange=d.minRange||d.maxZoom;this.range=d.range;this.offset=d.offset||0;this.stacks={};this.oldStacks={};this.stacksTouched=0;this.min=this.max=null;this.crosshair=p(d.crosshair,ua(a.options.tooltip.crosshairs)[c?0:1],!1);var f,d=this.options.events;pa(this,a.axes)===-1&&(c&&!this.isColorAxis?a.axes.splice(a.xAxis.length,0,this):a.axes.push(this),a[this.coll].push(this));this.series=this.series||[];if(a.inverted&&c&&this.reversed===A)this.reversed=\n!0;this.removePlotLine=this.removePlotBand=this.removePlotBandOrLine;for(f in d)N(this,f,d[f]);if(this.isLog)this.val2lin=this.log2lin,this.lin2val=this.lin2log},setOptions:function(a){this.options=E(this.defaultOptions,this.isXAxis?{}:this.defaultYAxisOptions,[this.defaultTopAxisOptions,this.defaultRightAxisOptions,this.defaultBottomAxisOptions,this.defaultLeftAxisOptions][this.side],E(U[this.coll],a))},defaultLabelFormatter:function(){var a=this.axis,b=this.value,c=a.categories,d=this.dateTimeLabelFormat,\ne=U.lang.numericSymbols,f=e&&e.length,g,h=a.options.labels.format,a=a.isLog?b:a.tickInterval;if(h)g=Na(h,this);else if(c)g=b;else if(d)g=Sa(d,b);else if(f&&a>=1E3)for(;f--&&g===A;)c=Math.pow(1E3,f+1),a>=c&&b*10%c===0&&e[f]!==null&&b!==0&&(g=u.numberFormat(b/c,-1)+e[f]);g===A&&(g=Q(b)>=1E4?u.numberFormat(b,-1):u.numberFormat(b,-1,A,""));return g},getSeriesExtremes:function(){var a=this,b=a.chart;a.hasVisibleSeries=!1;a.dataMin=a.dataMax=a.threshold=null;a.softThreshold=!a.isXAxis;a.buildStacks&&a.buildStacks();\nq(a.series,function(c){if(c.visible||!b.options.chart.ignoreHiddenSeries){var d=c.options,e=d.threshold,f;a.hasVisibleSeries=!0;a.isLog&&e<=0&&(e=null);if(a.isXAxis){if(d=c.xData,d.length)c=Oa(d),!J(c)&&!(c instanceof ma)&&(d=Ca(d,function(a){return J(a)}),c=Oa(d)),a.dataMin=F(p(a.dataMin,d[0]),c),a.dataMax=t(p(a.dataMax,d[0]),Ha(d))}else{c.getExtremes();f=c.dataMax;c=c.dataMin;if(s(c)&&s(f))a.dataMin=F(p(a.dataMin,c),c),a.dataMax=t(p(a.dataMax,f),f);if(s(e))a.threshold=e;if(!d.softThreshold||a.isLog)a.softThreshold=\n!1}}})},translate:function(a,b,c,d,e,f){var g=this.linkedParent||this,h=1,i=0,j=d?g.oldTransA:g.transA,d=d?g.oldMin:g.min,k=g.minPixelPadding,e=(g.isOrdinal||g.isBroken||g.isLog&&e)&&g.lin2val;if(!j)j=g.transA;if(c)h*=-1,i=g.len;g.reversed&&(h*=-1,i-=h*(g.sector||g.len));b?(a=a*h+i,a-=k,a=a/j+d,e&&(a=g.lin2val(a))):(e&&(a=g.val2lin(a)),f==="between"&&(f=0.5),a=h*(a-d)*j+i+h*k+(J(f)?j*f*g.pointRange:0));return a},toPixels:function(a,b){return this.translate(a,!1,!this.horiz,null,!0)+(b?0:this.pos)},\ntoValue:function(a,b){return this.translate(a-(b?0:this.pos),!0,!this.horiz,null,!0)},getPlotLinePath:function(a,b,c,d,e){var f=this.chart,g=this.left,h=this.top,i,j,k=c&&f.oldChartHeight||f.chartHeight,l=c&&f.oldChartWidth||f.chartWidth,m;i=this.transB;var n=function(a,b,c){if(a<b||a>c)d?a=F(t(b,a),c):m=!0;return a},e=p(e,this.translate(a,null,null,c)),a=c=C(e+i);i=j=C(k-e-i);J(e)?this.horiz?(i=h,j=k-this.bottom,a=c=n(a,g,g+this.width)):(a=g,c=l-this.right,i=j=n(i,h,h+this.height)):m=!0;return m&&\n!d?null:f.renderer.crispLine([X,a,i,S,c,j],b||1)},getLinearTickPositions:function(a,b,c){var d,e=aa(V(b/a)*a),f=aa(va(c/a)*a),g=[];if(b===c&&J(b))return[b];for(b=e;b<=f;){g.push(b);b=aa(b+a);if(b===d)break;d=b}return g},getMinorTickPositions:function(){var a=this.options,b=this.tickPositions,c=this.minorTickInterval,d=[],e,f=this.pointRangePadding||0;e=this.min-f;var f=this.max+f,g=f-e;if(g&&g/c<this.len/3)if(this.isLog){f=b.length;for(e=1;e<f;e++)d=d.concat(this.getLogTickPositions(c,b[e-1],b[e],\n!0))}else if(this.isDatetimeAxis&&a.minorTickInterval==="auto")d=d.concat(this.getTimeTicks(this.normalizeTimeTickInterval(c),e,f,a.startOfWeek));else for(b=e+(b[0]-e)%c;b<=f;b+=c)d.push(b);d.length!==0&&this.trimTicks(d,a.startOnTick,a.endOnTick);return d},adjustForMinRange:function(){var a=this.options,b=this.min,c=this.max,d,e=this.dataMax-this.dataMin>=this.minRange,f,g,h,i,j,k;if(this.isXAxis&&this.minRange===A&&!this.isLog)s(a.min)||s(a.max)?this.minRange=null:(q(this.series,function(a){i=a.xData;\nfor(g=j=a.xIncrement?1:i.length-1;g>0;g--)if(h=i[g]-i[g-1],f===A||h<f)f=h}),this.minRange=F(f*5,this.dataMax-this.dataMin));if(c-b<this.minRange){k=this.minRange;d=(k-c+b)/2;d=[b-d,p(a.min,b-d)];if(e)d[2]=this.dataMin;b=Ha(d);c=[b+k,p(a.max,b+k)];if(e)c[2]=this.dataMax;c=Oa(c);c-b<k&&(d[0]=c-k,d[1]=p(a.min,c-k),b=Ha(d))}this.min=b;this.max=c},getClosest:function(){var a;this.categories?a=1:q(this.series,function(b){var c=b.closestPointRange;!b.noSharedTooltip&&s(c)&&(a=s(a)?F(a,c):c)});return a},\nsetAxisTranslation:function(a){var b=this,c=b.max-b.min,d=b.axisPointRange||0,e,f=0,g=0,h=b.linkedParent,i=!!b.categories,j=b.transA,k=b.isXAxis;if(k||i||d)if(h?(f=h.minPointOffset,g=h.pointRangePadding):(e=b.getClosest(),q(b.series,function(a){var c=i?1:k?p(a.options.pointRange,e,0):b.axisPointRange||0,a=a.options.pointPlacement;d=t(d,c);b.single||(f=t(f,ya(a)?0:c/2),g=t(g,a==="on"?0:c))})),h=b.ordinalSlope&&e?b.ordinalSlope/e:1,b.minPointOffset=f*=h,b.pointRangePadding=g*=h,b.pointRange=F(d,c),\nk)b.closestPointRange=e;if(a)b.oldTransA=j;b.translationSlope=b.transA=j=b.len/(c+g||1);b.transB=b.horiz?b.left:b.bottom;b.minPixelPadding=j*f},minFromRange:function(){return this.max-this.range},setTickInterval:function(a){var b=this,c=b.chart,d=b.options,e=b.isLog,f=b.log2lin,g=b.isDatetimeAxis,h=b.isXAxis,i=b.isLinked,j=d.maxPadding,k=d.minPadding,l=d.tickInterval,m=d.tickPixelInterval,n=b.categories,o=b.threshold,z=b.softThreshold,r,G,w,v;!g&&!n&&!i&&this.getTickAmount();w=p(b.userMin,d.min);\nv=p(b.userMax,d.max);i?(b.linkedParent=c[b.coll][d.linkedTo],c=b.linkedParent.getExtremes(),b.min=p(c.min,c.dataMin),b.max=p(c.max,c.dataMax),d.type!==b.linkedParent.options.type&&ca(11,1)):(!z&&s(o)&&(b.dataMin>=o?(r=o,k=0):b.dataMax<=o&&(G=o,j=0)),b.min=p(w,r,b.dataMin),b.max=p(v,G,b.dataMax));if(e)!a&&F(b.min,p(b.dataMin,b.min))<=0&&ca(10,1),b.min=aa(f(b.min),15),b.max=aa(f(b.max),15);if(b.range&&s(b.max))b.userMin=b.min=w=t(b.min,b.minFromRange()),b.userMax=v=b.max,b.range=null;I(b,"foundExtremes");\nb.beforePadding&&b.beforePadding();b.adjustForMinRange();if(!n&&!b.axisPointRange&&!b.usePercentage&&!i&&s(b.min)&&s(b.max)&&(f=b.max-b.min))!s(w)&&k&&(b.min-=f*k),!s(v)&&j&&(b.max+=f*j);if(J(d.floor))b.min=t(b.min,d.floor);if(J(d.ceiling))b.max=F(b.max,d.ceiling);if(z&&s(b.dataMin))if(o=o||0,!s(w)&&b.min<o&&b.dataMin>=o)b.min=o;else if(!s(v)&&b.max>o&&b.dataMax<=o)b.max=o;b.tickInterval=b.min===b.max||b.min===void 0||b.max===void 0?1:i&&!l&&m===b.linkedParent.options.tickPixelInterval?l=b.linkedParent.tickInterval:\np(l,this.tickAmount?(b.max-b.min)/t(this.tickAmount-1,1):void 0,n?1:(b.max-b.min)*m/t(b.len,m));h&&!a&&q(b.series,function(a){a.processData(b.min!==b.oldMin||b.max!==b.oldMax)});b.setAxisTranslation(!0);b.beforeSetTickPositions&&b.beforeSetTickPositions();if(b.postProcessTickInterval)b.tickInterval=b.postProcessTickInterval(b.tickInterval);if(b.pointRange&&!l)b.tickInterval=t(b.pointRange,b.tickInterval);a=p(d.minTickInterval,b.isDatetimeAxis&&b.closestPointRange);if(!l&&b.tickInterval<a)b.tickInterval=\na;if(!g&&!e&&!l)b.tickInterval=vb(b.tickInterval,null,ub(b.tickInterval),p(d.allowDecimals,!(b.tickInterval>0.5&&b.tickInterval<5&&b.max>1E3&&b.max<9999)),!!this.tickAmount);if(!this.tickAmount&&this.len)b.tickInterval=b.unsquish();this.setTickPositions()},setTickPositions:function(){var a=this.options,b,c=a.tickPositions,d=a.tickPositioner,e=a.startOnTick,f=a.endOnTick,g;this.tickmarkOffset=this.categories&&a.tickmarkPlacement==="between"&&this.tickInterval===1?0.5:0;this.minorTickInterval=a.minorTickInterval===\n"auto"&&this.tickInterval?this.tickInterval/5:a.minorTickInterval;this.tickPositions=b=c&&c.slice();if(!b&&(b=this.isDatetimeAxis?this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval,a.units),this.min,this.max,a.startOfWeek,this.ordinalPositions,this.closestPointRange,!0):this.isLog?this.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,this.min,this.max),b.length>this.len&&(b=[b[0],b.pop()]),this.tickPositions=b,d&&(d=d.apply(this,\n[this.min,this.max]))))this.tickPositions=b=d;if(!this.isLinked)this.trimTicks(b,e,f),this.min===this.max&&s(this.min)&&!this.tickAmount&&(g=!0,this.min-=0.5,this.max+=0.5),this.single=g,!c&&!d&&this.adjustTickAmount()},trimTicks:function(a,b,c){var d=a[0],e=a[a.length-1],f=this.minPointOffset||0;if(b)this.min=d;else for(;this.min-f>a[0];)a.shift();if(c)this.max=e;else for(;this.max+f<a[a.length-1];)a.pop();a.length===0&&s(d)&&a.push((e+d)/2)},alignToOthers:function(){var a={},b,c=this.options;this.chart.options.chart.alignTicks!==\n!1&&c.alignTicks!==!1&&q(this.chart[this.coll],function(c){var e=c.options,e=[c.horiz?e.left:e.top,e.width,e.height,e.pane].join(",");c.series.length&&(a[e]?b=!0:a[e]=1)});return b},getTickAmount:function(){var a=this.options,b=a.tickAmount,c=a.tickPixelInterval;!s(a.tickInterval)&&this.len<c&&!this.isRadial&&!this.isLog&&a.startOnTick&&a.endOnTick&&(b=2);!b&&this.alignToOthers()&&(b=va(this.len/c)+1);if(b<4)this.finalTickAmt=b,b=5;this.tickAmount=b},adjustTickAmount:function(){var a=this.tickInterval,\nb=this.tickPositions,c=this.tickAmount,d=this.finalTickAmt,e=b&&b.length;if(e<c){for(;b.length<c;)b.push(aa(b[b.length-1]+a));this.transA*=(e-1)/(c-1);this.max=b[b.length-1]}else e>c&&(this.tickInterval*=2,this.setTickPositions());if(s(d)){for(a=c=b.length;a--;)(d===3&&a%2===1||d<=2&&a>0&&a<c-1)&&b.splice(a,1);this.finalTickAmt=A}},setScale:function(){var a,b;this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;this.setAxisSize();b=this.len!==this.oldAxisLength;q(this.series,function(b){if(b.isDirtyData||\nb.isDirty||b.xAxis.isDirty)a=!0});if(b||a||this.isLinked||this.forceRedraw||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax||this.alignToOthers()){if(this.resetStacks&&this.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,!this.isDirty)this.isDirty=b||this.min!==this.oldMin||this.max!==this.oldMax}else this.cleanStacks&&this.cleanStacks()},setExtremes:function(a,b,c,d,e){var f=this,g=f.chart,\nc=p(c,!0);q(f.series,function(a){delete a.kdTree});e=x(e,{min:a,max:b});I(f,"setExtremes",e,function(){f.userMin=a;f.userMax=b;f.eventArgs=e;c&&g.redraw(d)})},zoom:function(a,b){var c=this.dataMin,d=this.dataMax,e=this.options,f=F(c,p(e.min,c)),e=t(d,p(e.max,d));this.allowZoomOutside||(s(c)&&a<=f&&(a=f),s(d)&&b>=e&&(b=e));this.displayBtn=a!==A||b!==A;this.setExtremes(a,b,!1,A,{trigger:"zoom"});return!0},setAxisSize:function(){var a=this.chart,b=this.options,c=b.offsetLeft||0,d=this.horiz,e=p(b.width,\na.plotWidth-c+(b.offsetRight||0)),f=p(b.height,a.plotHeight),g=p(b.top,a.plotTop),b=p(b.left,a.plotLeft+c),c=/%$/;c.test(f)&&(f=Math.round(parseFloat(f)/100*a.plotHeight));c.test(g)&&(g=Math.round(parseFloat(g)/100*a.plotHeight+a.plotTop));this.left=b;this.top=g;this.width=e;this.height=f;this.bottom=a.chartHeight-f-g;this.right=a.chartWidth-e-b;this.len=t(d?e:f,0);this.pos=d?b:g},getExtremes:function(){var a=this.isLog,b=this.lin2log;return{min:a?aa(b(this.min)):this.min,max:a?aa(b(this.max)):this.max,\ndataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}},getThreshold:function(a){var b=this.isLog,c=this.lin2log,d=b?c(this.min):this.min,b=b?c(this.max):this.max;a===null?a=d:d>a?a=d:b<a&&(a=b);return this.translate(a,0,1,0,1)},autoLabelAlign:function(a){a=(p(a,0)-this.side*90+720)%360;return a>15&&a<165?"right":a>195&&a<345?"left":"center"},tickSize:function(a){var b=this.options,c=b[a+"Length"],d=p(b[a+"Width"],a==="tick"&&this.isXAxis?1:0);if(d&&c)return b[a+"Position"]===\n"inside"&&(c=-c),[c,d]},labelMetrics:function(){return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize,this.ticks[0]&&this.ticks[0].label)},unsquish:function(){var a=this.options.labels,b=this.horiz,c=this.tickInterval,d=c,e=this.len/(((this.categories?1:0)+this.max-this.min)/c),f,g=a.rotation,h=this.labelMetrics(),i,j=Number.MAX_VALUE,k,l=function(a){a/=e||1;a=a>1?va(a):1;return a*c};b?(k=!a.staggerLines&&!a.step&&(s(g)?[g]:e<p(a.autoRotationLimit,80)&&a.autoRotation))&&q(k,function(a){var b;\nif(a===g||a&&a>=-90&&a<=90)i=l(Q(h.h/ea(ka*a))),b=i+Q(a/360),b<j&&(j=b,f=a,d=i)}):a.step||(d=l(h.h));this.autoRotation=k;this.labelRotation=p(f,g);return d},getSlotWidth:function(){var a=this.chart,b=this.horiz,c=this.options.labels,d=Math.max(this.tickPositions.length-(this.categories?0:1),1),e=a.margin[3];return b&&(c.step||0)<2&&!c.rotation&&(this.staggerLines||1)*a.plotWidth/d||!b&&(e&&e-a.spacing[3]||a.chartWidth*0.33)},renderUnsquish:function(){var a=this.chart,b=a.renderer,c=this.tickPositions,\nd=this.ticks,e=this.options.labels,f=this.horiz,g=this.getSlotWidth(),h=t(1,C(g-2*(e.padding||5))),i={},j=this.labelMetrics(),k=e.style.textOverflow,l,m=0,n,o;if(!ya(e.rotation))i.rotation=e.rotation||0;if(this.autoRotation)q(c,function(a){if((a=d[a])&&a.labelLength>m)m=a.labelLength}),m>h&&m>j.h?i.rotation=this.labelRotation:this.labelRotation=0;else if(g&&(l={width:h+"px"},!k)){l.textOverflow="clip";for(n=c.length;!f&&n--;)if(o=c[n],h=d[o].label)if(h.styles.textOverflow==="ellipsis"?h.css({textOverflow:"clip"}):\nd[o].labelLength>g&&h.css({width:g+"px"}),h.getBBox().height>this.len/c.length-(j.h-j.f))h.specCss={textOverflow:"ellipsis"}}if(i.rotation&&(l={width:(m>a.chartHeight*0.5?a.chartHeight*0.33:a.chartHeight)+"px"},!k))l.textOverflow="ellipsis";if(this.labelAlign=e.align||this.autoLabelAlign(this.labelRotation))i.align=this.labelAlign;q(c,function(a){var b=(a=d[a])&&a.label;if(b)b.attr(i),l&&b.css(E(l,b.specCss)),delete b.specCss,a.rotation=i.rotation});this.tickRotCorr=b.rotCorr(j.b,this.labelRotation||\n0,this.side!==0)},hasData:function(){return this.hasVisibleSeries||s(this.min)&&s(this.max)&&!!this.tickPositions},getOffset:function(){var a=this,b=a.chart,c=b.renderer,d=a.options,e=a.tickPositions,f=a.ticks,g=a.horiz,h=a.side,i=b.inverted?[1,0,3,2][h]:h,j,k,l=0,m,n=0,o=d.title,z=d.labels,r=0,G=a.opposite,w=b.axisOffset,b=b.clipOffset,v=[-1,1,1,-1][h],x,u=a.axisParent,ba=this.tickSize("tick");j=a.hasData();a.showAxis=k=j||p(d.showEmpty,!0);a.staggerLines=a.horiz&&z.staggerLines;if(!a.axisGroup)a.gridGroup=\nc.g("grid").attr({zIndex:d.gridZIndex||1}).add(u),a.axisGroup=c.g("axis").attr({zIndex:d.zIndex||2}).add(u),a.labelGroup=c.g("axis-labels").attr({zIndex:z.zIndex||7}).addClass("highcharts-"+a.coll.toLowerCase()+"-labels").add(u);if(j||a.isLinked){if(q(e,function(b){f[b]?f[b].addLabel():f[b]=new Xa(a,b)}),a.renderUnsquish(),z.reserveSpace!==!1&&(h===0||h===2||{1:"left",3:"right"}[h]===a.labelAlign||a.labelAlign==="center")&&q(e,function(a){r=t(f[a].getLabelSize(),r)}),a.staggerLines)r*=a.staggerLines,\na.labelOffset=r*(a.opposite?-1:1)}else for(x in f)f[x].destroy(),delete f[x];if(o&&o.text&&o.enabled!==!1){if(!a.axisTitle)(x=o.textAlign)||(x=(g?{low:"left",middle:"center",high:"right"}:{low:G?"right":"left",middle:"center",high:G?"left":"right"})[o.align]),a.axisTitle=c.text(o.text,0,0,o.useHTML).attr({zIndex:7,rotation:o.rotation||0,align:x}).addClass("highcharts-"+this.coll.toLowerCase()+"-title").css(o.style).add(a.axisGroup),a.axisTitle.isNew=!0;if(k)l=a.axisTitle.getBBox()[g?"height":"width"],\nm=o.offset,n=s(m)?0:p(o.margin,g?5:10);a.axisTitle[k?"show":"hide"](!0)}a.offset=v*p(d.offset,w[h]);a.tickRotCorr=a.tickRotCorr||{x:0,y:0};c=h===0?-a.labelMetrics().h:h===2?a.tickRotCorr.y:0;n=Math.abs(r)+n;r&&(n-=c,n+=v*(g?p(z.y,a.tickRotCorr.y+v*8):z.x));a.axisTitleMargin=p(m,n);w[h]=t(w[h],a.axisTitleMargin+l+v*a.offset,n,j&&e.length&&ba?ba[0]:0);d=d.offset?0:V(d.lineWidth/2)*2;b[i]=t(b[i],d)},getLinePath:function(a){var b=this.chart,c=this.opposite,d=this.offset,e=this.horiz,f=this.left+(c?this.width:\n0)+d,d=b.chartHeight-this.bottom-(c?this.height:0)+d;c&&(a*=-1);return b.renderer.crispLine([X,e?this.left:f,e?d:this.top,S,e?b.chartWidth-this.right:f,e?d:b.chartHeight-this.bottom],a)},getTitlePosition:function(){var a=this.horiz,b=this.left,c=this.top,d=this.len,e=this.options.title,f=a?b:c,g=this.opposite,h=this.offset,i=e.x||0,j=e.y||0,k=this.chart.renderer.fontMetrics(e.style.fontSize).f,d={low:f+(a?0:d),middle:f+d/2,high:f+(a?d:0)}[e.align],b=(a?c+this.height:b)+(a?1:-1)*(g?-1:1)*this.axisTitleMargin+\n(this.side===2?k:0);return{x:a?d+i:b+(g?this.width:0)+h+i,y:a?b+j-(g?this.height:0)+h:d+j}},render:function(){var a=this,b=a.chart,c=b.renderer,d=a.options,e=a.isLog,f=a.lin2log,g=a.isLinked,h=a.tickPositions,i=a.axisTitle,j=a.ticks,k=a.minorTicks,l=a.alternateBands,m=d.stackLabels,n=d.alternateGridColor,o=a.tickmarkOffset,z=d.lineWidth,r,p=b.hasRendered&&J(a.oldMin),w=a.showAxis,v=bb(c.globalAnimation),t,s;a.labelEdge.length=0;a.overlap=!1;q([j,k,l],function(a){for(var b in a)a[b].isActive=!1});\nif(a.hasData()||g){a.minorTickInterval&&!a.categories&&q(a.getMinorTickPositions(),function(b){k[b]||(k[b]=new Xa(a,b,"minor"));p&&k[b].isNew&&k[b].render(null,!0);k[b].render(null,!1,1)});if(h.length&&(q(h,function(b,c){if(!g||b>=a.min&&b<=a.max)j[b]||(j[b]=new Xa(a,b)),p&&j[b].isNew&&j[b].render(c,!0,0.1),j[b].render(c)}),o&&(a.min===0||a.single)))j[-1]||(j[-1]=new Xa(a,-1,null,!0)),j[-1].render(-1);n&&q(h,function(c,d){s=h[d+1]!==A?h[d+1]+o:a.max-o;if(d%2===0&&c<a.max&&s<=a.max+(b.polar?-o:o))l[c]||\n(l[c]=new u.PlotLineOrBand(a)),t=c+o,l[c].options={from:e?f(t):t,to:e?f(s):s,color:n},l[c].render(),l[c].isActive=!0});if(!a._addedPlotLB)q((d.plotLines||[]).concat(d.plotBands||[]),function(b){a.addPlotBandOrLine(b)}),a._addedPlotLB=!0}q([j,k,l],function(a){var c,d,e=[],f=v.duration;for(c in a)if(!a[c].isActive)a[c].render(c,!1,0),a[c].isActive=!1,e.push(c);Ra(function(){for(d=e.length;d--;)a[e[d]]&&!a[e[d]].isActive&&(a[e[d]].destroy(),delete a[e[d]])},a===l||!b.hasRendered||!f?0:f)});if(z)r=a.getLinePath(z),\na.axisLine?a.axisLine.animate({d:r}):a.axisLine=c.path(r).attr({stroke:d.lineColor,"stroke-width":z,zIndex:7}).add(a.axisGroup),a.axisLine[w?"show":"hide"](!0);if(i&&w)i[i.isNew?"attr":"animate"](a.getTitlePosition()),i.isNew=!1;m&&m.enabled&&a.renderStackTotals();a.isDirty=!1},redraw:function(){this.visible&&(this.render(),q(this.plotLinesAndBands,function(a){a.render()}));q(this.series,function(a){a.isDirty=!0})},destroy:function(a){var b=this,c=b.stacks,d,e=b.plotLinesAndBands;a||Y(b);for(d in c)Ta(c[d]),\nc[d]=null;q([b.ticks,b.minorTicks,b.alternateBands],function(a){Ta(a)});for(a=e.length;a--;)e[a].destroy();q("stackTotalGroup,axisLine,axisTitle,axisGroup,gridGroup,labelGroup,cross".split(","),function(a){b[a]&&(b[a]=b[a].destroy())});this._addedPlotLB=this.chart._labelPanes=this.ordinalSlope=void 0},drawCrosshair:function(a,b){var c,d=this.crosshair,e,f;a||(a=this.cross&&this.cross.e);if(!this.crosshair||(s(b)||!p(d.snap,!0))===!1)this.hideCrosshair();else if(p(d.snap,!0)?s(b)&&(c=this.isXAxis?\nb.plotX:this.len-b.plotY):c=this.horiz?a.chartX-this.pos:this.len-a.chartY+this.pos,c=this.isRadial?this.getPlotLinePath(this.isXAxis?b.x:p(b.stackY,b.y))||null:this.getPlotLinePath(null,null,null,null,c)||null,c===null)this.hideCrosshair();else{e=this.categories&&!this.isRadial;f=p(d.width,e?this.transA:1);if(this.cross)this.cross.attr({d:c,visibility:"visible","stroke-width":f});else{e={"pointer-events":"none","stroke-width":f,stroke:d.color||(e?"rgba(155,200,255,0.2)":"#C0C0C0"),zIndex:p(d.zIndex,\n2)};if(d.dashStyle)e.dashstyle=d.dashStyle;this.cross=this.chart.renderer.path(c).attr(e).add()}this.cross.e=a}},hideCrosshair:function(){this.cross&&this.cross.hide()}};x(ia.prototype,{getPlotBandPath:function(a,b){var c=this.getPlotLinePath(b,null,null,!0),d=this.getPlotLinePath(a,null,null,!0);d&&c?(d.flat=d.toString()===c.toString(),d.push(c[4],c[5],c[1],c[2])):d=null;return d},addPlotBand:function(a){return this.addPlotBandOrLine(a,"plotBands")},addPlotLine:function(a){return this.addPlotBandOrLine(a,\n"plotLines")},addPlotBandOrLine:function(a,b){var c=(new u.PlotLineOrBand(this,a)).render(),d=this.userOptions;c&&(b&&(d[b]=d[b]||[],d[b].push(a)),this.plotLinesAndBands.push(c));return c},removePlotBandOrLine:function(a){for(var b=this.plotLinesAndBands,c=this.options,d=this.userOptions,e=b.length;e--;)b[e].id===a&&b[e].destroy();q([c.plotLines||[],d.plotLines||[],c.plotBands||[],d.plotBands||[]],function(b){for(e=b.length;e--;)b[e].id===a&&ra(b,b[e])})}});ia.prototype.getTimeTicks=function(a,b,\nc,d){var e=[],f={},g=U.global.useUTC,h,i=new ma(b-$a(b)),j=a.unitRange,k=a.count;if(s(b)){i[Hb](j>=H.second?0:k*V(i.getMilliseconds()/k));if(j>=H.second)i[Ib](j>=H.minute?0:k*V(i.getSeconds()/k));if(j>=H.minute)i[Jb](j>=H.hour?0:k*V(i[wb]()/k));if(j>=H.hour)i[Kb](j>=H.day?0:k*V(i[xb]()/k));if(j>=H.day)i[mb](j>=H.month?1:k*V(i[Wa]()/k));j>=H.month&&(i[zb](j>=H.year?0:k*V(i[cb]()/k)),h=i[db]());j>=H.year&&(h-=h%k,i[Ab](h));if(j===H.week)i[mb](i[Wa]()-i[yb]()+p(d,1));b=1;if(tb||ab)i=i.getTime(),i=new ma(i+\n$a(i));h=i[db]();for(var d=i.getTime(),l=i[cb](),m=i[Wa](),n=!g||!!ab,o=(H.day+(g?$a(i):i.getTimezoneOffset()*6E4))%H.day;d<c;)e.push(d),j===H.year?d=lb(h+b*k,0):j===H.month?d=lb(h,l+b*k):n&&(j===H.day||j===H.week)?d=lb(h,l,m+b*k*(j===H.day?1:7)):d+=j*k,b++;e.push(d);q(Ca(e,function(a){return j<=H.hour&&a%H.day===o}),function(a){f[a]="day"})}e.info=x(a,{higherRanks:f,totalRange:j*k});return e};ia.prototype.normalizeTimeTickInterval=function(a,b){var c=b||[["millisecond",[1,2,5,10,20,25,50,100,200,\n500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,3,4,6]],["year",null]],d=c[c.length-1],e=H[d[0]],f=d[1],g;for(g=0;g<c.length;g++)if(d=c[g],e=H[d[0]],f=d[1],c[g+1]&&a<=(e*f[f.length-1]+H[c[g+1][0]])/2)break;e===H.year&&a<5*e&&(f=[1,2,5]);c=vb(a/e,f,d[0]==="year"?t(ub(a/e),1):1);return{unitRange:e,count:c,unitName:d[0]}};ia.prototype.getLogTickPositions=function(a,b,c,d){var e=this.options,f=this.len,g=this.lin2log,h=\nthis.log2lin,i=[];if(!d)this._minorAutoInterval=null;if(a>=0.5)a=C(a),i=this.getLinearTickPositions(a,b,c);else if(a>=0.08)for(var f=V(b),j,k,l,m,n,e=a>0.3?[1,2,4]:a>0.15?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];f<c+1&&!n;f++){k=e.length;for(j=0;j<k&&!n;j++)l=h(g(f)*e[j]),l>b&&(!d||m<=c)&&m!==A&&i.push(m),m>c&&(n=!0),m=l}else if(b=g(b),c=g(c),a=e[d?"minorTickInterval":"tickInterval"],a=p(a==="auto"?null:a,this._minorAutoInterval,(c-b)*(e.tickPixelInterval/(d?5:1))/((d?f/this.tickPositions.length:f)||1)),a=\nvb(a,null,ub(a)),i=Da(this.getLinearTickPositions(a,b,c),h),!d)this._minorAutoInterval=a/5;if(!d)this.tickInterval=a;return i};ia.prototype.log2lin=function(a){return Z.log(a)/Z.LN10};ia.prototype.lin2log=function(a){return Z.pow(10,a)};var Qb=u.Tooltip=function(){this.init.apply(this,arguments)};Qb.prototype={init:function(a,b){var c=b.borderWidth,d=b.style,e=B(d.padding);this.chart=a;this.options=b;this.crosshairs=[];this.now={x:0,y:0};this.isHidden=!0;this.label=a.renderer.label("",0,0,b.shape||\n"callout",null,null,b.useHTML,null,"tooltip").attr({padding:e,fill:b.backgroundColor,"stroke-width":c,r:b.borderRadius,zIndex:8}).css(d).css({padding:0}).add().attr({y:-9E9});la||this.label.shadow(b.shadow);this.shared=b.shared},destroy:function(){if(this.label)this.label=this.label.destroy();clearTimeout(this.hideTimer);clearTimeout(this.tooltipTimeout)},move:function(a,b,c,d){var e=this,f=e.now,g=e.options.animation!==!1&&!e.isHidden&&(Q(a-f.x)>1||Q(b-f.y)>1),h=e.followPointer||e.len>1;x(f,{x:g?\n(2*f.x+a)/3:a,y:g?(f.y+b)/2:b,anchorX:h?A:g?(2*f.anchorX+c)/3:c,anchorY:h?A:g?(f.anchorY+d)/2:d});e.label.attr(f);if(g)clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){e&&e.move(a,b,c,d)},32)},hide:function(a){var b=this;clearTimeout(this.hideTimer);a=p(a,this.options.hideDelay,500);if(!this.isHidden)this.hideTimer=Ra(function(){b.label[a?"fadeOut":"hide"]();b.isHidden=!0},a)},getAnchor:function(a,b){var c,d=this.chart,e=d.inverted,f=d.plotTop,g=d.plotLeft,h=0,i=0,j,k,a=\nua(a);c=a[0].tooltipPos;this.followPointer&&b&&(b.chartX===A&&(b=d.pointer.normalize(b)),c=[b.chartX-d.plotLeft,b.chartY-f]);c||(q(a,function(a){j=a.series.yAxis;k=a.series.xAxis;h+=a.plotX+(!e&&k?k.left-g:0);i+=(a.plotLow?(a.plotLow+a.plotHigh)/2:a.plotY)+(!e&&j?j.top-f:0)}),h/=a.length,i/=a.length,c=[e?d.plotWidth-i:h,this.shared&&!e&&a.length>1&&b?b.chartY-f:e?d.plotHeight-h:i]);return Da(c,C)},getPosition:function(a,b,c){var d=this.chart,e=this.distance,f={},g=c.h||0,h,i=["y",d.chartHeight,b,\nc.plotY+d.plotTop,d.plotTop,d.plotTop+d.plotHeight],j=["x",d.chartWidth,a,c.plotX+d.plotLeft,d.plotLeft,d.plotLeft+d.plotWidth],k=!this.followPointer&&p(c.ttBelow,!d.inverted===!!c.negative),l=function(a,b,c,d,h,i){var j=c<d-e,m=d+e+c<b,l=d-e-c;d+=e;if(k&&m)f[a]=d;else if(!k&&j)f[a]=l;else if(j)f[a]=F(i-c,l-g<0?l:l-g);else if(m)f[a]=t(h,d+g+c>b?d:d+g);else return!1},m=function(a,b,c,d){var g;d<e||d>b-e?g=!1:f[a]=d<c/2?1:d>b-c/2?b-c-2:d-c/2;return g},n=function(a){var b=i;i=j;j=b;h=a},o=function(){l.apply(0,\ni)!==!1?m.apply(0,j)===!1&&!h&&(n(!0),o()):h?f.x=f.y=0:(n(!0),o())};(d.inverted||this.len>1)&&n();o();return f},defaultFormatter:function(a){var b=this.points||ua(this),c;c=[a.tooltipFooterHeaderFormatter(b[0])];c=c.concat(a.bodyFormatter(b));c.push(a.tooltipFooterHeaderFormatter(b[0],!0));return c.join("")},refresh:function(a,b){var c=this.chart,d=this.label,e=this.options,f,g,h,i={},j,k=[];j=e.formatter||this.defaultFormatter;var i=c.hoverPoints,l,m=this.shared;clearTimeout(this.hideTimer);this.followPointer=\nua(a)[0].series.tooltipOptions.followPointer;h=this.getAnchor(a,b);f=h[0];g=h[1];m&&(!a.series||!a.series.noSharedTooltip)?(c.hoverPoints=a,i&&q(i,function(a){a.setState()}),q(a,function(a){a.setState("hover");k.push(a.getLabelConfig())}),i={x:a[0].category,y:a[0].y},i.points=k,this.len=k.length,a=a[0]):i=a.getLabelConfig();j=j.call(i,this);i=a.series;this.distance=p(i.tooltipOptions.distance,16);j===!1?this.hide():(this.isHidden&&(Ka(d),d.attr("opacity",1).show()),d.attr({text:j}),l=e.borderColor||\na.color||i.color||"#606060",d.attr({stroke:l}),this.updatePosition({plotX:f,plotY:g,negative:a.negative,ttBelow:a.ttBelow,h:h[2]||0}),this.isHidden=!1);I(c,"tooltipRefresh",{text:j,x:f+c.plotLeft,y:g+c.plotTop,borderColor:l})},updatePosition:function(a){var b=this.chart,c=this.label,c=(this.options.positioner||this.getPosition).call(this,c.width,c.height,a);this.move(C(c.x),C(c.y||0),a.plotX+b.plotLeft,a.plotY+b.plotTop)},getXDateFormat:function(a,b,c){var d,b=b.dateTimeLabelFormats,e=c&&c.closestPointRange,\nf,g={millisecond:15,second:12,minute:9,hour:6,day:3},h,i="millisecond";if(e){h=Sa("%m-%d %H:%M:%S.%L",a.x);for(f in H){if(e===H.week&&+Sa("%w",a.x)===c.options.startOfWeek&&h.substr(6)==="00:00:00.000"){f="week";break}if(H[f]>e){f=i;break}if(g[f]&&h.substr(g[f])!=="01-01 00:00:00.000".substr(g[f]))break;f!=="week"&&(i=f)}f&&(d=b[f])}else d=b.day;return d||b.year},tooltipFooterHeaderFormatter:function(a,b){var c=b?"footer":"header",d=a.series,e=d.tooltipOptions,f=e.xDateFormat,g=d.xAxis,h=g&&g.options.type===\n"datetime"&&J(a.key),c=e[c+"Format"];h&&!f&&(f=this.getXDateFormat(a,e,g));h&&f&&(c=c.replace("{point.key}","{point.key:"+f+"}"));return Na(c,{point:a,series:d})},bodyFormatter:function(a){return Da(a,function(a){var c=a.series.tooltipOptions;return(c.pointFormatter||a.point.tooltipFormatter).call(a.point,c.pointFormat)})}};var ja;fb=y&&y.documentElement.ontouchstart!==A;var Za=u.Pointer=function(a,b){this.init(a,b)};Za.prototype={init:function(a,b){var c=b.chart,d=c.events,e=la?"":c.zoomType,c=a.inverted,\nf;this.options=b;this.chart=a;this.zoomX=f=/x/.test(e);this.zoomY=e=/y/.test(e);this.zoomHor=f&&!c||e&&c;this.zoomVert=e&&!c||f&&c;this.hasZoom=f||e;this.runChartClick=d&&!!d.click;this.pinchDown=[];this.lastValidTouch={};if(u.Tooltip&&b.tooltip.enabled)a.tooltip=new Qb(a,b.tooltip),this.followTouchMove=p(b.tooltip.followTouchMove,!0);this.setDOMEvents()},normalize:function(a,b){var c,d,a=a||D.event;if(!a.target)a.target=a.srcElement;d=a.touches?a.touches.length?a.touches.item(0):a.changedTouches[0]:\na;if(!b)this.chartPosition=b=Cb(this.chart.container);d.pageX===A?(c=t(a.x,a.clientX-b.left),d=a.y):(c=d.pageX-b.left,d=d.pageY-b.top);return x(a,{chartX:C(c),chartY:C(d)})},getCoordinates:function(a){var b={xAxis:[],yAxis:[]};q(this.chart.axes,function(c){b[c.isXAxis?"xAxis":"yAxis"].push({axis:c,value:c.toValue(a[c.horiz?"chartX":"chartY"])})});return b},runPointActions:function(a){var b=this.chart,c=b.series,d=b.tooltip,e=d?d.shared:!1,f=b.hoverPoint,g=b.hoverSeries,h,i=[Number.MAX_VALUE,Number.MAX_VALUE],\nj,k,l=[],m=[],n;if(!e&&!g)for(h=0;h<c.length;h++)if(c[h].directTouch||!c[h].options.stickyTracking)c=[];g&&(e?g.noSharedTooltip:g.directTouch)&&f?m=[f]:(q(c,function(b){j=b.noSharedTooltip&&e;k=!e&&b.directTouch;b.visible&&!j&&!k&&p(b.options.enableMouseTracking,!0)&&(n=b.searchPoint(a,!j&&b.kdDimensions===1))&&n.series&&l.push(n)}),q(l,function(a){a&&q(["dist","distX"],function(b,c){if(J(a[b])){var d=a[b]===i[c]&&a.series.group.zIndex>=m[c].series.group.zIndex;if(a[b]<i[c]||d)i[c]=a[b],m[c]=a}})}));\nif(e)for(h=l.length;h--;)(l[h].clientX!==m[1].clientX||l[h].series.noSharedTooltip)&&l.splice(h,1);if(m[0]&&(m[0]!==this.prevKDPoint||d&&d.isHidden))if(e&&!m[0].series.noSharedTooltip)l.length&&d&&d.refresh(l,a),q(l,function(b){b.onMouseOver(a,b!==(g&&g.directTouch&&f||m[0]))}),this.prevKDPoint=m[1];else{d&&d.refresh(m[0],a);if(!g||!g.directTouch)m[0].onMouseOver(a);this.prevKDPoint=m[0]}else c=g&&g.tooltipOptions.followPointer,d&&c&&!d.isHidden&&(c=d.getAnchor([{}],a),d.updatePosition({plotX:c[0],\nplotY:c[1]}));if(!this._onDocumentMouseMove)this._onDocumentMouseMove=function(a){if(T[ja])T[ja].pointer.onDocumentMouseMove(a)},N(y,"mousemove",this._onDocumentMouseMove);q(e?l:[p(f,m[1])],function(c){q(b.axes,function(b){(!c||c.series[b.coll]===b)&&b.drawCrosshair(a,c)})})},reset:function(a,b){var c=this.chart,d=c.hoverSeries,e=c.hoverPoint,f=c.hoverPoints,g=c.tooltip,h=g&&g.shared?f:e;a&&h&&q(ua(h),function(b){b.series.isCartesian&&b.plotX===void 0&&(a=!1)});if(a)g&&h&&(g.refresh(h),e&&(e.setState(e.state,\n!0),q(c.axes,function(a){a.crosshair&&a.drawCrosshair(null,e)})));else{if(e)e.onMouseOut();f&&q(f,function(a){a.setState()});if(d)d.onMouseOut();g&&g.hide(b);if(this._onDocumentMouseMove)Y(y,"mousemove",this._onDocumentMouseMove),this._onDocumentMouseMove=null;q(c.axes,function(a){a.hideCrosshair()});this.hoverX=this.prevKDPoint=c.hoverPoints=c.hoverPoint=null}},scaleGroups:function(a,b){var c=this.chart,d;q(c.series,function(e){d=a||e.getPlotBox();e.xAxis&&e.xAxis.zoomEnabled&&(e.group.attr(d),e.markerGroup&&\n(e.markerGroup.attr(d),e.markerGroup.clip(b?c.clipRect:null)),e.dataLabelsGroup&&e.dataLabelsGroup.attr(d))});c.clipRect.attr(b||c.clipBox)},dragStart:function(a){var b=this.chart;b.mouseIsDown=a.type;b.cancelClick=!1;b.mouseDownX=this.mouseDownX=a.chartX;b.mouseDownY=this.mouseDownY=a.chartY},drag:function(a){var b=this.chart,c=b.options.chart,d=a.chartX,e=a.chartY,f=this.zoomHor,g=this.zoomVert,h=b.plotLeft,i=b.plotTop,j=b.plotWidth,k=b.plotHeight,l,m=this.selectionMarker,n=this.mouseDownX,o=this.mouseDownY,\np=c.panKey&&a[c.panKey+"Key"];if(!m||!m.touch)if(d<h?d=h:d>h+j&&(d=h+j),e<i?e=i:e>i+k&&(e=i+k),this.hasDragged=Math.sqrt(Math.pow(n-d,2)+Math.pow(o-e,2)),this.hasDragged>10){l=b.isInsidePlot(n-h,o-i);if(b.hasCartesianSeries&&(this.zoomX||this.zoomY)&&l&&!p&&!m)this.selectionMarker=m=b.renderer.rect(h,i,f?1:j,g?1:k,0).attr({fill:c.selectionMarkerFill||"rgba(69,114,167,0.25)",zIndex:7}).add();m&&f&&(d-=n,m.attr({width:Q(d),x:(d>0?0:d)+n}));m&&g&&(d=e-o,m.attr({height:Q(d),y:(d>0?0:d)+o}));l&&!m&&c.panning&&\nb.pan(a,c.panning)}},drop:function(a){var b=this,c=this.chart,d=this.hasPinched;if(this.selectionMarker){var e={originalEvent:a,xAxis:[],yAxis:[]},f=this.selectionMarker,g=f.attr?f.attr("x"):f.x,h=f.attr?f.attr("y"):f.y,i=f.attr?f.attr("width"):f.width,j=f.attr?f.attr("height"):f.height,k;if(this.hasDragged||d)q(c.axes,function(c){if(c.zoomEnabled&&s(c.min)&&(d||b[{xAxis:"zoomX",yAxis:"zoomY"}[c.coll]])){var f=c.horiz,n=a.type==="touchend"?c.minPixelPadding:0,o=c.toValue((f?g:h)+n),f=c.toValue((f?\ng+i:h+j)-n);e[c.coll].push({axis:c,min:F(o,f),max:t(o,f)});k=!0}}),k&&I(c,"selection",e,function(a){c.zoom(x(a,d?{animation:!1}:null))});this.selectionMarker=this.selectionMarker.destroy();d&&this.scaleGroups()}if(c)M(c.container,{cursor:c._cursor}),c.cancelClick=this.hasDragged>10,c.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=[]},onContainerMouseDown:function(a){a=this.normalize(a);a.preventDefault&&a.preventDefault();this.dragStart(a)},onDocumentMouseUp:function(a){T[ja]&&T[ja].pointer.drop(a)},\nonDocumentMouseMove:function(a){var b=this.chart,c=this.chartPosition,a=this.normalize(a,c);c&&!this.inClass(a.target,"highcharts-tracker")&&!b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop)&&this.reset()},onContainerMouseLeave:function(a){var b=T[ja];if(b&&(a.relatedTarget||a.toElement))b.pointer.reset(),b.pointer.chartPosition=null},onContainerMouseMove:function(a){var b=this.chart;if(!s(ja)||!T[ja]||!T[ja].mouseIsDown)ja=b.index;a=this.normalize(a);a.returnValue=!1;b.mouseIsDown==="mousedown"&&\nthis.drag(a);(this.inClass(a.target,"highcharts-tracker")||b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop))&&!b.openMenu&&this.runPointActions(a)},inClass:function(a,b){for(var c;a;){if(c=P(a,"class")){if(c.indexOf(b)!==-1)return!0;if(c.indexOf("highcharts-container")!==-1)return!1}a=a.parentNode}},onTrackerMouseOut:function(a){var b=this.chart.hoverSeries,a=a.relatedTarget||a.toElement;if(b&&a&&!b.options.stickyTracking&&!this.inClass(a,"highcharts-tooltip")&&!this.inClass(a,"highcharts-series-"+\nb.index))b.onMouseOut()},onContainerClick:function(a){var b=this.chart,c=b.hoverPoint,d=b.plotLeft,e=b.plotTop,a=this.normalize(a);b.cancelClick||(c&&this.inClass(a.target,"highcharts-tracker")?(I(c.series,"click",x(a,{point:c})),b.hoverPoint&&c.firePointEvent("click",a)):(x(a,this.getCoordinates(a)),b.isInsidePlot(a.chartX-d,a.chartY-e)&&I(b,"click",a)))},setDOMEvents:function(){var a=this,b=a.chart.container;b.onmousedown=function(b){a.onContainerMouseDown(b)};b.onmousemove=function(b){a.onContainerMouseMove(b)};\nb.onclick=function(b){a.onContainerClick(b)};N(b,"mouseleave",a.onContainerMouseLeave);gb===1&&N(y,"mouseup",a.onDocumentMouseUp);if(fb)b.ontouchstart=function(b){a.onContainerTouchStart(b)},b.ontouchmove=function(b){a.onContainerTouchMove(b)},gb===1&&N(y,"touchend",a.onDocumentTouchEnd)},destroy:function(){var a;Y(this.chart.container,"mouseleave",this.onContainerMouseLeave);gb||(Y(y,"mouseup",this.onDocumentMouseUp),Y(y,"touchend",this.onDocumentTouchEnd));clearInterval(this.tooltipTimeout);for(a in this)this[a]=\nnull}};x(u.Pointer.prototype,{pinchTranslate:function(a,b,c,d,e,f){(this.zoomHor||this.pinchHor)&&this.pinchTranslateDirection(!0,a,b,c,d,e,f);(this.zoomVert||this.pinchVert)&&this.pinchTranslateDirection(!1,a,b,c,d,e,f)},pinchTranslateDirection:function(a,b,c,d,e,f,g,h){var i=this.chart,j=a?"x":"y",k=a?"X":"Y",l="chart"+k,m=a?"width":"height",n=i["plot"+(a?"Left":"Top")],o,p,r=h||1,q=i.inverted,w=i.bounds[a?"h":"v"],v=b.length===1,s=b[0][l],t=c[0][l],x=!v&&b[1][l],u=!v&&c[1][l],C,c=function(){!v&&\nQ(s-x)>20&&(r=h||Q(t-u)/Q(s-x));p=(n-t)/r+s;o=i["plot"+(a?"Width":"Height")]/r};c();b=p;b<w.min?(b=w.min,C=!0):b+o>w.max&&(b=w.max-o,C=!0);C?(t-=0.8*(t-g[j][0]),v||(u-=0.8*(u-g[j][1])),c()):g[j]=[t,u];q||(f[j]=p-n,f[m]=o);f=q?1/r:r;e[m]=o;e[j]=b;d[q?a?"scaleY":"scaleX":"scale"+k]=r;d["translate"+k]=f*n+(t-f*s)},pinch:function(a){var b=this,c=b.chart,d=b.pinchDown,e=a.touches,f=e.length,g=b.lastValidTouch,h=b.hasZoom,i=b.selectionMarker,j={},k=f===1&&(b.inClass(a.target,"highcharts-tracker")&&c.runTrackerClick||\nb.runChartClick),l={};if(f>1)b.initiated=!0;h&&b.initiated&&!k&&a.preventDefault();Da(e,function(a){return b.normalize(a)});if(a.type==="touchstart")q(e,function(a,b){d[b]={chartX:a.chartX,chartY:a.chartY}}),g.x=[d[0].chartX,d[1]&&d[1].chartX],g.y=[d[0].chartY,d[1]&&d[1].chartY],q(c.axes,function(a){if(a.zoomEnabled){var b=c.bounds[a.horiz?"h":"v"],d=a.minPixelPadding,e=a.toPixels(p(a.options.min,a.dataMin)),f=a.toPixels(p(a.options.max,a.dataMax)),g=F(e,f),e=t(e,f);b.min=F(a.pos,g-d);b.max=t(a.pos+\na.len,e+d)}}),b.res=!0;else if(d.length){if(!i)b.selectionMarker=i=x({destroy:Ba,touch:!0},c.plotBox);b.pinchTranslate(d,e,j,i,l,g);b.hasPinched=h;b.scaleGroups(j,l);if(!h&&b.followTouchMove&&f===1)this.runPointActions(b.normalize(a));else if(b.res)b.res=!1,this.reset(!1,0)}},touch:function(a,b){var c=this.chart,d;ja=c.index;if(a.touches.length===1)if(a=this.normalize(a),c.isInsidePlot(a.chartX-c.plotLeft,a.chartY-c.plotTop)&&!c.openMenu){b&&this.runPointActions(a);if(a.type==="touchmove")c=this.pinchDown,\nd=c[0]?Math.sqrt(Math.pow(c[0].chartX-a.chartX,2)+Math.pow(c[0].chartY-a.chartY,2))>=4:!1;p(d,!0)&&this.pinch(a)}else b&&this.reset();else a.touches.length===2&&this.pinch(a)},onContainerTouchStart:function(a){this.touch(a,!0)},onContainerTouchMove:function(a){this.touch(a)},onDocumentTouchEnd:function(a){T[ja]&&T[ja].pointer.drop(a)}});if(D.PointerEvent||D.MSPointerEvent){var wa={},Eb=!!D.PointerEvent,Tb=function(){var a,b=[];b.item=function(a){return this[a]};for(a in wa)wa.hasOwnProperty(a)&&b.push({pageX:wa[a].pageX,\npageY:wa[a].pageY,target:wa[a].target});return b},Fb=function(a,b,c,d){if((a.pointerType==="touch"||a.pointerType===a.MSPOINTER_TYPE_TOUCH)&&T[ja])d(a),d=T[ja].pointer,d[b]({type:c,target:a.currentTarget,preventDefault:Ba,touches:Tb()})};x(Za.prototype,{onContainerPointerDown:function(a){Fb(a,"onContainerTouchStart","touchstart",function(a){wa[a.pointerId]={pageX:a.pageX,pageY:a.pageY,target:a.currentTarget}})},onContainerPointerMove:function(a){Fb(a,"onContainerTouchMove","touchmove",function(a){wa[a.pointerId]=\n{pageX:a.pageX,pageY:a.pageY};if(!wa[a.pointerId].target)wa[a.pointerId].target=a.currentTarget})},onDocumentPointerUp:function(a){Fb(a,"onDocumentTouchEnd","touchend",function(a){delete wa[a.pointerId]})},batchMSEvents:function(a){a(this.chart.container,Eb?"pointerdown":"MSPointerDown",this.onContainerPointerDown);a(this.chart.container,Eb?"pointermove":"MSPointerMove",this.onContainerPointerMove);a(y,Eb?"pointerup":"MSPointerUp",this.onDocumentPointerUp)}});hb(Za.prototype,"init",function(a,b,c){a.call(this,\nb,c);this.hasZoom&&M(b.container,{"-ms-touch-action":"none","touch-action":"none"})});hb(Za.prototype,"setDOMEvents",function(a){a.apply(this);(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(N)});hb(Za.prototype,"destroy",function(a){this.batchMSEvents(Y);a.call(this)})}var rb=u.Legend=function(a,b){this.init(a,b)};rb.prototype={init:function(a,b){var c=this,d=b.itemStyle,e=b.itemMarginTop||0;this.options=b;if(b.enabled)c.itemStyle=d,c.itemHiddenStyle=E(d,b.itemHiddenStyle),c.itemMarginTop=\ne,c.padding=d=p(b.padding,8),c.initialItemX=d,c.initialItemY=d-5,c.maxItemWidth=0,c.chart=a,c.itemHeight=0,c.symbolWidth=p(b.symbolWidth,16),c.pages=[],c.render(),N(c.chart,"endResize",function(){c.positionCheckboxes()})},colorizeItem:function(a,b){var c=this.options,d=a.legendItem,e=a.legendLine,f=a.legendSymbol,g=this.itemHiddenStyle.color,c=b?c.itemStyle.color:g,h=b?a.legendColor||a.color||"#CCC":g,g=a.options&&a.options.marker,i={fill:h},j;d&&d.css({fill:c,color:c});e&&e.attr({stroke:h});if(f){if(g&&\nf.isMarker)for(j in i.stroke=h,g=a.convertAttribs(g),g)d=g[j],d!==A&&(i[j]=d);f.attr(i)}},positionItem:function(a){var b=this.options,c=b.symbolPadding,b=!b.rtl,d=a._legendItemPos,e=d[0],d=d[1],f=a.checkbox;(a=a.legendGroup)&&a.element&&a.translate(b?e:this.legendWidth-e-2*c-4,d);if(f)f.x=e,f.y=d},destroyItem:function(a){var b=a.checkbox;q(["legendItem","legendLine","legendSymbol","legendGroup"],function(b){a[b]&&(a[b]=a[b].destroy())});b&&Ua(a.checkbox)},destroy:function(){var a=this.group,b=this.box;\nif(b)this.box=b.destroy();if(a)this.group=a.destroy()},positionCheckboxes:function(a){var b=this.group.alignAttr,c,d=this.clipHeight||this.legendHeight,e=this.titleHeight;if(b)c=b.translateY,q(this.allItems,function(f){var g=f.checkbox,h;g&&(h=c+e+g.y+(a||0)+3,M(g,{left:b.translateX+f.checkboxOffset+g.x-20+"px",top:h+"px",display:h>c-6&&h<c+d-6?"":"none"}))})},renderTitle:function(){var a=this.padding,b=this.options.title,c=0;if(b.text){if(!this.title)this.title=this.chart.renderer.label(b.text,a-\n3,a-4,null,null,null,null,null,"legend-title").attr({zIndex:1}).css(b.style).add(this.group);a=this.title.getBBox();c=a.height;this.offsetWidth=a.width;this.contentGroup.attr({translateY:c})}this.titleHeight=c},setText:function(a){var b=this.options;a.legendItem.attr({text:b.labelFormat?Na(b.labelFormat,a):b.labelFormatter.call(a)})},renderItem:function(a){var b=this.chart,c=b.renderer,d=this.options,e=d.layout==="horizontal",f=this.symbolWidth,g=d.symbolPadding,h=this.itemStyle,i=this.itemHiddenStyle,\nj=this.padding,k=e?p(d.itemDistance,20):0,l=!d.rtl,m=d.width,n=d.itemMarginBottom||0,o=this.itemMarginTop,z=this.initialItemX,r=a.legendItem,q=a.series&&a.series.drawLegendSymbol?a.series:a,w=q.options,w=this.createCheckboxForItem&&w&&w.showCheckbox,v=d.useHTML;if(!r){a.legendGroup=c.g("legend-item").attr({zIndex:1}).add(this.scrollGroup);a.legendItem=r=c.text("",l?f+g:-g,this.baseline||0,v).css(E(a.visible?h:i)).attr({align:l?"left":"right",zIndex:2}).add(a.legendGroup);if(!this.baseline)this.fontMetrics=\nc.fontMetrics(h.fontSize,r),this.baseline=this.fontMetrics.f+3+o,r.attr("y",this.baseline);q.drawLegendSymbol(this,a);this.setItemEvents&&this.setItemEvents(a,r,v,h,i);w&&this.createCheckboxForItem(a)}this.colorizeItem(a,a.visible);this.setText(a);c=r.getBBox();f=a.checkboxOffset=d.itemWidth||a.legendItemWidth||f+g+c.width+k+(w?20:0);this.itemHeight=g=C(a.legendItemHeight||c.height);if(e&&this.itemX-z+f>(m||b.chartWidth-2*j-z-d.x))this.itemX=z,this.itemY+=o+this.lastLineHeight+n,this.lastLineHeight=\n0;this.maxItemWidth=t(this.maxItemWidth,f);this.lastItemY=o+this.itemY+n;this.lastLineHeight=t(g,this.lastLineHeight);a._legendItemPos=[this.itemX,this.itemY];e?this.itemX+=f:(this.itemY+=o+g+n,this.lastLineHeight=g);this.offsetWidth=m||t((e?this.itemX-z-k:f)+j,this.offsetWidth)},getAllItems:function(){var a=[];q(this.chart.series,function(b){var c=b.options;if(p(c.showInLegend,!s(c.linkedTo)?A:!1,!0))a=a.concat(b.legendItems||(c.legendType==="point"?b.data:b))});return a},adjustMargins:function(a,\nb){var c=this.chart,d=this.options,e=d.align.charAt(0)+d.verticalAlign.charAt(0)+d.layout.charAt(0);d.floating||q([/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/],function(f,g){f.test(e)&&!s(a[g])&&(c[pb[g]]=t(c[pb[g]],c.legend[(g+1)%2?"legendHeight":"legendWidth"]+[1,-1,-1,1][g]*d[g%2?"x":"y"]+p(d.margin,12)+b[g]))})},render:function(){var a=this,b=a.chart,c=b.renderer,d=a.group,e,f,g,h,i=a.box,j=a.options,k=a.padding,l=j.borderWidth,m=j.backgroundColor;a.itemX=a.initialItemX;a.itemY=\na.initialItemY;a.offsetWidth=0;a.lastItemY=0;if(!d)a.group=d=c.g("legend").attr({zIndex:7}).add(),a.contentGroup=c.g().attr({zIndex:1}).add(d),a.scrollGroup=c.g().add(a.contentGroup);a.renderTitle();e=a.getAllItems();jb(e,function(a,b){return(a.options&&a.options.legendIndex||0)-(b.options&&b.options.legendIndex||0)});j.reversed&&e.reverse();a.allItems=e;a.display=f=!!e.length;a.lastLineHeight=0;q(e,function(b){a.renderItem(b)});g=(j.width||a.offsetWidth)+k;h=a.lastItemY+a.lastLineHeight+a.titleHeight;\nh=a.handleOverflow(h);h+=k;if(l||m){if(i){if(g>0&&h>0)i[i.isNew?"attr":"animate"](i.crisp({width:g,height:h})),i.isNew=!1}else a.box=i=c.rect(0,0,g,h,j.borderRadius,l||0).attr({stroke:j.borderColor,"stroke-width":l||0,fill:m||"none"}).add(d).shadow(j.shadow),i.isNew=!0;i[f?"show":"hide"]()}a.legendWidth=g;a.legendHeight=h;q(e,function(b){a.positionItem(b)});f&&d.align(x({width:g,height:h},j),!0,"spacingBox");b.isResizing||this.positionCheckboxes()},handleOverflow:function(a){var b=this,c=this.chart,\nd=c.renderer,e=this.options,f=e.y,f=c.spacingBox.height+(e.verticalAlign==="top"?-f:f)-this.padding,g=e.maxHeight,h,i=this.clipRect,j=e.navigation,k=p(j.animation,!0),l=j.arrowSize||12,m=this.nav,n=this.pages,o=this.padding,z,r=this.allItems,s=function(a){i.attr({height:a});if(b.contentGroup.div)b.contentGroup.div.style.clip="rect("+o+"px,9999px,"+(o+a)+"px,0)"};e.layout==="horizontal"&&(f/=2);g&&(f=F(f,g));n.length=0;if(a>f&&j.enabled!==!1){this.clipHeight=h=t(f-20-this.titleHeight-o,0);this.currentPage=\np(this.currentPage,1);this.fullHeight=a;q(r,function(a,b){var c=a._legendItemPos[1],d=C(a.legendItem.getBBox().height),e=n.length;if(!e||c-n[e-1]>h&&(z||c)!==n[e-1])n.push(z||c),e++;b===r.length-1&&c+d-n[e-1]>h&&n.push(c);c!==z&&(z=c)});if(!i)i=b.clipRect=d.clipRect(0,o,9999,0),b.contentGroup.clip(i);s(h);if(!m)this.nav=m=d.g().attr({zIndex:1}).add(this.group),this.up=d.symbol("triangle",0,0,l,l).on("click",function(){b.scroll(-1,k)}).add(m),this.pager=d.text("",15,10).css(j.style).add(m),this.down=\nd.symbol("triangle-down",0,0,l,l).on("click",function(){b.scroll(1,k)}).add(m);b.scroll(0);a=f}else if(m)s(c.chartHeight),m.hide(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0;return a},scroll:function(a,b){var c=this.pages,d=c.length,e=this.currentPage+a,f=this.clipHeight,g=this.options.navigation,h=g.activeColor,g=g.inactiveColor,i=this.pager,j=this.padding;e>d&&(e=d);if(e>0)b!==A&&Va(b,this.chart),this.nav.attr({translateX:j,translateY:f+this.padding+7+this.titleHeight,visibility:"visible"}),\nthis.up.attr({fill:e===1?g:h}).css({cursor:e===1?"default":"pointer"}),i.attr({text:e+"/"+d}),this.down.attr({x:18+this.pager.getBBox().width,fill:e===d?g:h}).css({cursor:e===d?"default":"pointer"}),c=-c[e-1]+this.initialItemY,this.scrollGroup.animate({translateY:c}),this.currentPage=e,this.positionCheckboxes(c)}};K=u.LegendSymbolMixin={drawRectangle:function(a,b){var c=a.options.symbolHeight||a.fontMetrics.f;b.legendSymbol=this.chart.renderer.rect(0,a.baseline-c+1,a.symbolWidth,c,a.options.symbolRadius||\n0).attr({zIndex:3}).add(b.legendGroup)},drawLineMarker:function(a){var b=this.options,c=b.marker,d=a.symbolWidth,e=this.chart.renderer,f=this.legendGroup,a=a.baseline-C(a.fontMetrics.b*0.3),g;if(b.lineWidth){g={"stroke-width":b.lineWidth};if(b.dashStyle)g.dashstyle=b.dashStyle;this.legendLine=e.path([X,0,a,S,d,a]).attr(g).add(f)}if(c&&c.enabled!==!1)b=c.radius,this.legendSymbol=c=e.symbol(this.symbol,d/2-b,a-b,2*b,2*b,c).add(f),c.isMarker=!0}};(/Trident\\/7\\.0/.test(Aa)||Qa)&&hb(rb.prototype,"positionItem",\nfunction(a,b){var c=this,d=function(){b._legendItemPos&&a.call(c,b)};d();setTimeout(d)});var ib=u.Chart=function(){this.getArgs.apply(this,arguments)};u.chart=function(a,b,c){return new ib(a,b,c)};ib.prototype={callbacks:[],getArgs:function(){var a=[].slice.call(arguments);if(ya(a[0])||a[0].nodeName)this.renderTo=a.shift();this.init(a[0],a[1])},init:function(a,b){var c,d=a.series;a.series=null;c=E(U,a);c.series=a.series=d;this.userOptions=a;d=c.chart;this.margin=this.splashArray("margin",d);this.spacing=\nthis.splashArray("spacing",d);var e=d.events;this.bounds={h:{},v:{}};this.callback=b;this.isResizing=0;this.options=c;this.axes=[];this.series=[];this.hasCartesianSeries=d.showAxes;var f=this,g;f.index=T.length;T.push(f);gb++;d.reflow!==!1&&N(f,"load",function(){f.initReflow()});if(e)for(g in e)N(f,g,e[g]);f.xAxis=[];f.yAxis=[];f.animation=la?!1:p(d.animation,!0);f.pointCount=f.colorCounter=f.symbolCounter=0;f.firstRender()},initSeries:function(a){var b=this.options.chart;(b=L[a.type||b.type||b.defaultSeriesType])||\nca(17,!0);b=new b;b.init(this,a);return b},isInsidePlot:function(a,b,c){var d=c?b:a,a=c?a:b;return d>=0&&d<=this.plotWidth&&a>=0&&a<=this.plotHeight},redraw:function(a){var b=this.axes,c=this.series,d=this.pointer,e=this.legend,f=this.isDirtyLegend,g,h,i=this.hasCartesianSeries,j=this.isDirtyBox,k=c.length,l=k,m=this.renderer,n=m.isHidden(),o=[];Va(a,this);n&&this.cloneRenderTo();for(this.layOutTitles();l--;)if(a=c[l],a.options.stacking&&(g=!0,a.isDirty)){h=!0;break}if(h)for(l=k;l--;)if(a=c[l],a.options.stacking)a.isDirty=\n!0;q(c,function(a){a.isDirty&&a.options.legendType==="point"&&(a.updateTotals&&a.updateTotals(),f=!0);a.isDirtyData&&I(a,"updatedData")});if(f&&e.options.enabled)e.render(),this.isDirtyLegend=!1;g&&this.getStacks();if(i&&!this.isResizing)this.maxTicks=null,q(b,function(a){a.setScale()});this.getMargins();i&&(q(b,function(a){a.isDirty&&(j=!0)}),q(b,function(a){var b=a.min+","+a.max;if(a.extKey!==b)a.extKey=b,o.push(function(){I(a,"afterSetExtremes",x(a.eventArgs,a.getExtremes()));delete a.eventArgs});\n(j||g)&&a.redraw()}));j&&this.drawChartBox();q(c,function(a){a.isDirty&&a.visible&&(!a.isCartesian||a.xAxis)&&a.redraw()});d&&d.reset(!0);m.draw();I(this,"redraw");n&&this.cloneRenderTo(!0);q(o,function(a){a.call()})},get:function(a){var b=this.axes,c=this.series,d,e;for(d=0;d<b.length;d++)if(b[d].options.id===a)return b[d];for(d=0;d<c.length;d++)if(c[d].options.id===a)return c[d];for(d=0;d<c.length;d++){e=c[d].points||[];for(b=0;b<e.length;b++)if(e[b].id===a)return e[b]}return null},getAxes:function(){var a=\nthis,b=this.options,c=b.xAxis=ua(b.xAxis||{}),b=b.yAxis=ua(b.yAxis||{});q(c,function(a,b){a.index=b;a.isX=!0});q(b,function(a,b){a.index=b});c=c.concat(b);q(c,function(b){new ia(a,b)})},getSelectedPoints:function(){var a=[];q(this.series,function(b){a=a.concat(Ca(b.points||[],function(a){return a.selected}))});return a},getSelectedSeries:function(){return Ca(this.series,function(a){return a.selected})},setTitle:function(a,b,c){var g;var d=this,e=d.options,f;f=e.title=E(e.title,a);g=e.subtitle=E(e.subtitle,\nb),e=g;q([["title",a,f],["subtitle",b,e]],function(a){var b=a[0],c=d[b],e=a[1],a=a[2];c&&e&&(d[b]=c=c.destroy());a&&a.text&&!c&&(d[b]=d.renderer.text(a.text,0,0,a.useHTML).attr({align:a.align,"class":"highcharts-"+b,zIndex:a.zIndex||4}).css(a.style).add())});d.layOutTitles(c)},layOutTitles:function(a){var b=0,c=this.title,d=this.subtitle,e=this.options,f=e.title,e=e.subtitle,g=this.renderer,h=this.spacingBox;if(c&&(c.css({width:(f.width||h.width+f.widthAdjust)+"px"}).align(x({y:g.fontMetrics(f.style.fontSize,\nc).b-3},f),!1,h),!f.floating&&!f.verticalAlign))b=c.getBBox().height;d&&(d.css({width:(e.width||h.width+e.widthAdjust)+"px"}).align(x({y:b+(f.margin-13)+g.fontMetrics(e.style.fontSize,c).b},e),!1,h),!e.floating&&!e.verticalAlign&&(b=va(b+d.getBBox().height)));c=this.titleOffset!==b;this.titleOffset=b;if(!this.isDirtyBox&&c)this.isDirtyBox=c,this.hasRendered&&p(a,!0)&&this.isDirtyBox&&this.redraw()},getChartSize:function(){var a=this.options.chart,b=a.width,a=a.height,c=this.renderToClone||this.renderTo;\nif(!s(b))this.containerWidth=oa(c,"width");if(!s(a))this.containerHeight=oa(c,"height");this.chartWidth=t(0,b||this.containerWidth||600);this.chartHeight=t(0,p(a,this.containerHeight>19?this.containerHeight:400))},cloneRenderTo:function(a){var b=this.renderToClone,c=this.container;a?b&&(this.renderTo.appendChild(c),Ua(b),delete this.renderToClone):(c&&c.parentNode===this.renderTo&&this.renderTo.removeChild(c),this.renderToClone=b=this.renderTo.cloneNode(0),M(b,{position:"absolute",top:"-9999px",display:"block"}),\nb.style.setProperty&&b.style.setProperty("display","block","important"),y.body.appendChild(b),c&&b.appendChild(c))},getContainer:function(){var a,b=this.options,c=b.chart,d,e;a=this.renderTo;var f="highcharts-"+Bb++;if(!a)this.renderTo=a=c.renderTo;if(ya(a))this.renderTo=a=y.getElementById(a);a||ca(13,!0);d=B(P(a,"data-highcharts-chart"));J(d)&&T[d]&&T[d].hasRendered&&T[d].destroy();P(a,"data-highcharts-chart",this.index);a.innerHTML="";!c.skipClone&&!a.offsetWidth&&this.cloneRenderTo();this.getChartSize();\nd=this.chartWidth;e=this.chartHeight;this.container=a=da(Pa,{className:"highcharts-container"+(c.className?" "+c.className:""),id:f},x({position:"relative",overflow:"hidden",width:d+"px",height:e+"px",textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)"},c.style),this.renderToClone||a);this._cursor=a.style.cursor;this.renderer=new (u[c.renderer]||eb)(a,d,e,c.style,c.forExport,b.exporting&&b.exporting.allowHTML);la&&this.renderer.create(this,a,d,e);this.renderer.chartIndex=\nthis.index},getMargins:function(a){var b=this.spacing,c=this.margin,d=this.titleOffset;this.resetMargins();if(d&&!s(c[0]))this.plotTop=t(this.plotTop,d+this.options.title.margin+b[0]);this.legend.display&&this.legend.adjustMargins(c,b);this.extraBottomMargin&&(this.marginBottom+=this.extraBottomMargin);this.extraTopMargin&&(this.plotTop+=this.extraTopMargin);a||this.getAxisMargins()},getAxisMargins:function(){var a=this,b=a.axisOffset=[0,0,0,0],c=a.margin;a.hasCartesianSeries&&q(a.axes,function(a){a.visible&&\na.getOffset()});q(pb,function(d,e){s(c[e])||(a[d]+=b[e])});a.setChartSize()},reflow:function(a){var b=this,c=b.options.chart,d=b.renderTo,e=s(c.width),f=c.width||oa(d,"width"),c=c.height||oa(d,"height"),d=a?a.target:D;if(!e&&!b.isPrinting&&f&&c&&(d===D||d===y)){if(f!==b.containerWidth||c!==b.containerHeight)clearTimeout(b.reflowTimeout),b.reflowTimeout=Ra(function(){b.container&&b.setSize(void 0,void 0,!1)},a?100:0);b.containerWidth=f;b.containerHeight=c}},initReflow:function(){var a=this,b=function(b){a.reflow(b)};\nN(D,"resize",b);N(a,"destroy",function(){Y(D,"resize",b)})},setSize:function(a,b,c){var d=this,e=d.renderer;d.isResizing+=1;Va(c,d);d.oldChartHeight=d.chartHeight;d.oldChartWidth=d.chartWidth;if(a!==void 0)d.options.chart.width=a;if(b!==void 0)d.options.chart.height=b;d.getChartSize();a=e.globalAnimation;(a?Ya:M)(d.container,{width:d.chartWidth+"px",height:d.chartHeight+"px"},a);d.setChartSize(!0);e.setSize(d.chartWidth,d.chartHeight,c);d.maxTicks=null;q(d.axes,function(a){a.isDirty=!0;a.setScale()});\nq(d.series,function(a){a.isDirty=!0});d.isDirtyLegend=!0;d.isDirtyBox=!0;d.layOutTitles();d.getMargins();d.redraw(c);d.oldChartHeight=null;I(d,"resize");Ra(function(){d&&I(d,"endResize",null,function(){d.isResizing-=1})},bb(a).duration)},setChartSize:function(a){var b=this.inverted,c=this.renderer,d=this.chartWidth,e=this.chartHeight,f=this.options.chart,g=this.spacing,h=this.clipOffset,i,j,k,l;this.plotLeft=i=C(this.plotLeft);this.plotTop=j=C(this.plotTop);this.plotWidth=k=t(0,C(d-i-this.marginRight));\nthis.plotHeight=l=t(0,C(e-j-this.marginBottom));this.plotSizeX=b?l:k;this.plotSizeY=b?k:l;this.plotBorderWidth=f.plotBorderWidth||0;this.spacingBox=c.spacingBox={x:g[3],y:g[0],width:d-g[3]-g[1],height:e-g[0]-g[2]};this.plotBox=c.plotBox={x:i,y:j,width:k,height:l};d=2*V(this.plotBorderWidth/2);b=va(t(d,h[3])/2);c=va(t(d,h[0])/2);this.clipBox={x:b,y:c,width:V(this.plotSizeX-t(d,h[1])/2-b),height:t(0,V(this.plotSizeY-t(d,h[2])/2-c))};a||q(this.axes,function(a){a.setAxisSize();a.setAxisTranslation()})},\nresetMargins:function(){var a=this;q(pb,function(b,c){a[b]=p(a.margin[c],a.spacing[c])});a.axisOffset=[0,0,0,0];a.clipOffset=[0,0,0,0]},drawChartBox:function(){var a=this.options.chart,b=this.renderer,c=this.chartWidth,d=this.chartHeight,e=this.chartBackground,f=this.plotBackground,g=this.plotBorder,h=this.plotBGImage,i=a.borderWidth||0,j=a.backgroundColor,k=a.plotBackgroundColor,l=a.plotBackgroundImage,m=a.plotBorderWidth||0,n,o=this.plotLeft,p=this.plotTop,r=this.plotWidth,q=this.plotHeight,w=this.plotBox,\nv=this.clipRect,s=this.clipBox;n=i+(a.shadow?8:0);if(i||j)if(e)e.animate(e.crisp({width:c-n,height:d-n}));else{e={fill:j||"none"};if(i)e.stroke=a.borderColor,e["stroke-width"]=i;this.chartBackground=b.rect(n/2,n/2,c-n,d-n,a.borderRadius,i).attr(e).addClass("highcharts-background").add().shadow(a.shadow)}if(k)f?f.animate(w):this.plotBackground=b.rect(o,p,r,q,0).attr({fill:k}).add().shadow(a.plotShadow);if(l)h?h.animate(w):this.plotBGImage=b.image(l,o,p,r,q).add();v?v.animate({width:s.width,height:s.height}):\nthis.clipRect=b.clipRect(s);if(m)g?(g.strokeWidth=-m,g.animate(g.crisp({x:o,y:p,width:r,height:q}))):this.plotBorder=b.rect(o,p,r,q,0,-m).attr({stroke:a.plotBorderColor,"stroke-width":m,fill:"none",zIndex:1}).add();this.isDirtyBox=!1},propFromSeries:function(){var a=this,b=a.options.chart,c,d=a.options.series,e,f;q(["inverted","angular","polar"],function(g){c=L[b.type||b.defaultSeriesType];f=a[g]||b[g]||c&&c.prototype[g];for(e=d&&d.length;!f&&e--;)(c=L[d[e].type])&&c.prototype[g]&&(f=!0);a[g]=f})},\nlinkSeries:function(){var a=this,b=a.series;q(b,function(a){a.linkedSeries.length=0});q(b,function(b){var d=b.options.linkedTo;if(ya(d)&&(d=d===":previous"?a.series[b.index-1]:a.get(d)))d.linkedSeries.push(b),b.linkedParent=d,b.visible=p(b.options.visible,d.options.visible,b.visible)})},renderSeries:function(){q(this.series,function(a){a.translate();a.render()})},renderLabels:function(){var a=this,b=a.options.labels;b.items&&q(b.items,function(c){var d=x(b.style,c.style),e=B(d.left)+a.plotLeft,f=\nB(d.top)+a.plotTop+12;delete d.left;delete d.top;a.renderer.text(c.html,e,f).attr({zIndex:2}).css(d).add()})},render:function(){var a=this.axes,b=this.renderer,c=this.options,d,e,f,g;this.setTitle();this.legend=new rb(this,c.legend);this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();d=this.plotWidth;e=this.plotHeight-=21;q(a,function(a){a.setScale()});this.getAxisMargins();f=d/this.plotWidth>1.1;g=e/this.plotHeight>1.05;if(f||g)this.maxTicks=null,q(a,function(a){(a.horiz&&f||\n!a.horiz&&g)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries&&q(a,function(a){a.visible&&a.render()});if(!this.seriesGroup)this.seriesGroup=b.g("series-group").attr({zIndex:3}).add();this.renderSeries();this.renderLabels();this.showCredits(c.credits);this.hasRendered=!0},showCredits:function(a){if(a.enabled&&!this.credits)this.credits=this.renderer.text(a.text,0,0).on("click",function(){if(a.href)D.location.href=a.href}).attr({align:a.position.align,zIndex:8}).css(a.style).add().align(a.position)},\ndestroy:function(){var a=this,b=a.axes,c=a.series,d=a.container,e,f=d&&d.parentNode;I(a,"destroy");T[a.index]=A;gb--;a.renderTo.removeAttribute("data-highcharts-chart");Y(a);for(e=b.length;e--;)b[e]=b[e].destroy();for(e=c.length;e--;)c[e]=c[e].destroy();q("title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,pointer,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer".split(","),function(b){var c=a[b];c&&c.destroy&&(a[b]=c.destroy())});if(d)d.innerHTML=\n"",Y(d),f&&Ua(d);for(e in a)delete a[e]},isReadyToRender:function(){var a=this;return!ga&&D==D.top&&y.readyState!=="complete"||la&&!D.canvg?(la?Pb.push(function(){a.firstRender()},a.options.global.canvasToolsURL):y.attachEvent("onreadystatechange",function(){y.detachEvent("onreadystatechange",a.firstRender);y.readyState==="complete"&&a.firstRender()}),!1):!0},firstRender:function(){var a=this,b=a.options;if(a.isReadyToRender()){a.getContainer();I(a,"init");a.resetMargins();a.setChartSize();a.propFromSeries();\na.getAxes();q(b.series||[],function(b){a.initSeries(b)});a.linkSeries();I(a,"beforeRender");if(u.Pointer)a.pointer=new Za(a,b);a.render();a.renderer.draw();if(!a.renderer.imgCount&&a.onload)a.onload();a.cloneRenderTo(!0)}},onload:function(){var a=this;q([this.callback].concat(this.callbacks),function(b){b&&a.index!==void 0&&b.apply(a,[a])});I(a,"load");this.onload=null},splashArray:function(a,b){var c=b[a],c=$(c)?c:[c,c,c,c];return[p(b[a+"Top"],c[0]),p(b[a+"Right"],c[1]),p(b[a+"Bottom"],c[2]),p(b[a+\n"Left"],c[3])]}};var Db=u.CenteredSeriesMixin={getCenter:function(){var a=this.options,b=this.chart,c=2*(a.slicedOffset||0),d=b.plotWidth-2*c,b=b.plotHeight-2*c,e=a.center,e=[p(e[0],"50%"),p(e[1],"50%"),a.size||"100%",a.innerSize||0],f=F(d,b),g,h;for(g=0;g<4;++g)h=e[g],a=g<2||g===2&&/%$/.test(h),e[g]=(/%$/.test(h)?[d,b,f,e[2]][g]*parseFloat(h)/100:parseFloat(h))+(a?c:0);e[3]>e[2]&&(e[3]=e[2]);return e}},Ma=function(){};Ma.prototype={init:function(a,b,c){this.series=a;this.color=a.color;this.applyOptions(b,\nc);this.pointAttr={};if(a.options.colorByPoint&&(b=a.options.colors||a.chart.options.colors,this.color=this.color||b[a.colorCounter++],a.colorCounter===b.length))a.colorCounter=0;a.chart.pointCount++;return this},applyOptions:function(a,b){var c=this.series,d=c.options.pointValKey||c.pointValKey,a=Ma.prototype.optionsToObject.call(this,a);x(this,a);this.options=this.options?x(this.options,a):a;if(d)this.y=this[d];this.isNull=this.x===null||!J(this.y,!0);if(this.x===void 0&&c)this.x=b===void 0?c.autoIncrement(this):\nb;if(c.xAxis&&c.xAxis.names)c.xAxis.names[this.x]=this.name;return this},optionsToObject:function(a){var b={},c=this.series,d=c.options.keys,e=d||c.pointArrayMap||["y"],f=e.length,g=0,h=0;if(J(a)||a===null)b[e[0]]=a;else if(Fa(a)){if(!d&&a.length>f){c=typeof a[0];if(c==="string")b.name=a[0];else if(c==="number")b.x=a[0];g++}for(;h<f;){if(!d||a[g]!==void 0)b[e[h]]=a[g];g++;h++}}else if(typeof a==="object"){b=a;if(a.dataLabels)c._hasPointLabels=!0;if(a.marker)c._hasPointMarkers=!0}return b},destroy:function(){var a=\nthis.series.chart,b=a.hoverPoints,c;a.pointCount--;if(b&&(this.setState(),ra(b,this),!b.length))a.hoverPoints=null;if(this===a.hoverPoint)this.onMouseOut();if(this.graphic||this.dataLabel)Y(this),this.destroyElements();this.legendItem&&a.legend.destroyItem(this);for(c in this)this[c]=null},destroyElements:function(){for(var a=["graphic","dataLabel","dataLabelUpper","connector","shadowGroup"],b,c=6;c--;)b=a[c],this[b]&&(this[b]=this[b].destroy())},getLabelConfig:function(){return{x:this.category,y:this.y,\ncolor:this.color,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}},tooltipFormatter:function(a){var b=this.series,c=b.tooltipOptions,d=p(c.valueDecimals,""),e=c.valuePrefix||"",f=c.valueSuffix||"";q(b.pointArrayMap||["y"],function(b){b="{point."+b;if(e||f)a=a.replace(b+"}",e+b+"}"+f);a=a.replace(b+"}",b+":,."+d+"f}")});return Na(a,{point:this,series:this.series})},firePointEvent:function(a,b,c){var d=this,e=this.series.options;\n(e.point.events[a]||d.options&&d.options.events&&d.options.events[a])&&this.importEvents();a==="click"&&e.allowPointSelect&&(c=function(a){d.select&&d.select(null,a.ctrlKey||a.metaKey||a.shiftKey)});I(this,a,b,c)},visible:!0};var R=u.Series=function(){};R.prototype={isCartesian:!0,type:"line",pointClass:Ma,sorted:!0,requireSorting:!0,pointAttrToOptions:{stroke:"lineColor","stroke-width":"lineWidth",fill:"fillColor",r:"radius"},directTouch:!1,axisTypes:["xAxis","yAxis"],colorCounter:0,parallelArrays:["x",\n"y"],init:function(a,b){var c=this,d,e,f=a.series,g=function(a,b){return p(a.options.index,a._i)-p(b.options.index,b._i)};c.chart=a;c.options=b=c.setOptions(b);c.linkedSeries=[];c.bindAxes();x(c,{name:b.name,state:"",pointAttr:{},visible:b.visible!==!1,selected:b.selected===!0});if(la)b.animation=!1;e=b.events;for(d in e)N(c,d,e[d]);if(e&&e.click||b.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=!0;c.getColor();c.getSymbol();q(c.parallelArrays,function(a){c[a+"Data"]=\n[]});c.setData(b.data,!1);if(c.isCartesian)a.hasCartesianSeries=!0;f.push(c);c._i=f.length-1;jb(f,g);this.yAxis&&jb(this.yAxis.series,g);q(f,function(a,b){a.index=b;a.name=a.name||"Series "+(b+1)})},bindAxes:function(){var a=this,b=a.options,c=a.chart,d;q(a.axisTypes||[],function(e){q(c[e],function(c){d=c.options;if(b[e]===d.index||b[e]!==A&&b[e]===d.id||b[e]===A&&d.index===0)c.series.push(a),a[e]=c,c.isDirty=!0});!a[e]&&a.optionalAxis!==e&&ca(18,!0)})},updateParallelArrays:function(a,b){var c=a.series,\nd=arguments,e=J(b)?function(d){var e=d==="y"&&c.toYData?c.toYData(a):a[d];c[d+"Data"][b]=e}:function(a){Array.prototype[b].apply(c[a+"Data"],Array.prototype.slice.call(d,2))};q(c.parallelArrays,e)},autoIncrement:function(a){var g;var b=this.options,c=this.xIncrement,d=b.pointIntervalUnit,e=this.xAxis,f,c=p(c,b.pointStart,0);this.pointInterval=b=p(this.pointInterval,b.pointInterval,1);if(e&&e.categories&&a.name)if(this.requireSorting=!1,g=(f=Fa(e.categories))?e.categories:e.names,e=g,a=pa(a.name,e),\na===-1){if(!f)c=e.length}else c=a;d&&(a=new ma(c),d==="day"?a=+a[mb](a[Wa]()+b):d==="month"?a=+a[zb](a[cb]()+b):d==="year"&&(a=+a[Ab](a[db]()+b)),b=a-c);this.xIncrement=c+b;return c},setOptions:function(a){var b=this.chart,c=b.options.plotOptions,b=b.userOptions||{},d=b.plotOptions||{},e=c[this.type];this.userOptions=a;c=E(e,c.series,a);this.tooltipOptions=E(U.tooltip,U.plotOptions[this.type].tooltip,b.tooltip,d.series&&d.series.tooltip,d[this.type]&&d[this.type].tooltip,a.tooltip);e.marker===null&&\ndelete c.marker;this.zoneAxis=c.zoneAxis;a=this.zones=(c.zones||[]).slice();if((c.negativeColor||c.negativeFillColor)&&!c.zones)a.push({value:c[this.zoneAxis+"Threshold"]||c.threshold||0,color:c.negativeColor,fillColor:c.negativeFillColor});a.length&&s(a[a.length-1].value)&&a.push({color:this.color,fillColor:this.fillColor});return c},getCyclic:function(a,b,c){var d=this.userOptions,e="_"+a+"Index",f=a+"Counter";b||(s(d[e])?b=d[e]:(d[e]=b=this.chart[f]%c.length,this.chart[f]+=1),b=c[b]);this[a]=b},\ngetColor:function(){this.options.colorByPoint?this.options.color=null:this.getCyclic("color",this.options.color||fa[this.type].color,this.chart.options.colors)},getSymbol:function(){var a=this.options.marker;this.getCyclic("symbol",a.symbol,this.chart.options.symbols);if(/^url/.test(this.symbol))a.radius=0},drawLegendSymbol:K.drawLineMarker,setData:function(a,b,c,d){var e=this,f=e.points,g=f&&f.length||0,h,i=e.options,j=e.chart,k=null,l=e.xAxis,m=i.turboThreshold,n=this.xData,o=this.yData,z=(h=e.pointArrayMap)&&\nh.length,a=a||[];h=a.length;b=p(b,!0);if(d!==!1&&h&&g===h&&!e.cropped&&!e.hasGroupedData&&e.visible)q(a,function(a,b){f[b].update&&a!==i.data[b]&&f[b].update(a,!1,null,!1)});else{e.xIncrement=null;e.colorCounter=0;q(this.parallelArrays,function(a){e[a+"Data"].length=0});if(m&&h>m){for(c=0;k===null&&c<h;)k=a[c],c++;if(J(k)){k=p(i.pointStart,0);z=p(i.pointInterval,1);for(c=0;c<h;c++)n[c]=k,o[c]=a[c],k+=z;e.xIncrement=k}else if(Fa(k))if(z)for(c=0;c<h;c++)k=a[c],n[c]=k[0],o[c]=k.slice(1,z+1);else for(c=\n0;c<h;c++)k=a[c],n[c]=k[0],o[c]=k[1];else ca(12)}else for(c=0;c<h;c++)a[c]!==A&&(k={series:e},e.pointClass.prototype.applyOptions.apply(k,[a[c]]),e.updateParallelArrays(k,c));ya(o[0])&&ca(14,!0);e.data=[];e.options.data=e.userOptions.data=a;for(c=g;c--;)f[c]&&f[c].destroy&&f[c].destroy();if(l)l.minRange=l.userMinRange;e.isDirty=e.isDirtyData=j.isDirtyBox=!0;c=!1}i.legendType==="point"&&(this.processData(),this.generatePoints());b&&j.redraw(c)},processData:function(a){var b=this.xData,c=this.yData,\nd=b.length,e;e=0;var f,g,h=this.xAxis,i,j=this.options;i=j.cropThreshold;var k=this.getExtremesFromAll||j.getExtremesFromAll,l=this.isCartesian,j=h&&h.val2lin,m=h&&h.isLog,n,o;if(l&&!this.isDirty&&!h.isDirty&&!this.yAxis.isDirty&&!a)return!1;if(h)a=h.getExtremes(),n=a.min,o=a.max;if(l&&this.sorted&&!k&&(!i||d>i||this.forceCrop))if(b[d-1]<n||b[0]>o)b=[],c=[];else if(b[0]<n||b[d-1]>o)e=this.cropData(this.xData,this.yData,n,o),b=e.xData,c=e.yData,e=e.start,f=!0;for(i=b.length||1;--i;)d=m?j(b[i])-j(b[i-\n1]):b[i]-b[i-1],d>0&&(g===A||d<g)?g=d:d<0&&this.requireSorting&&ca(15);this.cropped=f;this.cropStart=e;this.processedXData=b;this.processedYData=c;this.closestPointRange=g},cropData:function(a,b,c,d){var e=a.length,f=0,g=e,h=p(this.cropShoulder,1),i;for(i=0;i<e;i++)if(a[i]>=c){f=t(0,i-h);break}for(c=i;c<e;c++)if(a[c]>d){g=c+h;break}return{xData:a.slice(f,g),yData:b.slice(f,g),start:f,end:g}},generatePoints:function(){var a=this.options.data,b=this.data,c,d=this.processedXData,e=this.processedYData,\nf=this.pointClass,g=d.length,h=this.cropStart||0,i,j=this.hasGroupedData,k,l=[],m;if(!b&&!j)b=[],b.length=a.length,b=this.data=b;for(m=0;m<g;m++)i=h+m,j?(l[m]=(new f).init(this,[d[m]].concat(ua(e[m]))),l[m].dataGroup=this.groupMap[m]):(b[i]?k=b[i]:a[i]!==A&&(b[i]=k=(new f).init(this,a[i],d[m])),l[m]=k),l[m].index=i;if(b&&(g!==(c=b.length)||j))for(m=0;m<c;m++)if(m===h&&!j&&(m+=g),b[m])b[m].destroyElements(),b[m].plotX=A;this.data=b;this.points=l},getExtremes:function(a){var b=this.yAxis,c=this.processedXData,\nd,e=[],f=0;d=this.xAxis.getExtremes();var g=d.min,h=d.max,i,j,k,l,a=a||this.stackedYData||this.processedYData||[];d=a.length;for(l=0;l<d;l++)if(j=c[l],k=a[l],i=k!==null&&k!==A&&(!b.isLog||k.length||k>0),j=this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||(c[l+1]||j)>=g&&(c[l-1]||j)<=h,i&&j)if(i=k.length)for(;i--;)k[i]!==null&&(e[f++]=k[i]);else e[f++]=k;this.dataMin=Oa(e);this.dataMax=Ha(e)},translate:function(){this.processedXData||this.processData();this.generatePoints();for(var a=\nthis.options,b=a.stacking,c=this.xAxis,d=c.categories,e=this.yAxis,f=this.points,g=f.length,h=!!this.modifyValue,i=a.pointPlacement,j=i==="between"||J(i),k=a.threshold,l=a.startFromThreshold?k:0,m,n,o,q,r=Number.MAX_VALUE,a=0;a<g;a++){var G=f[a],w=G.x,v=G.y;n=G.low;var x=b&&e.stacks[(this.negStacks&&v<(l?0:k)?"-":"")+this.stackKey],u;if(e.isLog&&v!==null&&v<=0)G.y=v=null,ca(10);G.plotX=m=aa(F(t(-1E5,c.translate(w,0,0,0,1,i,this.type==="flags")),1E5));if(b&&this.visible&&!G.isNull&&x&&x[w])q=this.getStackIndicator(q,\nw,this.index),u=x[w],v=u.points[q.key],n=v[0],v=v[1],n===l&&q.key===x[w].base&&(n=p(k,e.min)),e.isLog&&n<=0&&(n=null),G.total=G.stackTotal=u.total,G.percentage=u.total&&G.y/u.total*100,G.stackY=v,u.setOffset(this.pointXOffset||0,this.barW||0);G.yBottom=s(n)?e.translate(n,0,1,0,1):null;h&&(v=this.modifyValue(v,G));G.plotY=n=typeof v==="number"&&v!==Infinity?F(t(-1E5,e.translate(v,0,1,0,1)),1E5):A;G.isInside=n!==A&&n>=0&&n<=e.len&&m>=0&&m<=c.len;G.clientX=j?aa(c.translate(w,0,0,0,1)):m;G.negative=G.y<\n(k||0);G.category=d&&d[G.x]!==A?d[G.x]:G.x;G.isNull||(o!==void 0&&(r=F(r,Q(m-o))),o=m)}this.closestPointRangePx=r},getValidPoints:function(a,b){var c=this.chart;return Ca(a||this.points||[],function(a){return b&&!c.isInsidePlot(a.plotX,a.plotY,c.inverted)?!1:!a.isNull})},setClip:function(a){var b=this.chart,c=this.options,d=b.renderer,e=b.inverted,f=this.clipBox,g=f||b.clipBox,h=this.sharedClipKey||["_sharedClip",a&&a.duration,a&&a.easing,g.height,c.xAxis,c.yAxis].join(","),i=b[h],j=b[h+"m"];if(!i){if(a)g.width=\n0,b[h+"m"]=j=d.clipRect(-99,e?-b.plotLeft:-b.plotTop,99,e?b.chartWidth:b.chartHeight);b[h]=i=d.clipRect(g);i.count={length:0}}a&&!i.count[this.index]&&(i.count[this.index]=!0,i.count.length+=1);if(c.clip!==!1)this.group.clip(a||f?i:b.clipRect),this.markerGroup.clip(j),this.sharedClipKey=h;a||(i.count[this.index]&&(delete i.count[this.index],i.count.length-=1),i.count.length===0&&h&&b[h]&&(f||(b[h]=b[h].destroy()),b[h+"m"]&&(b[h+"m"]=b[h+"m"].destroy())))},animate:function(a){var b=this.chart,c=this.options.animation,\nd;if(c&&!$(c))c=fa[this.type].animation;a?this.setClip(c):(d=this.sharedClipKey,(a=b[d])&&a.animate({width:b.plotSizeX},c),b[d+"m"]&&b[d+"m"].animate({width:b.plotSizeX+99},c),this.animate=null)},afterAnimate:function(){this.setClip();I(this,"afterAnimate")},drawPoints:function(){var a,b=this.points,c=this.chart,d,e,f,g,h,i,j,k,l=this.options.marker,m=this.pointAttr[""],n,o,q,r=this.markerGroup,s=p(l.enabled,this.xAxis.isRadial,this.closestPointRangePx>2*l.radius);if(l.enabled!==!1||this._hasPointMarkers)for(f=\nb.length;f--;)if(g=b[f],d=V(g.plotX),e=g.plotY,k=g.graphic,n=g.marker||{},o=!!g.marker,a=s&&n.enabled===A||n.enabled,q=g.isInside,a&&J(e)&&g.y!==null)if(a=g.pointAttr[g.selected?"select":""]||m,h=a.r,i=p(n.symbol,this.symbol),j=i.indexOf("url")===0,k)k[q?"show":"hide"](!0).attr(a).animate(x({x:d-h,y:e-h},k.symbolName?{width:2*h,height:2*h}:{}));else{if(q&&(h>0||j))g.graphic=c.renderer.symbol(i,d-h,e-h,2*h,2*h,o?n:l).attr(a).add(r)}else if(k)g.graphic=k.destroy()},convertAttribs:function(a,b,c,d){var e=\nthis.pointAttrToOptions,f,g,h={},a=a||{},b=b||{},c=c||{},d=d||{};for(f in e)g=e[f],h[f]=p(a[g],b[f],c[f],d[f]);return h},getAttribs:function(){var a=this,b=a.options,c=fa[a.type].marker?b.marker:b,d=c.states,e=d.hover,f,g=a.color,h=a.options.negativeColor,i={stroke:g,fill:g},j=a.points||[],k,l=[],m,n=a.pointAttrToOptions;f=a.hasPointSpecificOptions;var o=c.lineColor,z=c.fillColor;k=b.turboThreshold;var r=a.zones,t=a.zoneAxis||"y",w,v;b.marker?(e.radius=+e.radius||+c.radius+ +e.radiusPlus,e.lineWidth=\ne.lineWidth||c.lineWidth+e.lineWidthPlus):(e.color=e.color||na(e.color||g).brighten(e.brightness).get(),e.negativeColor=e.negativeColor||na(e.negativeColor||h).brighten(e.brightness).get());l[""]=a.convertAttribs(c,i);q(["hover","select"],function(b){l[b]=a.convertAttribs(d[b],l[""])});a.pointAttr=l;g=j.length;if(!k||g<k||f)for(;g--;){k=j[g];if((c=k.options&&k.options.marker||k.options)&&c.enabled===!1)c.radius=0;i=null;if(r.length){f=0;for(i=r[f];k[t]>=i.value;)i=r[++f];k.color=k.fillColor=i=p(i.color,\na.color)}f=b.colorByPoint||k.color;if(k.options)for(v in n)s(c[n[v]])&&(f=!0);if(f){c=c||{};m=[];d=c.states||{};f=d.hover=d.hover||{};if(!b.marker||k.negative&&!f.fillColor&&!e.fillColor)f[a.pointAttrToOptions.fill]=f.color||!k.options.color&&e[k.negative&&h?"negativeColor":"color"]||na(k.color).brighten(f.brightness||e.brightness).get();w={color:k.color};if(!z)w.fillColor=k.color;if(!o)w.lineColor=k.color;c.hasOwnProperty("color")&&!c.color&&delete c.color;if(i&&!e.fillColor)f.fillColor=i;m[""]=\na.convertAttribs(x(w,c),l[""]);m.hover=a.convertAttribs(d.hover,l.hover,m[""]);m.select=a.convertAttribs(d.select,l.select,m[""])}else m=l;k.pointAttr=m}},destroy:function(){var a=this,b=a.chart,c=/AppleWebKit\\/533/.test(Aa),d,e=a.data||[],f,g,h;I(a,"destroy");Y(a);q(a.axisTypes||[],function(b){if(h=a[b])ra(h.series,a),h.isDirty=h.forceRedraw=!0});a.legendItem&&a.chart.legend.destroyItem(a);for(d=e.length;d--;)(f=e[d])&&f.destroy&&f.destroy();a.points=null;clearTimeout(a.animationTimeout);for(g in a)a[g]instanceof\nO&&!a[g].survive&&(d=c&&g==="group"?"hide":"destroy",a[g][d]());if(b.hoverSeries===a)b.hoverSeries=null;ra(b.series,a);for(g in a)delete a[g]},getGraphPath:function(a,b,c){var d=this,e=d.options,f=e.step,g,h=[],i=[],j,a=a||d.points;(g=a.reversed)&&a.reverse();(f={right:1,center:2}[f]||f&&3)&&g&&(f=4-f);e.connectNulls&&!b&&!c&&(a=this.getValidPoints(a));q(a,function(g,l){var m=g.plotX,n=g.plotY,o=a[l-1];if((g.leftCliff||o&&o.rightCliff)&&!c)j=!0;g.isNull&&!s(b)&&l>0?j=!e.connectNulls:g.isNull&&!b?\nj=!0:(l===0||j?o=[X,g.plotX,g.plotY]:d.getPointSpline?o=d.getPointSpline(a,g,l):f?(o=f===1?[S,o.plotX,n]:f===2?[S,(o.plotX+m)/2,o.plotY,S,(o.plotX+m)/2,n]:[S,m,o.plotY],o.push(S,m,n)):o=[S,m,n],i.push(g.x),f&&i.push(g.x),h.push.apply(h,o),j=!1)});h.xMap=i;return d.graphPath=h},drawGraph:function(){var a=this,b=this.options,c=[["graph",b.lineColor||this.color,b.dashStyle]],d=b.lineWidth,e=b.linecap!=="square",f=(this.gappedPath||this.getGraphPath).call(this);q(this.zones,function(d,e){c.push(["zoneGraph"+\ne,d.color||a.color,d.dashStyle||b.dashStyle])});q(c,function(c,h){var i=c[0],j=a[i];if(j)j.endX=f.xMap,j.animate({d:f});else if(d&&f.length)j={stroke:c[1],"stroke-width":d,fill:"none",zIndex:1},c[2]?j.dashstyle=c[2]:e&&(j["stroke-linecap"]=j["stroke-linejoin"]="round"),j=a[i]=a.chart.renderer.path(f).attr(j).add(a.group).shadow(h<2&&b.shadow);if(j)j.startX=f.xMap,j.isArea=f.isArea})},applyZones:function(){var a=this,b=this.chart,c=b.renderer,d=this.zones,e,f,g=this.clips||[],h,i=this.graph,j=this.area,\nk=t(b.chartWidth,b.chartHeight),l=this[(this.zoneAxis||"y")+"Axis"],m,n=l.reversed,o=b.inverted,z=l.horiz,r,s,w,v=!1;if(d.length&&(i||j)&&l.min!==A)i&&i.hide(),j&&j.hide(),m=l.getExtremes(),q(d,function(d,q){e=n?z?b.plotWidth:0:z?0:l.toPixels(m.min);e=F(t(p(f,e),0),k);f=F(t(C(l.toPixels(p(d.value,m.max),!0)),0),k);v&&(e=f=l.toPixels(m.max));r=Math.abs(e-f);s=F(e,f);w=t(e,f);if(l.isXAxis){if(h={x:o?w:s,y:0,width:r,height:k},!z)h.x=b.plotHeight-h.x}else if(h={x:0,y:o?w:s,width:k,height:r},z)h.y=b.plotWidth-\nh.y;b.inverted&&c.isVML&&(h=l.isXAxis?{x:0,y:n?s:w,height:h.width,width:b.chartWidth}:{x:h.y-b.plotLeft-b.spacingBox.x,y:0,width:h.height,height:b.chartHeight});g[q]?g[q].animate(h):(g[q]=c.clipRect(h),i&&a["zoneGraph"+q].clip(g[q]),j&&a["zoneArea"+q].clip(g[q]));v=d.value>m.max}),this.clips=g},invertGroups:function(){function a(){var a={width:b.yAxis.len,height:b.xAxis.len};q(["group","markerGroup"],function(c){b[c]&&b[c].attr(a).invert()})}var b=this,c=b.chart;if(b.xAxis)N(c,"resize",a),N(b,"destroy",\nfunction(){Y(c,"resize",a)}),a(),b.invertGroups=a},plotGroup:function(a,b,c,d,e){var f=this[a],g=!f;g&&(this[a]=f=this.chart.renderer.g(b).attr({zIndex:d||0.1}).add(e),f.addClass("highcharts-series-"+this.index));f.attr({visibility:c})[g?"attr":"animate"](this.getPlotBox());return f},getPlotBox:function(){var a=this.chart,b=this.xAxis,c=this.yAxis;if(a.inverted)b=c,c=this.xAxis;return{translateX:b?b.left:a.plotLeft,translateY:c?c.top:a.plotTop,scaleX:1,scaleY:1}},render:function(){var a=this,b=a.chart,\nc,d=a.options,e=!!a.animate&&b.renderer.isSVG&&bb(d.animation).duration,f=a.visible?"inherit":"hidden",g=d.zIndex,h=a.hasRendered,i=b.seriesGroup;c=a.plotGroup("group","series",f,g,i);a.markerGroup=a.plotGroup("markerGroup","markers",f,g,i);e&&a.animate(!0);a.getAttribs();c.inverted=a.isCartesian?b.inverted:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());q(a.points,function(a){a.redraw&&a.redraw()});a.drawDataLabels&&a.drawDataLabels();a.visible&&a.drawPoints();a.drawTracker&&a.options.enableMouseTracking!==\n!1&&a.drawTracker();b.inverted&&a.invertGroups();d.clip!==!1&&!a.sharedClipKey&&!h&&c.clip(b.clipRect);e&&a.animate();if(!h)a.animationTimeout=Ra(function(){a.afterAnimate()},e);a.isDirty=a.isDirtyData=!1;a.hasRendered=!0},redraw:function(){var a=this.chart,b=this.isDirty||this.isDirtyData,c=this.group,d=this.xAxis,e=this.yAxis;c&&(a.inverted&&c.attr({width:a.plotWidth,height:a.plotHeight}),c.animate({translateX:p(d&&d.left,a.plotLeft),translateY:p(e&&e.top,a.plotTop)}));this.translate();this.render();\nb&&delete this.kdTree},kdDimensions:1,kdAxisArray:["clientX","plotY"],searchPoint:function(a,b){var c=this.xAxis,d=this.yAxis,e=this.chart.inverted;return this.searchKDTree({clientX:e?c.len-a.chartY+c.pos:a.chartX-c.pos,plotY:e?d.len-a.chartX+d.pos:a.chartY-d.pos},b)},buildKDTree:function(){function a(c,e,f){var g,h;if(h=c&&c.length)return g=b.kdAxisArray[e%f],c.sort(function(a,b){return a[g]-b[g]}),h=Math.floor(h/2),{point:c[h],left:a(c.slice(0,h),e+1,f),right:a(c.slice(h+1),e+1,f)}}var b=this,c=\nb.kdDimensions;delete b.kdTree;Ra(function(){b.kdTree=a(b.getValidPoints(null,!b.directTouch),c,c)},b.options.kdNow?0:1)},searchKDTree:function(a,b){function c(a,b,j,k){var l=b.point,m=d.kdAxisArray[j%k],n,o,p=l;o=s(a[e])&&s(l[e])?Math.pow(a[e]-l[e],2):null;n=s(a[f])&&s(l[f])?Math.pow(a[f]-l[f],2):null;n=(o||0)+(n||0);l.dist=s(n)?Math.sqrt(n):Number.MAX_VALUE;l.distX=s(o)?Math.sqrt(o):Number.MAX_VALUE;m=a[m]-l[m];n=m<0?"left":"right";o=m<0?"right":"left";b[n]&&(n=c(a,b[n],j+1,k),p=n[g]<p[g]?n:l);\nb[o]&&Math.sqrt(m*m)<p[g]&&(a=c(a,b[o],j+1,k),p=a[g]<p[g]?a:p);return p}var d=this,e=this.kdAxisArray[0],f=this.kdAxisArray[1],g=b?"distX":"dist";this.kdTree||this.buildKDTree();if(this.kdTree)return c(a,this.kdTree,this.kdDimensions,this.kdDimensions)}};Lb.prototype={destroy:function(){Ta(this,this.axis)},render:function(a){var b=this.options,c=b.format,c=c?Na(c,this):b.formatter.call(this);this.label?this.label.attr({text:c,visibility:"hidden"}):this.label=this.axis.chart.renderer.text(c,null,null,\nb.useHTML).css(b.style).attr({align:this.textAlign,rotation:b.rotation,visibility:"hidden"}).add(a)},setOffset:function(a,b){var c=this.axis,d=c.chart,e=d.inverted,f=c.reversed,f=this.isNegative&&!f||!this.isNegative&&f,g=c.translate(c.usePercentage?100:this.total,0,0,0,1),c=c.translate(0),c=Q(g-c),h=d.xAxis[0].translate(this.x)+a,i=d.plotHeight,f={x:e?f?g:g-c:h,y:e?i-h-b:f?i-g-c:i-g,width:e?c:b,height:e?b:c};if(e=this.label)e.align(this.alignOptions,null,f),f=e.alignAttr,e[this.options.crop===!1||\nd.isInsidePlot(f.x,f.y)?"show":"hide"](!0)}};ib.prototype.getStacks=function(){var a=this;q(a.yAxis,function(a){if(a.stacks&&a.hasVisibleSeries)a.oldStacks=a.stacks});q(a.series,function(b){if(b.options.stacking&&(b.visible===!0||a.options.chart.ignoreHiddenSeries===!1))b.stackKey=b.type+p(b.options.stack,"")})};ia.prototype.buildStacks=function(){var a=this.series,b,c=p(this.options.reversedStacks,!0),d=a.length,e;if(!this.isXAxis){this.usePercentage=!1;for(e=d;e--;)a[c?e:d-e-1].setStackedPoints();\nfor(e=d;e--;)b=a[c?e:d-e-1],b.setStackCliffs&&b.setStackCliffs();if(this.usePercentage)for(e=0;e<d;e++)a[e].setPercentStacks()}};ia.prototype.renderStackTotals=function(){var a=this.chart,b=a.renderer,c=this.stacks,d,e,f=this.stackTotalGroup;if(!f)this.stackTotalGroup=f=b.g("stack-labels").attr({visibility:"visible",zIndex:6}).add();f.translate(a.plotLeft,a.plotTop);for(d in c)for(e in a=c[d],a)a[e].render(f)};ia.prototype.resetStacks=function(){var a=this.stacks,b,c;if(!this.isXAxis)for(b in a)for(c in a[b])a[b][c].touched<\nthis.stacksTouched?(a[b][c].destroy(),delete a[b][c]):(a[b][c].total=null,a[b][c].cum=0)};ia.prototype.cleanStacks=function(){var a,b,c;if(!this.isXAxis){if(this.oldStacks)a=this.stacks=this.oldStacks;for(b in a)for(c in a[b])a[b][c].cum=a[b][c].total}};R.prototype.setStackedPoints=function(){if(this.options.stacking&&!(this.visible!==!0&&this.chart.options.chart.ignoreHiddenSeries!==!1)){var a=this.processedXData,b=this.processedYData,c=[],d=b.length,e=this.options,f=e.threshold,g=e.startFromThreshold?\nf:0,h=e.stack,e=e.stacking,i=this.stackKey,j="-"+i,k=this.negStacks,l=this.yAxis,m=l.stacks,n=l.oldStacks,o,q,r,x,w,v,u;l.stacksTouched+=1;for(w=0;w<d;w++){v=a[w];u=b[w];o=this.getStackIndicator(o,v,this.index);x=o.key;r=(q=k&&u<(g?0:f))?j:i;m[r]||(m[r]={});if(!m[r][v])n[r]&&n[r][v]?(m[r][v]=n[r][v],m[r][v].total=null):m[r][v]=new Lb(l,l.options.stackLabels,q,v,h);r=m[r][v];if(u!==null){r.points[x]=r.points[this.index]=[p(r.cum,g)];if(!s(r.cum))r.base=x;r.touched=l.stacksTouched;o.index>0&&this.singleStacks===\n!1&&(r.points[x][0]=r.points[this.index+","+v+",0"][0])}e==="percent"?(q=q?i:j,k&&m[q]&&m[q][v]?(q=m[q][v],r.total=q.total=t(q.total,r.total)+Q(u)||0):r.total=aa(r.total+(Q(u)||0))):r.total=aa(r.total+(u||0));r.cum=p(r.cum,g)+(u||0);if(u!==null)r.points[x].push(r.cum),c[w]=r.cum}if(e==="percent")l.usePercentage=!0;this.stackedYData=c;l.oldStacks={}}};R.prototype.setPercentStacks=function(){var a=this,b=a.stackKey,c=a.yAxis.stacks,d=a.processedXData,e;q([b,"-"+b],function(b){var f;for(var g=d.length,\nh,i;g--;)if(h=d[g],e=a.getStackIndicator(e,h,a.index),f=(i=c[b]&&c[b][h])&&i.points[e.key],h=f)i=i.total?100/i.total:0,h[0]=aa(h[0]*i),h[1]=aa(h[1]*i),a.stackedYData[g]=h[1]})};R.prototype.getStackIndicator=function(a,b,c){!s(a)||a.x!==b?a={x:b,index:0}:a.index++;a.key=[c,b,a.index].join(",");return a};x(ib.prototype,{addSeries:function(a,b,c){var d,e=this;a&&(b=p(b,!0),I(e,"addSeries",{options:a},function(){d=e.initSeries(a);e.isDirtyLegend=!0;e.linkSeries();b&&e.redraw(c)}));return d},addAxis:function(a,\nb,c,d){var e=b?"xAxis":"yAxis",f=this.options,a=E(a,{index:this[e].length,isX:b});new ia(this,a);f[e]=ua(f[e]||{});f[e].push(a);p(c,!0)&&this.redraw(d)},showLoading:function(a){var b=this,c=b.options,d=b.loadingDiv,e=c.loading,f=function(){d&&M(d,{left:b.plotLeft+"px",top:b.plotTop+"px",width:b.plotWidth+"px",height:b.plotHeight+"px"})};if(!d)b.loadingDiv=d=da(Pa,{className:"highcharts-loading"},x(e.style,{zIndex:10,display:"none"}),b.container),b.loadingSpan=da("span",null,e.labelStyle,d),N(b,"redraw",\nf);b.loadingSpan.innerHTML=a||c.lang.loading;if(!b.loadingShown)M(d,{opacity:0,display:""}),Ya(d,{opacity:e.style.opacity},{duration:e.showDuration||0}),b.loadingShown=!0;f()},hideLoading:function(){var a=this.options,b=this.loadingDiv;b&&Ya(b,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){M(b,{display:"none"})}});this.loadingShown=!1}});x(Ma.prototype,{update:function(a,b,c,d){function e(){f.applyOptions(a);if(f.y===null&&h)f.graphic=h.destroy();if($(a,!0))f.redraw=function(){if(h&&\nh.element&&a&&a.marker&&a.marker.symbol)f.graphic=h.destroy();if(a&&a.dataLabels&&f.dataLabel)f.dataLabel=f.dataLabel.destroy();f.redraw=null};i=f.index;g.updateParallelArrays(f,i);if(l&&f.name)l[f.x]=f.name;k.data[i]=$(k.data[i],!0)?f.options:a;g.isDirty=g.isDirtyData=!0;if(!g.fixedBox&&g.hasCartesianSeries)j.isDirtyBox=!0;if(k.legendType==="point")j.isDirtyLegend=!0;b&&j.redraw(c)}var f=this,g=f.series,h=f.graphic,i,j=g.chart,k=g.options,l=g.xAxis&&g.xAxis.names,b=p(b,!0);d===!1?e():f.firePointEvent("update",\n{options:a},e)},remove:function(a,b){this.series.removePoint(pa(this,this.series.data),a,b)}});x(R.prototype,{addPoint:function(a,b,c,d){var e=this.options,f=this.data,g=this.chart,h=this.xAxis&&this.xAxis.names,i=e.data,j,k=this.xData,l,m;Va(d,g);b=p(b,!0);d={series:this};this.pointClass.prototype.applyOptions.apply(d,[a]);m=d.x;l=k.length;if(this.requireSorting&&m<k[l-1])for(j=!0;l&&k[l-1]>m;)l--;this.updateParallelArrays(d,"splice",l,0,0);this.updateParallelArrays(d,l);if(h&&d.name)h[m]=d.name;\ni.splice(l,0,a);j&&(this.data.splice(l,0,null),this.processData());e.legendType==="point"&&this.generatePoints();c&&(f[0]&&f[0].remove?f[0].remove(!1):(f.shift(),this.updateParallelArrays(d,"shift"),i.shift()));this.isDirtyData=this.isDirty=!0;b&&(this.getAttribs(),g.redraw())},removePoint:function(a,b,c){var d=this,e=d.data,f=e[a],g=d.points,h=d.chart,i=function(){g&&g.length===e.length&&g.splice(a,1);e.splice(a,1);d.options.data.splice(a,1);d.updateParallelArrays(f||{series:d},"splice",a,1);f&&\nf.destroy();d.isDirty=!0;d.isDirtyData=!0;b&&h.redraw()};Va(c,h);b=p(b,!0);f?f.firePointEvent("remove",null,i):i()},remove:function(a,b){var c=this,d=c.chart;I(c,"remove",null,function(){c.destroy();d.isDirtyLegend=d.isDirtyBox=!0;d.linkSeries();p(a,!0)&&d.redraw(b)})},update:function(a,b){var c=this,d=this.chart,e=this.userOptions,f=this.type,g=L[f].prototype,h=["group","markerGroup","dataLabelsGroup"],i;if(a.type&&a.type!==f||a.zIndex!==void 0)h.length=0;q(h,function(a){h[a]=c[a];delete c[a]});\na=E(e,{animation:!1,index:this.index,pointStart:this.xData[0]},{data:this.options.data},a);this.remove(!1);for(i in g)this[i]=A;x(this,L[a.type||f].prototype);q(h,function(a){c[a]=h[a]});this.init(d,a);d.linkSeries();p(b,!0)&&d.redraw(!1)}});x(ia.prototype,{update:function(a,b){var c=this.chart,a=c.options[this.coll][this.options.index]=E(this.userOptions,a);this.destroy(!0);this.init(c,x(a,{events:A}));c.isDirtyBox=!0;p(b,!0)&&c.redraw()},remove:function(a){for(var b=this.chart,c=this.coll,d=this.series,\ne=d.length;e--;)d[e]&&d[e].remove(!1);ra(b.axes,this);ra(b[c],this);b.options[c].splice(this.options.index,1);q(b[c],function(a,b){a.options.index=b});this.destroy();b.isDirtyBox=!0;p(a,!0)&&b.redraw()},setTitle:function(a,b){this.update({title:a},b)},setCategories:function(a,b){this.update({categories:a},b)}});var xa=sa(R);L.line=xa;fa.area=E(ha,{softThreshold:!1,threshold:0});var qa=sa(R,{type:"area",singleStacks:!1,getStackPoints:function(){var a=[],b=[],c=this.xAxis,d=this.yAxis,e=d.stacks[this.stackKey],\nf={},g=this.points,h=this.index,i=d.series,j=i.length,k,l=p(d.options.reversedStacks,!0)?1:-1,m,n;if(this.options.stacking){for(m=0;m<g.length;m++)f[g[m].x]=g[m];for(n in e)e[n].total!==null&&b.push(n);b.sort(function(a,b){return a-b});k=Da(i,function(){return this.visible});q(b,function(g,i){var n=0,p,s;if(f[g]&&!f[g].isNull)a.push(f[g]),q([-1,1],function(a){var c=a===1?"rightNull":"leftNull",d=0,n=e[b[i+a]];if(n)for(m=h;m>=0&&m<j;)p=n.points[m],p||(m===h?f[g][c]=!0:k[m]&&(s=e[g].points[m])&&(d-=\ns[1]-s[0])),m+=l;f[g][a===1?"rightCliff":"leftCliff"]=d});else{for(m=h;m>=0&&m<j;){if(p=e[g].points[m]){n=p[1];break}m+=l}n=d.toPixels(n,!0);a.push({isNull:!0,plotX:c.toPixels(g,!0),plotY:n,yBottom:n})}})}return a},getGraphPath:function(a){var b=R.prototype.getGraphPath,c=this.options,d=c.stacking,e=this.yAxis,f,g,h=[],i=[],j=this.index,k,l=e.stacks[this.stackKey],m=c.threshold,n=e.getThreshold(c.threshold),o,c=c.connectNulls||d==="percent",q=function(b,c,f){var g=a[b],b=d&&l[g.x].points[j],o=g[f+\n"Null"]||0,f=g[f+"Cliff"]||0,p,q,g=!0;f||o?(p=(o?b[0]:b[1])+f,q=b[0]+f,g=!!o):!d&&a[c]&&a[c].isNull&&(p=q=m);p!==void 0&&(i.push({plotX:k,plotY:p===null?n:e.getThreshold(p),isNull:g}),h.push({plotX:k,plotY:q===null?n:e.getThreshold(q)}))},a=a||this.points;d&&(a=this.getStackPoints());for(f=0;f<a.length;f++)if(g=a[f].isNull,k=p(a[f].rectPlotX,a[f].plotX),o=p(a[f].yBottom,n),!g||c){c||q(f,f-1,"left");if(!g||d||!c)i.push(a[f]),h.push({x:f,plotX:k,plotY:o});c||q(f,f+1,"right")}f=b.call(this,i,!0,!0);\nh.reversed=!0;g=b.call(this,h,!0,!0);g.length&&(g[0]=S);g=f.concat(g);b=b.call(this,i,!1,c);g.xMap=f.xMap;this.areaPath=g;return b},drawGraph:function(){this.areaPath=[];R.prototype.drawGraph.apply(this);var a=this,b=this.areaPath,c=this.options,d=[["area",this.color,c.fillColor]];q(this.zones,function(b,f){d.push(["zoneArea"+f,b.color||a.color,b.fillColor||c.fillColor])});q(d,function(d){var f=d[0],g=a[f];g?(g.endX=b.xMap,g.animate({d:b})):(g={fill:d[2]||d[1],zIndex:0},d[2]||(g["fill-opacity"]=p(c.fillOpacity,\n0.75)),g=a[f]=a.chart.renderer.path(b).attr(g).add(a.group),g.isArea=!0);g.startX=b.xMap;g.shiftUnit=c.step?2:1})},drawLegendSymbol:K.drawRectangle});L.area=qa;fa.spline=E(ha);xa=sa(R,{type:"spline",getPointSpline:function(a,b,c){var d=b.plotX,e=b.plotY,f=a[c-1],c=a[c+1],g,h,i,j;if(f&&!f.isNull&&c&&!c.isNull){a=f.plotY;i=c.plotX;var c=c.plotY,k=0;g=(1.5*d+f.plotX)/2.5;h=(1.5*e+a)/2.5;i=(1.5*d+i)/2.5;j=(1.5*e+c)/2.5;i!==g&&(k=(j-h)*(i-d)/(i-g)+e-j);h+=k;j+=k;h>a&&h>e?(h=t(a,e),j=2*e-h):h<a&&h<e&&(h=\nF(a,e),j=2*e-h);j>c&&j>e?(j=t(c,e),h=2*e-j):j<c&&j<e&&(j=F(c,e),h=2*e-j);b.rightContX=i;b.rightContY=j}b=["C",p(f.rightContX,f.plotX),p(f.rightContY,f.plotY),p(g,d),p(h,e),d,e];f.rightContX=f.rightContY=null;return b}});L.spline=xa;fa.areaspline=E(fa.area);qa=qa.prototype;xa=sa(xa,{type:"areaspline",getStackPoints:qa.getStackPoints,getGraphPath:qa.getGraphPath,setStackCliffs:qa.setStackCliffs,drawGraph:qa.drawGraph,drawLegendSymbol:K.drawRectangle});L.areaspline=xa;fa.column=E(ha,{borderColor:"#FFFFFF",\nborderRadius:0,groupPadding:0.2,marker:null,pointPadding:0.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{brightness:0.1,shadow:!1,halo:!1},select:{color:"#C0C0C0",borderColor:"#000000",shadow:!1}},dataLabels:{align:null,verticalAlign:null,y:null},softThreshold:!1,startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0});xa=sa(R,{type:"column",pointAttrToOptions:{stroke:"borderColor",fill:"color",r:"borderRadius"},cropShoulder:0,directTouch:!0,trackerGroups:["group",\n"dataLabelsGroup"],negStacks:!0,init:function(){R.prototype.init.apply(this,arguments);var a=this,b=a.chart;b.hasRendered&&q(b.series,function(b){if(b.type===a.type)b.isDirty=!0})},getColumnMetrics:function(){var a=this,b=a.options,c=a.xAxis,d=a.yAxis,e=c.reversed,f,g={},h=0;b.grouping===!1?h=1:q(a.chart.series,function(b){var c=b.options,e=b.yAxis,i;if(b.type===a.type&&b.visible&&d.len===e.len&&d.pos===e.pos)c.stacking?(f=b.stackKey,g[f]===A&&(g[f]=h++),i=g[f]):c.grouping!==!1&&(i=h++),b.columnIndex=\ni});var i=F(Q(c.transA)*(c.ordinalSlope||b.pointRange||c.closestPointRange||c.tickInterval||1),c.len),j=i*b.groupPadding,k=(i-2*j)/h,b=F(b.maxPointWidth||c.len,p(b.pointWidth,k*(1-2*b.pointPadding)));a.columnMetrics={width:b,offset:(k-b)/2+(j+((a.columnIndex||0)+(e?1:0))*k-i/2)*(e?-1:1)};return a.columnMetrics},crispCol:function(a,b,c,d){var e=this.chart,f=this.borderWidth,g=-(f%2?0.5:0),f=f%2?0.5:1;e.inverted&&e.renderer.isVML&&(f+=1);c=Math.round(a+c)+g;a=Math.round(a)+g;c-=a;d=Math.round(b+d)+\nf;g=Q(b)<=0.5&&d>0.5;b=Math.round(b)+f;d-=b;g&&d&&(b-=1,d+=1);return{x:a,y:b,width:c,height:d}},translate:function(){var a=this,b=a.chart,c=a.options,d=a.borderWidth=p(c.borderWidth,a.closestPointRange*a.xAxis.transA<2?0:1),e=a.yAxis,f=a.translatedThreshold=e.getThreshold(c.threshold),g=p(c.minPointLength,5),h=a.getColumnMetrics(),i=h.width,j=a.barW=t(i,1+2*d),k=a.pointXOffset=h.offset;b.inverted&&(f-=0.5);c.pointPadding&&(j=va(j));R.prototype.translate.apply(a);q(a.points,function(c){var d=F(p(c.yBottom,\nf),9E4),h=999+Q(d),h=F(t(-h,c.plotY),e.len+h),o=c.plotX+k,q=j,r=F(h,d),s,w=t(h,d)-r;Q(w)<g&&g&&(w=g,s=!e.reversed&&!c.negative||e.reversed&&c.negative,r=Q(r-f)>g?d-g:f-(s?g:0));c.barX=o;c.pointWidth=i;c.tooltipPos=b.inverted?[e.len+e.pos-b.plotLeft-h,a.xAxis.len-o-q/2,w]:[o+q/2,h+e.pos-b.plotTop,w];c.shapeType="rect";c.shapeArgs=a.crispCol(o,r,q,w)})},getSymbol:Ba,drawLegendSymbol:K.drawRectangle,drawGraph:Ba,drawPoints:function(){var a=this,b=this.chart,c=a.options,d=b.renderer,e=c.animationLimit||\n250,f,g;q(a.points,function(h){var i=h.graphic,j;if(J(h.plotY)&&h.y!==null)f=h.shapeArgs,j=s(a.borderWidth)?{"stroke-width":a.borderWidth}:{},g=h.pointAttr[h.selected?"select":""]||a.pointAttr[""],i?(Ka(i),i.attr(j).attr(g)[b.pointCount<e?"animate":"attr"](E(f))):h.graphic=d[h.shapeType](f).attr(j).attr(g).add(h.group||a.group).shadow(c.shadow,null,c.stacking&&!c.borderRadius);else if(i)h.graphic=i.destroy()})},animate:function(a){var b=this,c=this.yAxis,d=b.options,e=this.chart.inverted,f={};if(ga)a?\n(f.scaleY=0.001,a=F(c.pos+c.len,t(c.pos,c.toPixels(d.threshold))),e?f.translateX=a-c.len:f.translateY=a,b.group.attr(f)):(f[e?"translateX":"translateY"]=c.pos,b.group.animate(f,x(bb(b.options.animation),{step:function(a,c){b.group.attr({scaleY:t(0.001,c.pos)})}})),b.animate=null)},remove:function(){var a=this,b=a.chart;b.hasRendered&&q(b.series,function(b){if(b.type===a.type)b.isDirty=!0});R.prototype.remove.apply(a,arguments)}});L.column=xa;fa.bar=E(fa.column);qa=sa(xa,{type:"bar",inverted:!0});\nL.bar=qa;fa.scatter=E(ha,{lineWidth:0,marker:{enabled:!0},tooltip:{headerFormat:\'<span style="color:{point.color}">\\u25cf</span> <span style="font-size: 10px;"> {series.name}</span><br/>\',pointFormat:"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"}});qa=sa(R,{type:"scatter",sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group","markerGroup","dataLabelsGroup"],takeOrdinalPosition:!1,kdDimensions:2,drawGraph:function(){this.options.lineWidth&&R.prototype.drawGraph.call(this)}});L.scatter=\nqa;fa.pie=E(ha,{borderColor:"#FFFFFF",borderWidth:1,center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{distance:30,enabled:!0,formatter:function(){return this.y===null?void 0:this.point.name},x:0},ignoreHiddenPoint:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,states:{hover:{brightness:0.1,shadow:!1}},stickyTracking:!1,tooltip:{followPointer:!0}});ha={type:"pie",isCartesian:!1,pointClass:sa(Ma,{init:function(){Ma.prototype.init.apply(this,arguments);var a=this,b;\na.name=p(a.name,"Slice");b=function(b){a.slice(b.type==="select")};N(a,"select",b);N(a,"unselect",b);return a},setVisible:function(a,b){var c=this,d=c.series,e=d.chart,f=d.options.ignoreHiddenPoint,b=p(b,f);if(a!==c.visible){c.visible=c.options.visible=a=a===A?!c.visible:a;d.options.data[pa(c,d.data)]=c.options;q(["graphic","dataLabel","connector","shadowGroup"],function(b){if(c[b])c[b][a?"show":"hide"](!0)});c.legendItem&&e.legend.colorizeItem(c,a);!a&&c.state==="hover"&&c.setState("");if(f)d.isDirty=\n!0;b&&e.redraw()}},slice:function(a,b,c){var d=this.series;Va(c,d.chart);p(b,!0);this.sliced=this.options.sliced=a=s(a)?a:!this.sliced;d.options.data[pa(this,d.data)]=this.options;a=a?this.slicedTranslation:{translateX:0,translateY:0};this.graphic.animate(a);this.shadowGroup&&this.shadowGroup.animate(a)},haloPath:function(a){var b=this.shapeArgs,c=this.series.chart;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(c.plotLeft+b.x,c.plotTop+b.y,b.r+a,b.r+a,{innerR:this.shapeArgs.r,\nstart:b.start,end:b.end})}}),requireSorting:!1,directTouch:!0,noSharedTooltip:!0,trackerGroups:["group","dataLabelsGroup"],axisTypes:[],pointAttrToOptions:{stroke:"borderColor","stroke-width":"borderWidth",fill:"color"},animate:function(a){var b=this,c=b.points,d=b.startAngleRad;if(!a)q(c,function(a){var c=a.graphic,g=a.shapeArgs;c&&(c.attr({r:a.startR||b.center[3]/2,start:d,end:d}),c.animate({r:g.r,start:g.start,end:g.end},b.options.animation))}),b.animate=null},updateTotals:function(){var a,b=0,\nc=this.points,d=c.length,e,f=this.options.ignoreHiddenPoint;for(a=0;a<d;a++){e=c[a];if(e.y<0)e.y=null;b+=f&&!e.visible?0:e.y}this.total=b;for(a=0;a<d;a++)e=c[a],e.percentage=b>0&&(e.visible||!f)?e.y/b*100:0,e.total=b},generatePoints:function(){R.prototype.generatePoints.call(this);this.updateTotals()},translate:function(a){this.generatePoints();var b=0,c=this.options,d=c.slicedOffset,e=d+c.borderWidth,f,g,h,i=c.startAngle||0,j=this.startAngleRad=ta/180*(i-90),i=(this.endAngleRad=ta/180*(p(c.endAngle,\ni+360)-90))-j,k=this.points,l=c.dataLabels.distance,c=c.ignoreHiddenPoint,m,n=k.length,o;if(!a)this.center=a=this.getCenter();this.getX=function(b,c){h=Z.asin(F((b-a[1])/(a[2]/2+l),1));return a[0]+(c?-1:1)*W(h)*(a[2]/2+l)};for(m=0;m<n;m++){o=k[m];f=j+b*i;if(!c||o.visible)b+=o.percentage/100;g=j+b*i;o.shapeType="arc";o.shapeArgs={x:a[0],y:a[1],r:a[2]/2,innerR:a[3]/2,start:C(f*1E3)/1E3,end:C(g*1E3)/1E3};h=(g+f)/2;h>1.5*ta?h-=2*ta:h<-ta/2&&(h+=2*ta);o.slicedTranslation={translateX:C(W(h)*d),translateY:C(ea(h)*\nd)};f=W(h)*a[2]/2;g=ea(h)*a[2]/2;o.tooltipPos=[a[0]+f*0.7,a[1]+g*0.7];o.half=h<-ta/2||h>ta/2?1:0;o.angle=h;e=F(e,l/2);o.labelPos=[a[0]+f+W(h)*l,a[1]+g+ea(h)*l,a[0]+f+W(h)*e,a[1]+g+ea(h)*e,a[0]+f,a[1]+g,l<0?"center":o.half?"right":"left",h]}},drawGraph:null,drawPoints:function(){var a=this,b=a.chart.renderer,c,d,e=a.options.shadow,f,g,h,i;if(e&&!a.shadowGroup)a.shadowGroup=b.g("shadow").add(a.group);q(a.points,function(j){if(j.y!==null){d=j.graphic;h=j.shapeArgs;f=j.shadowGroup;g=j.pointAttr[j.selected?\n"select":""];if(!g.stroke)g.stroke=g.fill;if(e&&!f)f=j.shadowGroup=b.g("shadow").add(a.shadowGroup);c=j.sliced?j.slicedTranslation:{translateX:0,translateY:0};f&&f.attr(c);if(d)d.setRadialReference(a.center).attr(g).animate(x(h,c));else{i={"stroke-linejoin":"round"};if(!j.visible)i.visibility="hidden";j.graphic=d=b[j.shapeType](h).setRadialReference(a.center).attr(g).attr(i).attr(c).add(a.group).shadow(e,f)}}})},searchPoint:Ba,sortByAngle:function(a,b){a.sort(function(a,d){return a.angle!==void 0&&\n(d.angle-a.angle)*b})},drawLegendSymbol:K.drawRectangle,getCenter:Db.getCenter,getSymbol:Ba};ha=sa(R,ha);L.pie=ha;R.prototype.drawDataLabels=function(){var a=this,b=a.options,c=b.cursor,d=b.dataLabels,e=a.points,f,g,h=a.hasRendered||0,i,j,k=p(d.defer,!0),l=a.chart.renderer;if(d.enabled||a._hasPointLabels)a.dlProcessOptions&&a.dlProcessOptions(d),j=a.plotGroup("dataLabelsGroup","data-labels",k&&!h?"hidden":"visible",d.zIndex||6),k&&(j.attr({opacity:+h}),h||N(a,"afterAnimate",function(){a.visible&&\nj.show(!0);j[b.animation?"animate":"attr"]({opacity:1},{duration:200})})),g=d,q(e,function(e){var h,k=e.dataLabel,q,r,t=e.connector,w=!0,v,u={};f=e.dlOptions||e.options&&e.options.dataLabels;h=p(f&&f.enabled,g.enabled)&&e.y!==null;if(k&&!h)e.dataLabel=k.destroy();else if(h){d=E(g,f);v=d.style;h=d.rotation;q=e.getLabelConfig();i=d.format?Na(d.format,q):d.formatter.call(q,d);v.color=p(d.color,v.color,a.color,"black");if(k)if(s(i))k.attr({text:i}),w=!1;else{if(e.dataLabel=k=k.destroy(),t)e.connector=\nt.destroy()}else if(s(i)){k={fill:d.backgroundColor,stroke:d.borderColor,"stroke-width":d.borderWidth,r:d.borderRadius||0,rotation:h,padding:d.padding,zIndex:1};if(v.color==="contrast")u.color=d.inside||d.distance<0||b.stacking?l.getContrast(e.color||a.color):"#000000";if(c)u.cursor=c;for(r in k)k[r]===A&&delete k[r];k=e.dataLabel=l[h?"text":"label"](i,0,-9999,d.shape,null,null,d.useHTML).attr(k).css(x(v,u)).add(j).shadow(d.shadow)}k&&a.alignDataLabel(e,k,d,null,w)}})};R.prototype.alignDataLabel=\nfunction(a,b,c,d,e){var f=this.chart,g=f.inverted,h=p(a.plotX,-9999),i=p(a.plotY,-9999),j=b.getBBox(),k=f.renderer.fontMetrics(c.style.fontSize).b,l=c.rotation,m=c.align,n=this.visible&&(a.series.forceDL||f.isInsidePlot(h,C(i),g)||d&&f.isInsidePlot(h,g?d.x+1:d.y+d.height-1,g)),o=p(c.overflow,"justify")==="justify";if(n)d=x({x:g?f.plotWidth-i:h,y:C(g?f.plotHeight-h:i),width:0,height:0},d),x(c,{width:j.width,height:j.height}),l?(o=!1,g=f.renderer.rotCorr(k,l),g={x:d.x+c.x+d.width/2+g.x,y:d.y+c.y+{top:0,\nmiddle:0.5,bottom:1}[c.verticalAlign]*d.height},b[e?"attr":"animate"](g).attr({align:m}),h=(l+720)%360,h=h>180&&h<360,m==="left"?g.y-=h?j.height:0:m==="center"?(g.x-=j.width/2,g.y-=j.height/2):m==="right"&&(g.x-=j.width,g.y-=h?0:j.height)):(b.align(c,null,d),g=b.alignAttr),o?this.justifyDataLabel(b,c,g,j,d,e):p(c.crop,!0)&&(n=f.isInsidePlot(g.x,g.y)&&f.isInsidePlot(g.x+j.width,g.y+j.height)),c.shape&&!l&&b.attr({anchorX:a.plotX,anchorY:a.plotY});if(!n)Ka(b),b.attr({y:-9999}),b.placed=!1};R.prototype.justifyDataLabel=\nfunction(a,b,c,d,e,f){var g=this.chart,h=b.align,i=b.verticalAlign,j,k,l=a.box?0:a.padding||0;j=c.x+l;if(j<0)h==="right"?b.align="left":b.x=-j,k=!0;j=c.x+d.width-l;if(j>g.plotWidth)h==="left"?b.align="right":b.x=g.plotWidth-j,k=!0;j=c.y+l;if(j<0)i==="bottom"?b.verticalAlign="top":b.y=-j,k=!0;j=c.y+d.height-l;if(j>g.plotHeight)i==="top"?b.verticalAlign="bottom":b.y=g.plotHeight-j,k=!0;if(k)a.placed=!f,a.align(b,null,e)};if(L.pie)L.pie.prototype.drawDataLabels=function(){var a=this,b=a.data,c,d=a.chart,\ne=a.options.dataLabels,f=p(e.connectorPadding,10),g=p(e.connectorWidth,1),h=d.plotWidth,i=d.plotHeight,j,k,l=p(e.softConnector,!0),m=e.distance,n=a.center,o=n[2]/2,s=n[1],r=m>0,u,w,v,x=[[],[]],A,y,D,E,B,H=[0,0,0,0],M=function(a,b){return b.y-a.y};if(a.visible&&(e.enabled||a._hasPointLabels)){R.prototype.drawDataLabels.apply(a);q(b,function(a){if(a.dataLabel&&a.visible)x[a.half].push(a),a.dataLabel._pos=null});for(E=2;E--;){var I=[],N=[],J=x[E],L=J.length,K;if(L){a.sortByAngle(J,E-0.5);for(B=b=0;!b&&\nJ[B];)b=J[B]&&J[B].dataLabel&&(J[B].dataLabel.getBBox().height||21),B++;if(m>0){w=F(s+o+m,d.plotHeight);for(B=t(0,s-o-m);B<=w;B+=b)I.push(B);w=I.length;if(L>w){c=[].concat(J);c.sort(M);for(B=L;B--;)c[B].rank=B;for(B=L;B--;)J[B].rank>=w&&J.splice(B,1);L=J.length}for(B=0;B<L;B++){c=J[B];v=c.labelPos;c=9999;var P,O;for(O=0;O<w;O++)P=Q(I[O]-v[1]),P<c&&(c=P,K=O);if(K<B&&I[B]!==null)K=B;else for(w<L-B+K&&I[B]!==null&&(K=w-L+B);I[K]===null;)K++;N.push({i:K,y:I[K]});I[K]=null}N.sort(M)}for(B=0;B<L;B++){c=\nJ[B];v=c.labelPos;u=c.dataLabel;D=c.visible===!1?"hidden":"inherit";c=v[1];if(m>0){if(w=N.pop(),K=w.i,y=w.y,c>y&&I[K+1]!==null||c<y&&I[K-1]!==null)y=F(t(0,c),d.plotHeight)}else y=c;A=e.justify?n[0]+(E?-1:1)*(o+m):a.getX(y===s-o-m||y===s+o+m?c:y,E);u._attr={visibility:D,align:v[6]};u._pos={x:A+e.x+({left:f,right:-f}[v[6]]||0),y:y+e.y-10};u.connX=A;u.connY=y;if(this.options.size===null)w=u.width,A-w<f?H[3]=t(C(w-A+f),H[3]):A+w>h-f&&(H[1]=t(C(A+w-h+f),H[1])),y-b/2<0?H[0]=t(C(-y+b/2),H[0]):y+b/2>i&&(H[2]=\nt(C(y+b/2-i),H[2]))}}}if(Ha(H)===0||this.verifyDataLabelOverflow(H))this.placeDataLabels(),r&&g&&q(this.points,function(b){j=b.connector;v=b.labelPos;if((u=b.dataLabel)&&u._pos&&b.visible)D=u._attr.visibility,A=u.connX,y=u.connY,k=l?[X,A+(v[6]==="left"?5:-5),y,"C",A,y,2*v[2]-v[4],2*v[3]-v[5],v[2],v[3],S,v[4],v[5]]:[X,A+(v[6]==="left"?5:-5),y,S,v[2],v[3],S,v[4],v[5]],j?(j.animate({d:k}),j.attr("visibility",D)):b.connector=j=a.chart.renderer.path(k).attr({"stroke-width":g,stroke:e.connectorColor||b.color||\n"#606060",visibility:D}).add(a.dataLabelsGroup);else if(j)b.connector=j.destroy()})}},L.pie.prototype.placeDataLabels=function(){q(this.points,function(a){var b=a.dataLabel;if(b&&a.visible)(a=b._pos)?(b.attr(b._attr),b[b.moved?"animate":"attr"](a),b.moved=!0):b&&b.attr({y:-9999})})},L.pie.prototype.alignDataLabel=Ba,L.pie.prototype.verifyDataLabelOverflow=function(a){var b=this.center,c=this.options,d=c.center,e=c.minSize||80,f=e,g;d[0]!==null?f=t(b[2]-t(a[1],a[3]),e):(f=t(b[2]-a[1]-a[3],e),b[0]+=\n(a[3]-a[1])/2);d[1]!==null?f=t(F(f,b[2]-t(a[0],a[2])),e):(f=t(F(f,b[2]-a[0]-a[2]),e),b[1]+=(a[0]-a[2])/2);f<b[2]?(b[2]=f,b[3]=Math.min(/%$/.test(c.innerSize||0)?f*parseFloat(c.innerSize||0)/100:parseFloat(c.innerSize||0),f),this.translate(b),this.drawDataLabels&&this.drawDataLabels()):g=!0;return g};if(L.column)L.column.prototype.alignDataLabel=function(a,b,c,d,e){var f=this.chart.inverted,g=a.series,h=a.dlBox||a.shapeArgs,i=p(a.below,a.plotY>p(this.translatedThreshold,g.yAxis.len)),j=p(c.inside,\n!!this.options.stacking);if(h){d=E(h);if(d.y<0)d.height+=d.y,d.y=0;h=d.y+d.height-g.yAxis.len;h>0&&(d.height-=h);f&&(d={x:g.yAxis.len-d.y-d.height,y:g.xAxis.len-d.x-d.width,width:d.height,height:d.width});if(!j)f?(d.x+=i?0:d.width,d.width=0):(d.y+=i?d.height:0,d.height=0)}c.align=p(c.align,!f||j?"center":i?"right":"left");c.verticalAlign=p(c.verticalAlign,f||j?"middle":i?"top":"bottom");R.prototype.alignDataLabel.call(this,a,b,c,d,e)};(function(a){var b=a.Chart,c=a.each,d=a.pick,e=a.addEvent;b.prototype.callbacks.push(function(a){function b(){var e=\n[];c(a.series,function(a){var b=a.options.dataLabels,f=a.dataLabelCollections||["dataLabel"];(b.enabled||a._hasPointLabels)&&!b.allowOverlap&&a.visible&&c(f,function(b){c(a.points,function(a){if(a[b])a[b].labelrank=d(a.labelrank,a.shapeArgs&&a.shapeArgs.height),e.push(a[b])})})});a.hideOverlappingLabels(e)}b();e(a,"redraw",b)});b.prototype.hideOverlappingLabels=function(a){var b=a.length,d,e,j,k,l,m,n,o,p;for(e=0;e<b;e++)if(d=a[e])d.oldOpacity=d.opacity,d.newOpacity=1;a.sort(function(a,b){return(b.labelrank||\n0)-(a.labelrank||0)});for(e=0;e<b;e++){j=a[e];for(d=e+1;d<b;++d)if(k=a[d],j&&k&&j.placed&&k.placed&&j.newOpacity!==0&&k.newOpacity!==0&&(l=j.alignAttr,m=k.alignAttr,n=j.parentGroup,o=k.parentGroup,p=2*(j.box?0:j.padding),l=!(m.x+o.translateX>l.x+n.translateX+(j.width-p)||m.x+o.translateX+(k.width-p)<l.x+n.translateX||m.y+o.translateY>l.y+n.translateY+(j.height-p)||m.y+o.translateY+(k.height-p)<l.y+n.translateY)))(j.labelrank<k.labelrank?j:k).newOpacity=0}c(a,function(a){var b,c;if(a){c=a.newOpacity;\nif(a.oldOpacity!==c&&a.placed)c?a.show(!0):b=function(){a.hide()},a.alignAttr.opacity=c,a[a.isOld?"animate":"attr"](a.alignAttr,null,b);a.isOld=!0}})}})(u);ha=u.TrackerMixin={drawTrackerPoint:function(){var a=this,b=a.chart,c=b.pointer,d=a.options.cursor,e=d&&{cursor:d},f=function(a){for(var c=a.target,d;c&&!d;)d=c.point,c=c.parentNode;if(d!==A&&d!==b.hoverPoint)d.onMouseOver(a)};q(a.points,function(a){if(a.graphic)a.graphic.element.point=a;if(a.dataLabel)a.dataLabel.element.point=a});if(!a._hasTracking)q(a.trackerGroups,\nfunction(b){if(a[b]&&(a[b].addClass("highcharts-tracker").on("mouseover",f).on("mouseout",function(a){c.onTrackerMouseOut(a)}).css(e),fb))a[b].on("touchstart",f)}),a._hasTracking=!0},drawTrackerGraph:function(){var a=this,b=a.options,c=b.trackByArea,d=[].concat(c?a.areaPath:a.graphPath),e=d.length,f=a.chart,g=f.pointer,h=f.renderer,i=f.options.tooltip.snap,j=a.tracker,k=b.cursor,l=k&&{cursor:k},m=function(){if(f.hoverSeries!==a)a.onMouseOver()},n="rgba(192,192,192,"+(ga?1.0E-4:0.002)+")";if(e&&!c)for(k=\ne+1;k--;)d[k]===X&&d.splice(k+1,0,d[k+1]-i,d[k+2],S),(k&&d[k]===X||k===e)&&d.splice(k,0,S,d[k-2]+i,d[k-1]);j?j.attr({d:d}):(a.tracker=h.path(d).attr({"stroke-linejoin":"round",visibility:a.visible?"visible":"hidden",stroke:n,fill:c?n:"none","stroke-width":b.lineWidth+(c?0:2*i),zIndex:2}).add(a.group),q([a.tracker,a.markerGroup],function(a){a.addClass("highcharts-tracker").on("mouseover",m).on("mouseout",function(a){g.onTrackerMouseOut(a)}).css(l);if(fb)a.on("touchstart",m)}))}};if(L.column)xa.prototype.drawTracker=\nha.drawTrackerPoint;if(L.pie)L.pie.prototype.drawTracker=ha.drawTrackerPoint;if(L.scatter)qa.prototype.drawTracker=ha.drawTrackerPoint;x(rb.prototype,{setItemEvents:function(a,b,c,d,e){var f=this;(c?b:a.legendGroup).on("mouseover",function(){a.setState("hover");b.css(f.options.itemHoverStyle)}).on("mouseout",function(){b.css(a.visible?d:e);a.setState()}).on("click",function(b){var c=function(){a.setVisible&&a.setVisible()},b={browserEvent:b};a.firePointEvent?a.firePointEvent("legendItemClick",b,c):\nI(a,"legendItemClick",b,c)})},createCheckboxForItem:function(a){a.checkbox=da("input",{type:"checkbox",checked:a.selected,defaultChecked:a.selected},this.options.itemCheckboxStyle,this.chart.container);N(a.checkbox,"click",function(b){I(a.series||a,"checkboxClick",{checked:b.target.checked,item:a},function(){a.select()})})}});U.legend.itemStyle.cursor="pointer";x(ib.prototype,{showResetZoom:function(){var a=this,b=U.lang,c=a.options.chart.resetZoomButton,d=c.theme,e=d.states,f=c.relativeTo==="chart"?\nnull:"plotBox";this.resetZoomButton=a.renderer.button(b.resetZoom,null,null,function(){a.zoomOut()},d,e&&e.hover).attr({align:c.position.align,title:b.resetZoomTitle}).add().align(c.position,!1,f)},zoomOut:function(){var a=this;I(a,"selection",{resetSelection:!0},function(){a.zoom()})},zoom:function(a){var b,c=this.pointer,d=!1,e;!a||a.resetSelection?q(this.axes,function(a){b=a.zoom()}):q(a.xAxis.concat(a.yAxis),function(a){var e=a.axis,h=e.isXAxis;if(c[h?"zoomX":"zoomY"]||c[h?"pinchX":"pinchY"])b=\ne.zoom(a.min,a.max),e.displayBtn&&(d=!0)});e=this.resetZoomButton;if(d&&!e)this.showResetZoom();else if(!d&&$(e))this.resetZoomButton=e.destroy();b&&this.redraw(p(this.options.chart.animation,a&&a.animation,this.pointCount<100))},pan:function(a,b){var c=this,d=c.hoverPoints,e;d&&q(d,function(a){a.setState()});q(b==="xy"?[1,0]:[1],function(b){var b=c[b?"xAxis":"yAxis"][0],d=b.horiz,h=a[d?"chartX":"chartY"],d=d?"mouseDownX":"mouseDownY",i=c[d],j=(b.pointRange||0)/2,k=b.getExtremes(),l=b.toValue(i-h,\n!0)+j,j=b.toValue(i+b.len-h,!0)-j,i=i>h;if(b.series.length&&(i||l>F(k.dataMin,k.min))&&(!i||j<t(k.dataMax,k.max)))b.setExtremes(l,j,!1,!1,{trigger:"pan"}),e=!0;c[d]=h});e&&c.redraw(!1);M(c.container,{cursor:"move"})}});x(Ma.prototype,{select:function(a,b){var c=this,d=c.series,e=d.chart,a=p(a,!c.selected);c.firePointEvent(a?"select":"unselect",{accumulate:b},function(){c.selected=c.options.selected=a;d.options.data[pa(c,d.data)]=c.options;c.setState(a&&"select");b||q(e.getSelectedPoints(),function(a){if(a.selected&&\na!==c)a.selected=a.options.selected=!1,d.options.data[pa(a,d.data)]=a.options,a.setState(""),a.firePointEvent("unselect")})})},onMouseOver:function(a,b){var c=this.series,d=c.chart,e=d.tooltip,f=d.hoverPoint;if(d.hoverSeries!==c)c.onMouseOver();if(f&&f!==this)f.onMouseOut();if(this.series&&(this.firePointEvent("mouseOver"),e&&(!e.shared||c.noSharedTooltip)&&e.refresh(this,a),this.setState("hover"),!b))d.hoverPoint=this},onMouseOut:function(){var a=this.series.chart,b=a.hoverPoints;this.firePointEvent("mouseOut");\nif(!b||pa(this,b)===-1)this.setState(),a.hoverPoint=null},importEvents:function(){if(!this.hasImportedEvents){var a=E(this.series.options.point,this.options).events,b;this.events=a;for(b in a)N(this,b,a[b]);this.hasImportedEvents=!0}},setState:function(a,b){var c=V(this.plotX),d=this.plotY,e=this.series,f=e.options.states,g=fa[e.type].marker&&e.options.marker,h=g&&!g.enabled,i=g&&g.states[a],j=i&&i.enabled===!1,k=e.stateMarkerGraphic,l=this.marker||{},m=e.chart,n=e.halo,o,a=a||"";o=this.pointAttr[a]||\ne.pointAttr[a];if(!(a===this.state&&!b||this.selected&&a!=="select"||f[a]&&f[a].enabled===!1||a&&(j||h&&i.enabled===!1)||a&&l.states&&l.states[a]&&l.states[a].enabled===!1)){if(this.graphic)g=g&&this.graphic.symbolName&&o.r,this.graphic.attr(E(o,g?{x:c-g,y:d-g,width:2*g,height:2*g}:{})),k&&k.hide();else{if(a&&i)if(g=i.radius,l=l.symbol||e.symbol,k&&k.currentSymbol!==l&&(k=k.destroy()),k)k[b?"animate":"attr"]({x:c-g,y:d-g});else if(l)e.stateMarkerGraphic=k=m.renderer.symbol(l,c-g,d-g,2*g,2*g).attr(o).add(e.markerGroup),\nk.currentSymbol=l;if(k)k[a&&m.isInsidePlot(c,d,m.inverted)?"show":"hide"](),k.element.point=this}if((c=f[a]&&f[a].halo)&&c.size){if(!n)e.halo=n=m.renderer.path().add(m.seriesGroup);n.attr(x({fill:this.color||e.color,"fill-opacity":c.opacity,zIndex:-1},c.attributes))[b?"animate":"attr"]({d:this.haloPath(c.size)})}else n&&n.attr({d:[]});this.state=a}},haloPath:function(a){var b=this.series,c=b.chart,d=b.getPlotBox(),e=c.inverted,f=Math.floor(this.plotX);return c.renderer.symbols.circle(d.translateX+\n(e?b.yAxis.len-this.plotY:f)-a,d.translateY+(e?b.xAxis.len-f:this.plotY)-a,a*2,a*2)}});x(R.prototype,{onMouseOver:function(){var a=this.chart,b=a.hoverSeries;if(b&&b!==this)b.onMouseOut();this.options.events.mouseOver&&I(this,"mouseOver");this.setState("hover");a.hoverSeries=this},onMouseOut:function(){var a=this.options,b=this.chart,c=b.tooltip,d=b.hoverPoint;b.hoverSeries=null;if(d)d.onMouseOut();this&&a.events.mouseOut&&I(this,"mouseOut");c&&!a.stickyTracking&&(!c.shared||this.noSharedTooltip)&&\nc.hide();this.setState()},setState:function(a){var b=this.options,c=this.graph,d=b.states,e=b.lineWidth,b=0,a=a||"";if(this.state!==a&&(this.state=a,!(d[a]&&d[a].enabled===!1)&&(a&&(e=d[a].lineWidth||e+(d[a].lineWidthPlus||0)),c&&!c.dashstyle))){a={"stroke-width":e};for(c.attr(a);this["zoneGraph"+b];)this["zoneGraph"+b].attr(a),b+=1}},setVisible:function(a,b){var c=this,d=c.chart,e=c.legendItem,f,g=d.options.chart.ignoreHiddenSeries,h=c.visible;f=(c.visible=a=c.userOptions.visible=a===A?!h:a)?"show":\n"hide";q(["group","dataLabelsGroup","markerGroup","tracker"],function(a){if(c[a])c[a][f]()});if(d.hoverSeries===c||(d.hoverPoint&&d.hoverPoint.series)===c)c.onMouseOut();e&&d.legend.colorizeItem(c,a);c.isDirty=!0;c.options.stacking&&q(d.series,function(a){if(a.options.stacking&&a.visible)a.isDirty=!0});q(c.linkedSeries,function(b){b.setVisible(a,!1)});if(g)d.isDirtyBox=!0;b!==!1&&d.redraw();I(c,f)},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(a){this.selected=\na=a===A?!this.selected:a;if(this.checkbox)this.checkbox.checked=a;I(this,a?"select":"unselect")},drawTracker:ha.drawTrackerGraph});x(u,{Color:na,Point:Ma,Tick:Xa,Renderer:eb,SVGElement:O,SVGRenderer:Ea,arrayMin:Oa,arrayMax:Ha,charts:T,correctFloat:aa,dateFormat:Sa,error:ca,format:Na,pathAnim:void 0,getOptions:function(){return U},hasBidiBug:Rb,isTouchDevice:Nb,setOptions:function(a){U=E(!0,U,a);Gb();return U},addEvent:N,removeEvent:Y,createElement:da,discardElement:Ua,css:M,each:q,map:Da,merge:E,\nsplat:ua,stableSort:jb,extendClass:sa,pInt:B,svg:ga,canvas:la,vml:!ga&&!la,product:"Highcharts",version:"4.2.6"});return u});\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9oaWdoY2hhcnRzL2hpZ2hjaGFydHMuanM/MDFiNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsK0ZBQStGLHNEQUFzRCxpQkFBaUIsOERBQThELG9CQUFvQiwwQkFBMEIsbUJBQW1CLGVBQWUsWUFBWSxZQUFZLGFBQWEsd0JBQXdCLGlCQUFpQixRQUFRLDBCQUEwQixFQUFFO0FBQ3RiLDZHQUE2RyxVQUFVLFVBQVUsc0RBQXNELFdBQVcsUUFBUSxJQUFJLGdCQUFnQixTQUFTLGdCQUFnQix5QkFBeUIsZUFBZSwyQkFBMkIsZUFBZSw0REFBNEQsaUJBQWlCLG1CQUFtQixJQUFJLGNBQWMsY0FBYyxPQUFPLGNBQWM7QUFDOWQsa0JBQWtCLFFBQVEsMkVBQTJFLHFEQUFxRCxTQUFTLGVBQWUsbUJBQW1CLG1CQUFtQiw4QkFBOEIsWUFBWSxnQkFBZ0IseUVBQXlFLGFBQWEsdUJBQXVCLHFCQUFxQixVQUFVLFFBQVEsaUNBQWlDLEVBQUUsVUFBVSxvQkFBb0IsU0FBUztBQUNoZixHQUFHLG1CQUFtQixrQkFBa0IsaUJBQWlCLFNBQVMsbUJBQW1CLHFEQUFxRCxlQUFlLDZCQUE2QixpQkFBaUIsWUFBWSxzQkFBc0Isc0JBQXNCLEVBQUUsZUFBZSxNQUFNLGVBQWUsdUJBQXVCLFdBQVcsSUFBSSxRQUFRLElBQUksY0FBYztBQUNyVyxpREFBaUQsVUFBVSxlQUFlLFdBQVcsSUFBSSxFQUFFLFVBQVUsa0JBQWtCLGVBQWUsb0NBQW9DLHVCQUF1QixtQkFBbUIsTUFBTSxxRUFBcUUsUUFBUSxXQUFXLDhEQUE4RCxLQUFLLFNBQVMsaUJBQWlCLG1CQUFtQixRQUFRLElBQUksaUJBQWlCLHFCQUFxQixTQUFTO0FBQzdkLEVBQUUsRUFBRSxRQUFRLElBQUksc0JBQXNCLGVBQWUsMEJBQTBCLElBQUksa0JBQWtCLFNBQVMsZUFBZSwwQkFBMEIsSUFBSSxrQkFBa0IsU0FBUyxp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QiwrRUFBK0UsZ0NBQWdDLG9EQUFvRCxVQUFVLDREQUE0RCxxQ0FBcUMsd0JBQXdCLEVBQUUsZ0JBQWdCLEtBQUssRUFBRSxjQUFjLHNCQUFzQixtRkFBbUY7QUFDeGMscUZBQXFGLEVBQUUsZUFBZSx1QkFBdUIsaUNBQWlDLDhCQUE4QixtREFBbUQsdUJBQXVCLG1CQUFtQix1QkFBdUIsMkRBQTJELG1CQUFtQixvQkFBb0IsNENBQTRDO0FBQzliLFNBQVMsZ0JBQWdCLHNCQUFzQixxRUFBcUUsa0lBQWtJLEdBQUcsa0JBQWtCLGNBQWMsb0JBQW9CLG1DQUFtQywwQkFBMEIsdUZBQXVGO0FBQ2pjLE9BQU8sa0VBQWtFLGtCQUFrQixFQUFFLDZFQUE2RSw4QkFBOEIsYUFBYSwyQ0FBMkMsOENBQThDLEVBQUUsNkJBQTZCLG1CQUFtQixFQUFFLHFCQUFxQixtQkFBbUIsT0FBTyxpQkFBaUIsb0JBQW9CLGlCQUFpQixvQkFBb0Isb0JBQW9CO0FBQy9lLHlCQUF5Qix5Q0FBeUMsOEJBQThCLGlDQUFpQyxFQUFFLEtBQUssMExBQTBMLFNBQVMsdURBQXVELFlBQVksS0FBSyxTQUFTO0FBQzVaLGdIQUFnSCxFQUFFLFNBQVMiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gSGlnaGNoYXJ0cyBKUyB2NC4yLjYgKDIwMTYtMDgtMDIpXG5cbiAoYykgMjAwOS0yMDE2IFRvcnN0ZWluIEhvbnNpXG5cbiBMaWNlbnNlOiB3d3cuaGlnaGNoYXJ0cy5jb20vbGljZW5zZVxuKi9cbihmdW5jdGlvbihELGNhKXt0eXBlb2YgbW9kdWxlPT09XCJvYmplY3RcIiYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9RC5kb2N1bWVudD9jYShEKTpjYTpELkhpZ2hjaGFydHM9Y2EoRCl9KSh0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6dGhpcyxmdW5jdGlvbihEKXtmdW5jdGlvbiBjYShhLGIpe3ZhciBjPVwiSGlnaGNoYXJ0cyBlcnJvciAjXCIrYStcIjogd3d3LmhpZ2hjaGFydHMuY29tL2Vycm9ycy9cIithO2lmKGIpdGhyb3cgRXJyb3IoYyk7RC5jb25zb2xlJiZjb25zb2xlLmxvZyhjKX1mdW5jdGlvbiBzYihhLGIsYyl7dGhpcy5vcHRpb25zPWI7dGhpcy5lbGVtPWE7dGhpcy5wcm9wPWN9ZnVuY3Rpb24gRSgpe3ZhciBhLGI9YXJndW1lbnRzLGMsZD17fSxlPWZ1bmN0aW9uKGEsYil7dmFyIGMsZDt0eXBlb2YgYSE9PVwib2JqZWN0XCImJihhPXt9KTtmb3IoZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihjPWJbZF0sYVtkXT1jJiZ0eXBlb2YgYz09PVwib2JqZWN0XCImJlxuT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGMpIT09XCJbb2JqZWN0IEFycmF5XVwiJiZkIT09XCJyZW5kZXJUb1wiJiZ0eXBlb2YgYy5ub2RlVHlwZSE9PVwibnVtYmVyXCI/ZShhW2RdfHx7fSxjKTpiW2RdKTtyZXR1cm4gYX07YlswXT09PSEwJiYoZD1iWzFdLGI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYiwyKSk7Yz1iLmxlbmd0aDtmb3IoYT0wO2E8YzthKyspZD1lKGQsYlthXSk7cmV0dXJuIGR9ZnVuY3Rpb24gQihhLGIpe3JldHVybiBwYXJzZUludChhLGJ8fDEwKX1mdW5jdGlvbiB5YShhKXtyZXR1cm4gdHlwZW9mIGE9PT1cInN0cmluZ1wifWZ1bmN0aW9uIEZhKGEpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk9PT1cIltvYmplY3QgQXJyYXldXCJ9ZnVuY3Rpb24gcmEoYSxiKXtmb3IodmFyIGM9YS5sZW5ndGg7Yy0tOylpZihhW2NdPT09Yil7YS5zcGxpY2UoYywxKTticmVha319ZnVuY3Rpb24gcyhhKXtyZXR1cm4gYSE9PUEmJmEhPT1udWxsfVxuZnVuY3Rpb24gUChhLGIsYyl7dmFyIGQsZTtpZih5YShiKSlzKGMpP2Euc2V0QXR0cmlidXRlKGIsYyk6YSYmYS5nZXRBdHRyaWJ1dGUmJihlPWEuZ2V0QXR0cmlidXRlKGIpKTtlbHNlIGlmKHMoYikmJiQoYikpZm9yKGQgaW4gYilhLnNldEF0dHJpYnV0ZShkLGJbZF0pO3JldHVybiBlfWZ1bmN0aW9uIHVhKGEpe3JldHVybiBGYShhKT9hOlthXX1mdW5jdGlvbiBSYShhLGIsYyl7aWYoYilyZXR1cm4gc2V0VGltZW91dChhLGIsYyk7YS5jYWxsKDAsYyl9ZnVuY3Rpb24gTShhLGIpe2lmKHphJiYhZ2EmJmImJmIub3BhY2l0eSE9PUEpYi5maWx0ZXI9XCJhbHBoYShvcGFjaXR5PVwiK2Iub3BhY2l0eSoxMDArXCIpXCI7eChhLnN0eWxlLGIpfWZ1bmN0aW9uIGRhKGEsYixjLGQsZSl7YT15LmNyZWF0ZUVsZW1lbnQoYSk7YiYmeChhLGIpO2UmJk0oYSx7cGFkZGluZzowLGJvcmRlcjpcIm5vbmVcIixtYXJnaW46MH0pO2MmJk0oYSxjKTtkJiZkLmFwcGVuZENoaWxkKGEpO3JldHVybiBhfWZ1bmN0aW9uIHNhKGEsXG5iKXt2YXIgYz1mdW5jdGlvbigpe307Yy5wcm90b3R5cGU9bmV3IGE7eChjLnByb3RvdHlwZSxiKTtyZXR1cm4gY31mdW5jdGlvbiBHYShhLGIsYyl7cmV0dXJuIEFycmF5KChifHwyKSsxLVN0cmluZyhhKS5sZW5ndGgpLmpvaW4oY3x8MCkrYX1mdW5jdGlvbiAkYShhKXtyZXR1cm4oYWImJmFiKGEpfHx0Ynx8MCkqNkU0fWZ1bmN0aW9uIE5hKGEsYil7Zm9yKHZhciBjPVwie1wiLGQ9ITEsZSxmLGcsaCxpLGo9W107KGM9YS5pbmRleE9mKGMpKSE9PS0xOyl7ZT1hLnNsaWNlKDAsYyk7aWYoZCl7Zj1lLnNwbGl0KFwiOlwiKTtnPWYuc2hpZnQoKS5zcGxpdChcIi5cIik7aT1nLmxlbmd0aDtlPWI7Zm9yKGg9MDtoPGk7aCsrKWU9ZVtnW2hdXTtpZihmLmxlbmd0aClmPWYuam9pbihcIjpcIiksZz0vXFwuKFswLTldKS8saD1VLmxhbmcsaT12b2lkIDAsL2YkLy50ZXN0KGYpPyhpPShpPWYubWF0Y2goZykpP2lbMV06LTEsZSE9PW51bGwmJihlPXUubnVtYmVyRm9ybWF0KGUsaSxoLmRlY2ltYWxQb2ludCxcbmYuaW5kZXhPZihcIixcIik+LTE/aC50aG91c2FuZHNTZXA6XCJcIikpKTplPVNhKGYsZSl9ai5wdXNoKGUpO2E9YS5zbGljZShjKzEpO2M9KGQ9IWQpP1wifVwiOlwie1wifWoucHVzaChhKTtyZXR1cm4gai5qb2luKFwiXCIpfWZ1bmN0aW9uIHViKGEpe3JldHVybiBaLnBvdygxMCxWKFoubG9nKGEpL1ouTE4xMCkpfWZ1bmN0aW9uIHZiKGEsYixjLGQsZSl7dmFyIGYsZz1hLGM9cChjLDEpO2Y9YS9jO2J8fChiPVsxLDIsMi41LDUsMTBdLGQ9PT0hMSYmKGM9PT0xP2I9WzEsMiw1LDEwXTpjPD0wLjEmJihiPVsxL2NdKSkpO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspaWYoZz1iW2RdLGUmJmcqYz49YXx8IWUmJmY8PShiW2RdKyhiW2QrMV18fGJbZF0pKS8yKWJyZWFrO2cqPWM7cmV0dXJuIGd9ZnVuY3Rpb24gamIoYSxiKXt2YXIgYz1hLmxlbmd0aCxkLGU7Zm9yKGU9MDtlPGM7ZSsrKWFbZV0uc2FmZUk9ZTthLnNvcnQoZnVuY3Rpb24oYSxjKXtkPWIoYSxjKTtyZXR1cm4gZD09PTA/YS5zYWZlSS1jLnNhZmVJOlxuZH0pO2ZvcihlPTA7ZTxjO2UrKylkZWxldGUgYVtlXS5zYWZlSX1mdW5jdGlvbiBPYShhKXtmb3IodmFyIGI9YS5sZW5ndGgsYz1hWzBdO2ItLTspYVtiXTxjJiYoYz1hW2JdKTtyZXR1cm4gY31mdW5jdGlvbiBIYShhKXtmb3IodmFyIGI9YS5sZW5ndGgsYz1hWzBdO2ItLTspYVtiXT5jJiYoYz1hW2JdKTtyZXR1cm4gY31mdW5jdGlvbiBUYShhLGIpe2Zvcih2YXIgYyBpbiBhKWFbY10mJmFbY10hPT1iJiZhW2NdLmRlc3Ryb3kmJmFbY10uZGVzdHJveSgpLGRlbGV0ZSBhW2NdfWZ1bmN0aW9uIFVhKGEpe2tifHwoa2I9ZGEoUGEpKTthJiZrYi5hcHBlbmRDaGlsZChhKTtrYi5pbm5lckhUTUw9XCJcIn1mdW5jdGlvbiBhYShhLGIpe3JldHVybiBwYXJzZUZsb2F0KGEudG9QcmVjaXNpb24oYnx8MTQpKX1mdW5jdGlvbiBWYShhLGIpe2IucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uPXAoYSxiLmFuaW1hdGlvbil9ZnVuY3Rpb24gYmIoYSl7cmV0dXJuICQoYSk/RShhKTp7ZHVyYXRpb246YT9cbjUwMDowfX1mdW5jdGlvbiBHYigpe3ZhciBhPVUuZ2xvYmFsLGI9YS51c2VVVEMsYz1iP1wiZ2V0VVRDXCI6XCJnZXRcIixkPWI/XCJzZXRVVENcIjpcInNldFwiO21hPWEuRGF0ZXx8RC5EYXRlO3RiPWImJmEudGltZXpvbmVPZmZzZXQ7YWI9YiYmYS5nZXRUaW1lem9uZU9mZnNldDtsYj1mdW5jdGlvbihhLGMsZCxoLGksail7dmFyIGs7Yj8oaz1tYS5VVEMuYXBwbHkoMCxhcmd1bWVudHMpLGsrPSRhKGspKTprPShuZXcgbWEoYSxjLHAoZCwxKSxwKGgsMCkscChpLDApLHAoaiwwKSkpLmdldFRpbWUoKTtyZXR1cm4ga307d2I9YytcIk1pbnV0ZXNcIjt4Yj1jK1wiSG91cnNcIjt5Yj1jK1wiRGF5XCI7V2E9YytcIkRhdGVcIjtjYj1jK1wiTW9udGhcIjtkYj1jK1wiRnVsbFllYXJcIjtIYj1kK1wiTWlsbGlzZWNvbmRzXCI7SWI9ZCtcIlNlY29uZHNcIjtKYj1kK1wiTWludXRlc1wiO0tiPWQrXCJIb3Vyc1wiO21iPWQrXCJEYXRlXCI7emI9ZCtcIk1vbnRoXCI7QWI9ZCtcIkZ1bGxZZWFyXCJ9ZnVuY3Rpb24gbmEoYSl7aWYoISh0aGlzIGluc3RhbmNlb2Zcbm5hKSlyZXR1cm4gbmV3IG5hKGEpO3RoaXMuaW5pdChhKX1mdW5jdGlvbiBPKCl7fWZ1bmN0aW9uIFhhKGEsYixjLGQpe3RoaXMuYXhpcz1hO3RoaXMucG9zPWI7dGhpcy50eXBlPWN8fFwiXCI7dGhpcy5pc05ldz0hMDshYyYmIWQmJnRoaXMuYWRkTGFiZWwoKX1mdW5jdGlvbiBMYihhLGIsYyxkLGUpe3ZhciBmPWEuY2hhcnQuaW52ZXJ0ZWQ7dGhpcy5heGlzPWE7dGhpcy5pc05lZ2F0aXZlPWM7dGhpcy5vcHRpb25zPWI7dGhpcy54PWQ7dGhpcy50b3RhbD1udWxsO3RoaXMucG9pbnRzPXt9O3RoaXMuc3RhY2s9ZTt0aGlzLnJpZ2h0Q2xpZmY9dGhpcy5sZWZ0Q2xpZmY9MDt0aGlzLmFsaWduT3B0aW9ucz17YWxpZ246Yi5hbGlnbnx8KGY/Yz9cImxlZnRcIjpcInJpZ2h0XCI6XCJjZW50ZXJcIiksdmVydGljYWxBbGlnbjpiLnZlcnRpY2FsQWxpZ258fChmP1wibWlkZGxlXCI6Yz9cImJvdHRvbVwiOlwidG9wXCIpLHk6cChiLnksZj80OmM/MTQ6LTYpLHg6cChiLngsZj9jPy02OjY6MCl9O3RoaXMudGV4dEFsaWduPVxuYi50ZXh0QWxpZ258fChmP2M/XCJyaWdodFwiOlwibGVmdFwiOlwiY2VudGVyXCIpfXZhciBBLHk9RC5kb2N1bWVudCxaPU1hdGgsQz1aLnJvdW5kLFY9Wi5mbG9vcix2YT1aLmNlaWwsdD1aLm1heCxGPVoubWluLFE9Wi5hYnMsVz1aLmNvcyxlYT1aLnNpbix0YT1aLlBJLGthPXRhKjIvMzYwLEFhPUQubmF2aWdhdG9yJiZELm5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCIsTWI9RC5vcGVyYSx6YT0vKG1zaWV8dHJpZGVudHxlZGdlKS9pLnRlc3QoQWEpJiYhTWIsbmI9eSYmeS5kb2N1bWVudE1vZGU9PT04LG9iPSF6YSYmL0FwcGxlV2ViS2l0Ly50ZXN0KEFhKSxRYT0vRmlyZWZveC8udGVzdChBYSksTmI9LyhNb2JpbGV8QW5kcm9pZHxXaW5kb3dzIFBob25lKS8udGVzdChBYSksSWE9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLGdhPXkmJnkuY3JlYXRlRWxlbWVudE5TJiYhIXkuY3JlYXRlRWxlbWVudE5TKElhLFwic3ZnXCIpLmNyZWF0ZVNWR1JlY3QsUmI9UWEmJnBhcnNlSW50KEFhLnNwbGl0KFwiRmlyZWZveC9cIilbMV0sXG4xMCk8NCxsYT15JiYhZ2EmJiF6YSYmISF5LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dCxlYixmYixPYj17fSxCYj0wLGtiLFUsU2EsSCxCYT1mdW5jdGlvbigpe30sVD1bXSxnYj0wLFBhPVwiZGl2XCIsWD1cIk1cIixTPVwiTFwiLFNiPS9eWzAtOV0rJC8scGI9W1wicGxvdFRvcFwiLFwibWFyZ2luUmlnaHRcIixcIm1hcmdpbkJvdHRvbVwiLFwicGxvdExlZnRcIl0sbWEsbGIsdGIsYWIsd2IseGIseWIsV2EsY2IsZGIsSGIsSWIsSmIsS2IsbWIsemIsQWIsTD17fSx1O3U9RC5IaWdoY2hhcnRzP2NhKDE2LCEwKTp7d2luOkR9O3Uuc2VyaWVzVHlwZXM9TDt2YXIgSmE9W10sb2EscGEscSxDYSxDYixEYSxOLFksSSxZYSxLYTtzYi5wcm90b3R5cGU9e2RTZXR0ZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnBhdGhzWzBdLGI9dGhpcy5wYXRoc1sxXSxjPVtdLGQ9dGhpcy5ub3csZT1hLmxlbmd0aCxmO2lmKGQ9PT0xKWM9dGhpcy50b0Q7ZWxzZSBpZihlPT09Yi5sZW5ndGgmJmQ8MSlmb3IoO2UtLTspZj1cbnBhcnNlRmxvYXQoYVtlXSksY1tlXT1pc05hTihmKT9hW2VdOmQqcGFyc2VGbG9hdChiW2VdLWYpK2Y7ZWxzZSBjPWI7dGhpcy5lbGVtLmF0dHIoXCJkXCIsYyl9LHVwZGF0ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbSxiPXRoaXMucHJvcCxjPXRoaXMubm93LGQ9dGhpcy5vcHRpb25zLnN0ZXA7aWYodGhpc1tiK1wiU2V0dGVyXCJdKXRoaXNbYitcIlNldHRlclwiXSgpO2Vsc2UgYS5hdHRyP2EuZWxlbWVudCYmYS5hdHRyKGIsYyk6YS5zdHlsZVtiXT1jK3RoaXMudW5pdDtkJiZkLmNhbGwoYSxjLHRoaXMpfSxydW46ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMsZT1mdW5jdGlvbihhKXtyZXR1cm4gZS5zdG9wcGVkPyExOmQuc3RlcChhKX0sZjt0aGlzLnN0YXJ0VGltZT0rbmV3IG1hO3RoaXMuc3RhcnQ9YTt0aGlzLmVuZD1iO3RoaXMudW5pdD1jO3RoaXMubm93PXRoaXMuc3RhcnQ7dGhpcy5wb3M9MDtlLmVsZW09dGhpcy5lbGVtO2lmKGUoKSYmSmEucHVzaChlKT09PTEpZS50aW1lcklkPVxuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtmb3IoZj0wO2Y8SmEubGVuZ3RoO2YrKylKYVtmXSgpfHxKYS5zcGxpY2UoZi0tLDEpO0phLmxlbmd0aHx8Y2xlYXJJbnRlcnZhbChlLnRpbWVySWQpfSwxMyl9LHN0ZXA6ZnVuY3Rpb24oYSl7dmFyIGI9K25ldyBtYSxjLGQ9dGhpcy5vcHRpb25zO2M9dGhpcy5lbGVtO3ZhciBlPWQuY29tcGxldGUsZj1kLmR1cmF0aW9uLGc9ZC5jdXJBbmltLGg7aWYoYy5hdHRyJiYhYy5lbGVtZW50KWM9ITE7ZWxzZSBpZihhfHxiPj1mK3RoaXMuc3RhcnRUaW1lKXt0aGlzLm5vdz10aGlzLmVuZDt0aGlzLnBvcz0xO3RoaXMudXBkYXRlKCk7YT1nW3RoaXMucHJvcF09ITA7Zm9yKGggaW4gZylnW2hdIT09ITAmJihhPSExKTthJiZlJiZlLmNhbGwoYyk7Yz0hMX1lbHNlIHRoaXMucG9zPWQuZWFzaW5nKChiLXRoaXMuc3RhcnRUaW1lKS9mKSx0aGlzLm5vdz10aGlzLnN0YXJ0Kyh0aGlzLmVuZC10aGlzLnN0YXJ0KSp0aGlzLnBvcyx0aGlzLnVwZGF0ZSgpLGM9XG4hMDtyZXR1cm4gY30saW5pdFBhdGg6ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSl7Zm9yKG49YS5sZW5ndGg7bi0tOykoYVtuXT09PVh8fGFbbl09PT1TKSYmYS5zcGxpY2UobisxLDAsYVtuKzFdLGFbbisyXSxhW24rMV0sYVtuKzJdKX1mdW5jdGlvbiBlKGEsYil7Zm9yKDthLmxlbmd0aDxsOyl7YVswXT1iW2wtYS5sZW5ndGhdO3ZhciBjPWEuc2xpY2UoMCxrKTtbXS5zcGxpY2UuYXBwbHkoYSxbMCwwXS5jb25jYXQoYykpO28mJihjPWEuc2xpY2UoYS5sZW5ndGgtayksW10uc3BsaWNlLmFwcGx5KGEsW2EubGVuZ3RoLDBdLmNvbmNhdChjKSksbi0tKX1hWzBdPVwiTVwifWZ1bmN0aW9uIGYoYSxiKXtmb3IodmFyIGM9KGwtYS5sZW5ndGgpL2s7Yz4wJiZjLS07KW09YS5zbGljZSgpLnNwbGljZShhLmxlbmd0aC96LWssayp6KSxtWzBdPWJbbC1rLWMqa10saiYmKG1bay02XT1tW2stMl0sbVtrLTVdPW1bay0xXSksW10uc3BsaWNlLmFwcGx5KGEsW2EubGVuZ3RoL3osMF0uY29uY2F0KG0pKSxcbm8mJmMtLX12YXIgYj1ifHxcIlwiLGcsaD1hLnN0YXJ0WCxpPWEuZW5kWCxqPWIuaW5kZXhPZihcIkNcIik+LTEsaz1qPzc6MyxsLG0sbixiPWIuc3BsaXQoXCIgXCIpLGM9Yy5zbGljZSgpLG89YS5pc0FyZWEsej1vPzI6MSxyO2omJihkKGIpLGQoYykpO2lmKGgmJmkpe2ZvcihuPTA7bjxoLmxlbmd0aDtuKyspaWYoaFtuXT09PWlbMF0pe2c9bjticmVha31lbHNlIGlmKGhbMF09PT1pW2kubGVuZ3RoLWgubGVuZ3RoK25dKXtnPW47cj0hMDticmVha31nPT09dm9pZCAwJiYoYj1bXSl9Yi5sZW5ndGgmJnUuaXNOdW1iZXIoZykmJihsPWMubGVuZ3RoK2cqeiprLHI/KGUoYixjKSxmKGMsYikpOihlKGMsYiksZihiLGMpKSk7cmV0dXJuW2IsY119fTt2YXIgeD11LmV4dGVuZD1mdW5jdGlvbihhLGIpe3ZhciBjO2F8fChhPXt9KTtmb3IoYyBpbiBiKWFbY109YltjXTtyZXR1cm4gYX0sJD11LmlzT2JqZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEmJnR5cGVvZiBhPT09XCJvYmplY3RcIiYmKCFifHwhRmEoYSkpfSxcbko9dS5pc051bWJlcj1mdW5jdGlvbihhKXtyZXR1cm4gdHlwZW9mIGE9PT1cIm51bWJlclwiJiYhaXNOYU4oYSl9LHA9dS5waWNrPWZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzLGIsYyxkPWEubGVuZ3RoO2ZvcihiPTA7YjxkO2IrKylpZihjPWFbYl0sYyE9PUEmJmMhPT1udWxsKXJldHVybiBjfSxoYj11LndyYXA9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWFbYl07YVtiXT1mdW5jdGlvbigpe3ZhciBhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7YS51bnNoaWZ0KGQpO3JldHVybiBjLmFwcGx5KHRoaXMsYSl9fTtTYT1mdW5jdGlvbihhLGIsYyl7aWYoIXMoYil8fGlzTmFOKGIpKXJldHVybiBVLmxhbmcuaW52YWxpZERhdGV8fFwiXCI7dmFyIGE9cChhLFwiJVktJW0tJWQgJUg6JU06JVNcIiksZD1uZXcgbWEoYi0kYShiKSksZSxmPWRbeGJdKCksZz1kW3liXSgpLGg9ZFtXYV0oKSxpPWRbY2JdKCksaj1kW2RiXSgpLGs9VS5sYW5nLGw9ay53ZWVrZGF5cyxtPWsuc2hvcnRXZWVrZGF5cyxcbmQ9eCh7YTptP21bZ106bFtnXS5zdWJzdHIoMCwzKSxBOmxbZ10sZDpHYShoKSxlOkdhKGgsMixcIiBcIiksdzpnLGI6ay5zaG9ydE1vbnRoc1tpXSxCOmsubW9udGhzW2ldLG06R2EoaSsxKSx5OmoudG9TdHJpbmcoKS5zdWJzdHIoMiwyKSxZOmosSDpHYShmKSxrOmYsSTpHYShmJTEyfHwxMiksbDpmJTEyfHwxMixNOkdhKGRbd2JdKCkpLHA6ZjwxMj9cIkFNXCI6XCJQTVwiLFA6ZjwxMj9cImFtXCI6XCJwbVwiLFM6R2EoZC5nZXRTZWNvbmRzKCkpLEw6R2EoQyhiJTFFMyksMyl9LHUuZGF0ZUZvcm1hdHMpO2ZvcihlIGluIGQpZm9yKDthLmluZGV4T2YoXCIlXCIrZSkhPT0tMTspYT1hLnJlcGxhY2UoXCIlXCIrZSx0eXBlb2YgZFtlXT09PVwiZnVuY3Rpb25cIj9kW2VdKGIpOmRbZV0pO3JldHVybiBjP2Euc3Vic3RyKDAsMSkudG9VcHBlckNhc2UoKSthLnN1YnN0cigxKTphfTtIPXttaWxsaXNlY29uZDoxLHNlY29uZDoxRTMsbWludXRlOjZFNCxob3VyOjM2RTUsZGF5Ojg2NEU1LHdlZWs6NjA0OEU1LG1vbnRoOjI0MTkyRTUsXG55ZWFyOjMxNDQ5NkU1fTt1Lm51bWJlckZvcm1hdD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgYT0rYXx8MCxiPStiLGU9VS5sYW5nLGY9KGEudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV18fFwiXCIpLmxlbmd0aCxnLGgsaT1NYXRoLmFicyhhKTtiPT09LTE/Yj1NYXRoLm1pbihmLDIwKTpKKGIpfHwoYj0yKTtnPVN0cmluZyhCKGkudG9GaXhlZChiKSkpO2g9Zy5sZW5ndGg+Mz9nLmxlbmd0aCUzOjA7Yz1wKGMsZS5kZWNpbWFsUG9pbnQpO2Q9cChkLGUudGhvdXNhbmRzU2VwKTthPWE8MD9cIi1cIjpcIlwiO2ErPWg/Zy5zdWJzdHIoMCxoKStkOlwiXCI7YSs9Zy5zdWJzdHIoaCkucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csXCIkMVwiK2QpO2ImJihkPU1hdGguYWJzKGktZytNYXRoLnBvdygxMCwtTWF0aC5tYXgoYixmKS0xKSksYSs9YytkLnRvRml4ZWQoYikuc2xpY2UoMikpO3JldHVybiBhfTtNYXRoLmVhc2VJbk91dFNpbmU9ZnVuY3Rpb24oYSl7cmV0dXJuLTAuNSooTWF0aC5jb3MoTWF0aC5QSSphKS1cbjEpfTtvYT1mdW5jdGlvbihhLGIpe3ZhciBjO2lmKGI9PT1cIndpZHRoXCIpcmV0dXJuIE1hdGgubWluKGEub2Zmc2V0V2lkdGgsYS5zY3JvbGxXaWR0aCktb2EoYSxcInBhZGRpbmctbGVmdFwiKS1vYShhLFwicGFkZGluZy1yaWdodFwiKTtlbHNlIGlmKGI9PT1cImhlaWdodFwiKXJldHVybiBNYXRoLm1pbihhLm9mZnNldEhlaWdodCxhLnNjcm9sbEhlaWdodCktb2EoYSxcInBhZGRpbmctdG9wXCIpLW9hKGEsXCJwYWRkaW5nLWJvdHRvbVwiKTtyZXR1cm4oYz1ELmdldENvbXB1dGVkU3R5bGUoYSx2b2lkIDApKSYmQihjLmdldFByb3BlcnR5VmFsdWUoYikpfTtwYT1mdW5jdGlvbihhLGIpe3JldHVybiBiLmluZGV4T2Y/Yi5pbmRleE9mKGEpOltdLmluZGV4T2YuY2FsbChiLGEpfTtDYT1mdW5jdGlvbihhLGIpe3JldHVybltdLmZpbHRlci5jYWxsKGEsYil9O0RhPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdLGQ9MCxlPWEubGVuZ3RoO2Q8ZTtkKyspY1tkXT1iLmNhbGwoYVtkXSxhW2RdLGQsYSk7cmV0dXJuIGN9O1xuQ2I9ZnVuY3Rpb24oYSl7dmFyIGI9eS5kb2N1bWVudEVsZW1lbnQsYT1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt0b3A6YS50b3ArKEQucGFnZVlPZmZzZXR8fGIuc2Nyb2xsVG9wKS0oYi5jbGllbnRUb3B8fDApLGxlZnQ6YS5sZWZ0KyhELnBhZ2VYT2Zmc2V0fHxiLnNjcm9sbExlZnQpLShiLmNsaWVudExlZnR8fDApfX07S2E9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPUphLmxlbmd0aDtiLS07KWlmKEphW2JdLmVsZW09PT1hKUphW2JdLnN0b3BwZWQ9ITB9O3E9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhLGIpfTtOPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGIpe2IudGFyZ2V0PWIuc3JjRWxlbWVudHx8RDtjLmNhbGwoYSxiKX12YXIgZT1hLmhjRXZlbnRzPWEuaGNFdmVudHN8fHt9O2lmKGEuYWRkRXZlbnRMaXN0ZW5lcilhLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKTtlbHNlIGlmKGEuYXR0YWNoRXZlbnQpe2lmKCFhLmhjRXZlbnRzSUUpYS5oY0V2ZW50c0lFPVxue307YS5oY0V2ZW50c0lFW2MudG9TdHJpbmcoKV09ZDthLmF0dGFjaEV2ZW50KFwib25cIitiLGQpfWVbYl18fChlW2JdPVtdKTtlW2JdLnB1c2goYyl9O1k9ZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYixjKXthLnJlbW92ZUV2ZW50TGlzdGVuZXI/YS5yZW1vdmVFdmVudExpc3RlbmVyKGIsYywhMSk6YS5hdHRhY2hFdmVudCYmKGM9YS5oY0V2ZW50c0lFW2MudG9TdHJpbmcoKV0sYS5kZXRhY2hFdmVudChcIm9uXCIrYixjKSl9ZnVuY3Rpb24gZSgpe3ZhciBjLGUsZjtpZihhLm5vZGVOYW1lKWZvcihmIGluIGI/KGM9e30sY1tiXT0hMCk6Yz1nLGMpaWYoZ1tmXSlmb3IoZT1nW2ZdLmxlbmd0aDtlLS07KWQoZixnW2ZdW2VdKX12YXIgZixnPWEuaGNFdmVudHMsaDtpZihnKWI/KGY9Z1tiXXx8W10sYz8oaD1wYShjLGYpLGg+LTEmJihmLnNwbGljZShoLDEpLGdbYl09ZiksZChiLGMpKTooZSgpLGdbYl09W10pKTooZSgpLGEuaGNFdmVudHM9e30pfTtJPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlO1xuZT1hLmhjRXZlbnRzO3ZhciBmLGcsYz1jfHx7fTtpZih5LmNyZWF0ZUV2ZW50JiYoYS5kaXNwYXRjaEV2ZW50fHxhLmZpcmVFdmVudCkpZT15LmNyZWF0ZUV2ZW50KFwiRXZlbnRzXCIpLGUuaW5pdEV2ZW50KGIsITAsITApLGUudGFyZ2V0PWEseChlLGMpLGEuZGlzcGF0Y2hFdmVudD9hLmRpc3BhdGNoRXZlbnQoZSk6YS5maXJlRXZlbnQoYixlKTtlbHNlIGlmKGUpe2U9ZVtiXXx8W107Zj1lLmxlbmd0aDtpZighYy5wcmV2ZW50RGVmYXVsdCljLnByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKCl7Yy5kZWZhdWx0UHJldmVudGVkPSEwfTtjLnRhcmdldD1hO2lmKCFjLnR5cGUpYy50eXBlPWI7Zm9yKGI9MDtiPGY7YisrKShnPWVbYl0pJiZnLmNhbGwoYSxjKT09PSExJiZjLnByZXZlbnREZWZhdWx0KCl9ZCYmIWMuZGVmYXVsdFByZXZlbnRlZCYmZChjKX07WWE9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU9XCJcIixmLGcsaDskKGMpfHwoZD1hcmd1bWVudHMsYz17ZHVyYXRpb246ZFsyXSxlYXNpbmc6ZFszXSxcbmNvbXBsZXRlOmRbNF19KTtpZighSihjLmR1cmF0aW9uKSljLmR1cmF0aW9uPTQwMDtjLmVhc2luZz10eXBlb2YgYy5lYXNpbmc9PT1cImZ1bmN0aW9uXCI/Yy5lYXNpbmc6TWF0aFtjLmVhc2luZ118fE1hdGguZWFzZUluT3V0U2luZTtjLmN1ckFuaW09RShiKTtmb3IoaCBpbiBiKWc9bmV3IHNiKGEsYyxoKSxmPW51bGwsaD09PVwiZFwiPyhnLnBhdGhzPWcuaW5pdFBhdGgoYSxhLmQsYi5kKSxnLnRvRD1iLmQsZD0wLGY9MSk6YS5hdHRyP2Q9YS5hdHRyKGgpOihkPXBhcnNlRmxvYXQob2EoYSxoKSl8fDAsaCE9PVwib3BhY2l0eVwiJiYoZT1cInB4XCIpKSxmfHwoZj1iW2hdKSxmLm1hdGNoJiZmLm1hdGNoKFwicHhcIikmJihmPWYucmVwbGFjZSgvcHgvZyxcIlwiKSksZy5ydW4oZCxmLGUpfTtpZihELmpRdWVyeSlELmpRdWVyeS5mbi5oaWdoY2hhcnRzPWZ1bmN0aW9uKCl7dmFyIGE9W10uc2xpY2UuY2FsbChhcmd1bWVudHMpO2lmKHRoaXNbMF0pcmV0dXJuIGFbMF0/KG5ldyAodVt5YShhWzBdKT9hLnNoaWZ0KCk6XG5cIkNoYXJ0XCJdKSh0aGlzWzBdLGFbMF0sYVsxXSksdGhpcyk6VFtQKHRoaXNbMF0sXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIildfTt5JiYheS5kZWZhdWx0VmlldyYmKG9hPWZ1bmN0aW9uKGEsYil7dmFyIGM7Yz17d2lkdGg6XCJjbGllbnRXaWR0aFwiLGhlaWdodDpcImNsaWVudEhlaWdodFwifVtiXTtpZihhLnN0eWxlW2JdKXJldHVybiBCKGEuc3R5bGVbYl0pO2I9PT1cIm9wYWNpdHlcIiYmKGI9XCJmaWx0ZXJcIik7aWYoYylyZXR1cm4gYS5zdHlsZS56b29tPTEsTWF0aC5tYXgoYVtjXS0yKm9hKGEsXCJwYWRkaW5nXCIpLDApO2M9YS5jdXJyZW50U3R5bGVbYi5yZXBsYWNlKC9cXC0oXFx3KS9nLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudG9VcHBlckNhc2UoKX0pXTtiPT09XCJmaWx0ZXJcIiYmKGM9Yy5yZXBsYWNlKC9hbHBoYVxcKG9wYWNpdHk9KFswLTldKylcXCkvLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIvMTAwfSkpO3JldHVybiBjPT09XCJcIj8xOkIoYyl9KTtBcnJheS5wcm90b3R5cGUuZm9yRWFjaHx8XG4ocT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGg7YzxkO2MrKylpZihiLmNhbGwoYVtjXSxhW2NdLGMsYSk9PT0hMSlyZXR1cm4gY30pO0FycmF5LnByb3RvdHlwZS5pbmRleE9mfHwocGE9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPTA7aWYoYilmb3IoYz1iLmxlbmd0aDtkPGM7ZCsrKWlmKGJbZF09PT1hKXJldHVybiBkO3JldHVybi0xfSk7QXJyYXkucHJvdG90eXBlLmZpbHRlcnx8KENhPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdLGQ9MCxlPWEubGVuZ3RoO2Q8ZTtkKyspYihhW2RdLGQpJiZjLnB1c2goYVtkXSk7cmV0dXJuIGN9KTt1LkZ4PXNiO3UuaW5BcnJheT1wYTt1LmVhY2g9cTt1LmdyZXA9Q2E7dS5vZmZzZXQ9Q2I7dS5tYXA9RGE7dS5hZGRFdmVudD1OO3UucmVtb3ZlRXZlbnQ9WTt1LmZpcmVFdmVudD1JO3UuYW5pbWF0ZT1ZYTt1LmFuaW1PYmplY3Q9YmI7dS5zdG9wPUthO1U9e2NvbG9yczpcIiM3Y2I1ZWMsIzQzNDM0OCwjOTBlZDdkLCNmN2EzNWMsIzgwODVlOSwjZjE1YzgwLCNlNGQzNTQsIzJiOTA4ZiwjZjQ1YjViLCM5MWU4ZTFcIi5zcGxpdChcIixcIiksXG5zeW1ib2xzOltcImNpcmNsZVwiLFwiZGlhbW9uZFwiLFwic3F1YXJlXCIsXCJ0cmlhbmdsZVwiLFwidHJpYW5nbGUtZG93blwiXSxsYW5nOntsb2FkaW5nOlwiTG9hZGluZy4uLlwiLG1vbnRoczpcIkphbnVhcnksRmVicnVhcnksTWFyY2gsQXByaWwsTWF5LEp1bmUsSnVseSxBdWd1c3QsU2VwdGVtYmVyLE9jdG9iZXIsTm92ZW1iZXIsRGVjZW1iZXJcIi5zcGxpdChcIixcIiksc2hvcnRNb250aHM6XCJKYW4sRmViLE1hcixBcHIsTWF5LEp1bixKdWwsQXVnLFNlcCxPY3QsTm92LERlY1wiLnNwbGl0KFwiLFwiKSx3ZWVrZGF5czpcIlN1bmRheSxNb25kYXksVHVlc2RheSxXZWRuZXNkYXksVGh1cnNkYXksRnJpZGF5LFNhdHVyZGF5XCIuc3BsaXQoXCIsXCIpLGRlY2ltYWxQb2ludDpcIi5cIixudW1lcmljU3ltYm9sczpcImssTSxHLFQsUCxFXCIuc3BsaXQoXCIsXCIpLHJlc2V0Wm9vbTpcIlJlc2V0IHpvb21cIixyZXNldFpvb21UaXRsZTpcIlJlc2V0IHpvb20gbGV2ZWwgMToxXCIsdGhvdXNhbmRzU2VwOlwiIFwifSxnbG9iYWw6e3VzZVVUQzohMCxcbmNhbnZhc1Rvb2xzVVJMOlwiaHR0cDovL2NvZGUuaGlnaGNoYXJ0cy5jb20vbW9kdWxlcy9jYW52YXMtdG9vbHMuanNcIixWTUxSYWRpYWxHcmFkaWVudFVSTDpcImh0dHA6Ly9jb2RlLmhpZ2hjaGFydHMuY29tLzQuMi42L2dmeC92bWwtcmFkaWFsLWdyYWRpZW50LnBuZ1wifSxjaGFydDp7Ym9yZGVyQ29sb3I6XCIjNDU3MkE3XCIsYm9yZGVyUmFkaXVzOjAsZGVmYXVsdFNlcmllc1R5cGU6XCJsaW5lXCIsaWdub3JlSGlkZGVuU2VyaWVzOiEwLHNwYWNpbmc6WzEwLDEwLDE1LDEwXSxiYWNrZ3JvdW5kQ29sb3I6XCIjRkZGRkZGXCIscGxvdEJvcmRlckNvbG9yOlwiI0MwQzBDMFwiLHJlc2V0Wm9vbUJ1dHRvbjp7dGhlbWU6e3pJbmRleDoyMH0scG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4Oi0xMCx5OjEwfX0sd2lkdGg6bnVsbCxoZWlnaHQ6bnVsbH0sdGl0bGU6e3RleHQ6XCJDaGFydCB0aXRsZVwiLGFsaWduOlwiY2VudGVyXCIsbWFyZ2luOjE1LHN0eWxlOntjb2xvcjpcIiMzMzMzMzNcIixmb250U2l6ZTpcIjE4cHhcIn0sXG53aWR0aEFkanVzdDotNDR9LHN1YnRpdGxlOnt0ZXh0OlwiXCIsYWxpZ246XCJjZW50ZXJcIixzdHlsZTp7Y29sb3I6XCIjNTU1NTU1XCJ9LHdpZHRoQWRqdXN0Oi00NH0scGxvdE9wdGlvbnM6e2xpbmU6e2FsbG93UG9pbnRTZWxlY3Q6ITEsc2hvd0NoZWNrYm94OiExLGFuaW1hdGlvbjp7ZHVyYXRpb246MUUzfSxldmVudHM6e30sbGluZVdpZHRoOjIsbWFya2VyOntsaW5lV2lkdGg6MCxyYWRpdXM6NCxsaW5lQ29sb3I6XCIjRkZGRkZGXCIsc3RhdGVzOntob3Zlcjp7ZW5hYmxlZDohMCxsaW5lV2lkdGhQbHVzOjEscmFkaXVzUGx1czoyfSxzZWxlY3Q6e2ZpbGxDb2xvcjpcIiNGRkZGRkZcIixsaW5lQ29sb3I6XCIjMDAwMDAwXCIsbGluZVdpZHRoOjJ9fX0scG9pbnQ6e2V2ZW50czp7fX0sZGF0YUxhYmVsczp7YWxpZ246XCJjZW50ZXJcIixmb3JtYXR0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy55PT09bnVsbD9cIlwiOnUubnVtYmVyRm9ybWF0KHRoaXMueSwtMSl9LHN0eWxlOntjb2xvcjpcImNvbnRyYXN0XCIsXG5mb250U2l6ZTpcIjExcHhcIixmb250V2VpZ2h0OlwiYm9sZFwiLHRleHRTaGFkb3c6XCIwIDAgNnB4IGNvbnRyYXN0LCAwIDAgM3B4IGNvbnRyYXN0XCJ9LHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix4OjAseTowLHBhZGRpbmc6NX0sY3JvcFRocmVzaG9sZDozMDAscG9pbnRSYW5nZTowLHNvZnRUaHJlc2hvbGQ6ITAsc3RhdGVzOntob3Zlcjp7bGluZVdpZHRoUGx1czoxLG1hcmtlcjp7fSxoYWxvOntzaXplOjEwLG9wYWNpdHk6MC4yNX19LHNlbGVjdDp7bWFya2VyOnt9fX0sc3RpY2t5VHJhY2tpbmc6ITAsdHVyYm9UaHJlc2hvbGQ6MUUzfX0sbGFiZWxzOntzdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLGNvbG9yOlwiIzNFNTc2RlwifX0sbGVnZW5kOntlbmFibGVkOiEwLGFsaWduOlwiY2VudGVyXCIsbGF5b3V0OlwiaG9yaXpvbnRhbFwiLGxhYmVsRm9ybWF0dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZX0sYm9yZGVyQ29sb3I6XCIjOTA5MDkwXCIsYm9yZGVyUmFkaXVzOjAsbmF2aWdhdGlvbjp7YWN0aXZlQ29sb3I6XCIjMjc0YjZkXCIsXG5pbmFjdGl2ZUNvbG9yOlwiI0NDQ1wifSxzaGFkb3c6ITEsaXRlbVN0eWxlOntjb2xvcjpcIiMzMzMzMzNcIixmb250U2l6ZTpcIjEycHhcIixmb250V2VpZ2h0OlwiYm9sZFwifSxpdGVtSG92ZXJTdHlsZTp7Y29sb3I6XCIjMDAwXCJ9LGl0ZW1IaWRkZW5TdHlsZTp7Y29sb3I6XCIjQ0NDXCJ9LGl0ZW1DaGVja2JveFN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsd2lkdGg6XCIxM3B4XCIsaGVpZ2h0OlwiMTNweFwifSxzeW1ib2xQYWRkaW5nOjUsdmVydGljYWxBbGlnbjpcImJvdHRvbVwiLHg6MCx5OjAsdGl0bGU6e3N0eWxlOntmb250V2VpZ2h0OlwiYm9sZFwifX19LGxvYWRpbmc6e2xhYmVsU3R5bGU6e2ZvbnRXZWlnaHQ6XCJib2xkXCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLHRvcDpcIjQ1JVwifSxzdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLGJhY2tncm91bmRDb2xvcjpcIndoaXRlXCIsb3BhY2l0eTowLjUsdGV4dEFsaWduOlwiY2VudGVyXCJ9fSx0b29sdGlwOntlbmFibGVkOiEwLGFuaW1hdGlvbjpnYSxiYWNrZ3JvdW5kQ29sb3I6XCJyZ2JhKDI0OSwgMjQ5LCAyNDksIC44NSlcIixcbmJvcmRlcldpZHRoOjEsYm9yZGVyUmFkaXVzOjMsZGF0ZVRpbWVMYWJlbEZvcm1hdHM6e21pbGxpc2Vjb25kOlwiJUEsICViICVlLCAlSDolTTolUy4lTFwiLHNlY29uZDpcIiVBLCAlYiAlZSwgJUg6JU06JVNcIixtaW51dGU6XCIlQSwgJWIgJWUsICVIOiVNXCIsaG91cjpcIiVBLCAlYiAlZSwgJUg6JU1cIixkYXk6XCIlQSwgJWIgJWUsICVZXCIsd2VlazpcIldlZWsgZnJvbSAlQSwgJWIgJWUsICVZXCIsbW9udGg6XCIlQiAlWVwiLHllYXI6XCIlWVwifSxmb290ZXJGb3JtYXQ6XCJcIixoZWFkZXJGb3JtYXQ6JzxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxMHB4XCI+e3BvaW50LmtleX08L3NwYW4+PGJyLz4nLHBvaW50Rm9ybWF0Oic8c3BhbiBzdHlsZT1cImNvbG9yOntwb2ludC5jb2xvcn1cIj5cXHUyNWNmPC9zcGFuPiB7c2VyaWVzLm5hbWV9OiA8Yj57cG9pbnQueX08L2I+PGJyLz4nLHNoYWRvdzohMCxzbmFwOk5iPzI1OjEwLHN0eWxlOntjb2xvcjpcIiMzMzMzMzNcIixjdXJzb3I6XCJkZWZhdWx0XCIsZm9udFNpemU6XCIxMnB4XCIsXG5wYWRkaW5nOlwiOHB4XCIscG9pbnRlckV2ZW50czpcIm5vbmVcIix3aGl0ZVNwYWNlOlwibm93cmFwXCJ9fSxjcmVkaXRzOntlbmFibGVkOiEwLHRleHQ6XCJIaWdoY2hhcnRzLmNvbVwiLGhyZWY6XCJodHRwOi8vd3d3LmhpZ2hjaGFydHMuY29tXCIscG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4Oi0xMCx2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCIseTotNX0sc3R5bGU6e2N1cnNvcjpcInBvaW50ZXJcIixjb2xvcjpcIiM5MDkwOTBcIixmb250U2l6ZTpcIjlweFwifX19O3ZhciBmYT1VLnBsb3RPcHRpb25zLGhhPWZhLmxpbmU7R2IoKTtuYS5wcm90b3R5cGU9e3BhcnNlcnM6W3tyZWdleDovcmdiYVxcKFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV0/KD86XFwuWzAtOV0rKT8pXFxzKlxcKS8scGFyc2U6ZnVuY3Rpb24oYSl7cmV0dXJuW0IoYVsxXSksQihhWzJdKSxCKGFbM10pLHBhcnNlRmxvYXQoYVs0XSwxMCldfX0se3JlZ2V4Oi8jKFthLWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkoW2EtZkEtRjAtOV17Mn0pLyxcbnBhcnNlOmZ1bmN0aW9uKGEpe3JldHVybltCKGFbMV0sMTYpLEIoYVsyXSwxNiksQihhWzNdLDE2KSwxXX19LHtyZWdleDovcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvLHBhcnNlOmZ1bmN0aW9uKGEpe3JldHVybltCKGFbMV0pLEIoYVsyXSksQihhWzNdKSwxXX19XSxpbml0OmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlO2lmKCh0aGlzLmlucHV0PWEpJiZhLnN0b3BzKXRoaXMuc3RvcHM9RGEoYS5zdG9wcyxmdW5jdGlvbihhKXtyZXR1cm4gbmV3IG5hKGFbMV0pfSk7ZWxzZSBmb3IoZD10aGlzLnBhcnNlcnMubGVuZ3RoO2QtLSYmIWM7KWU9dGhpcy5wYXJzZXJzW2RdLChiPWUucmVnZXguZXhlYyhhKSkmJihjPWUucGFyc2UoYikpO3RoaXMucmdiYT1jfHxbXX0sZ2V0OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuaW5wdXQsYz10aGlzLnJnYmEsZDt0aGlzLnN0b3BzPyhkPUUoYiksZC5zdG9wcz1bXS5jb25jYXQoZC5zdG9wcyksXG5xKHRoaXMuc3RvcHMsZnVuY3Rpb24oYixjKXtkLnN0b3BzW2NdPVtkLnN0b3BzW2NdWzBdLGIuZ2V0KGEpXX0pKTpkPWMmJkooY1swXSk/YT09PVwicmdiXCJ8fCFhJiZjWzNdPT09MT9cInJnYihcIitjWzBdK1wiLFwiK2NbMV0rXCIsXCIrY1syXStcIilcIjphPT09XCJhXCI/Y1szXTpcInJnYmEoXCIrYy5qb2luKFwiLFwiKStcIilcIjpiO3JldHVybiBkfSxicmlnaHRlbjpmdW5jdGlvbihhKXt2YXIgYixjPXRoaXMucmdiYTtpZih0aGlzLnN0b3BzKXEodGhpcy5zdG9wcyxmdW5jdGlvbihiKXtiLmJyaWdodGVuKGEpfSk7ZWxzZSBpZihKKGEpJiZhIT09MClmb3IoYj0wO2I8MztiKyspY1tiXSs9QihhKjI1NSksY1tiXTwwJiYoY1tiXT0wKSxjW2JdPjI1NSYmKGNbYl09MjU1KTtyZXR1cm4gdGhpc30sc2V0T3BhY2l0eTpmdW5jdGlvbihhKXt0aGlzLnJnYmFbM109YTtyZXR1cm4gdGhpc319O08ucHJvdG90eXBlPXtvcGFjaXR5OjEsdGV4dFByb3BzOlwiZGlyZWN0aW9uLGZvbnRTaXplLGZvbnRXZWlnaHQsZm9udEZhbWlseSxmb250U3R5bGUsY29sb3IsbGluZUhlaWdodCx3aWR0aCx0ZXh0RGVjb3JhdGlvbix0ZXh0T3ZlcmZsb3csdGV4dFNoYWRvd1wiLnNwbGl0KFwiLFwiKSxcbmluaXQ6ZnVuY3Rpb24oYSxiKXt0aGlzLmVsZW1lbnQ9Yj09PVwic3BhblwiP2RhKGIpOnkuY3JlYXRlRWxlbWVudE5TKElhLGIpO3RoaXMucmVuZGVyZXI9YX0sYW5pbWF0ZTpmdW5jdGlvbihhLGIsYyl7Yj1wKGIsdGhpcy5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24sITApO0thKHRoaXMpO2lmKGIpe2lmKGMpYi5jb21wbGV0ZT1jO1lhKHRoaXMsYSxiKX1lbHNlIHRoaXMuYXR0cihhLG51bGwsYyk7cmV0dXJuIHRoaXN9LGNvbG9yR3JhZGllbnQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMucmVuZGVyZXIsZSxmLGcsaCxpLGosayxsLG0sbixvLHo9W10scjthLmxpbmVhckdyYWRpZW50P2Y9XCJsaW5lYXJHcmFkaWVudFwiOmEucmFkaWFsR3JhZGllbnQmJihmPVwicmFkaWFsR3JhZGllbnRcIik7aWYoZil7Zz1hW2ZdO2k9ZC5ncmFkaWVudHM7az1hLnN0b3BzO249Yy5yYWRpYWxSZWZlcmVuY2U7RmEoZykmJihhW2ZdPWc9e3gxOmdbMF0seTE6Z1sxXSx4MjpnWzJdLHkyOmdbM10sZ3JhZGllbnRVbml0czpcInVzZXJTcGFjZU9uVXNlXCJ9KTtcbmY9PT1cInJhZGlhbEdyYWRpZW50XCImJm4mJiFzKGcuZ3JhZGllbnRVbml0cykmJihoPWcsZz1FKGcsZC5nZXRSYWRpYWxBdHRyKG4saCkse2dyYWRpZW50VW5pdHM6XCJ1c2VyU3BhY2VPblVzZVwifSkpO2ZvcihvIGluIGcpbyE9PVwiaWRcIiYmei5wdXNoKG8sZ1tvXSk7Zm9yKG8gaW4gayl6LnB1c2goa1tvXSk7ej16LmpvaW4oXCIsXCIpO2lbel0/bj1pW3pdLmF0dHIoXCJpZFwiKTooZy5pZD1uPVwiaGlnaGNoYXJ0cy1cIitCYisrLGlbel09aj1kLmNyZWF0ZUVsZW1lbnQoZikuYXR0cihnKS5hZGQoZC5kZWZzKSxqLnJhZEF0dHI9aCxqLnN0b3BzPVtdLHEoayxmdW5jdGlvbihhKXthWzFdLmluZGV4T2YoXCJyZ2JhXCIpPT09MD8oZT1uYShhWzFdKSxsPWUuZ2V0KFwicmdiXCIpLG09ZS5nZXQoXCJhXCIpKToobD1hWzFdLG09MSk7YT1kLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIpLmF0dHIoe29mZnNldDphWzBdLFwic3RvcC1jb2xvclwiOmwsXCJzdG9wLW9wYWNpdHlcIjptfSkuYWRkKGopO2ouc3RvcHMucHVzaChhKX0pKTtcbnI9XCJ1cmwoXCIrZC51cmwrXCIjXCIrbitcIilcIjtjLnNldEF0dHJpYnV0ZShiLHIpO2MuZ3JhZGllbnQ9ejthLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHJ9fX0sYXBwbHlUZXh0U2hhZG93OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudCxjLGQ9YS5pbmRleE9mKFwiY29udHJhc3RcIikhPT0tMSxlPXt9LGY9dGhpcy5yZW5kZXJlci5mb3JFeHBvcnQsZz1mfHxiLnN0eWxlLnRleHRTaGFkb3chPT1BJiYhemE7aWYoZCllLnRleHRTaGFkb3c9YT1hLnJlcGxhY2UoL2NvbnRyYXN0L2csdGhpcy5yZW5kZXJlci5nZXRDb250cmFzdChiLnN0eWxlLmZpbGwpKTtpZihvYnx8ZillLnRleHRSZW5kZXJpbmc9XCJnZW9tZXRyaWNQcmVjaXNpb25cIjtnP3RoaXMuY3NzKGUpOih0aGlzLmZha2VUUz0hMCx0aGlzLnlTZXR0ZXI9dGhpcy54U2V0dGVyLGM9W10uc2xpY2UuY2FsbChiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHNwYW5cIikpLHEoYS5zcGxpdCgvXFxzPyxcXHM/L2cpLGZ1bmN0aW9uKGEpe3ZhciBkPVxuYi5maXJzdENoaWxkLGUsZixhPWEuc3BsaXQoXCIgXCIpO2U9YVthLmxlbmd0aC0xXTsoZj1hW2EubGVuZ3RoLTJdKSYmcShjLGZ1bmN0aW9uKGEsYyl7dmFyIGc7Yz09PTAmJihhLnNldEF0dHJpYnV0ZShcInhcIixiLmdldEF0dHJpYnV0ZShcInhcIikpLGM9Yi5nZXRBdHRyaWJ1dGUoXCJ5XCIpLGEuc2V0QXR0cmlidXRlKFwieVwiLGN8fDApLGM9PT1udWxsJiZiLnNldEF0dHJpYnV0ZShcInlcIiwwKSk7Zz1hLmNsb25lTm9kZSgxKTtQKGcse1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtdGV4dC1zaGFkb3dcIixmaWxsOmUsc3Ryb2tlOmUsXCJzdHJva2Utb3BhY2l0eVwiOjEvdChCKGYpLDMpLFwic3Ryb2tlLXdpZHRoXCI6ZixcInN0cm9rZS1saW5lam9pblwiOlwicm91bmRcIn0pO2IuaW5zZXJ0QmVmb3JlKGcsZCl9KX0pKX0sYXR0cjpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZT10aGlzLmVsZW1lbnQsZixnPXRoaXMsaDt0eXBlb2YgYT09PVwic3RyaW5nXCImJmIhPT1BJiYoZD1hLGE9e30sYVtkXT1iKTtpZih0eXBlb2YgYT09PVxuXCJzdHJpbmdcIilnPSh0aGlzW2ErXCJHZXR0ZXJcIl18fHRoaXMuX2RlZmF1bHRHZXR0ZXIpLmNhbGwodGhpcyxhLGUpO2Vsc2V7Zm9yKGQgaW4gYSl7Yj1hW2RdO2g9ITE7dGhpcy5zeW1ib2xOYW1lJiYvXih4fHl8d2lkdGh8aGVpZ2h0fHJ8c3RhcnR8ZW5kfGlubmVyUnxhbmNob3JYfGFuY2hvclkpLy50ZXN0KGQpJiYoZnx8KHRoaXMuc3ltYm9sQXR0cihhKSxmPSEwKSxoPSEwKTtpZih0aGlzLnJvdGF0aW9uJiYoZD09PVwieFwifHxkPT09XCJ5XCIpKXRoaXMuZG9UcmFuc2Zvcm09ITA7aHx8KGg9dGhpc1tkK1wiU2V0dGVyXCJdfHx0aGlzLl9kZWZhdWx0U2V0dGVyLGguY2FsbCh0aGlzLGIsZCxlKSx0aGlzLnNoYWRvd3MmJi9eKHdpZHRofGhlaWdodHx2aXNpYmlsaXR5fHh8eXxkfHRyYW5zZm9ybXxjeHxjeXxyKSQvLnRlc3QoZCkmJnRoaXMudXBkYXRlU2hhZG93cyhkLGIsaCkpfWlmKHRoaXMuZG9UcmFuc2Zvcm0pdGhpcy51cGRhdGVUcmFuc2Zvcm0oKSx0aGlzLmRvVHJhbnNmb3JtPSExfWMmJlxuYygpO3JldHVybiBnfSx1cGRhdGVTaGFkb3dzOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9dGhpcy5zaGFkb3dzLGU9ZC5sZW5ndGg7ZS0tOyljLmNhbGwoZFtlXSxhPT09XCJoZWlnaHRcIj9NYXRoLm1heChiLShkW2VdLmN1dEhlaWdodHx8MCksMCk6YT09PVwiZFwiP3RoaXMuZDpiLGEsZFtlXSl9LGFkZENsYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudCxjPVAoYixcImNsYXNzXCIpfHxcIlwiO2MuaW5kZXhPZihhKT09PS0xJiZQKGIsXCJjbGFzc1wiLGMrXCIgXCIrYSk7cmV0dXJuIHRoaXN9LHN5bWJvbEF0dHI6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztxKFwieCx5LHIsc3RhcnQsZW5kLHdpZHRoLGhlaWdodCxpbm5lclIsYW5jaG9yWCxhbmNob3JZXCIuc3BsaXQoXCIsXCIpLGZ1bmN0aW9uKGMpe2JbY109cChhW2NdLGJbY10pfSk7Yi5hdHRyKHtkOmIucmVuZGVyZXIuc3ltYm9sc1tiLnN5bWJvbE5hbWVdKGIueCxiLnksYi53aWR0aCxiLmhlaWdodCxiKX0pfSxjbGlwOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmF0dHIoXCJjbGlwLXBhdGhcIixcbmE/XCJ1cmwoXCIrdGhpcy5yZW5kZXJlci51cmwrXCIjXCIrYS5pZCtcIilcIjpcIm5vbmVcIil9LGNyaXNwOmZ1bmN0aW9uKGEpe3ZhciBiLGM9e30sZCxlPXRoaXMuc3Ryb2tlV2lkdGh8fDA7ZD1DKGUpJTIvMjthLng9VihhLnh8fHRoaXMueHx8MCkrZDthLnk9VihhLnl8fHRoaXMueXx8MCkrZDthLndpZHRoPVYoKGEud2lkdGh8fHRoaXMud2lkdGh8fDApLTIqZCk7YS5oZWlnaHQ9VigoYS5oZWlnaHR8fHRoaXMuaGVpZ2h0fHwwKS0yKmQpO2Euc3Ryb2tlV2lkdGg9ZTtmb3IoYiBpbiBhKXRoaXNbYl0hPT1hW2JdJiYodGhpc1tiXT1jW2JdPWFbYl0pO3JldHVybiBjfSxjc3M6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zdHlsZXMsYz17fSxkPXRoaXMuZWxlbWVudCxlLGYsZz1cIlwiO2U9IWI7aWYoYSYmYS5jb2xvcilhLmZpbGw9YS5jb2xvcjtpZihiKWZvcihmIGluIGEpYVtmXSE9PWJbZl0mJihjW2ZdPWFbZl0sZT0hMCk7aWYoZSl7ZT10aGlzLnRleHRXaWR0aD1hJiZhLndpZHRoJiZkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cblwidGV4dFwiJiZCKGEud2lkdGgpfHx0aGlzLnRleHRXaWR0aDtiJiYoYT14KGIsYykpO3RoaXMuc3R5bGVzPWE7ZSYmKGxhfHwhZ2EmJnRoaXMucmVuZGVyZXIuZm9yRXhwb3J0KSYmZGVsZXRlIGEud2lkdGg7aWYoemEmJiFnYSlNKHRoaXMuZWxlbWVudCxhKTtlbHNle2I9ZnVuY3Rpb24oYSxiKXtyZXR1cm5cIi1cIitiLnRvTG93ZXJDYXNlKCl9O2ZvcihmIGluIGEpZys9Zi5yZXBsYWNlKC8oW0EtWl0pL2csYikrXCI6XCIrYVtmXStcIjtcIjtQKGQsXCJzdHlsZVwiLGcpfWUmJnRoaXMuYWRkZWQmJnRoaXMucmVuZGVyZXIuYnVpbGRUZXh0KHRoaXMpfXJldHVybiB0aGlzfSxvbjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1jLmVsZW1lbnQ7ZmImJmE9PT1cImNsaWNrXCI/KGQub250b3VjaHN0YXJ0PWZ1bmN0aW9uKGEpe2MudG91Y2hFdmVudEZpcmVkPW1hLm5vdygpO2EucHJldmVudERlZmF1bHQoKTtiLmNhbGwoZCxhKX0sZC5vbmNsaWNrPWZ1bmN0aW9uKGEpeyhBYS5pbmRleE9mKFwiQW5kcm9pZFwiKT09PVxuLTF8fG1hLm5vdygpLShjLnRvdWNoRXZlbnRGaXJlZHx8MCk+MTEwMCkmJmIuY2FsbChkLGEpfSk6ZFtcIm9uXCIrYV09YjtyZXR1cm4gdGhpc30sc2V0UmFkaWFsUmVmZXJlbmNlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMucmVuZGVyZXIuZ3JhZGllbnRzW3RoaXMuZWxlbWVudC5ncmFkaWVudF07dGhpcy5lbGVtZW50LnJhZGlhbFJlZmVyZW5jZT1hO2ImJmIucmFkQXR0ciYmYi5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0UmFkaWFsQXR0cihhLGIucmFkQXR0cikpO3JldHVybiB0aGlzfSx0cmFuc2xhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5hdHRyKHt0cmFuc2xhdGVYOmEsdHJhbnNsYXRlWTpifSl9LGludmVydDpmdW5jdGlvbigpe3RoaXMuaW52ZXJ0ZWQ9ITA7dGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtyZXR1cm4gdGhpc30sdXBkYXRlVHJhbnNmb3JtOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50cmFuc2xhdGVYfHwwLGI9dGhpcy50cmFuc2xhdGVZfHwwLGM9dGhpcy5zY2FsZVgsXG5kPXRoaXMuc2NhbGVZLGU9dGhpcy5pbnZlcnRlZCxmPXRoaXMucm90YXRpb24sZz10aGlzLmVsZW1lbnQ7ZSYmKGErPXRoaXMuYXR0cihcIndpZHRoXCIpLGIrPXRoaXMuYXR0cihcImhlaWdodFwiKSk7YT1bXCJ0cmFuc2xhdGUoXCIrYStcIixcIitiK1wiKVwiXTtlP2EucHVzaChcInJvdGF0ZSg5MCkgc2NhbGUoLTEsMSlcIik6ZiYmYS5wdXNoKFwicm90YXRlKFwiK2YrXCIgXCIrKGcuZ2V0QXR0cmlidXRlKFwieFwiKXx8MCkrXCIgXCIrKGcuZ2V0QXR0cmlidXRlKFwieVwiKXx8MCkrXCIpXCIpOyhzKGMpfHxzKGQpKSYmYS5wdXNoKFwic2NhbGUoXCIrcChjLDEpK1wiIFwiK3AoZCwxKStcIilcIik7YS5sZW5ndGgmJmcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsYS5qb2luKFwiIFwiKSl9LHRvRnJvbnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnQ7YS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGEpO3JldHVybiB0aGlzfSxhbGlnbjpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGcsaD17fTtlPXRoaXMucmVuZGVyZXI7Zj1lLmFsaWduZWRPYmplY3RzO1xuaWYoYSl7aWYodGhpcy5hbGlnbk9wdGlvbnM9YSx0aGlzLmFsaWduQnlUcmFuc2xhdGU9YiwhY3x8eWEoYykpdGhpcy5hbGlnblRvPWQ9Y3x8XCJyZW5kZXJlclwiLHJhKGYsdGhpcyksZi5wdXNoKHRoaXMpLGM9bnVsbH1lbHNlIGE9dGhpcy5hbGlnbk9wdGlvbnMsYj10aGlzLmFsaWduQnlUcmFuc2xhdGUsZD10aGlzLmFsaWduVG87Yz1wKGMsZVtkXSxlKTtkPWEuYWxpZ247ZT1hLnZlcnRpY2FsQWxpZ247Zj0oYy54fHwwKSsoYS54fHwwKTtnPShjLnl8fDApKyhhLnl8fDApO2lmKGQ9PT1cInJpZ2h0XCJ8fGQ9PT1cImNlbnRlclwiKWYrPShjLndpZHRoLShhLndpZHRofHwwKSkve3JpZ2h0OjEsY2VudGVyOjJ9W2RdO2hbYj9cInRyYW5zbGF0ZVhcIjpcInhcIl09QyhmKTtpZihlPT09XCJib3R0b21cInx8ZT09PVwibWlkZGxlXCIpZys9KGMuaGVpZ2h0LShhLmhlaWdodHx8MCkpLyh7Ym90dG9tOjEsbWlkZGxlOjJ9W2VdfHwxKTtoW2I/XCJ0cmFuc2xhdGVZXCI6XCJ5XCJdPUMoZyk7dGhpc1t0aGlzLnBsYWNlZD9cblwiYW5pbWF0ZVwiOlwiYXR0clwiXShoKTt0aGlzLnBsYWNlZD0hMDt0aGlzLmFsaWduQXR0cj1oO3JldHVybiB0aGlzfSxnZXRCQm94OmZ1bmN0aW9uKGEsYil7dmFyIGMsZD10aGlzLnJlbmRlcmVyLGUsZixnLGg9dGhpcy5lbGVtZW50LGk9dGhpcy5zdHlsZXM7ZT10aGlzLnRleHRTdHI7dmFyIGosaz1oLnN0eWxlLGwsbT1kLmNhY2hlLG49ZC5jYWNoZUtleXMsbztmPXAoYix0aGlzLnJvdGF0aW9uKTtnPWYqa2E7ZSE9PUEmJihvPVtcIlwiLGZ8fDAsaSYmaS5mb250U2l6ZSxoLnN0eWxlLndpZHRoXS5qb2luKFwiLFwiKSxvPWU9PT1cIlwifHxTYi50ZXN0KGUpP1wibnVtOlwiK2UudG9TdHJpbmcoKS5sZW5ndGgrbzplK28pO28mJiFhJiYoYz1tW29dKTtpZighYyl7aWYoaC5uYW1lc3BhY2VVUkk9PT1JYXx8ZC5mb3JFeHBvcnQpe3RyeXtsPXRoaXMuZmFrZVRTJiZmdW5jdGlvbihhKXtxKGgucXVlcnlTZWxlY3RvckFsbChcIi5oaWdoY2hhcnRzLXRleHQtc2hhZG93XCIpLGZ1bmN0aW9uKGIpe2Iuc3R5bGUuZGlzcGxheT1cbmF9KX0sUWEmJmsudGV4dFNoYWRvdz8oaj1rLnRleHRTaGFkb3csay50ZXh0U2hhZG93PVwiXCIpOmwmJmwoXCJub25lXCIpLGM9aC5nZXRCQm94P3goe30saC5nZXRCQm94KCkpOnt3aWR0aDpoLm9mZnNldFdpZHRoLGhlaWdodDpoLm9mZnNldEhlaWdodH0saj9rLnRleHRTaGFkb3c9ajpsJiZsKFwiXCIpfWNhdGNoKHope31pZighY3x8Yy53aWR0aDwwKWM9e3dpZHRoOjAsaGVpZ2h0OjB9fWVsc2UgYz10aGlzLmh0bWxHZXRCQm94KCk7aWYoZC5pc1NWRyl7ZD1jLndpZHRoO2U9Yy5oZWlnaHQ7aWYoemEmJmkmJmkuZm9udFNpemU9PT1cIjExcHhcIiYmZS50b1ByZWNpc2lvbigzKT09PVwiMTYuOVwiKWMuaGVpZ2h0PWU9MTQ7aWYoZiljLndpZHRoPVEoZSplYShnKSkrUShkKlcoZykpLGMuaGVpZ2h0PVEoZSpXKGcpKStRKGQqZWEoZykpfWlmKG8pe2Zvcig7bi5sZW5ndGg+MjUwOylkZWxldGUgbVtuLnNoaWZ0KCldO21bb118fG4ucHVzaChvKTttW29dPWN9fXJldHVybiBjfSxzaG93OmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmF0dHIoe3Zpc2liaWxpdHk6YT9cblwiaW5oZXJpdFwiOlwidmlzaWJsZVwifSl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdHRyKHt2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9KX0sZmFkZU91dDpmdW5jdGlvbihhKXt2YXIgYj10aGlzO2IuYW5pbWF0ZSh7b3BhY2l0eTowfSx7ZHVyYXRpb246YXx8MTUwLGNvbXBsZXRlOmZ1bmN0aW9uKCl7Yi5hdHRyKHt5Oi05OTk5fSl9fSl9LGFkZDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnJlbmRlcmVyLGM9dGhpcy5lbGVtZW50LGQ7aWYoYSl0aGlzLnBhcmVudEdyb3VwPWE7dGhpcy5wYXJlbnRJbnZlcnRlZD1hJiZhLmludmVydGVkO3RoaXMudGV4dFN0ciE9PXZvaWQgMCYmYi5idWlsZFRleHQodGhpcyk7dGhpcy5hZGRlZD0hMDtpZighYXx8YS5oYW5kbGVafHx0aGlzLnpJbmRleClkPXRoaXMuekluZGV4U2V0dGVyKCk7ZHx8KGE/YS5lbGVtZW50OmIuYm94KS5hcHBlbmRDaGlsZChjKTtpZih0aGlzLm9uQWRkKXRoaXMub25BZGQoKTtyZXR1cm4gdGhpc30sc2FmZVJlbW92ZUNoaWxkOmZ1bmN0aW9uKGEpe3ZhciBiPVxuYS5wYXJlbnROb2RlO2ImJmIucmVtb3ZlQ2hpbGQoYSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5lbGVtZW50fHx7fSxjPWEuc2hhZG93cyxkPWEucmVuZGVyZXIuaXNTVkcmJmIubm9kZU5hbWU9PT1cIlNQQU5cIiYmYS5wYXJlbnRHcm91cCxlLGY7Yi5vbmNsaWNrPWIub25tb3VzZW91dD1iLm9ubW91c2VvdmVyPWIub25tb3VzZW1vdmU9Yi5wb2ludD1udWxsO0thKGEpO2lmKGEuY2xpcFBhdGgpYS5jbGlwUGF0aD1hLmNsaXBQYXRoLmRlc3Ryb3koKTtpZihhLnN0b3BzKXtmb3IoZj0wO2Y8YS5zdG9wcy5sZW5ndGg7ZisrKWEuc3RvcHNbZl09YS5zdG9wc1tmXS5kZXN0cm95KCk7YS5zdG9wcz1udWxsfWEuc2FmZVJlbW92ZUNoaWxkKGIpO2ZvcihjJiZxKGMsZnVuY3Rpb24oYil7YS5zYWZlUmVtb3ZlQ2hpbGQoYil9KTtkJiZkLmRpdiYmZC5kaXYuY2hpbGROb2Rlcy5sZW5ndGg9PT0wOyliPWQucGFyZW50R3JvdXAsYS5zYWZlUmVtb3ZlQ2hpbGQoZC5kaXYpLGRlbGV0ZSBkLmRpdixcbmQ9YjthLmFsaWduVG8mJnJhKGEucmVuZGVyZXIuYWxpZ25lZE9iamVjdHMsYSk7Zm9yKGUgaW4gYSlkZWxldGUgYVtlXTtyZXR1cm4gbnVsbH0sc2hhZG93OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1bXSxlLGYsZz10aGlzLmVsZW1lbnQsaCxpLGosaztpZihhKXtpPXAoYS53aWR0aCwzKTtqPShhLm9wYWNpdHl8fDAuMTUpL2k7az10aGlzLnBhcmVudEludmVydGVkP1wiKC0xLC0xKVwiOlwiKFwiK3AoYS5vZmZzZXRYLDEpK1wiLCBcIitwKGEub2Zmc2V0WSwxKStcIilcIjtmb3IoZT0xO2U8PWk7ZSsrKXtmPWcuY2xvbmVOb2RlKDApO2g9aSoyKzEtMiplO1AoZix7aXNTaGFkb3c6XCJ0cnVlXCIsc3Ryb2tlOmEuY29sb3J8fFwiYmxhY2tcIixcInN0cm9rZS1vcGFjaXR5XCI6aiplLFwic3Ryb2tlLXdpZHRoXCI6aCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGVcIitrLGZpbGw6XCJub25lXCJ9KTtpZihjKVAoZixcImhlaWdodFwiLHQoUChmLFwiaGVpZ2h0XCIpLWgsMCkpLGYuY3V0SGVpZ2h0PWg7Yj9iLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZik6XG5nLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGYsZyk7ZC5wdXNoKGYpfXRoaXMuc2hhZG93cz1kfXJldHVybiB0aGlzfSx4R2V0dGVyOmZ1bmN0aW9uKGEpe3RoaXMuZWxlbWVudC5ub2RlTmFtZT09PVwiY2lyY2xlXCImJihhPXt4OlwiY3hcIix5OlwiY3lcIn1bYV18fGEpO3JldHVybiB0aGlzLl9kZWZhdWx0R2V0dGVyKGEpfSxfZGVmYXVsdEdldHRlcjpmdW5jdGlvbihhKXthPXAodGhpc1thXSx0aGlzLmVsZW1lbnQ/dGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShhKTpudWxsLDApOy9eW1xcLTAtOVxcLl0rJC8udGVzdChhKSYmKGE9cGFyc2VGbG9hdChhKSk7cmV0dXJuIGF9LGRTZXR0ZXI6ZnVuY3Rpb24oYSxiLGMpe2EmJmEuam9pbiYmKGE9YS5qb2luKFwiIFwiKSk7LyhOYU58IHsyfXxeJCkvLnRlc3QoYSkmJihhPVwiTSAwIDBcIik7Yy5zZXRBdHRyaWJ1dGUoYixhKTt0aGlzW2JdPWF9LGRhc2hzdHlsZVNldHRlcjpmdW5jdGlvbihhKXt2YXIgYixjPXRoaXNbXCJzdHJva2Utd2lkdGhcIl07Yz09PVxuXCJpbmhlcml0XCImJihjPTEpO2lmKGE9YSYmYS50b0xvd2VyQ2FzZSgpKXthPWEucmVwbGFjZShcInNob3J0ZGFzaGRvdGRvdFwiLFwiMywxLDEsMSwxLDEsXCIpLnJlcGxhY2UoXCJzaG9ydGRhc2hkb3RcIixcIjMsMSwxLDFcIikucmVwbGFjZShcInNob3J0ZG90XCIsXCIxLDEsXCIpLnJlcGxhY2UoXCJzaG9ydGRhc2hcIixcIjMsMSxcIikucmVwbGFjZShcImxvbmdkYXNoXCIsXCI4LDMsXCIpLnJlcGxhY2UoL2RvdC9nLFwiMSwzLFwiKS5yZXBsYWNlKFwiZGFzaFwiLFwiNCwzLFwiKS5yZXBsYWNlKC8sJC8sXCJcIikuc3BsaXQoXCIsXCIpO2ZvcihiPWEubGVuZ3RoO2ItLTspYVtiXT1CKGFbYl0pKmM7YT1hLmpvaW4oXCIsXCIpLnJlcGxhY2UoL05hTi9nLFwibm9uZVwiKTt0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLGEpfX0sYWxpZ25TZXR0ZXI6ZnVuY3Rpb24oYSl7dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcInRleHQtYW5jaG9yXCIse2xlZnQ6XCJzdGFydFwiLGNlbnRlcjpcIm1pZGRsZVwiLHJpZ2h0OlwiZW5kXCJ9W2FdKX0sXG5vcGFjaXR5U2V0dGVyOmZ1bmN0aW9uKGEsYixjKXt0aGlzW2JdPWE7Yy5zZXRBdHRyaWJ1dGUoYixhKX0sdGl0bGVTZXR0ZXI6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGl0bGVcIilbMF07Ynx8KGI9eS5jcmVhdGVFbGVtZW50TlMoSWEsXCJ0aXRsZVwiKSx0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoYikpO2IuZmlyc3RDaGlsZCYmYi5yZW1vdmVDaGlsZChiLmZpcnN0Q2hpbGQpO2IuYXBwZW5kQ2hpbGQoeS5jcmVhdGVUZXh0Tm9kZShTdHJpbmcocChhKSxcIlwiKS5yZXBsYWNlKC88W14+XSo+L2csXCJcIikpKX0sdGV4dFNldHRlcjpmdW5jdGlvbihhKXtpZihhIT09dGhpcy50ZXh0U3RyKWRlbGV0ZSB0aGlzLmJCb3gsdGhpcy50ZXh0U3RyPWEsdGhpcy5hZGRlZCYmdGhpcy5yZW5kZXJlci5idWlsZFRleHQodGhpcyl9LGZpbGxTZXR0ZXI6ZnVuY3Rpb24oYSxiLGMpe3R5cGVvZiBhPT09XCJzdHJpbmdcIj9jLnNldEF0dHJpYnV0ZShiLGEpOlxuYSYmdGhpcy5jb2xvckdyYWRpZW50KGEsYixjKX0sdmlzaWJpbGl0eVNldHRlcjpmdW5jdGlvbihhLGIsYyl7YT09PVwiaW5oZXJpdFwiP2MucmVtb3ZlQXR0cmlidXRlKGIpOmMuc2V0QXR0cmlidXRlKGIsYSl9LHpJbmRleFNldHRlcjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMucmVuZGVyZXIsZD10aGlzLnBhcmVudEdyb3VwLGM9KGR8fGMpLmVsZW1lbnR8fGMuYm94LGUsZixnPXRoaXMuZWxlbWVudCxoO2U9dGhpcy5hZGRlZDt2YXIgaTtpZihzKGEpKWcuekluZGV4PWEsYT0rYSx0aGlzW2JdPT09YSYmKGU9ITEpLHRoaXNbYl09YTtpZihlKXtpZigoYT10aGlzLnpJbmRleCkmJmQpZC5oYW5kbGVaPSEwO2Q9Yy5jaGlsZE5vZGVzO2ZvcihpPTA7aTxkLmxlbmd0aCYmIWg7aSsrKWlmKGU9ZFtpXSxmPWUuekluZGV4LGUhPT1nJiYoQihmKT5hfHwhcyhhKSYmcyhmKSkpYy5pbnNlcnRCZWZvcmUoZyxlKSxoPSEwO2h8fGMuYXBwZW5kQ2hpbGQoZyl9cmV0dXJuIGh9LF9kZWZhdWx0U2V0dGVyOmZ1bmN0aW9uKGEsXG5iLGMpe2Muc2V0QXR0cmlidXRlKGIsYSl9fTtPLnByb3RvdHlwZS55R2V0dGVyPU8ucHJvdG90eXBlLnhHZXR0ZXI7Ty5wcm90b3R5cGUudHJhbnNsYXRlWFNldHRlcj1PLnByb3RvdHlwZS50cmFuc2xhdGVZU2V0dGVyPU8ucHJvdG90eXBlLnJvdGF0aW9uU2V0dGVyPU8ucHJvdG90eXBlLnZlcnRpY2FsQWxpZ25TZXR0ZXI9Ty5wcm90b3R5cGUuc2NhbGVYU2V0dGVyPU8ucHJvdG90eXBlLnNjYWxlWVNldHRlcj1mdW5jdGlvbihhLGIpe3RoaXNbYl09YTt0aGlzLmRvVHJhbnNmb3JtPSEwfTtPLnByb3RvdHlwZVtcInN0cm9rZS13aWR0aFNldHRlclwiXT1PLnByb3RvdHlwZS5zdHJva2VTZXR0ZXI9ZnVuY3Rpb24oYSxiLGMpe3RoaXNbYl09YTtpZih0aGlzLnN0cm9rZSYmdGhpc1tcInN0cm9rZS13aWR0aFwiXSl0aGlzLnN0cm9rZVdpZHRoPXRoaXNbXCJzdHJva2Utd2lkdGhcIl0sTy5wcm90b3R5cGUuZmlsbFNldHRlci5jYWxsKHRoaXMsdGhpcy5zdHJva2UsXCJzdHJva2VcIixjKSxjLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLFxudGhpc1tcInN0cm9rZS13aWR0aFwiXSksdGhpcy5oYXNTdHJva2U9ITA7ZWxzZSBpZihiPT09XCJzdHJva2Utd2lkdGhcIiYmYT09PTAmJnRoaXMuaGFzU3Ryb2tlKWMucmVtb3ZlQXR0cmlidXRlKFwic3Ryb2tlXCIpLHRoaXMuaGFzU3Ryb2tlPSExfTt2YXIgRWE9ZnVuY3Rpb24oKXt0aGlzLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtFYS5wcm90b3R5cGU9e0VsZW1lbnQ6Tyxpbml0OmZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZyxkPXRoaXMuY3JlYXRlRWxlbWVudChcInN2Z1wiKS5hdHRyKHt2ZXJzaW9uOlwiMS4xXCJ9KS5jc3ModGhpcy5nZXRTdHlsZShkKSk7Zz1kLmVsZW1lbnQ7YS5hcHBlbmRDaGlsZChnKTthLmlubmVySFRNTC5pbmRleE9mKFwieG1sbnNcIik9PT0tMSYmUChnLFwieG1sbnNcIixJYSk7dGhpcy5pc1NWRz0hMDt0aGlzLmJveD1nO3RoaXMuYm94V3JhcHBlcj1kO3RoaXMuYWxpZ25lZE9iamVjdHM9W107dGhpcy51cmw9KFFhfHxvYikmJnkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJiYXNlXCIpLmxlbmd0aD9cbkQubG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLio/JC8sXCJcIikucmVwbGFjZSgvKFtcXCgnXFwpXSkvZyxcIlxcXFwkMVwiKS5yZXBsYWNlKC8gL2csXCIlMjBcIik6XCJcIjt0aGlzLmNyZWF0ZUVsZW1lbnQoXCJkZXNjXCIpLmFkZCgpLmVsZW1lbnQuYXBwZW5kQ2hpbGQoeS5jcmVhdGVUZXh0Tm9kZShcIkNyZWF0ZWQgd2l0aCBIaWdoY2hhcnRzIDQuMi42XCIpKTt0aGlzLmRlZnM9dGhpcy5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKS5hZGQoKTt0aGlzLmFsbG93SFRNTD1mO3RoaXMuZm9yRXhwb3J0PWU7dGhpcy5ncmFkaWVudHM9e307dGhpcy5jYWNoZT17fTt0aGlzLmNhY2hlS2V5cz1bXTt0aGlzLmltZ0NvdW50PTA7dGhpcy5zZXRTaXplKGIsYywhMSk7dmFyIGg7aWYoUWEmJmEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KXRoaXMuc3ViUGl4ZWxGaXg9Yj1mdW5jdGlvbigpe00oYSx7bGVmdDowLHRvcDowfSk7aD1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO00oYSx7bGVmdDp2YShoLmxlZnQpLWgubGVmdCtcInB4XCIsXG50b3A6dmEoaC50b3ApLWgudG9wK1wicHhcIn0pfSxiKCksTihELFwicmVzaXplXCIsYil9LGdldFN0eWxlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnN0eWxlPXgoe2ZvbnRGYW1pbHk6J1wiTHVjaWRhIEdyYW5kZVwiLCBcIkx1Y2lkYSBTYW5zIFVuaWNvZGVcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsZm9udFNpemU6XCIxMnB4XCJ9LGEpfSxpc0hpZGRlbjpmdW5jdGlvbigpe3JldHVybiF0aGlzLmJveFdyYXBwZXIuZ2V0QkJveCgpLndpZHRofSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5kZWZzO3RoaXMuYm94PW51bGw7dGhpcy5ib3hXcmFwcGVyPXRoaXMuYm94V3JhcHBlci5kZXN0cm95KCk7VGEodGhpcy5ncmFkaWVudHN8fHt9KTt0aGlzLmdyYWRpZW50cz1udWxsO2lmKGEpdGhpcy5kZWZzPWEuZGVzdHJveSgpO3RoaXMuc3ViUGl4ZWxGaXgmJlkoRCxcInJlc2l6ZVwiLHRoaXMuc3ViUGl4ZWxGaXgpO3JldHVybiB0aGlzLmFsaWduZWRPYmplY3RzPW51bGx9LGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24oYSl7dmFyIGI9XG5uZXcgdGhpcy5FbGVtZW50O2IuaW5pdCh0aGlzLGEpO3JldHVybiBifSxkcmF3OmZ1bmN0aW9uKCl7fSxnZXRSYWRpYWxBdHRyOmZ1bmN0aW9uKGEsYil7cmV0dXJue2N4OmFbMF0tYVsyXS8yK2IuY3gqYVsyXSxjeTphWzFdLWFbMl0vMitiLmN5KmFbMl0scjpiLnIqYVsyXX19LGJ1aWxkVGV4dDpmdW5jdGlvbihhKXtmb3IodmFyIGI9YS5lbGVtZW50LGM9dGhpcyxkPWMuZm9yRXhwb3J0LGU9cChhLnRleHRTdHIsXCJcIikudG9TdHJpbmcoKSxmPWUuaW5kZXhPZihcIjxcIikhPT0tMSxnPWIuY2hpbGROb2RlcyxoLGksaixrPVAoYixcInhcIiksbD1hLnN0eWxlcyxtPWEudGV4dFdpZHRoLG49bCYmbC5saW5lSGVpZ2h0LG89bCYmbC50ZXh0U2hhZG93LHo9bCYmbC50ZXh0T3ZlcmZsb3c9PT1cImVsbGlwc2lzXCIscj1nLmxlbmd0aCxHPW0mJiFhLmFkZGVkJiZ0aGlzLmJveCx3PWZ1bmN0aW9uKGEpe3JldHVybiBuP0Iobik6Yy5mb250TWV0cmljcygvKHB4fGVtKSQvLnRlc3QoYSYmYS5zdHlsZS5mb250U2l6ZSk/XG5hLnN0eWxlLmZvbnRTaXplOmwmJmwuZm9udFNpemV8fGMuc3R5bGUuZm9udFNpemV8fDEyLGEpLmh9LHY9ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZSgvJmx0Oy9nLFwiPFwiKS5yZXBsYWNlKC8mZ3Q7L2csXCI+XCIpfTtyLS07KWIucmVtb3ZlQ2hpbGQoZ1tyXSk7IWYmJiFvJiYheiYmIW0mJmUuaW5kZXhPZihcIiBcIik9PT0tMT9iLmFwcGVuZENoaWxkKHkuY3JlYXRlVGV4dE5vZGUodihlKSkpOihoPS88LipzdHlsZT1cIihbXlwiXSspXCIuKj4vLGk9LzwuKmhyZWY9XCIoaHR0cFteXCJdKylcIi4qPi8sRyYmRy5hcHBlbmRDaGlsZChiKSxlPWY/ZS5yZXBsYWNlKC88KGJ8c3Ryb25nKT4vZywnPHNwYW4gc3R5bGU9XCJmb250LXdlaWdodDpib2xkXCI+JykucmVwbGFjZSgvPChpfGVtKT4vZywnPHNwYW4gc3R5bGU9XCJmb250LXN0eWxlOml0YWxpY1wiPicpLnJlcGxhY2UoLzxhL2csXCI8c3BhblwiKS5yZXBsYWNlKC88XFwvKGJ8c3Ryb25nfGl8ZW18YSk+L2csXCI8L3NwYW4+XCIpLnNwbGl0KC88YnIuKj8+L2cpOlxuW2VdLGU9Q2EoZSxmdW5jdGlvbihhKXtyZXR1cm4gYSE9PVwiXCJ9KSxxKGUsZnVuY3Rpb24oZSxmKXt2YXIgZyxuPTAsZT1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIikucmVwbGFjZSgvPHNwYW4vZyxcInx8fDxzcGFuXCIpLnJlcGxhY2UoLzxcXC9zcGFuPi9nLFwiPC9zcGFuPnx8fFwiKTtnPWUuc3BsaXQoXCJ8fHxcIik7cShnLGZ1bmN0aW9uKGUpe2lmKGUhPT1cIlwifHxnLmxlbmd0aD09PTEpe3ZhciBvPXt9LHI9eS5jcmVhdGVFbGVtZW50TlMoSWEsXCJ0c3BhblwiKSxwO2gudGVzdChlKSYmKHA9ZS5tYXRjaChoKVsxXS5yZXBsYWNlKC8oO3wgfF4pY29sb3IoWyA6XSkvLFwiJDFmaWxsJDJcIiksUChyLFwic3R5bGVcIixwKSk7aS50ZXN0KGUpJiYhZCYmKFAocixcIm9uY2xpY2tcIiwnbG9jYXRpb24uaHJlZj1cIicrZS5tYXRjaChpKVsxXSsnXCInKSxNKHIse2N1cnNvcjpcInBvaW50ZXJcIn0pKTtlPXYoZS5yZXBsYWNlKC88KC58XFxuKSo/Pi9nLFwiXCIpfHxcIiBcIik7aWYoZSE9PVwiIFwiKXtyLmFwcGVuZENoaWxkKHkuY3JlYXRlVGV4dE5vZGUoZSkpO1xuaWYobilvLmR4PTA7ZWxzZSBpZihmJiZrIT09bnVsbClvLng9aztQKHIsbyk7Yi5hcHBlbmRDaGlsZChyKTshbiYmZiYmKCFnYSYmZCYmTShyLHtkaXNwbGF5OlwiYmxvY2tcIn0pLFAocixcImR5XCIsdyhyKSkpO2lmKG0pe2Zvcih2YXIgbz1lLnJlcGxhY2UoLyhbXlxcXl0pLS9nLFwiJDEtIFwiKS5zcGxpdChcIiBcIikscT1nLmxlbmd0aD4xfHxmfHxvLmxlbmd0aD4xJiZsLndoaXRlU3BhY2UhPT1cIm5vd3JhcFwiLEcscyxMYT1bXSx0PXcocikseD0xLEM9YS5yb3RhdGlvbixBPWUsdT1BLmxlbmd0aDsocXx8eikmJihvLmxlbmd0aHx8TGEubGVuZ3RoKTspYS5yb3RhdGlvbj0wLEc9YS5nZXRCQm94KCEwKSxzPUcud2lkdGgsIWdhJiZjLmZvckV4cG9ydCYmKHM9Yy5tZWFzdXJlU3BhbldpZHRoKHIuZmlyc3RDaGlsZC5kYXRhLGEuc3R5bGVzKSksRz1zPm0saj09PXZvaWQgMCYmKGo9RykseiYmaj8odS89MixBPT09XCJcInx8IUcmJnU8MC41P289W106KEE9ZS5zdWJzdHJpbmcoMCxBLmxlbmd0aCsoRz9cbi0xOjEpKnZhKHUpKSxvPVtBKyhtPjM/XCJcXHUyMDI2XCI6XCJcIildLHIucmVtb3ZlQ2hpbGQoci5maXJzdENoaWxkKSkpOiFHfHxvLmxlbmd0aD09PTE/KG89TGEsTGE9W10sby5sZW5ndGgmJih4Kysscj15LmNyZWF0ZUVsZW1lbnROUyhJYSxcInRzcGFuXCIpLFAocix7ZHk6dCx4Omt9KSxwJiZQKHIsXCJzdHlsZVwiLHApLGIuYXBwZW5kQ2hpbGQocikpLHM+bSYmKG09cykpOihyLnJlbW92ZUNoaWxkKHIuZmlyc3RDaGlsZCksTGEudW5zaGlmdChvLnBvcCgpKSksby5sZW5ndGgmJnIuYXBwZW5kQ2hpbGQoeS5jcmVhdGVUZXh0Tm9kZShvLmpvaW4oXCIgXCIpLnJlcGxhY2UoLy0gL2csXCItXCIpKSk7YS5yb3RhdGlvbj1DfW4rK319fSl9KSxqJiZhLmF0dHIoXCJ0aXRsZVwiLGEudGV4dFN0ciksRyYmRy5yZW1vdmVDaGlsZChiKSxvJiZhLmFwcGx5VGV4dFNoYWRvdyYmYS5hcHBseVRleHRTaGFkb3cobykpfSxnZXRDb250cmFzdDpmdW5jdGlvbihhKXthPW5hKGEpLnJnYmE7cmV0dXJuIGFbMF0rYVsxXStcbmFbMl0+Mzg0P1wiIzAwMDAwMFwiOlwiI0ZGRkZGRlwifSxidXR0b246ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3ZhciBqPXRoaXMubGFiZWwoYSxiLGMsaSxudWxsLG51bGwsbnVsbCxudWxsLFwiYnV0dG9uXCIpLGs9MCxsLG0sbixvLHoscixhPXt4MTowLHkxOjAseDI6MCx5MjoxfSxlPUUoe1wic3Ryb2tlLXdpZHRoXCI6MSxzdHJva2U6XCIjQ0NDQ0NDXCIsZmlsbDp7bGluZWFyR3JhZGllbnQ6YSxzdG9wczpbWzAsXCIjRkVGRUZFXCJdLFsxLFwiI0Y2RjZGNlwiXV19LHI6MixwYWRkaW5nOjUsc3R5bGU6e2NvbG9yOlwiYmxhY2tcIn19LGUpO249ZS5zdHlsZTtkZWxldGUgZS5zdHlsZTtmPUUoZSx7c3Ryb2tlOlwiIzY4QVwiLGZpbGw6e2xpbmVhckdyYWRpZW50OmEsc3RvcHM6W1swLFwiI0ZGRlwiXSxbMSxcIiNBQ0ZcIl1dfX0sZik7bz1mLnN0eWxlO2RlbGV0ZSBmLnN0eWxlO2c9RShlLHtzdHJva2U6XCIjNjhBXCIsZmlsbDp7bGluZWFyR3JhZGllbnQ6YSxzdG9wczpbWzAsXCIjOUJEXCJdLFsxLFwiI0NERlwiXV19fSxcbmcpO3o9Zy5zdHlsZTtkZWxldGUgZy5zdHlsZTtoPUUoZSx7c3R5bGU6e2NvbG9yOlwiI0NDQ1wifX0saCk7cj1oLnN0eWxlO2RlbGV0ZSBoLnN0eWxlO04oai5lbGVtZW50LHphP1wibW91c2VvdmVyXCI6XCJtb3VzZWVudGVyXCIsZnVuY3Rpb24oKXtrIT09MyYmai5hdHRyKGYpLmNzcyhvKX0pO04oai5lbGVtZW50LHphP1wibW91c2VvdXRcIjpcIm1vdXNlbGVhdmVcIixmdW5jdGlvbigpe2shPT0zJiYobD1bZSxmLGddW2tdLG09W24sbyx6XVtrXSxqLmF0dHIobCkuY3NzKG0pKX0pO2ouc2V0U3RhdGU9ZnVuY3Rpb24oYSl7KGouc3RhdGU9az1hKT9hPT09Mj9qLmF0dHIoZykuY3NzKHopOmE9PT0zJiZqLmF0dHIoaCkuY3NzKHIpOmouYXR0cihlKS5jc3Mobil9O3JldHVybiBqLm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXtrIT09MyYmZC5jYWxsKGosYSl9KS5hdHRyKGUpLmNzcyh4KHtjdXJzb3I6XCJkZWZhdWx0XCJ9LG4pKX0sY3Jpc3BMaW5lOmZ1bmN0aW9uKGEsYil7YVsxXT09PWFbNF0mJihhWzFdPVxuYVs0XT1DKGFbMV0pLWIlMi8yKTthWzJdPT09YVs1XSYmKGFbMl09YVs1XT1DKGFbMl0pK2IlMi8yKTtyZXR1cm4gYX0scGF0aDpmdW5jdGlvbihhKXt2YXIgYj17ZmlsbDpcIm5vbmVcIn07RmEoYSk/Yi5kPWE6JChhKSYmeChiLGEpO3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpLmF0dHIoYil9LGNpcmNsZTpmdW5jdGlvbihhLGIsYyl7YT0kKGEpP2E6e3g6YSx5OmIscjpjfTtiPXRoaXMuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiKTtiLnhTZXR0ZXI9Yi55U2V0dGVyPWZ1bmN0aW9uKGEsYixjKXtjLnNldEF0dHJpYnV0ZShcImNcIitiLGEpfTtyZXR1cm4gYi5hdHRyKGEpfSxhcmM6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2lmKCQoYSkpYj1hLnksYz1hLnIsZD1hLmlubmVyUixlPWEuc3RhcnQsZj1hLmVuZCxhPWEueDthPXRoaXMuc3ltYm9sKFwiYXJjXCIsYXx8MCxifHwwLGN8fDAsY3x8MCx7aW5uZXJSOmR8fDAsc3RhcnQ6ZXx8MCxlbmQ6Znx8MH0pO2Eucj1jO3JldHVybiBhfSxcbnJlY3Q6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBlPSQoYSk/YS5yOmUsZz10aGlzLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIpLGE9JChhKT9hOmE9PT1BP3t9Ont4OmEseTpiLHdpZHRoOnQoYywwKSxoZWlnaHQ6dChkLDApfTtpZihmIT09QSlnLnN0cm9rZVdpZHRoPWYsYT1nLmNyaXNwKGEpO2lmKGUpYS5yPWU7Zy5yU2V0dGVyPWZ1bmN0aW9uKGEsYixjKXtQKGMse3J4OmEscnk6YX0pfTtyZXR1cm4gZy5hdHRyKGEpfSxzZXRTaXplOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmFsaWduZWRPYmplY3RzLGU9ZC5sZW5ndGg7dGhpcy53aWR0aD1hO3RoaXMuaGVpZ2h0PWI7Zm9yKHRoaXMuYm94V3JhcHBlcltwKGMsITApP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7d2lkdGg6YSxoZWlnaHQ6Yn0pO2UtLTspZFtlXS5hbGlnbigpfSxnOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY3JlYXRlRWxlbWVudChcImdcIik7cmV0dXJuIHMoYSk/Yi5hdHRyKHtcImNsYXNzXCI6XCJoaWdoY2hhcnRzLVwiK2F9KTpcbmJ9LGltYWdlOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9e3ByZXNlcnZlQXNwZWN0UmF0aW86XCJub25lXCJ9O2FyZ3VtZW50cy5sZW5ndGg+MSYmeChmLHt4OmIseTpjLHdpZHRoOmQsaGVpZ2h0OmV9KTtmPXRoaXMuY3JlYXRlRWxlbWVudChcImltYWdlXCIpLmF0dHIoZik7Zi5lbGVtZW50LnNldEF0dHJpYnV0ZU5TP2YuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcImhyZWZcIixhKTpmLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGMtc3ZnLWhyZWZcIixhKTtyZXR1cm4gZn0sc3ltYm9sOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZz10aGlzLGgsaT10aGlzLnN5bWJvbHNbYV0saT1pJiZpKEMoYiksQyhjKSxkLGUsZiksaj0vXnVybFxcKCguKj8pXFwpJC8sayxsO2lmKGkpaD10aGlzLnBhdGgoaSkseChoLHtzeW1ib2xOYW1lOmEseDpiLHk6Yyx3aWR0aDpkLGhlaWdodDplfSksZiYmeChoLGYpO2Vsc2UgaWYoai50ZXN0KGEpKWw9ZnVuY3Rpb24oYSxcbmIpe2EuZWxlbWVudCYmKGEuYXR0cih7d2lkdGg6YlswXSxoZWlnaHQ6YlsxXX0pLGEuYWxpZ25CeVRyYW5zbGF0ZXx8YS50cmFuc2xhdGUoQygoZC1iWzBdKS8yKSxDKChlLWJbMV0pLzIpKSl9LGs9YS5tYXRjaChqKVsxXSxhPU9iW2tdfHxmJiZmLndpZHRoJiZmLmhlaWdodCYmW2Yud2lkdGgsZi5oZWlnaHRdLGg9dGhpcy5pbWFnZShrKS5hdHRyKHt4OmIseTpjfSksaC5pc0ltZz0hMCxhP2woaCxhKTooaC5hdHRyKHt3aWR0aDowLGhlaWdodDowfSksZGEoXCJpbWdcIix7b25sb2FkOmZ1bmN0aW9uKCl7dGhpcy53aWR0aD09PTAmJihNKHRoaXMse3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6XCItOTk5ZW1cIn0pLHkuYm9keS5hcHBlbmRDaGlsZCh0aGlzKSk7bChoLE9iW2tdPVt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XSk7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7Zy5pbWdDb3VudC0tO2lmKCFnLmltZ0NvdW50JiZUW2cuY2hhcnRJbmRleF0ub25sb2FkKVRbZy5jaGFydEluZGV4XS5vbmxvYWQoKX0sXG5zcmM6a30pLHRoaXMuaW1nQ291bnQrKyk7cmV0dXJuIGh9LHN5bWJvbHM6e2NpcmNsZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT0wLjE2NipjO3JldHVybltYLGErYy8yLGIsXCJDXCIsYStjK2UsYixhK2MrZSxiK2QsYStjLzIsYitkLFwiQ1wiLGEtZSxiK2QsYS1lLGIsYStjLzIsYixcIlpcIl19LHNxdWFyZTpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm5bWCxhLGIsUyxhK2MsYixhK2MsYitkLGEsYitkLFwiWlwiXX0sdHJpYW5nbGU6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuW1gsYStjLzIsYixTLGErYyxiK2QsYSxiK2QsXCJaXCJdfSxcInRyaWFuZ2xlLWRvd25cIjpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm5bWCxhLGIsUyxhK2MsYixhK2MvMixiK2QsXCJaXCJdfSxkaWFtb25kOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybltYLGErYy8yLGIsUyxhK2MsYitkLzIsYStjLzIsYitkLGEsYitkLzIsXCJaXCJdfSxhcmM6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1lLnN0YXJ0LGM9ZS5yfHxjfHxkLGc9ZS5lbmQtXG4wLjAwMSxkPWUuaW5uZXJSLGg9ZS5vcGVuLGk9VyhmKSxqPWVhKGYpLGs9VyhnKSxnPWVhKGcpLGU9ZS5lbmQtZjx0YT8wOjE7cmV0dXJuW1gsYStjKmksYitjKmosXCJBXCIsYyxjLDAsZSwxLGErYyprLGIrYypnLGg/WDpTLGErZCprLGIrZCpnLFwiQVwiLGQsZCwwLGUsMCxhK2QqaSxiK2QqaixoP1wiXCI6XCJaXCJdfSxjYWxsb3V0OmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9RihlJiZlLnJ8fDAsYyxkKSxnPWYrNixoPWUmJmUuYW5jaG9yWCxlPWUmJmUuYW5jaG9yWSxpO2k9W1wiTVwiLGErZixiLFwiTFwiLGErYy1mLGIsXCJDXCIsYStjLGIsYStjLGIsYStjLGIrZixcIkxcIixhK2MsYitkLWYsXCJDXCIsYStjLGIrZCxhK2MsYitkLGErYy1mLGIrZCxcIkxcIixhK2YsYitkLFwiQ1wiLGEsYitkLGEsYitkLGEsYitkLWYsXCJMXCIsYSxiK2YsXCJDXCIsYSxiLGEsYixhK2YsYl07aCYmaD5jJiZlPmIrZyYmZTxiK2QtZz9pLnNwbGljZSgxMywzLFwiTFwiLGErYyxlLTYsYStjKzYsZSxhK2MsZSs2LGErYyxiK2QtZik6aCYmXG5oPDAmJmU+YitnJiZlPGIrZC1nP2kuc3BsaWNlKDMzLDMsXCJMXCIsYSxlKzYsYS02LGUsYSxlLTYsYSxiK2YpOmUmJmU+ZCYmaD5hK2cmJmg8YStjLWc/aS5zcGxpY2UoMjMsMyxcIkxcIixoKzYsYitkLGgsYitkKzYsaC02LGIrZCxhK2YsYitkKTplJiZlPDAmJmg+YStnJiZoPGErYy1nJiZpLnNwbGljZSgzLDMsXCJMXCIsaC02LGIsaCxiLTYsaCs2LGIsYy1mLGIpO3JldHVybiBpfX0sY2xpcFJlY3Q6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9XCJoaWdoY2hhcnRzLVwiK0JiKyssZj10aGlzLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKS5hdHRyKHtpZDplfSkuYWRkKHRoaXMuZGVmcyksYT10aGlzLnJlY3QoYSxiLGMsZCwwKS5hZGQoZik7YS5pZD1lO2EuY2xpcFBhdGg9ZjthLmNvdW50PTA7cmV0dXJuIGF9LHRleHQ6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bGF8fCFnYSYmdGhpcy5mb3JFeHBvcnQsZj17fTtpZihkJiYodGhpcy5hbGxvd0hUTUx8fCF0aGlzLmZvckV4cG9ydCkpcmV0dXJuIHRoaXMuaHRtbChhLFxuYixjKTtmLng9TWF0aC5yb3VuZChifHwwKTtpZihjKWYueT1NYXRoLnJvdW5kKGMpO2lmKGF8fGE9PT0wKWYudGV4dD1hO2E9dGhpcy5jcmVhdGVFbGVtZW50KFwidGV4dFwiKS5hdHRyKGYpO2UmJmEuY3NzKHtwb3NpdGlvbjpcImFic29sdXRlXCJ9KTtpZighZClhLnhTZXR0ZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKSxlLGY9Yy5nZXRBdHRyaWJ1dGUoYiksbTtmb3IobT0wO208ZC5sZW5ndGg7bSsrKWU9ZFttXSxlLmdldEF0dHJpYnV0ZShiKT09PWYmJmUuc2V0QXR0cmlidXRlKGIsYSk7Yy5zZXRBdHRyaWJ1dGUoYixhKX07cmV0dXJuIGF9LGZvbnRNZXRyaWNzOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxhPWF8fHRoaXMuc3R5bGUuZm9udFNpemU7IWEmJmImJkQuZ2V0Q29tcHV0ZWRTdHlsZSYmKGI9Yi5lbGVtZW50fHxiLGE9KGM9RC5nZXRDb21wdXRlZFN0eWxlKGIsXCJcIikpJiZjLmZvbnRTaXplKTthPS9weC8udGVzdChhKT9CKGEpOlxuL2VtLy50ZXN0KGEpP3BhcnNlRmxvYXQoYSkqMTI6MTI7Yz1hPDI0P2ErMzpDKGEqMS4yKTtkPUMoYyowLjgpO3JldHVybntoOmMsYjpkLGY6YX19LHJvdENvcnI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWE7YiYmYyYmKGQ9dChkKlcoYiprYSksNCkpO3JldHVybnt4Oi1hLzMqZWEoYiprYSkseTpkfX0sbGFiZWw6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3ZhciBqPXRoaXMsaz1qLmcoaSksbD1qLnRleHQoXCJcIiwwLDAsZykuYXR0cih7ekluZGV4OjF9KSxtLG4sbz0wLHo9MyxyPTAscCx3LHYsTGEscWI9MCxiYT17fSx0LHUseSxGLEQ7eT1mdW5jdGlvbigpe3ZhciBhLGI7YT1sLmVsZW1lbnQuc3R5bGU7bj0ocD09PXZvaWQgMHx8dz09PXZvaWQgMHx8ay5zdHlsZXMudGV4dEFsaWduKSYmcyhsLnRleHRTdHIpJiZsLmdldEJCb3goKTtrLndpZHRoPShwfHxuLndpZHRofHwwKSsyKnorcjtrLmhlaWdodD0od3x8bi5oZWlnaHR8fDApKzIqejt0PXorai5mb250TWV0cmljcyhhJiZcbmEuZm9udFNpemUsbCkuYjtpZih1KXtpZighbSlhPXFiLGI9KGg/LXQ6MCkrcWIsay5ib3g9bT1qLnN5bWJvbHNbZF0/ai5zeW1ib2woZCxhLGIsay53aWR0aCxrLmhlaWdodCxiYSk6ai5yZWN0KGEsYixrLndpZHRoLGsuaGVpZ2h0LDAsYmFbXCJzdHJva2Utd2lkdGhcIl0pLG0uaXNJbWd8fG0uYXR0cihcImZpbGxcIixcIm5vbmVcIiksbS5hZGQoayk7bS5pc0ltZ3x8bS5hdHRyKHgoe3dpZHRoOkMoay53aWR0aCksaGVpZ2h0OkMoay5oZWlnaHQpfSxiYSkpO2JhPW51bGx9fTtGPWZ1bmN0aW9uKCl7dmFyIGE9ay5zdHlsZXMsYT1hJiZhLnRleHRBbGlnbixiPXIreixjO2M9aD8wOnQ7aWYocyhwKSYmbiYmKGE9PT1cImNlbnRlclwifHxhPT09XCJyaWdodFwiKSliKz17Y2VudGVyOjAuNSxyaWdodDoxfVthXSoocC1uLndpZHRoKTtpZihiIT09bC54fHxjIT09bC55KWwuYXR0cihcInhcIixiKSxjIT09QSYmbC5hdHRyKFwieVwiLGMpO2wueD1iO2wueT1jfTtEPWZ1bmN0aW9uKGEsYil7bT9tLmF0dHIoYSxiKTpcbmJhW2FdPWJ9O2sub25BZGQ9ZnVuY3Rpb24oKXtsLmFkZChrKTtrLmF0dHIoe3RleHQ6YXx8YT09PTA/YTpcIlwiLHg6Yix5OmN9KTttJiZzKGUpJiZrLmF0dHIoe2FuY2hvclg6ZSxhbmNob3JZOmZ9KX07ay53aWR0aFNldHRlcj1mdW5jdGlvbihhKXtwPWF9O2suaGVpZ2h0U2V0dGVyPWZ1bmN0aW9uKGEpe3c9YX07ay5wYWRkaW5nU2V0dGVyPWZ1bmN0aW9uKGEpe2lmKHMoYSkmJmEhPT16KXo9ay5wYWRkaW5nPWEsRigpfTtrLnBhZGRpbmdMZWZ0U2V0dGVyPWZ1bmN0aW9uKGEpe3MoYSkmJmEhPT1yJiYocj1hLEYoKSl9O2suYWxpZ25TZXR0ZXI9ZnVuY3Rpb24oYSl7YT17bGVmdDowLGNlbnRlcjowLjUscmlnaHQ6MX1bYV07YSE9PW8mJihvPWEsbiYmay5hdHRyKHt4OnZ9KSl9O2sudGV4dFNldHRlcj1mdW5jdGlvbihhKXthIT09QSYmbC50ZXh0U2V0dGVyKGEpO3koKTtGKCl9O2tbXCJzdHJva2Utd2lkdGhTZXR0ZXJcIl09ZnVuY3Rpb24oYSxiKXthJiYodT0hMCk7cWI9YSUyLzI7RChiLFxuYSl9O2suc3Ryb2tlU2V0dGVyPWsuZmlsbFNldHRlcj1rLnJTZXR0ZXI9ZnVuY3Rpb24oYSxiKXtiPT09XCJmaWxsXCImJmEmJih1PSEwKTtEKGIsYSl9O2suYW5jaG9yWFNldHRlcj1mdW5jdGlvbihhLGIpe2U9YTtEKGIsQyhhKS1xYi12KX07ay5hbmNob3JZU2V0dGVyPWZ1bmN0aW9uKGEsYil7Zj1hO0QoYixhLUxhKX07ay54U2V0dGVyPWZ1bmN0aW9uKGEpe2sueD1hO28mJihhLT1vKigocHx8bi53aWR0aCkrMip6KSk7dj1DKGEpO2suYXR0cihcInRyYW5zbGF0ZVhcIix2KX07ay55U2V0dGVyPWZ1bmN0aW9uKGEpe0xhPWsueT1DKGEpO2suYXR0cihcInRyYW5zbGF0ZVlcIixMYSl9O3ZhciBCPWsuY3NzO3JldHVybiB4KGsse2NzczpmdW5jdGlvbihhKXtpZihhKXt2YXIgYj17fSxhPUUoYSk7cShrLnRleHRQcm9wcyxmdW5jdGlvbihjKXthW2NdIT09QSYmKGJbY109YVtjXSxkZWxldGUgYVtjXSl9KTtsLmNzcyhiKX1yZXR1cm4gQi5jYWxsKGssYSl9LGdldEJCb3g6ZnVuY3Rpb24oKXtyZXR1cm57d2lkdGg6bi53aWR0aCtcbjIqeixoZWlnaHQ6bi5oZWlnaHQrMip6LHg6bi54LXoseTpuLnkten19LHNoYWRvdzpmdW5jdGlvbihhKXttJiZtLnNoYWRvdyhhKTtyZXR1cm4ga30sZGVzdHJveTpmdW5jdGlvbigpe1koay5lbGVtZW50LFwibW91c2VlbnRlclwiKTtZKGsuZWxlbWVudCxcIm1vdXNlbGVhdmVcIik7bCYmKGw9bC5kZXN0cm95KCkpO20mJihtPW0uZGVzdHJveSgpKTtPLnByb3RvdHlwZS5kZXN0cm95LmNhbGwoayk7az1qPXk9Rj1EPW51bGx9fSl9fTtlYj1FYTt4KE8ucHJvdG90eXBlLHtodG1sQ3NzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudDtpZihiPWEmJmIudGFnTmFtZT09PVwiU1BBTlwiJiZhLndpZHRoKWRlbGV0ZSBhLndpZHRoLHRoaXMudGV4dFdpZHRoPWIsdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtpZihhJiZhLnRleHRPdmVyZmxvdz09PVwiZWxsaXBzaXNcIilhLndoaXRlU3BhY2U9XCJub3dyYXBcIixhLm92ZXJmbG93PVwiaGlkZGVuXCI7dGhpcy5zdHlsZXM9eCh0aGlzLnN0eWxlcyxhKTtNKHRoaXMuZWxlbWVudCxcbmEpO3JldHVybiB0aGlzfSxodG1sR2V0QkJveDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudDtpZihhLm5vZGVOYW1lPT09XCJ0ZXh0XCIpYS5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCI7cmV0dXJue3g6YS5vZmZzZXRMZWZ0LHk6YS5vZmZzZXRUb3Asd2lkdGg6YS5vZmZzZXRXaWR0aCxoZWlnaHQ6YS5vZmZzZXRIZWlnaHR9fSxodG1sVXBkYXRlVHJhbnNmb3JtOmZ1bmN0aW9uKCl7aWYodGhpcy5hZGRlZCl7dmFyIGE9dGhpcy5yZW5kZXJlcixiPXRoaXMuZWxlbWVudCxjPXRoaXMudHJhbnNsYXRlWHx8MCxkPXRoaXMudHJhbnNsYXRlWXx8MCxlPXRoaXMueHx8MCxmPXRoaXMueXx8MCxnPXRoaXMudGV4dEFsaWdufHxcImxlZnRcIixoPXtsZWZ0OjAsY2VudGVyOjAuNSxyaWdodDoxfVtnXSxpPXRoaXMuc2hhZG93cyxqPXRoaXMuc3R5bGVzO00oYix7bWFyZ2luTGVmdDpjLG1hcmdpblRvcDpkfSk7aSYmcShpLGZ1bmN0aW9uKGEpe00oYSx7bWFyZ2luTGVmdDpjKzEsbWFyZ2luVG9wOmQrXG4xfSl9KTt0aGlzLmludmVydGVkJiZxKGIuY2hpbGROb2RlcyxmdW5jdGlvbihjKXthLmludmVydENoaWxkKGMsYil9KTtpZihiLnRhZ05hbWU9PT1cIlNQQU5cIil7dmFyIGk9dGhpcy5yb3RhdGlvbixrPUIodGhpcy50ZXh0V2lkdGgpLGw9aiYmai53aGl0ZVNwYWNlLG09W2ksZyxiLmlubmVySFRNTCx0aGlzLnRleHRXaWR0aCx0aGlzLnRleHRBbGlnbl0uam9pbihcIixcIik7aWYobSE9PXRoaXMuY1RUKXtqPWEuZm9udE1ldHJpY3MoYi5zdHlsZS5mb250U2l6ZSkuYjtzKGkpJiZ0aGlzLnNldFNwYW5Sb3RhdGlvbihpLGgsaik7TShiLHt3aWR0aDpcIlwiLHdoaXRlU3BhY2U6bHx8XCJub3dyYXBcIn0pO2lmKGIub2Zmc2V0V2lkdGg+ayYmL1sgXFwtXS8udGVzdChiLnRleHRDb250ZW50fHxiLmlubmVyVGV4dCkpTShiLHt3aWR0aDprK1wicHhcIixkaXNwbGF5OlwiYmxvY2tcIix3aGl0ZVNwYWNlOmx8fFwibm9ybWFsXCJ9KTt0aGlzLmdldFNwYW5Db3JyZWN0aW9uKGIub2Zmc2V0V2lkdGgsaixoLGksZyl9TShiLFxue2xlZnQ6ZSsodGhpcy54Q29ycnx8MCkrXCJweFwiLHRvcDpmKyh0aGlzLnlDb3JyfHwwKStcInB4XCJ9KTtpZihvYilqPWIub2Zmc2V0SGVpZ2h0O3RoaXMuY1RUPW19fWVsc2UgdGhpcy5hbGlnbk9uQWRkPSEwfSxzZXRTcGFuUm90YXRpb246ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXt9LGU9emE/XCItbXMtdHJhbnNmb3JtXCI6b2I/XCItd2Via2l0LXRyYW5zZm9ybVwiOlFhP1wiTW96VHJhbnNmb3JtXCI6TWI/XCItby10cmFuc2Zvcm1cIjpcIlwiO2RbZV09ZC50cmFuc2Zvcm09XCJyb3RhdGUoXCIrYStcImRlZylcIjtkW2UrKFFhP1wiT3JpZ2luXCI6XCItb3JpZ2luXCIpXT1kLnRyYW5zZm9ybU9yaWdpbj1iKjEwMCtcIiUgXCIrYytcInB4XCI7TSh0aGlzLmVsZW1lbnQsZCl9LGdldFNwYW5Db3JyZWN0aW9uOmZ1bmN0aW9uKGEsYixjKXt0aGlzLnhDb3JyPS1hKmM7dGhpcy55Q29ycj0tYn19KTt4KEVhLnByb3RvdHlwZSx7aHRtbDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5jcmVhdGVFbGVtZW50KFwic3BhblwiKSxlPVxuZC5lbGVtZW50LGY9ZC5yZW5kZXJlcixnPWYuaXNTVkcsaD1mdW5jdGlvbihhLGIpe3EoW1wib3BhY2l0eVwiLFwidmlzaWJpbGl0eVwiXSxmdW5jdGlvbihjKXtoYihhLGMrXCJTZXR0ZXJcIixmdW5jdGlvbihhLGMsZCxlKXthLmNhbGwodGhpcyxjLGQsZSk7YltkXT1jfSl9KX07ZC50ZXh0U2V0dGVyPWZ1bmN0aW9uKGEpe2EhPT1lLmlubmVySFRNTCYmZGVsZXRlIHRoaXMuYkJveDtlLmlubmVySFRNTD10aGlzLnRleHRTdHI9YTtkLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKX07ZyYmaChkLGQuZWxlbWVudC5zdHlsZSk7ZC54U2V0dGVyPWQueVNldHRlcj1kLmFsaWduU2V0dGVyPWQucm90YXRpb25TZXR0ZXI9ZnVuY3Rpb24oYSxiKXtiPT09XCJhbGlnblwiJiYoYj1cInRleHRBbGlnblwiKTtkW2JdPWE7ZC5odG1sVXBkYXRlVHJhbnNmb3JtKCl9O2QuYXR0cih7dGV4dDphLHg6QyhiKSx5OkMoYyl9KS5jc3Moe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixmb250RmFtaWx5OnRoaXMuc3R5bGUuZm9udEZhbWlseSxcbmZvbnRTaXplOnRoaXMuc3R5bGUuZm9udFNpemV9KTtlLnN0eWxlLndoaXRlU3BhY2U9XCJub3dyYXBcIjtkLmNzcz1kLmh0bWxDc3M7aWYoZylkLmFkZD1mdW5jdGlvbihhKXt2YXIgYixjPWYuYm94LnBhcmVudE5vZGUsZz1bXTtpZih0aGlzLnBhcmVudEdyb3VwPWEpe2lmKGI9YS5kaXYsIWIpe2Zvcig7YTspZy5wdXNoKGEpLGE9YS5wYXJlbnRHcm91cDtxKGcucmV2ZXJzZSgpLGZ1bmN0aW9uKGEpe3ZhciBkLGU9UChhLmVsZW1lbnQsXCJjbGFzc1wiKTtlJiYoZT17Y2xhc3NOYW1lOmV9KTtiPWEuZGl2PWEuZGl2fHxkYShQYSxlLHtwb3NpdGlvbjpcImFic29sdXRlXCIsbGVmdDooYS50cmFuc2xhdGVYfHwwKStcInB4XCIsdG9wOihhLnRyYW5zbGF0ZVl8fDApK1wicHhcIixvcGFjaXR5OmEub3BhY2l0eX0sYnx8Yyk7ZD1iLnN0eWxlO3goYSx7dHJhbnNsYXRlWFNldHRlcjpmdW5jdGlvbihiLGMpe2QubGVmdD1iK1wicHhcIjthW2NdPWI7YS5kb1RyYW5zZm9ybT0hMH0sdHJhbnNsYXRlWVNldHRlcjpmdW5jdGlvbihiLFxuYyl7ZC50b3A9YitcInB4XCI7YVtjXT1iO2EuZG9UcmFuc2Zvcm09ITB9fSk7aChhLGQpfSl9fWVsc2UgYj1jO2IuYXBwZW5kQ2hpbGQoZSk7ZC5hZGRlZD0hMDtkLmFsaWduT25BZGQmJmQuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpO3JldHVybiBkfTtyZXR1cm4gZH19KTt2YXIgSztpZighZ2EmJiFsYSl7Sz17aW5pdDpmdW5jdGlvbihhLGIpe3ZhciBjPVtcIjxcIixiLCcgZmlsbGVkPVwiZlwiIHN0cm9rZWQ9XCJmXCInXSxkPVtcInBvc2l0aW9uOiBcIixcImFic29sdXRlXCIsXCI7XCJdLGU9Yj09PVBhOyhiPT09XCJzaGFwZVwifHxlKSYmZC5wdXNoKFwibGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4O1wiKTtkLnB1c2goXCJ2aXNpYmlsaXR5OiBcIixlP1wiaGlkZGVuXCI6XCJ2aXNpYmxlXCIpO2MucHVzaCgnIHN0eWxlPVwiJyxkLmpvaW4oXCJcIiksJ1wiLz4nKTtpZihiKWM9ZXx8Yj09PVwic3BhblwifHxiPT09XCJpbWdcIj9jLmpvaW4oXCJcIik6YS5wcmVwVk1MKGMpLHRoaXMuZWxlbWVudD1kYShjKTt0aGlzLnJlbmRlcmVyPVxuYX0sYWRkOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMucmVuZGVyZXIsYz10aGlzLmVsZW1lbnQsZD1iLmJveCxlPWEmJmEuaW52ZXJ0ZWQsZD1hP2EuZWxlbWVudHx8YTpkO2lmKGEpdGhpcy5wYXJlbnRHcm91cD1hO2UmJmIuaW52ZXJ0Q2hpbGQoYyxkKTtkLmFwcGVuZENoaWxkKGMpO3RoaXMuYWRkZWQ9ITA7dGhpcy5hbGlnbk9uQWRkJiYhdGhpcy5kZWZlclVwZGF0ZVRyYW5zZm9ybSYmdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtpZih0aGlzLm9uQWRkKXRoaXMub25BZGQoKTtyZXR1cm4gdGhpc30sdXBkYXRlVHJhbnNmb3JtOk8ucHJvdG90eXBlLmh0bWxVcGRhdGVUcmFuc2Zvcm0sc2V0U3BhblJvdGF0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5yb3RhdGlvbixiPVcoYSprYSksYz1lYShhKmthKTtNKHRoaXMuZWxlbWVudCx7ZmlsdGVyOmE/W1wicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9XCIsYixcIiwgTTEyPVwiLC1jLFwiLCBNMjE9XCIsYyxcIiwgTTIyPVwiLFxuYixcIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpXCJdLmpvaW4oXCJcIik6XCJub25lXCJ9KX0sZ2V0U3BhbkNvcnJlY3Rpb246ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1kP1coZCprYSk6MSxnPWQ/ZWEoZCprYSk6MCxoPXAodGhpcy5lbGVtSGVpZ2h0LHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQpLGk7dGhpcy54Q29ycj1mPDAmJi1hO3RoaXMueUNvcnI9ZzwwJiYtaDtpPWYqZzwwO3RoaXMueENvcnIrPWcqYiooaT8xLWM6Yyk7dGhpcy55Q29yci09ZipiKihkP2k/YzoxLWM6MSk7ZSYmZSE9PVwibGVmdFwiJiYodGhpcy54Q29yci09YSpjKihmPDA/LTE6MSksZCYmKHRoaXMueUNvcnItPWgqYyooZzwwPy0xOjEpKSxNKHRoaXMuZWxlbWVudCx7dGV4dEFsaWduOmV9KSl9LHBhdGhUb1ZNTDpmdW5jdGlvbihhKXtmb3IodmFyIGI9YS5sZW5ndGgsYz1bXTtiLS07KWlmKEooYVtiXSkpY1tiXT1DKGFbYl0qMTApLTU7ZWxzZSBpZihhW2JdPT09XCJaXCIpY1tiXT1cInhcIjtlbHNlIGlmKGNbYl09XG5hW2JdLGEuaXNBcmMmJihhW2JdPT09XCJ3YVwifHxhW2JdPT09XCJhdFwiKSljW2IrNV09PT1jW2IrN10mJihjW2IrN10rPWFbYis3XT5hW2IrNV0/MTotMSksY1tiKzZdPT09Y1tiKzhdJiYoY1tiKzhdKz1hW2IrOF0+YVtiKzZdPzE6LTEpO3JldHVybiBjLmpvaW4oXCIgXCIpfHxcInhcIn0sY2xpcDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM7YT8oYz1hLm1lbWJlcnMscmEoYyxiKSxjLnB1c2goYiksYi5kZXN0cm95Q2xpcD1mdW5jdGlvbigpe3JhKGMsYil9LGE9YS5nZXRDU1MoYikpOihiLmRlc3Ryb3lDbGlwJiZiLmRlc3Ryb3lDbGlwKCksYT17Y2xpcDpuYj9cImluaGVyaXRcIjpcInJlY3QoYXV0bylcIn0pO3JldHVybiBiLmNzcyhhKX0sY3NzOk8ucHJvdG90eXBlLmh0bWxDc3Msc2FmZVJlbW92ZUNoaWxkOmZ1bmN0aW9uKGEpe2EucGFyZW50Tm9kZSYmVWEoYSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLmRlc3Ryb3lDbGlwJiZ0aGlzLmRlc3Ryb3lDbGlwKCk7cmV0dXJuIE8ucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcyl9LFxub246ZnVuY3Rpb24oYSxiKXt0aGlzLmVsZW1lbnRbXCJvblwiK2FdPWZ1bmN0aW9uKCl7dmFyIGE9RC5ldmVudDthLnRhcmdldD1hLnNyY0VsZW1lbnQ7YihhKX07cmV0dXJuIHRoaXN9LGN1dE9mZlBhdGg6ZnVuY3Rpb24oYSxiKXt2YXIgYyxhPWEuc3BsaXQoL1sgLF0vKTtjPWEubGVuZ3RoO2lmKGM9PT05fHxjPT09MTEpYVtjLTRdPWFbYy0yXT1CKGFbYy0yXSktMTAqYjtyZXR1cm4gYS5qb2luKFwiIFwiKX0sc2hhZG93OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1bXSxlLGY9dGhpcy5lbGVtZW50LGc9dGhpcy5yZW5kZXJlcixoLGk9Zi5zdHlsZSxqLGs9Zi5wYXRoLGwsbSxuLG87ayYmdHlwZW9mIGsudmFsdWUhPT1cInN0cmluZ1wiJiYoaz1cInhcIik7bT1rO2lmKGEpe249cChhLndpZHRoLDMpO289KGEub3BhY2l0eXx8MC4xNSkvbjtmb3IoZT0xO2U8PTM7ZSsrKXtsPW4qMisxLTIqZTtjJiYobT10aGlzLmN1dE9mZlBhdGgoay52YWx1ZSxsKzAuNSkpO2o9Wyc8c2hhcGUgaXNTaGFkb3c9XCJ0cnVlXCIgc3Ryb2tld2VpZ2h0PVwiJyxcbmwsJ1wiIGZpbGxlZD1cImZhbHNlXCIgcGF0aD1cIicsbSwnXCIgY29vcmRzaXplPVwiMTAgMTBcIiBzdHlsZT1cIicsZi5zdHlsZS5jc3NUZXh0LCdcIiAvPiddO2g9ZGEoZy5wcmVwVk1MKGopLG51bGwse2xlZnQ6QihpLmxlZnQpK3AoYS5vZmZzZXRYLDEpLHRvcDpCKGkudG9wKStwKGEub2Zmc2V0WSwxKX0pO2lmKGMpaC5jdXRPZmY9bCsxO2o9Wyc8c3Ryb2tlIGNvbG9yPVwiJyxhLmNvbG9yfHxcImJsYWNrXCIsJ1wiIG9wYWNpdHk9XCInLG8qZSwnXCIvPiddO2RhKGcucHJlcFZNTChqKSxudWxsLG51bGwsaCk7Yj9iLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaCk6Zi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShoLGYpO2QucHVzaChoKX10aGlzLnNoYWRvd3M9ZH1yZXR1cm4gdGhpc30sdXBkYXRlU2hhZG93czpCYSxzZXRBdHRyOmZ1bmN0aW9uKGEsYil7bmI/dGhpcy5lbGVtZW50W2FdPWI6dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShhLGIpfSxjbGFzc1NldHRlcjpmdW5jdGlvbihhKXt0aGlzLmVsZW1lbnQuY2xhc3NOYW1lPVxuYX0sZGFzaHN0eWxlU2V0dGVyOmZ1bmN0aW9uKGEsYixjKXsoYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN0cm9rZVwiKVswXXx8ZGEodGhpcy5yZW5kZXJlci5wcmVwVk1MKFtcIjxzdHJva2UvPlwiXSksbnVsbCxudWxsLGMpKVtiXT1hfHxcInNvbGlkXCI7dGhpc1tiXT1hfSxkU2V0dGVyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLnNoYWRvd3MsYT1hfHxbXTt0aGlzLmQ9YS5qb2luJiZhLmpvaW4oXCIgXCIpO2MucGF0aD1hPXRoaXMucGF0aFRvVk1MKGEpO2lmKGQpZm9yKGM9ZC5sZW5ndGg7Yy0tOylkW2NdLnBhdGg9ZFtjXS5jdXRPZmY/dGhpcy5jdXRPZmZQYXRoKGEsZFtjXS5jdXRPZmYpOmE7dGhpcy5zZXRBdHRyKGIsYSl9LGZpbGxTZXR0ZXI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWMubm9kZU5hbWU7aWYoZD09PVwiU1BBTlwiKWMuc3R5bGUuY29sb3I9YTtlbHNlIGlmKGQhPT1cIklNR1wiKWMuZmlsbGVkPWEhPT1cIm5vbmVcIix0aGlzLnNldEF0dHIoXCJmaWxsY29sb3JcIix0aGlzLnJlbmRlcmVyLmNvbG9yKGEsXG5jLGIsdGhpcykpfSxcImZpbGwtb3BhY2l0eVNldHRlclwiOmZ1bmN0aW9uKGEsYixjKXtkYSh0aGlzLnJlbmRlcmVyLnByZXBWTUwoW1wiPFwiLGIuc3BsaXQoXCItXCIpWzBdLCcgb3BhY2l0eT1cIicsYSwnXCIvPiddKSxudWxsLG51bGwsYyl9LG9wYWNpdHlTZXR0ZXI6QmEscm90YXRpb25TZXR0ZXI6ZnVuY3Rpb24oYSxiLGMpe2M9Yy5zdHlsZTt0aGlzW2JdPWNbYl09YTtjLmxlZnQ9LUMoZWEoYSprYSkrMSkrXCJweFwiO2MudG9wPUMoVyhhKmthKSkrXCJweFwifSxzdHJva2VTZXR0ZXI6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuc2V0QXR0cihcInN0cm9rZWNvbG9yXCIsdGhpcy5yZW5kZXJlci5jb2xvcihhLGMsYix0aGlzKSl9LFwic3Ryb2tlLXdpZHRoU2V0dGVyXCI6ZnVuY3Rpb24oYSxiLGMpe2Muc3Ryb2tlZD0hIWE7dGhpc1tiXT1hO0ooYSkmJihhKz1cInB4XCIpO3RoaXMuc2V0QXR0cihcInN0cm9rZXdlaWdodFwiLGEpfSx0aXRsZVNldHRlcjpmdW5jdGlvbihhLGIpe3RoaXMuc2V0QXR0cihiLGEpfSx2aXNpYmlsaXR5U2V0dGVyOmZ1bmN0aW9uKGEsXG5iLGMpe2E9PT1cImluaGVyaXRcIiYmKGE9XCJ2aXNpYmxlXCIpO3RoaXMuc2hhZG93cyYmcSh0aGlzLnNoYWRvd3MsZnVuY3Rpb24oYyl7Yy5zdHlsZVtiXT1hfSk7Yy5ub2RlTmFtZT09PVwiRElWXCImJihhPWE9PT1cImhpZGRlblwiP1wiLTk5OWVtXCI6MCxuYnx8KGMuc3R5bGVbYl09YT9cInZpc2libGVcIjpcImhpZGRlblwiKSxiPVwidG9wXCIpO2Muc3R5bGVbYl09YX0seFNldHRlcjpmdW5jdGlvbihhLGIsYyl7dGhpc1tiXT1hO2I9PT1cInhcIj9iPVwibGVmdFwiOmI9PT1cInlcIiYmKGI9XCJ0b3BcIik7dGhpcy51cGRhdGVDbGlwcGluZz8odGhpc1tiXT1hLHRoaXMudXBkYXRlQ2xpcHBpbmcoKSk6Yy5zdHlsZVtiXT1hfSx6SW5kZXhTZXR0ZXI6ZnVuY3Rpb24oYSxiLGMpe2Muc3R5bGVbYl09YX19O0tbXCJzdHJva2Utb3BhY2l0eVNldHRlclwiXT1LW1wiZmlsbC1vcGFjaXR5U2V0dGVyXCJdO3UuVk1MRWxlbWVudD1LPXNhKE8sSyk7Sy5wcm90b3R5cGUueVNldHRlcj1LLnByb3RvdHlwZS53aWR0aFNldHRlcj1LLnByb3RvdHlwZS5oZWlnaHRTZXR0ZXI9XG5LLnByb3RvdHlwZS54U2V0dGVyO3ZhciBEYj17RWxlbWVudDpLLGlzSUU4OkFhLmluZGV4T2YoXCJNU0lFIDguMFwiKT4tMSxpbml0OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlO3RoaXMuYWxpZ25lZE9iamVjdHM9W107ZD10aGlzLmNyZWF0ZUVsZW1lbnQoUGEpLmNzcyh4KHRoaXMuZ2V0U3R5bGUoZCkse3Bvc2l0aW9uOlwicmVsYXRpdmVcIn0pKTtlPWQuZWxlbWVudDthLmFwcGVuZENoaWxkKGQuZWxlbWVudCk7dGhpcy5pc1ZNTD0hMDt0aGlzLmJveD1lO3RoaXMuYm94V3JhcHBlcj1kO3RoaXMuZ3JhZGllbnRzPXt9O3RoaXMuY2FjaGU9e307dGhpcy5jYWNoZUtleXM9W107dGhpcy5pbWdDb3VudD0wO3RoaXMuc2V0U2l6ZShiLGMsITEpO2lmKCF5Lm5hbWVzcGFjZXMuaGN2KXt5Lm5hbWVzcGFjZXMuYWRkKFwiaGN2XCIsXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbFwiKTt0cnl7eS5jcmVhdGVTdHlsZVNoZWV0KCkuY3NzVGV4dD1cImhjdlxcXFw6ZmlsbCwgaGN2XFxcXDpwYXRoLCBoY3ZcXFxcOnNoYXBlLCBoY3ZcXFxcOnN0cm9rZXsgYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCk7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgfSBcIn1jYXRjaChmKXt5LnN0eWxlU2hlZXRzWzBdLmNzc1RleHQrPVxuXCJoY3ZcXFxcOmZpbGwsIGhjdlxcXFw6cGF0aCwgaGN2XFxcXDpzaGFwZSwgaGN2XFxcXDpzdHJva2V7IGJlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH0gXCJ9fX0saXNIaWRkZW46ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5ib3gub2Zmc2V0V2lkdGh9LGNsaXBSZWN0OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuY3JlYXRlRWxlbWVudCgpLGY9JChhKTtyZXR1cm4geChlLHttZW1iZXJzOltdLGNvdW50OjAsbGVmdDooZj9hLng6YSkrMSx0b3A6KGY/YS55OmIpKzEsd2lkdGg6KGY/YS53aWR0aDpjKS0xLGhlaWdodDooZj9hLmhlaWdodDpkKS0xLGdldENTUzpmdW5jdGlvbihhKXt2YXIgYj1hLmVsZW1lbnQsYz1iLm5vZGVOYW1lLGE9YS5pbnZlcnRlZCxkPXRoaXMudG9wLShjPT09XCJzaGFwZVwiP2Iub2Zmc2V0VG9wOjApLGU9dGhpcy5sZWZ0LGI9ZSt0aGlzLndpZHRoLGY9ZCt0aGlzLmhlaWdodCxkPXtjbGlwOlwicmVjdChcIitDKGE/ZTpkKStcInB4LFwiK1xuQyhhP2Y6YikrXCJweCxcIitDKGE/YjpmKStcInB4LFwiK0MoYT9kOmUpK1wicHgpXCJ9OyFhJiZuYiYmYz09PVwiRElWXCImJngoZCx7d2lkdGg6YitcInB4XCIsaGVpZ2h0OmYrXCJweFwifSk7cmV0dXJuIGR9LHVwZGF0ZUNsaXBwaW5nOmZ1bmN0aW9uKCl7cShlLm1lbWJlcnMsZnVuY3Rpb24oYSl7YS5lbGVtZW50JiZhLmNzcyhlLmdldENTUyhhKSl9KX19KX0sY29sb3I6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcyxmLGc9L15yZ2JhLyxoLGksaj1cIm5vbmVcIjthJiZhLmxpbmVhckdyYWRpZW50P2k9XCJncmFkaWVudFwiOmEmJmEucmFkaWFsR3JhZGllbnQmJihpPVwicGF0dGVyblwiKTtpZihpKXt2YXIgayxsLG09YS5saW5lYXJHcmFkaWVudHx8YS5yYWRpYWxHcmFkaWVudCxuLG8seixyLHAsdz1cIlwiLGE9YS5zdG9wcyx2LHM9W10sdD1mdW5jdGlvbigpe2g9Wyc8ZmlsbCBjb2xvcnM9XCInK3Muam9pbihcIixcIikrJ1wiIG9wYWNpdHk9XCInLHosJ1wiIG86b3BhY2l0eTI9XCInLG8sJ1wiIHR5cGU9XCInLGksJ1wiICcsXG53LCdmb2N1cz1cIjEwMCVcIiBtZXRob2Q9XCJhbnlcIiAvPiddO2RhKGUucHJlcFZNTChoKSxudWxsLG51bGwsYil9O249YVswXTt2PWFbYS5sZW5ndGgtMV07blswXT4wJiZhLnVuc2hpZnQoWzAsblsxXV0pO3ZbMF08MSYmYS5wdXNoKFsxLHZbMV1dKTtxKGEsZnVuY3Rpb24oYSxiKXtnLnRlc3QoYVsxXSk/KGY9bmEoYVsxXSksaz1mLmdldChcInJnYlwiKSxsPWYuZ2V0KFwiYVwiKSk6KGs9YVsxXSxsPTEpO3MucHVzaChhWzBdKjEwMCtcIiUgXCIrayk7Yj8oej1sLHI9ayk6KG89bCxwPWspfSk7aWYoYz09PVwiZmlsbFwiKWlmKGk9PT1cImdyYWRpZW50XCIpYz1tLngxfHxtWzBdfHwwLGE9bS55MXx8bVsxXXx8MCxuPW0ueDJ8fG1bMl18fDAsbT1tLnkyfHxtWzNdfHwwLHc9J2FuZ2xlPVwiJysoOTAtWi5hdGFuKChtLWEpLyhuLWMpKSoxODAvdGEpKydcIicsdCgpO2Vsc2V7dmFyIGo9bS5yLGJhPWoqMix4PWoqMix1PW0uY3gsQT1tLmN5LEM9Yi5yYWRpYWxSZWZlcmVuY2UseSxqPWZ1bmN0aW9uKCl7QyYmXG4oeT1kLmdldEJCb3goKSx1Kz0oQ1swXS15LngpL3kud2lkdGgtMC41LEErPShDWzFdLXkueSkveS5oZWlnaHQtMC41LGJhKj1DWzJdL3kud2lkdGgseCo9Q1syXS95LmhlaWdodCk7dz0nc3JjPVwiJytVLmdsb2JhbC5WTUxSYWRpYWxHcmFkaWVudFVSTCsnXCIgc2l6ZT1cIicrYmErXCIsXCIreCsnXCIgb3JpZ2luPVwiMC41LDAuNVwiIHBvc2l0aW9uPVwiJyt1K1wiLFwiK0ErJ1wiIGNvbG9yMj1cIicrcCsnXCIgJzt0KCl9O2QuYWRkZWQ/aigpOmQub25BZGQ9ajtqPXJ9ZWxzZSBqPWt9ZWxzZSBpZihnLnRlc3QoYSkmJmIudGFnTmFtZSE9PVwiSU1HXCIpZj1uYShhKSxkW2MrXCItb3BhY2l0eVNldHRlclwiXShmLmdldChcImFcIiksYyxiKSxqPWYuZ2V0KFwicmdiXCIpO2Vsc2V7aj1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGMpO2lmKGoubGVuZ3RoKWpbMF0ub3BhY2l0eT0xLGpbMF0udHlwZT1cInNvbGlkXCI7aj1hfXJldHVybiBqfSxwcmVwVk1MOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuaXNJRTgsYT1hLmpvaW4oXCJcIik7XG5iPyhhPWEucmVwbGFjZShcIi8+XCIsJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sXCIgLz4nKSxhPWEuaW5kZXhPZignc3R5bGU9XCInKT09PS0xP2EucmVwbGFjZShcIi8+XCIsJyBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpO1wiIC8+Jyk6YS5yZXBsYWNlKCdzdHlsZT1cIicsJ3N0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2s7YmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCk7JykpOmE9YS5yZXBsYWNlKFwiPFwiLFwiPGhjdjpcIik7cmV0dXJuIGF9LHRleHQ6RWEucHJvdG90eXBlLmh0bWwscGF0aDpmdW5jdGlvbihhKXt2YXIgYj17Y29vcmRzaXplOlwiMTAgMTBcIn07RmEoYSk/Yi5kPWE6JChhKSYmeChiLGEpO3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJzaGFwZVwiKS5hdHRyKGIpfSxjaXJjbGU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuc3ltYm9sKFwiY2lyY2xlXCIpO2lmKCQoYSkpYz1hLnIsYj1hLnksYT1hLng7ZC5pc0NpcmNsZT1cbiEwO2Qucj1jO3JldHVybiBkLmF0dHIoe3g6YSx5OmJ9KX0sZzpmdW5jdGlvbihhKXt2YXIgYjthJiYoYj17Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1cIithLFwiY2xhc3NcIjpcImhpZ2hjaGFydHMtXCIrYX0pO3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoUGEpLmF0dHIoYil9LGltYWdlOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLmF0dHIoe3NyYzphfSk7YXJndW1lbnRzLmxlbmd0aD4xJiZmLmF0dHIoe3g6Yix5OmMsd2lkdGg6ZCxoZWlnaHQ6ZX0pO3JldHVybiBmfSxjcmVhdGVFbGVtZW50OmZ1bmN0aW9uKGEpe3JldHVybiBhPT09XCJyZWN0XCI/dGhpcy5zeW1ib2woYSk6RWEucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLGEpfSxpbnZlcnRDaGlsZDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1iLnN0eWxlLGU9YS50YWdOYW1lPT09XCJJTUdcIiYmYS5zdHlsZTtNKGEse2ZsaXA6XCJ4XCIsbGVmdDpCKGQud2lkdGgpLShlP0IoZS50b3ApOlxuMSksdG9wOkIoZC5oZWlnaHQpLShlP0IoZS5sZWZ0KToxKSxyb3RhdGlvbjotOTB9KTtxKGEuY2hpbGROb2RlcyxmdW5jdGlvbihiKXtjLmludmVydENoaWxkKGIsYSl9KX0sc3ltYm9sczp7YXJjOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9ZS5zdGFydCxnPWUuZW5kLGg9ZS5yfHxjfHxkLGM9ZS5pbm5lclIsZD1XKGYpLGk9ZWEoZiksaj1XKGcpLGs9ZWEoZyk7aWYoZy1mPT09MClyZXR1cm5bXCJ4XCJdO2Y9W1wid2FcIixhLWgsYi1oLGEraCxiK2gsYStoKmQsYitoKmksYStoKmosYitoKmtdO2Uub3BlbiYmIWMmJmYucHVzaChcImVcIixYLGEsYik7Zi5wdXNoKFwiYXRcIixhLWMsYi1jLGErYyxiK2MsYStjKmosYitjKmssYStjKmQsYitjKmksXCJ4XCIsXCJlXCIpO2YuaXNBcmM9ITA7cmV0dXJuIGZ9LGNpcmNsZTpmdW5jdGlvbihhLGIsYyxkLGUpe2UmJihjPWQ9MiplLnIpO2UmJmUuaXNDaXJjbGUmJihhLT1jLzIsYi09ZC8yKTtyZXR1cm5bXCJ3YVwiLGEsYixhK2MsYitkLGErYyxiK2QvMixhK2MsXG5iK2QvMixcImVcIl19LHJlY3Q6ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gRWEucHJvdG90eXBlLnN5bWJvbHNbIXMoZSl8fCFlLnI/XCJzcXVhcmVcIjpcImNhbGxvdXRcIl0uY2FsbCgwLGEsYixjLGQsZSl9fX07dS5WTUxSZW5kZXJlcj1LPWZ1bmN0aW9uKCl7dGhpcy5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07Sy5wcm90b3R5cGU9RShFYS5wcm90b3R5cGUsRGIpO2ViPUt9RWEucHJvdG90eXBlLm1lYXN1cmVTcGFuV2lkdGg9ZnVuY3Rpb24oYSxiKXt2YXIgYz15LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLGQ7ZD15LmNyZWF0ZVRleHROb2RlKGEpO2MuYXBwZW5kQ2hpbGQoZCk7TShjLGIpO3RoaXMuYm94LmFwcGVuZENoaWxkKGMpO2Q9Yy5vZmZzZXRXaWR0aDtVYShjKTtyZXR1cm4gZH07dmFyIFBiO2lmKGxhKXUuQ2FuVkdSZW5kZXJlcj1LPWZ1bmN0aW9uKCl7SWE9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJ9LEsucHJvdG90eXBlLnN5bWJvbHM9e30sUGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dmFyIGE9XG5iLmxlbmd0aCxkO2ZvcihkPTA7ZDxhO2QrKyliW2RdKCk7Yj1bXX12YXIgYj1bXTtyZXR1cm57cHVzaDpmdW5jdGlvbihjLGQpe2lmKGIubGVuZ3RoPT09MCl7dmFyIGU9eS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0sZj15LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7Zi50eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI7Zi5zcmM9ZDtmLm9ubG9hZD1hO2UuYXBwZW5kQ2hpbGQoZil9Yi5wdXNoKGMpfX19KCksZWI9SztYYS5wcm90b3R5cGU9e2FkZExhYmVsOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5heGlzLGI9YS5vcHRpb25zLGM9YS5jaGFydCxkPWEuY2F0ZWdvcmllcyxlPWEubmFtZXMsZj10aGlzLnBvcyxnPWIubGFiZWxzLGg9YS50aWNrUG9zaXRpb25zLGk9Zj09PWhbMF0saj1mPT09aFtoLmxlbmd0aC0xXSxlPWQ/cChkW2ZdLGVbZl0sZik6ZixkPXRoaXMubGFiZWwsaD1oLmluZm8sazthLmlzRGF0ZXRpbWVBeGlzJiZoJiYoaz1iLmRhdGVUaW1lTGFiZWxGb3JtYXRzW2guaGlnaGVyUmFua3NbZl18fFxuaC51bml0TmFtZV0pO3RoaXMuaXNGaXJzdD1pO3RoaXMuaXNMYXN0PWo7Yj1hLmxhYmVsRm9ybWF0dGVyLmNhbGwoe2F4aXM6YSxjaGFydDpjLGlzRmlyc3Q6aSxpc0xhc3Q6aixkYXRlVGltZUxhYmVsRm9ybWF0OmssdmFsdWU6YS5pc0xvZz9hYShhLmxpbjJsb2coZSkpOmV9KTtzKGQpP2QmJmQuYXR0cih7dGV4dDpifSk6KHRoaXMubGFiZWxMZW5ndGg9KHRoaXMubGFiZWw9ZD1zKGIpJiZnLmVuYWJsZWQ/Yy5yZW5kZXJlci50ZXh0KGIsMCwwLGcudXNlSFRNTCkuY3NzKEUoZy5zdHlsZSkpLmFkZChhLmxhYmVsR3JvdXApOm51bGwpJiZkLmdldEJCb3goKS53aWR0aCx0aGlzLnJvdGF0aW9uPTApfSxnZXRMYWJlbFNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbD90aGlzLmxhYmVsLmdldEJCb3goKVt0aGlzLmF4aXMuaG9yaXo/XCJoZWlnaHRcIjpcIndpZHRoXCJdOjB9LGhhbmRsZU92ZXJmbG93OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYXhpcyxjPWEueCxkPWIuY2hhcnQuY2hhcnRXaWR0aCxcbmU9Yi5jaGFydC5zcGFjaW5nLGY9cChiLmxhYmVsTGVmdCxGKGIucG9zLGVbM10pKSxlPXAoYi5sYWJlbFJpZ2h0LHQoYi5wb3MrYi5sZW4sZC1lWzFdKSksZz10aGlzLmxhYmVsLGg9dGhpcy5yb3RhdGlvbixpPXtsZWZ0OjAsY2VudGVyOjAuNSxyaWdodDoxfVtiLmxhYmVsQWxpZ25dLGo9Zy5nZXRCQm94KCkud2lkdGgsaz1iLmdldFNsb3RXaWR0aCgpLGw9ayxtPTEsbixvPXt9O2lmKGgpaDwwJiZjLWkqajxmP249QyhjL1coaCprYSktZik6aD4wJiZjK2kqaj5lJiYobj1DKChkLWMpL1coaCprYSkpKTtlbHNlIGlmKGQ9YysoMS1pKSpqLGMtaSpqPGY/bD1hLngrbCooMS1pKS1mOmQ+ZSYmKGw9ZS1hLngrbCppLG09LTEpLGw9RihrLGwpLGw8ayYmYi5sYWJlbEFsaWduPT09XCJjZW50ZXJcIiYmKGEueCs9bSooay1sLWkqKGstRihqLGwpKSkpLGo+bHx8Yi5hdXRvUm90YXRpb24mJmcuc3R5bGVzLndpZHRoKW49bDtpZihuKXtvLndpZHRoPW47aWYoIWIub3B0aW9ucy5sYWJlbHMuc3R5bGUudGV4dE92ZXJmbG93KW8udGV4dE92ZXJmbG93PVxuXCJlbGxpcHNpc1wiO2cuY3NzKG8pfX0sZ2V0UG9zaXRpb246ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5heGlzLGY9ZS5jaGFydCxnPWQmJmYub2xkQ2hhcnRIZWlnaHR8fGYuY2hhcnRIZWlnaHQ7cmV0dXJue3g6YT9lLnRyYW5zbGF0ZShiK2MsbnVsbCxudWxsLGQpK2UudHJhbnNCOmUubGVmdCtlLm9mZnNldCsoZS5vcHBvc2l0ZT8oZCYmZi5vbGRDaGFydFdpZHRofHxmLmNoYXJ0V2lkdGgpLWUucmlnaHQtZS5sZWZ0OjApLHk6YT9nLWUuYm90dG9tK2Uub2Zmc2V0LShlLm9wcG9zaXRlP2UuaGVpZ2h0OjApOmctZS50cmFuc2xhdGUoYitjLG51bGwsbnVsbCxkKS1lLnRyYW5zQn19LGdldExhYmVsUG9zaXRpb246ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoKXt2YXIgaT10aGlzLmF4aXMsaj1pLnRyYW5zQSxrPWkucmV2ZXJzZWQsbD1pLnN0YWdnZXJMaW5lcyxtPWkudGlja1JvdENvcnJ8fHt4OjAseTowfSxuPWUueTtzKG4pfHwobj1pLnNpZGU9PT0wP2Mucm90YXRpb24/LTg6XG4tYy5nZXRCQm94KCkuaGVpZ2h0Omkuc2lkZT09PTI/bS55Kzg6VyhjLnJvdGF0aW9uKmthKSoobS55LWMuZ2V0QkJveCghMSwwKS5oZWlnaHQvMikpO2E9YStlLngrbS54LShmJiZkP2Yqaiooaz8tMToxKTowKTtiPWIrbi0oZiYmIWQ/ZipqKihrPzE6LTEpOjApO2wmJihjPWcvKGh8fDEpJWwsaS5vcHBvc2l0ZSYmKGM9bC1jLTEpLGIrPWMqKGkubGFiZWxPZmZzZXQvbCkpO3JldHVybnt4OmEseTpDKGIpfX0sZ2V0TWFya1BhdGg6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3JldHVybiBmLmNyaXNwTGluZShbWCxhLGIsUyxhKyhlPzA6LWMpLGIrKGU/YzowKV0sZCl9LHJlbmRlcjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5heGlzLGU9ZC5vcHRpb25zLGY9ZC5jaGFydC5yZW5kZXJlcixnPWQuaG9yaXosaD10aGlzLnR5cGUsaT10aGlzLmxhYmVsLGo9dGhpcy5wb3Msaz1lLmxhYmVscyxsPXRoaXMuZ3JpZExpbmUsbT1oP2grXCJHcmlkXCI6XCJncmlkXCIsbj1oP2grXCJUaWNrXCI6XCJ0aWNrXCIsXG5vPWVbbStcIkxpbmVXaWR0aFwiXSx6PWVbbStcIkxpbmVDb2xvclwiXSxyPWVbbStcIkxpbmVEYXNoU3R5bGVcIl0sbT1kLnRpY2tTaXplKG4pLG49ZVtuK1wiQ29sb3JcIl0scT10aGlzLm1hcmssdz1rLnN0ZXAsdj0hMCxzPWQudGlja21hcmtPZmZzZXQsdD10aGlzLmdldFBvc2l0aW9uKGcsaixzLGIpLGJhPXQueCx0PXQueSx4PWcmJmJhPT09ZC5wb3MrZC5sZW58fCFnJiZ0PT09ZC5wb3M/LTE6MSxjPXAoYywxKTt0aGlzLmlzQWN0aXZlPSEwO2lmKG8pe2o9ZC5nZXRQbG90TGluZVBhdGgoaitzLG8qeCxiLCEwKTtpZihsPT09QSl7bD17c3Ryb2tlOnosXCJzdHJva2Utd2lkdGhcIjpvfTtpZihyKWwuZGFzaHN0eWxlPXI7aWYoIWgpbC56SW5kZXg9MTtpZihiKWwub3BhY2l0eT0wO3RoaXMuZ3JpZExpbmU9bD1vP2YucGF0aChqKS5hdHRyKGwpLmFkZChkLmdyaWRHcm91cCk6bnVsbH1pZighYiYmbCYmailsW3RoaXMuaXNOZXc/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHtkOmosb3BhY2l0eTpjfSl9aWYobSlkLm9wcG9zaXRlJiZcbihtWzBdPS1tWzBdKSxoPXRoaXMuZ2V0TWFya1BhdGgoYmEsdCxtWzBdLG1bMV0qeCxnLGYpLHE/cS5hbmltYXRlKHtkOmgsb3BhY2l0eTpjfSk6dGhpcy5tYXJrPWYucGF0aChoKS5hdHRyKHtzdHJva2U6bixcInN0cm9rZS13aWR0aFwiOm1bMV0sb3BhY2l0eTpjfSkuYWRkKGQuYXhpc0dyb3VwKTtpZihpJiZKKGJhKSlpLnh5PXQ9dGhpcy5nZXRMYWJlbFBvc2l0aW9uKGJhLHQsaSxnLGsscyxhLHcpLHRoaXMuaXNGaXJzdCYmIXRoaXMuaXNMYXN0JiYhcChlLnNob3dGaXJzdExhYmVsLDEpfHx0aGlzLmlzTGFzdCYmIXRoaXMuaXNGaXJzdCYmIXAoZS5zaG93TGFzdExhYmVsLDEpP3Y9ITE6ZyYmIWQuaXNSYWRpYWwmJiFrLnN0ZXAmJiFrLnJvdGF0aW9uJiYhYiYmYyE9PTAmJnRoaXMuaGFuZGxlT3ZlcmZsb3codCksdyYmYSV3JiYodj0hMSksdiYmSih0LnkpPyh0Lm9wYWNpdHk9YyxpW3RoaXMuaXNOZXc/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHQpKTooS2EoaSksaS5hdHRyKFwieVwiLC05OTk5KSksXG50aGlzLmlzTmV3PSExfSxkZXN0cm95OmZ1bmN0aW9uKCl7VGEodGhpcyx0aGlzLmF4aXMpfX07dS5QbG90TGluZU9yQmFuZD1mdW5jdGlvbihhLGIpe3RoaXMuYXhpcz1hO2lmKGIpdGhpcy5vcHRpb25zPWIsdGhpcy5pZD1iLmlkfTt1LlBsb3RMaW5lT3JCYW5kLnByb3RvdHlwZT17cmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuYXhpcyxjPWIuaG9yaXosZD1hLm9wdGlvbnMsZT1kLmxhYmVsLGY9YS5sYWJlbCxnPWQud2lkdGgsaD1kLnRvLGk9ZC5mcm9tLGo9cyhpKSYmcyhoKSxrPWQudmFsdWUsbD1kLmRhc2hTdHlsZSxtPWEuc3ZnRWxlbSxuPVtdLG8sej1kLmNvbG9yLHI9cChkLnpJbmRleCwwKSxxPWQuZXZlbnRzLHc9e30sdj1iLmNoYXJ0LnJlbmRlcmVyLG49Yi5sb2cybGluO2IuaXNMb2cmJihpPW4oaSksaD1uKGgpLGs9bihrKSk7aWYoZyl7aWYobj1iLmdldFBsb3RMaW5lUGF0aChrLGcpLHc9e3N0cm9rZTp6LFwic3Ryb2tlLXdpZHRoXCI6Z30sbCl3LmRhc2hzdHlsZT1cbmx9ZWxzZSBpZihqKXtuPWIuZ2V0UGxvdEJhbmRQYXRoKGksaCxkKTtpZih6KXcuZmlsbD16O2lmKGQuYm9yZGVyV2lkdGgpdy5zdHJva2U9ZC5ib3JkZXJDb2xvcix3W1wic3Ryb2tlLXdpZHRoXCJdPWQuYm9yZGVyV2lkdGh9ZWxzZSByZXR1cm47dy56SW5kZXg9cjtpZihtKWlmKG4pbS5zaG93KCksbS5hbmltYXRlKHtkOm59KTtlbHNle2lmKG0uaGlkZSgpLGYpYS5sYWJlbD1mPWYuZGVzdHJveSgpfWVsc2UgaWYobiYmbi5sZW5ndGgmJihhLnN2Z0VsZW09bT12LnBhdGgobikuYXR0cih3KS5hZGQoKSxxKSlmb3IobyBpbiBkPWZ1bmN0aW9uKGIpe20ub24oYixmdW5jdGlvbihjKXtxW2JdLmFwcGx5KGEsW2NdKX0pfSxxKWQobyk7ZSYmcyhlLnRleHQpJiZuJiZuLmxlbmd0aCYmYi53aWR0aD4wJiZiLmhlaWdodD4wJiYhbi5mbGF0PyhlPUUoe2FsaWduOmMmJmomJlwiY2VudGVyXCIseDpjPyFqJiY0OjEwLHZlcnRpY2FsQWxpZ246IWMmJmomJlwibWlkZGxlXCIseTpjP2o/MTY6MTA6aj82OlxuLTQscm90YXRpb246YyYmIWomJjkwfSxlKSx0aGlzLnJlbmRlckxhYmVsKGUsbixqLHIpKTpmJiZmLmhpZGUoKTtyZXR1cm4gYX0scmVuZGVyTGFiZWw6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5sYWJlbCxmPXRoaXMuYXhpcy5jaGFydC5yZW5kZXJlcjtpZighZSllPXthbGlnbjphLnRleHRBbGlnbnx8YS5hbGlnbixyb3RhdGlvbjphLnJvdGF0aW9ufSxlLnpJbmRleD1kLHRoaXMubGFiZWw9ZT1mLnRleHQoYS50ZXh0LDAsMCxhLnVzZUhUTUwpLmF0dHIoZSkuY3NzKGEuc3R5bGUpLmFkZCgpO2Q9W2JbMV0sYls0XSxjP2JbNl06YlsxXV07Yj1bYlsyXSxiWzVdLGM/Yls3XTpiWzJdXTtjPU9hKGQpO2Y9T2EoYik7ZS5hbGlnbihhLCExLHt4OmMseTpmLHdpZHRoOkhhKGQpLWMsaGVpZ2h0OkhhKGIpLWZ9KTtlLnNob3coKX0sZGVzdHJveTpmdW5jdGlvbigpe3JhKHRoaXMuYXhpcy5wbG90TGluZXNBbmRCYW5kcyx0aGlzKTtkZWxldGUgdGhpcy5heGlzO1RhKHRoaXMpfX07XG52YXIgaWE9dS5BeGlzPWZ1bmN0aW9uKCl7dGhpcy5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07aWEucHJvdG90eXBlPXtkZWZhdWx0T3B0aW9uczp7ZGF0ZVRpbWVMYWJlbEZvcm1hdHM6e21pbGxpc2Vjb25kOlwiJUg6JU06JVMuJUxcIixzZWNvbmQ6XCIlSDolTTolU1wiLG1pbnV0ZTpcIiVIOiVNXCIsaG91cjpcIiVIOiVNXCIsZGF5OlwiJWUuICViXCIsd2VlazpcIiVlLiAlYlwiLG1vbnRoOlwiJWIgJyV5XCIseWVhcjpcIiVZXCJ9LGVuZE9uVGljazohMSxncmlkTGluZUNvbG9yOlwiI0Q4RDhEOFwiLGxhYmVsczp7ZW5hYmxlZDohMCxzdHlsZTp7Y29sb3I6XCIjNjA2MDYwXCIsY3Vyc29yOlwiZGVmYXVsdFwiLGZvbnRTaXplOlwiMTFweFwifSx4OjB9LGxpbmVDb2xvcjpcIiNDMEQwRTBcIixsaW5lV2lkdGg6MSxtaW5QYWRkaW5nOjAuMDEsbWF4UGFkZGluZzowLjAxLG1pbm9yR3JpZExpbmVDb2xvcjpcIiNFMEUwRTBcIixtaW5vckdyaWRMaW5lV2lkdGg6MSxtaW5vclRpY2tDb2xvcjpcIiNBMEEwQTBcIixtaW5vclRpY2tMZW5ndGg6Mixcbm1pbm9yVGlja1Bvc2l0aW9uOlwib3V0c2lkZVwiLHN0YXJ0T2ZXZWVrOjEsc3RhcnRPblRpY2s6ITEsdGlja0NvbG9yOlwiI0MwRDBFMFwiLHRpY2tMZW5ndGg6MTAsdGlja21hcmtQbGFjZW1lbnQ6XCJiZXR3ZWVuXCIsdGlja1BpeGVsSW50ZXJ2YWw6MTAwLHRpY2tQb3NpdGlvbjpcIm91dHNpZGVcIix0aXRsZTp7YWxpZ246XCJtaWRkbGVcIixzdHlsZTp7Y29sb3I6XCIjNzA3MDcwXCJ9fSx0eXBlOlwibGluZWFyXCJ9LGRlZmF1bHRZQXhpc09wdGlvbnM6e2VuZE9uVGljazohMCxncmlkTGluZVdpZHRoOjEsdGlja1BpeGVsSW50ZXJ2YWw6NzIsc2hvd0xhc3RMYWJlbDohMCxsYWJlbHM6e3g6LTh9LGxpbmVXaWR0aDowLG1heFBhZGRpbmc6MC4wNSxtaW5QYWRkaW5nOjAuMDUsc3RhcnRPblRpY2s6ITAsdGl0bGU6e3JvdGF0aW9uOjI3MCx0ZXh0OlwiVmFsdWVzXCJ9LHN0YWNrTGFiZWxzOntlbmFibGVkOiExLGZvcm1hdHRlcjpmdW5jdGlvbigpe3JldHVybiB1Lm51bWJlckZvcm1hdCh0aGlzLnRvdGFsLC0xKX0sXG5zdHlsZTpFKGZhLmxpbmUuZGF0YUxhYmVscy5zdHlsZSx7Y29sb3I6XCIjMDAwMDAwXCJ9KX19LGRlZmF1bHRMZWZ0QXhpc09wdGlvbnM6e2xhYmVsczp7eDotMTV9LHRpdGxlOntyb3RhdGlvbjoyNzB9fSxkZWZhdWx0UmlnaHRBeGlzT3B0aW9uczp7bGFiZWxzOnt4OjE1fSx0aXRsZTp7cm90YXRpb246OTB9fSxkZWZhdWx0Qm90dG9tQXhpc09wdGlvbnM6e2xhYmVsczp7YXV0b1JvdGF0aW9uOlstNDVdLHg6MH0sdGl0bGU6e3JvdGF0aW9uOjB9fSxkZWZhdWx0VG9wQXhpc09wdGlvbnM6e2xhYmVsczp7YXV0b1JvdGF0aW9uOlstNDVdLHg6MH0sdGl0bGU6e3JvdGF0aW9uOjB9fSxpbml0OmZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5pc1g7dGhpcy5jaGFydD1hO3RoaXMuaG9yaXo9YS5pbnZlcnRlZD8hYzpjO3RoaXMuY29sbD0odGhpcy5pc1hBeGlzPWMpP1wieEF4aXNcIjpcInlBeGlzXCI7dGhpcy5vcHBvc2l0ZT1iLm9wcG9zaXRlO3RoaXMuc2lkZT1iLnNpZGV8fCh0aGlzLmhvcml6P3RoaXMub3Bwb3NpdGU/XG4wOjI6dGhpcy5vcHBvc2l0ZT8xOjMpO3RoaXMuc2V0T3B0aW9ucyhiKTt2YXIgZD10aGlzLm9wdGlvbnMsZT1kLnR5cGU7dGhpcy5sYWJlbEZvcm1hdHRlcj1kLmxhYmVscy5mb3JtYXR0ZXJ8fHRoaXMuZGVmYXVsdExhYmVsRm9ybWF0dGVyO3RoaXMudXNlck9wdGlvbnM9Yjt0aGlzLm1pblBpeGVsUGFkZGluZz0wO3RoaXMucmV2ZXJzZWQ9ZC5yZXZlcnNlZDt0aGlzLnZpc2libGU9ZC52aXNpYmxlIT09ITE7dGhpcy56b29tRW5hYmxlZD1kLnpvb21FbmFibGVkIT09ITE7dGhpcy5jYXRlZ29yaWVzPWQuY2F0ZWdvcmllc3x8ZT09PVwiY2F0ZWdvcnlcIjt0aGlzLm5hbWVzPXRoaXMubmFtZXN8fFtdO3RoaXMuaXNMb2c9ZT09PVwibG9nYXJpdGhtaWNcIjt0aGlzLmlzRGF0ZXRpbWVBeGlzPWU9PT1cImRhdGV0aW1lXCI7dGhpcy5pc0xpbmtlZD1zKGQubGlua2VkVG8pO3RoaXMudGlja3M9e307dGhpcy5sYWJlbEVkZ2U9W107dGhpcy5taW5vclRpY2tzPXt9O3RoaXMucGxvdExpbmVzQW5kQmFuZHM9XG5bXTt0aGlzLmFsdGVybmF0ZUJhbmRzPXt9O3RoaXMubGVuPTA7dGhpcy5taW5SYW5nZT10aGlzLnVzZXJNaW5SYW5nZT1kLm1pblJhbmdlfHxkLm1heFpvb207dGhpcy5yYW5nZT1kLnJhbmdlO3RoaXMub2Zmc2V0PWQub2Zmc2V0fHwwO3RoaXMuc3RhY2tzPXt9O3RoaXMub2xkU3RhY2tzPXt9O3RoaXMuc3RhY2tzVG91Y2hlZD0wO3RoaXMubWluPXRoaXMubWF4PW51bGw7dGhpcy5jcm9zc2hhaXI9cChkLmNyb3NzaGFpcix1YShhLm9wdGlvbnMudG9vbHRpcC5jcm9zc2hhaXJzKVtjPzA6MV0sITEpO3ZhciBmLGQ9dGhpcy5vcHRpb25zLmV2ZW50cztwYSh0aGlzLGEuYXhlcyk9PT0tMSYmKGMmJiF0aGlzLmlzQ29sb3JBeGlzP2EuYXhlcy5zcGxpY2UoYS54QXhpcy5sZW5ndGgsMCx0aGlzKTphLmF4ZXMucHVzaCh0aGlzKSxhW3RoaXMuY29sbF0ucHVzaCh0aGlzKSk7dGhpcy5zZXJpZXM9dGhpcy5zZXJpZXN8fFtdO2lmKGEuaW52ZXJ0ZWQmJmMmJnRoaXMucmV2ZXJzZWQ9PT1BKXRoaXMucmV2ZXJzZWQ9XG4hMDt0aGlzLnJlbW92ZVBsb3RMaW5lPXRoaXMucmVtb3ZlUGxvdEJhbmQ9dGhpcy5yZW1vdmVQbG90QmFuZE9yTGluZTtmb3IoZiBpbiBkKU4odGhpcyxmLGRbZl0pO2lmKHRoaXMuaXNMb2cpdGhpcy52YWwybGluPXRoaXMubG9nMmxpbix0aGlzLmxpbjJ2YWw9dGhpcy5saW4ybG9nfSxzZXRPcHRpb25zOmZ1bmN0aW9uKGEpe3RoaXMub3B0aW9ucz1FKHRoaXMuZGVmYXVsdE9wdGlvbnMsdGhpcy5pc1hBeGlzP3t9OnRoaXMuZGVmYXVsdFlBeGlzT3B0aW9ucyxbdGhpcy5kZWZhdWx0VG9wQXhpc09wdGlvbnMsdGhpcy5kZWZhdWx0UmlnaHRBeGlzT3B0aW9ucyx0aGlzLmRlZmF1bHRCb3R0b21BeGlzT3B0aW9ucyx0aGlzLmRlZmF1bHRMZWZ0QXhpc09wdGlvbnNdW3RoaXMuc2lkZV0sRShVW3RoaXMuY29sbF0sYSkpfSxkZWZhdWx0TGFiZWxGb3JtYXR0ZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmF4aXMsYj10aGlzLnZhbHVlLGM9YS5jYXRlZ29yaWVzLGQ9dGhpcy5kYXRlVGltZUxhYmVsRm9ybWF0LFxuZT1VLmxhbmcubnVtZXJpY1N5bWJvbHMsZj1lJiZlLmxlbmd0aCxnLGg9YS5vcHRpb25zLmxhYmVscy5mb3JtYXQsYT1hLmlzTG9nP2I6YS50aWNrSW50ZXJ2YWw7aWYoaClnPU5hKGgsdGhpcyk7ZWxzZSBpZihjKWc9YjtlbHNlIGlmKGQpZz1TYShkLGIpO2Vsc2UgaWYoZiYmYT49MUUzKWZvcig7Zi0tJiZnPT09QTspYz1NYXRoLnBvdygxRTMsZisxKSxhPj1jJiZiKjEwJWM9PT0wJiZlW2ZdIT09bnVsbCYmYiE9PTAmJihnPXUubnVtYmVyRm9ybWF0KGIvYywtMSkrZVtmXSk7Zz09PUEmJihnPVEoYik+PTFFND91Lm51bWJlckZvcm1hdChiLC0xKTp1Lm51bWJlckZvcm1hdChiLC0xLEEsXCJcIikpO3JldHVybiBnfSxnZXRTZXJpZXNFeHRyZW1lczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0O2EuaGFzVmlzaWJsZVNlcmllcz0hMTthLmRhdGFNaW49YS5kYXRhTWF4PWEudGhyZXNob2xkPW51bGw7YS5zb2Z0VGhyZXNob2xkPSFhLmlzWEF4aXM7YS5idWlsZFN0YWNrcyYmYS5idWlsZFN0YWNrcygpO1xucShhLnNlcmllcyxmdW5jdGlvbihjKXtpZihjLnZpc2libGV8fCFiLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKXt2YXIgZD1jLm9wdGlvbnMsZT1kLnRocmVzaG9sZCxmO2EuaGFzVmlzaWJsZVNlcmllcz0hMDthLmlzTG9nJiZlPD0wJiYoZT1udWxsKTtpZihhLmlzWEF4aXMpe2lmKGQ9Yy54RGF0YSxkLmxlbmd0aCljPU9hKGQpLCFKKGMpJiYhKGMgaW5zdGFuY2VvZiBtYSkmJihkPUNhKGQsZnVuY3Rpb24oYSl7cmV0dXJuIEooYSl9KSxjPU9hKGQpKSxhLmRhdGFNaW49RihwKGEuZGF0YU1pbixkWzBdKSxjKSxhLmRhdGFNYXg9dChwKGEuZGF0YU1heCxkWzBdKSxIYShkKSl9ZWxzZXtjLmdldEV4dHJlbWVzKCk7Zj1jLmRhdGFNYXg7Yz1jLmRhdGFNaW47aWYocyhjKSYmcyhmKSlhLmRhdGFNaW49RihwKGEuZGF0YU1pbixjKSxjKSxhLmRhdGFNYXg9dChwKGEuZGF0YU1heCxmKSxmKTtpZihzKGUpKWEudGhyZXNob2xkPWU7aWYoIWQuc29mdFRocmVzaG9sZHx8YS5pc0xvZylhLnNvZnRUaHJlc2hvbGQ9XG4hMX19fSl9LHRyYW5zbGF0ZTpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9dGhpcy5saW5rZWRQYXJlbnR8fHRoaXMsaD0xLGk9MCxqPWQ/Zy5vbGRUcmFuc0E6Zy50cmFuc0EsZD1kP2cub2xkTWluOmcubWluLGs9Zy5taW5QaXhlbFBhZGRpbmcsZT0oZy5pc09yZGluYWx8fGcuaXNCcm9rZW58fGcuaXNMb2cmJmUpJiZnLmxpbjJ2YWw7aWYoIWopaj1nLnRyYW5zQTtpZihjKWgqPS0xLGk9Zy5sZW47Zy5yZXZlcnNlZCYmKGgqPS0xLGktPWgqKGcuc2VjdG9yfHxnLmxlbikpO2I/KGE9YSpoK2ksYS09ayxhPWEvaitkLGUmJihhPWcubGluMnZhbChhKSkpOihlJiYoYT1nLnZhbDJsaW4oYSkpLGY9PT1cImJldHdlZW5cIiYmKGY9MC41KSxhPWgqKGEtZCkqaitpK2gqaysoSihmKT9qKmYqZy5wb2ludFJhbmdlOjApKTtyZXR1cm4gYX0sdG9QaXhlbHM6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy50cmFuc2xhdGUoYSwhMSwhdGhpcy5ob3JpeixudWxsLCEwKSsoYj8wOnRoaXMucG9zKX0sXG50b1ZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMudHJhbnNsYXRlKGEtKGI/MDp0aGlzLnBvcyksITAsIXRoaXMuaG9yaXosbnVsbCwhMCl9LGdldFBsb3RMaW5lUGF0aDpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXMuY2hhcnQsZz10aGlzLmxlZnQsaD10aGlzLnRvcCxpLGosaz1jJiZmLm9sZENoYXJ0SGVpZ2h0fHxmLmNoYXJ0SGVpZ2h0LGw9YyYmZi5vbGRDaGFydFdpZHRofHxmLmNoYXJ0V2lkdGgsbTtpPXRoaXMudHJhbnNCO3ZhciBuPWZ1bmN0aW9uKGEsYixjKXtpZihhPGJ8fGE+YylkP2E9Rih0KGIsYSksYyk6bT0hMDtyZXR1cm4gYX0sZT1wKGUsdGhpcy50cmFuc2xhdGUoYSxudWxsLG51bGwsYykpLGE9Yz1DKGUraSk7aT1qPUMoay1lLWkpO0ooZSk/dGhpcy5ob3Jpej8oaT1oLGo9ay10aGlzLmJvdHRvbSxhPWM9bihhLGcsZyt0aGlzLndpZHRoKSk6KGE9ZyxjPWwtdGhpcy5yaWdodCxpPWo9bihpLGgsaCt0aGlzLmhlaWdodCkpOm09ITA7cmV0dXJuIG0mJlxuIWQ/bnVsbDpmLnJlbmRlcmVyLmNyaXNwTGluZShbWCxhLGksUyxjLGpdLGJ8fDEpfSxnZXRMaW5lYXJUaWNrUG9zaXRpb25zOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPWFhKFYoYi9hKSphKSxmPWFhKHZhKGMvYSkqYSksZz1bXTtpZihiPT09YyYmSihiKSlyZXR1cm5bYl07Zm9yKGI9ZTtiPD1mOyl7Zy5wdXNoKGIpO2I9YWEoYithKTtpZihiPT09ZClicmVhaztkPWJ9cmV0dXJuIGd9LGdldE1pbm9yVGlja1Bvc2l0aW9uczpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiPXRoaXMudGlja1Bvc2l0aW9ucyxjPXRoaXMubWlub3JUaWNrSW50ZXJ2YWwsZD1bXSxlLGY9dGhpcy5wb2ludFJhbmdlUGFkZGluZ3x8MDtlPXRoaXMubWluLWY7dmFyIGY9dGhpcy5tYXgrZixnPWYtZTtpZihnJiZnL2M8dGhpcy5sZW4vMylpZih0aGlzLmlzTG9nKXtmPWIubGVuZ3RoO2ZvcihlPTE7ZTxmO2UrKylkPWQuY29uY2F0KHRoaXMuZ2V0TG9nVGlja1Bvc2l0aW9ucyhjLGJbZS0xXSxiW2VdLFxuITApKX1lbHNlIGlmKHRoaXMuaXNEYXRldGltZUF4aXMmJmEubWlub3JUaWNrSW50ZXJ2YWw9PT1cImF1dG9cIilkPWQuY29uY2F0KHRoaXMuZ2V0VGltZVRpY2tzKHRoaXMubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbChjKSxlLGYsYS5zdGFydE9mV2VlaykpO2Vsc2UgZm9yKGI9ZSsoYlswXS1lKSVjO2I8PWY7Yis9YylkLnB1c2goYik7ZC5sZW5ndGghPT0wJiZ0aGlzLnRyaW1UaWNrcyhkLGEuc3RhcnRPblRpY2ssYS5lbmRPblRpY2spO3JldHVybiBkfSxhZGp1c3RGb3JNaW5SYW5nZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiPXRoaXMubWluLGM9dGhpcy5tYXgsZCxlPXRoaXMuZGF0YU1heC10aGlzLmRhdGFNaW4+PXRoaXMubWluUmFuZ2UsZixnLGgsaSxqLGs7aWYodGhpcy5pc1hBeGlzJiZ0aGlzLm1pblJhbmdlPT09QSYmIXRoaXMuaXNMb2cpcyhhLm1pbil8fHMoYS5tYXgpP3RoaXMubWluUmFuZ2U9bnVsbDoocSh0aGlzLnNlcmllcyxmdW5jdGlvbihhKXtpPWEueERhdGE7XG5mb3IoZz1qPWEueEluY3JlbWVudD8xOmkubGVuZ3RoLTE7Zz4wO2ctLSlpZihoPWlbZ10taVtnLTFdLGY9PT1BfHxoPGYpZj1ofSksdGhpcy5taW5SYW5nZT1GKGYqNSx0aGlzLmRhdGFNYXgtdGhpcy5kYXRhTWluKSk7aWYoYy1iPHRoaXMubWluUmFuZ2Upe2s9dGhpcy5taW5SYW5nZTtkPShrLWMrYikvMjtkPVtiLWQscChhLm1pbixiLWQpXTtpZihlKWRbMl09dGhpcy5kYXRhTWluO2I9SGEoZCk7Yz1bYitrLHAoYS5tYXgsYitrKV07aWYoZSljWzJdPXRoaXMuZGF0YU1heDtjPU9hKGMpO2MtYjxrJiYoZFswXT1jLWssZFsxXT1wKGEubWluLGMtayksYj1IYShkKSl9dGhpcy5taW49Yjt0aGlzLm1heD1jfSxnZXRDbG9zZXN0OmZ1bmN0aW9uKCl7dmFyIGE7dGhpcy5jYXRlZ29yaWVzP2E9MTpxKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGIpe3ZhciBjPWIuY2xvc2VzdFBvaW50UmFuZ2U7IWIubm9TaGFyZWRUb29sdGlwJiZzKGMpJiYoYT1zKGEpP0YoYSxjKTpjKX0pO3JldHVybiBhfSxcbnNldEF4aXNUcmFuc2xhdGlvbjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9Yi5tYXgtYi5taW4sZD1iLmF4aXNQb2ludFJhbmdlfHwwLGUsZj0wLGc9MCxoPWIubGlua2VkUGFyZW50LGk9ISFiLmNhdGVnb3JpZXMsaj1iLnRyYW5zQSxrPWIuaXNYQXhpcztpZihrfHxpfHxkKWlmKGg/KGY9aC5taW5Qb2ludE9mZnNldCxnPWgucG9pbnRSYW5nZVBhZGRpbmcpOihlPWIuZ2V0Q2xvc2VzdCgpLHEoYi5zZXJpZXMsZnVuY3Rpb24oYSl7dmFyIGM9aT8xOms/cChhLm9wdGlvbnMucG9pbnRSYW5nZSxlLDApOmIuYXhpc1BvaW50UmFuZ2V8fDAsYT1hLm9wdGlvbnMucG9pbnRQbGFjZW1lbnQ7ZD10KGQsYyk7Yi5zaW5nbGV8fChmPXQoZix5YShhKT8wOmMvMiksZz10KGcsYT09PVwib25cIj8wOmMpKX0pKSxoPWIub3JkaW5hbFNsb3BlJiZlP2Iub3JkaW5hbFNsb3BlL2U6MSxiLm1pblBvaW50T2Zmc2V0PWYqPWgsYi5wb2ludFJhbmdlUGFkZGluZz1nKj1oLGIucG9pbnRSYW5nZT1GKGQsYyksXG5rKWIuY2xvc2VzdFBvaW50UmFuZ2U9ZTtpZihhKWIub2xkVHJhbnNBPWo7Yi50cmFuc2xhdGlvblNsb3BlPWIudHJhbnNBPWo9Yi5sZW4vKGMrZ3x8MSk7Yi50cmFuc0I9Yi5ob3Jpej9iLmxlZnQ6Yi5ib3R0b207Yi5taW5QaXhlbFBhZGRpbmc9aipmfSxtaW5Gcm9tUmFuZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXgtdGhpcy5yYW5nZX0sc2V0VGlja0ludGVydmFsOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLmNoYXJ0LGQ9Yi5vcHRpb25zLGU9Yi5pc0xvZyxmPWIubG9nMmxpbixnPWIuaXNEYXRldGltZUF4aXMsaD1iLmlzWEF4aXMsaT1iLmlzTGlua2VkLGo9ZC5tYXhQYWRkaW5nLGs9ZC5taW5QYWRkaW5nLGw9ZC50aWNrSW50ZXJ2YWwsbT1kLnRpY2tQaXhlbEludGVydmFsLG49Yi5jYXRlZ29yaWVzLG89Yi50aHJlc2hvbGQsej1iLnNvZnRUaHJlc2hvbGQscixHLHcsdjshZyYmIW4mJiFpJiZ0aGlzLmdldFRpY2tBbW91bnQoKTt3PXAoYi51c2VyTWluLGQubWluKTtcbnY9cChiLnVzZXJNYXgsZC5tYXgpO2k/KGIubGlua2VkUGFyZW50PWNbYi5jb2xsXVtkLmxpbmtlZFRvXSxjPWIubGlua2VkUGFyZW50LmdldEV4dHJlbWVzKCksYi5taW49cChjLm1pbixjLmRhdGFNaW4pLGIubWF4PXAoYy5tYXgsYy5kYXRhTWF4KSxkLnR5cGUhPT1iLmxpbmtlZFBhcmVudC5vcHRpb25zLnR5cGUmJmNhKDExLDEpKTooIXomJnMobykmJihiLmRhdGFNaW4+PW8/KHI9byxrPTApOmIuZGF0YU1heDw9byYmKEc9byxqPTApKSxiLm1pbj1wKHcscixiLmRhdGFNaW4pLGIubWF4PXAodixHLGIuZGF0YU1heCkpO2lmKGUpIWEmJkYoYi5taW4scChiLmRhdGFNaW4sYi5taW4pKTw9MCYmY2EoMTAsMSksYi5taW49YWEoZihiLm1pbiksMTUpLGIubWF4PWFhKGYoYi5tYXgpLDE1KTtpZihiLnJhbmdlJiZzKGIubWF4KSliLnVzZXJNaW49Yi5taW49dz10KGIubWluLGIubWluRnJvbVJhbmdlKCkpLGIudXNlck1heD12PWIubWF4LGIucmFuZ2U9bnVsbDtJKGIsXCJmb3VuZEV4dHJlbWVzXCIpO1xuYi5iZWZvcmVQYWRkaW5nJiZiLmJlZm9yZVBhZGRpbmcoKTtiLmFkanVzdEZvck1pblJhbmdlKCk7aWYoIW4mJiFiLmF4aXNQb2ludFJhbmdlJiYhYi51c2VQZXJjZW50YWdlJiYhaSYmcyhiLm1pbikmJnMoYi5tYXgpJiYoZj1iLm1heC1iLm1pbikpIXModykmJmsmJihiLm1pbi09ZiprKSwhcyh2KSYmaiYmKGIubWF4Kz1mKmopO2lmKEooZC5mbG9vcikpYi5taW49dChiLm1pbixkLmZsb29yKTtpZihKKGQuY2VpbGluZykpYi5tYXg9RihiLm1heCxkLmNlaWxpbmcpO2lmKHomJnMoYi5kYXRhTWluKSlpZihvPW98fDAsIXModykmJmIubWluPG8mJmIuZGF0YU1pbj49byliLm1pbj1vO2Vsc2UgaWYoIXModikmJmIubWF4Pm8mJmIuZGF0YU1heDw9byliLm1heD1vO2IudGlja0ludGVydmFsPWIubWluPT09Yi5tYXh8fGIubWluPT09dm9pZCAwfHxiLm1heD09PXZvaWQgMD8xOmkmJiFsJiZtPT09Yi5saW5rZWRQYXJlbnQub3B0aW9ucy50aWNrUGl4ZWxJbnRlcnZhbD9sPWIubGlua2VkUGFyZW50LnRpY2tJbnRlcnZhbDpcbnAobCx0aGlzLnRpY2tBbW91bnQ/KGIubWF4LWIubWluKS90KHRoaXMudGlja0Ftb3VudC0xLDEpOnZvaWQgMCxuPzE6KGIubWF4LWIubWluKSptL3QoYi5sZW4sbSkpO2gmJiFhJiZxKGIuc2VyaWVzLGZ1bmN0aW9uKGEpe2EucHJvY2Vzc0RhdGEoYi5taW4hPT1iLm9sZE1pbnx8Yi5tYXghPT1iLm9sZE1heCl9KTtiLnNldEF4aXNUcmFuc2xhdGlvbighMCk7Yi5iZWZvcmVTZXRUaWNrUG9zaXRpb25zJiZiLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMoKTtpZihiLnBvc3RQcm9jZXNzVGlja0ludGVydmFsKWIudGlja0ludGVydmFsPWIucG9zdFByb2Nlc3NUaWNrSW50ZXJ2YWwoYi50aWNrSW50ZXJ2YWwpO2lmKGIucG9pbnRSYW5nZSYmIWwpYi50aWNrSW50ZXJ2YWw9dChiLnBvaW50UmFuZ2UsYi50aWNrSW50ZXJ2YWwpO2E9cChkLm1pblRpY2tJbnRlcnZhbCxiLmlzRGF0ZXRpbWVBeGlzJiZiLmNsb3Nlc3RQb2ludFJhbmdlKTtpZighbCYmYi50aWNrSW50ZXJ2YWw8YSliLnRpY2tJbnRlcnZhbD1cbmE7aWYoIWcmJiFlJiYhbCliLnRpY2tJbnRlcnZhbD12YihiLnRpY2tJbnRlcnZhbCxudWxsLHViKGIudGlja0ludGVydmFsKSxwKGQuYWxsb3dEZWNpbWFscywhKGIudGlja0ludGVydmFsPjAuNSYmYi50aWNrSW50ZXJ2YWw8NSYmYi5tYXg+MUUzJiZiLm1heDw5OTk5KSksISF0aGlzLnRpY2tBbW91bnQpO2lmKCF0aGlzLnRpY2tBbW91bnQmJnRoaXMubGVuKWIudGlja0ludGVydmFsPWIudW5zcXVpc2goKTt0aGlzLnNldFRpY2tQb3NpdGlvbnMoKX0sc2V0VGlja1Bvc2l0aW9uczpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiLGM9YS50aWNrUG9zaXRpb25zLGQ9YS50aWNrUG9zaXRpb25lcixlPWEuc3RhcnRPblRpY2ssZj1hLmVuZE9uVGljayxnO3RoaXMudGlja21hcmtPZmZzZXQ9dGhpcy5jYXRlZ29yaWVzJiZhLnRpY2ttYXJrUGxhY2VtZW50PT09XCJiZXR3ZWVuXCImJnRoaXMudGlja0ludGVydmFsPT09MT8wLjU6MDt0aGlzLm1pbm9yVGlja0ludGVydmFsPWEubWlub3JUaWNrSW50ZXJ2YWw9PT1cblwiYXV0b1wiJiZ0aGlzLnRpY2tJbnRlcnZhbD90aGlzLnRpY2tJbnRlcnZhbC81OmEubWlub3JUaWNrSW50ZXJ2YWw7dGhpcy50aWNrUG9zaXRpb25zPWI9YyYmYy5zbGljZSgpO2lmKCFiJiYoYj10aGlzLmlzRGF0ZXRpbWVBeGlzP3RoaXMuZ2V0VGltZVRpY2tzKHRoaXMubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCh0aGlzLnRpY2tJbnRlcnZhbCxhLnVuaXRzKSx0aGlzLm1pbix0aGlzLm1heCxhLnN0YXJ0T2ZXZWVrLHRoaXMub3JkaW5hbFBvc2l0aW9ucyx0aGlzLmNsb3Nlc3RQb2ludFJhbmdlLCEwKTp0aGlzLmlzTG9nP3RoaXMuZ2V0TG9nVGlja1Bvc2l0aW9ucyh0aGlzLnRpY2tJbnRlcnZhbCx0aGlzLm1pbix0aGlzLm1heCk6dGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKHRoaXMudGlja0ludGVydmFsLHRoaXMubWluLHRoaXMubWF4KSxiLmxlbmd0aD50aGlzLmxlbiYmKGI9W2JbMF0sYi5wb3AoKV0pLHRoaXMudGlja1Bvc2l0aW9ucz1iLGQmJihkPWQuYXBwbHkodGhpcyxcblt0aGlzLm1pbix0aGlzLm1heF0pKSkpdGhpcy50aWNrUG9zaXRpb25zPWI9ZDtpZighdGhpcy5pc0xpbmtlZCl0aGlzLnRyaW1UaWNrcyhiLGUsZiksdGhpcy5taW49PT10aGlzLm1heCYmcyh0aGlzLm1pbikmJiF0aGlzLnRpY2tBbW91bnQmJihnPSEwLHRoaXMubWluLT0wLjUsdGhpcy5tYXgrPTAuNSksdGhpcy5zaW5nbGU9ZywhYyYmIWQmJnRoaXMuYWRqdXN0VGlja0Ftb3VudCgpfSx0cmltVGlja3M6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWFbMF0sZT1hW2EubGVuZ3RoLTFdLGY9dGhpcy5taW5Qb2ludE9mZnNldHx8MDtpZihiKXRoaXMubWluPWQ7ZWxzZSBmb3IoO3RoaXMubWluLWY+YVswXTspYS5zaGlmdCgpO2lmKGMpdGhpcy5tYXg9ZTtlbHNlIGZvcig7dGhpcy5tYXgrZjxhW2EubGVuZ3RoLTFdOylhLnBvcCgpO2EubGVuZ3RoPT09MCYmcyhkKSYmYS5wdXNoKChlK2QpLzIpfSxhbGlnblRvT3RoZXJzOmZ1bmN0aW9uKCl7dmFyIGE9e30sYixjPXRoaXMub3B0aW9uczt0aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuYWxpZ25UaWNrcyE9PVxuITEmJmMuYWxpZ25UaWNrcyE9PSExJiZxKHRoaXMuY2hhcnRbdGhpcy5jb2xsXSxmdW5jdGlvbihjKXt2YXIgZT1jLm9wdGlvbnMsZT1bYy5ob3Jpej9lLmxlZnQ6ZS50b3AsZS53aWR0aCxlLmhlaWdodCxlLnBhbmVdLmpvaW4oXCIsXCIpO2Muc2VyaWVzLmxlbmd0aCYmKGFbZV0/Yj0hMDphW2VdPTEpfSk7cmV0dXJuIGJ9LGdldFRpY2tBbW91bnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj1hLnRpY2tBbW91bnQsYz1hLnRpY2tQaXhlbEludGVydmFsOyFzKGEudGlja0ludGVydmFsKSYmdGhpcy5sZW48YyYmIXRoaXMuaXNSYWRpYWwmJiF0aGlzLmlzTG9nJiZhLnN0YXJ0T25UaWNrJiZhLmVuZE9uVGljayYmKGI9Mik7IWImJnRoaXMuYWxpZ25Ub090aGVycygpJiYoYj12YSh0aGlzLmxlbi9jKSsxKTtpZihiPDQpdGhpcy5maW5hbFRpY2tBbXQ9YixiPTU7dGhpcy50aWNrQW1vdW50PWJ9LGFkanVzdFRpY2tBbW91bnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnRpY2tJbnRlcnZhbCxcbmI9dGhpcy50aWNrUG9zaXRpb25zLGM9dGhpcy50aWNrQW1vdW50LGQ9dGhpcy5maW5hbFRpY2tBbXQsZT1iJiZiLmxlbmd0aDtpZihlPGMpe2Zvcig7Yi5sZW5ndGg8YzspYi5wdXNoKGFhKGJbYi5sZW5ndGgtMV0rYSkpO3RoaXMudHJhbnNBKj0oZS0xKS8oYy0xKTt0aGlzLm1heD1iW2IubGVuZ3RoLTFdfWVsc2UgZT5jJiYodGhpcy50aWNrSW50ZXJ2YWwqPTIsdGhpcy5zZXRUaWNrUG9zaXRpb25zKCkpO2lmKHMoZCkpe2ZvcihhPWM9Yi5sZW5ndGg7YS0tOykoZD09PTMmJmElMj09PTF8fGQ8PTImJmE+MCYmYTxjLTEpJiZiLnNwbGljZShhLDEpO3RoaXMuZmluYWxUaWNrQW10PUF9fSxzZXRTY2FsZTpmdW5jdGlvbigpe3ZhciBhLGI7dGhpcy5vbGRNaW49dGhpcy5taW47dGhpcy5vbGRNYXg9dGhpcy5tYXg7dGhpcy5vbGRBeGlzTGVuZ3RoPXRoaXMubGVuO3RoaXMuc2V0QXhpc1NpemUoKTtiPXRoaXMubGVuIT09dGhpcy5vbGRBeGlzTGVuZ3RoO3EodGhpcy5zZXJpZXMsZnVuY3Rpb24oYil7aWYoYi5pc0RpcnR5RGF0YXx8XG5iLmlzRGlydHl8fGIueEF4aXMuaXNEaXJ0eSlhPSEwfSk7aWYoYnx8YXx8dGhpcy5pc0xpbmtlZHx8dGhpcy5mb3JjZVJlZHJhd3x8dGhpcy51c2VyTWluIT09dGhpcy5vbGRVc2VyTWlufHx0aGlzLnVzZXJNYXghPT10aGlzLm9sZFVzZXJNYXh8fHRoaXMuYWxpZ25Ub090aGVycygpKXtpZih0aGlzLnJlc2V0U3RhY2tzJiZ0aGlzLnJlc2V0U3RhY2tzKCksdGhpcy5mb3JjZVJlZHJhdz0hMSx0aGlzLmdldFNlcmllc0V4dHJlbWVzKCksdGhpcy5zZXRUaWNrSW50ZXJ2YWwoKSx0aGlzLm9sZFVzZXJNaW49dGhpcy51c2VyTWluLHRoaXMub2xkVXNlck1heD10aGlzLnVzZXJNYXgsIXRoaXMuaXNEaXJ0eSl0aGlzLmlzRGlydHk9Ynx8dGhpcy5taW4hPT10aGlzLm9sZE1pbnx8dGhpcy5tYXghPT10aGlzLm9sZE1heH1lbHNlIHRoaXMuY2xlYW5TdGFja3MmJnRoaXMuY2xlYW5TdGFja3MoKX0sc2V0RXh0cmVtZXM6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLGc9Zi5jaGFydCxcbmM9cChjLCEwKTtxKGYuc2VyaWVzLGZ1bmN0aW9uKGEpe2RlbGV0ZSBhLmtkVHJlZX0pO2U9eChlLHttaW46YSxtYXg6Yn0pO0koZixcInNldEV4dHJlbWVzXCIsZSxmdW5jdGlvbigpe2YudXNlck1pbj1hO2YudXNlck1heD1iO2YuZXZlbnRBcmdzPWU7YyYmZy5yZWRyYXcoZCl9KX0sem9vbTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZGF0YU1pbixkPXRoaXMuZGF0YU1heCxlPXRoaXMub3B0aW9ucyxmPUYoYyxwKGUubWluLGMpKSxlPXQoZCxwKGUubWF4LGQpKTt0aGlzLmFsbG93Wm9vbU91dHNpZGV8fChzKGMpJiZhPD1mJiYoYT1mKSxzKGQpJiZiPj1lJiYoYj1lKSk7dGhpcy5kaXNwbGF5QnRuPWEhPT1BfHxiIT09QTt0aGlzLnNldEV4dHJlbWVzKGEsYiwhMSxBLHt0cmlnZ2VyOlwiem9vbVwifSk7cmV0dXJuITB9LHNldEF4aXNTaXplOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydCxiPXRoaXMub3B0aW9ucyxjPWIub2Zmc2V0TGVmdHx8MCxkPXRoaXMuaG9yaXosZT1wKGIud2lkdGgsXG5hLnBsb3RXaWR0aC1jKyhiLm9mZnNldFJpZ2h0fHwwKSksZj1wKGIuaGVpZ2h0LGEucGxvdEhlaWdodCksZz1wKGIudG9wLGEucGxvdFRvcCksYj1wKGIubGVmdCxhLnBsb3RMZWZ0K2MpLGM9LyUkLztjLnRlc3QoZikmJihmPU1hdGgucm91bmQocGFyc2VGbG9hdChmKS8xMDAqYS5wbG90SGVpZ2h0KSk7Yy50ZXN0KGcpJiYoZz1NYXRoLnJvdW5kKHBhcnNlRmxvYXQoZykvMTAwKmEucGxvdEhlaWdodCthLnBsb3RUb3ApKTt0aGlzLmxlZnQ9Yjt0aGlzLnRvcD1nO3RoaXMud2lkdGg9ZTt0aGlzLmhlaWdodD1mO3RoaXMuYm90dG9tPWEuY2hhcnRIZWlnaHQtZi1nO3RoaXMucmlnaHQ9YS5jaGFydFdpZHRoLWUtYjt0aGlzLmxlbj10KGQ/ZTpmLDApO3RoaXMucG9zPWQ/YjpnfSxnZXRFeHRyZW1lczpmdW5jdGlvbigpe3ZhciBhPXRoaXMuaXNMb2csYj10aGlzLmxpbjJsb2c7cmV0dXJue21pbjphP2FhKGIodGhpcy5taW4pKTp0aGlzLm1pbixtYXg6YT9hYShiKHRoaXMubWF4KSk6dGhpcy5tYXgsXG5kYXRhTWluOnRoaXMuZGF0YU1pbixkYXRhTWF4OnRoaXMuZGF0YU1heCx1c2VyTWluOnRoaXMudXNlck1pbix1c2VyTWF4OnRoaXMudXNlck1heH19LGdldFRocmVzaG9sZDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmlzTG9nLGM9dGhpcy5saW4ybG9nLGQ9Yj9jKHRoaXMubWluKTp0aGlzLm1pbixiPWI/Yyh0aGlzLm1heCk6dGhpcy5tYXg7YT09PW51bGw/YT1kOmQ+YT9hPWQ6YjxhJiYoYT1iKTtyZXR1cm4gdGhpcy50cmFuc2xhdGUoYSwwLDEsMCwxKX0sYXV0b0xhYmVsQWxpZ246ZnVuY3Rpb24oYSl7YT0ocChhLDApLXRoaXMuc2lkZSo5MCs3MjApJTM2MDtyZXR1cm4gYT4xNSYmYTwxNjU/XCJyaWdodFwiOmE+MTk1JiZhPDM0NT9cImxlZnRcIjpcImNlbnRlclwifSx0aWNrU2l6ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMsYz1iW2ErXCJMZW5ndGhcIl0sZD1wKGJbYStcIldpZHRoXCJdLGE9PT1cInRpY2tcIiYmdGhpcy5pc1hBeGlzPzE6MCk7aWYoZCYmYylyZXR1cm4gYlthK1wiUG9zaXRpb25cIl09PT1cblwiaW5zaWRlXCImJihjPS1jKSxbYyxkXX0sbGFiZWxNZXRyaWNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3ModGhpcy5vcHRpb25zLmxhYmVscy5zdHlsZS5mb250U2l6ZSx0aGlzLnRpY2tzWzBdJiZ0aGlzLnRpY2tzWzBdLmxhYmVsKX0sdW5zcXVpc2g6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMubGFiZWxzLGI9dGhpcy5ob3JpeixjPXRoaXMudGlja0ludGVydmFsLGQ9YyxlPXRoaXMubGVuLygoKHRoaXMuY2F0ZWdvcmllcz8xOjApK3RoaXMubWF4LXRoaXMubWluKS9jKSxmLGc9YS5yb3RhdGlvbixoPXRoaXMubGFiZWxNZXRyaWNzKCksaSxqPU51bWJlci5NQVhfVkFMVUUsayxsPWZ1bmN0aW9uKGEpe2EvPWV8fDE7YT1hPjE/dmEoYSk6MTtyZXR1cm4gYSpjfTtiPyhrPSFhLnN0YWdnZXJMaW5lcyYmIWEuc3RlcCYmKHMoZyk/W2ddOmU8cChhLmF1dG9Sb3RhdGlvbkxpbWl0LDgwKSYmYS5hdXRvUm90YXRpb24pKSYmcShrLGZ1bmN0aW9uKGEpe3ZhciBiO1xuaWYoYT09PWd8fGEmJmE+PS05MCYmYTw9OTApaT1sKFEoaC5oL2VhKGthKmEpKSksYj1pK1EoYS8zNjApLGI8aiYmKGo9YixmPWEsZD1pKX0pOmEuc3RlcHx8KGQ9bChoLmgpKTt0aGlzLmF1dG9Sb3RhdGlvbj1rO3RoaXMubGFiZWxSb3RhdGlvbj1wKGYsZyk7cmV0dXJuIGR9LGdldFNsb3RXaWR0aDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj10aGlzLmhvcml6LGM9dGhpcy5vcHRpb25zLmxhYmVscyxkPU1hdGgubWF4KHRoaXMudGlja1Bvc2l0aW9ucy5sZW5ndGgtKHRoaXMuY2F0ZWdvcmllcz8wOjEpLDEpLGU9YS5tYXJnaW5bM107cmV0dXJuIGImJihjLnN0ZXB8fDApPDImJiFjLnJvdGF0aW9uJiYodGhpcy5zdGFnZ2VyTGluZXN8fDEpKmEucGxvdFdpZHRoL2R8fCFiJiYoZSYmZS1hLnNwYWNpbmdbM118fGEuY2hhcnRXaWR0aCowLjMzKX0scmVuZGVyVW5zcXVpc2g6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9YS5yZW5kZXJlcixjPXRoaXMudGlja1Bvc2l0aW9ucyxcbmQ9dGhpcy50aWNrcyxlPXRoaXMub3B0aW9ucy5sYWJlbHMsZj10aGlzLmhvcml6LGc9dGhpcy5nZXRTbG90V2lkdGgoKSxoPXQoMSxDKGctMiooZS5wYWRkaW5nfHw1KSkpLGk9e30saj10aGlzLmxhYmVsTWV0cmljcygpLGs9ZS5zdHlsZS50ZXh0T3ZlcmZsb3csbCxtPTAsbixvO2lmKCF5YShlLnJvdGF0aW9uKSlpLnJvdGF0aW9uPWUucm90YXRpb258fDA7aWYodGhpcy5hdXRvUm90YXRpb24pcShjLGZ1bmN0aW9uKGEpe2lmKChhPWRbYV0pJiZhLmxhYmVsTGVuZ3RoPm0pbT1hLmxhYmVsTGVuZ3RofSksbT5oJiZtPmouaD9pLnJvdGF0aW9uPXRoaXMubGFiZWxSb3RhdGlvbjp0aGlzLmxhYmVsUm90YXRpb249MDtlbHNlIGlmKGcmJihsPXt3aWR0aDpoK1wicHhcIn0sIWspKXtsLnRleHRPdmVyZmxvdz1cImNsaXBcIjtmb3Iobj1jLmxlbmd0aDshZiYmbi0tOylpZihvPWNbbl0saD1kW29dLmxhYmVsKWlmKGguc3R5bGVzLnRleHRPdmVyZmxvdz09PVwiZWxsaXBzaXNcIj9oLmNzcyh7dGV4dE92ZXJmbG93OlwiY2xpcFwifSk6XG5kW29dLmxhYmVsTGVuZ3RoPmcmJmguY3NzKHt3aWR0aDpnK1wicHhcIn0pLGguZ2V0QkJveCgpLmhlaWdodD50aGlzLmxlbi9jLmxlbmd0aC0oai5oLWouZikpaC5zcGVjQ3NzPXt0ZXh0T3ZlcmZsb3c6XCJlbGxpcHNpc1wifX1pZihpLnJvdGF0aW9uJiYobD17d2lkdGg6KG0+YS5jaGFydEhlaWdodCowLjU/YS5jaGFydEhlaWdodCowLjMzOmEuY2hhcnRIZWlnaHQpK1wicHhcIn0sIWspKWwudGV4dE92ZXJmbG93PVwiZWxsaXBzaXNcIjtpZih0aGlzLmxhYmVsQWxpZ249ZS5hbGlnbnx8dGhpcy5hdXRvTGFiZWxBbGlnbih0aGlzLmxhYmVsUm90YXRpb24pKWkuYWxpZ249dGhpcy5sYWJlbEFsaWduO3EoYyxmdW5jdGlvbihhKXt2YXIgYj0oYT1kW2FdKSYmYS5sYWJlbDtpZihiKWIuYXR0cihpKSxsJiZiLmNzcyhFKGwsYi5zcGVjQ3NzKSksZGVsZXRlIGIuc3BlY0NzcyxhLnJvdGF0aW9uPWkucm90YXRpb259KTt0aGlzLnRpY2tSb3RDb3JyPWIucm90Q29ycihqLmIsdGhpcy5sYWJlbFJvdGF0aW9ufHxcbjAsdGhpcy5zaWRlIT09MCl9LGhhc0RhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNWaXNpYmxlU2VyaWVzfHxzKHRoaXMubWluKSYmcyh0aGlzLm1heCkmJiEhdGhpcy50aWNrUG9zaXRpb25zfSxnZXRPZmZzZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydCxjPWIucmVuZGVyZXIsZD1hLm9wdGlvbnMsZT1hLnRpY2tQb3NpdGlvbnMsZj1hLnRpY2tzLGc9YS5ob3JpeixoPWEuc2lkZSxpPWIuaW52ZXJ0ZWQ/WzEsMCwzLDJdW2hdOmgsaixrLGw9MCxtLG49MCxvPWQudGl0bGUsej1kLmxhYmVscyxyPTAsRz1hLm9wcG9zaXRlLHc9Yi5heGlzT2Zmc2V0LGI9Yi5jbGlwT2Zmc2V0LHY9Wy0xLDEsMSwtMV1baF0seCx1PWEuYXhpc1BhcmVudCxiYT10aGlzLnRpY2tTaXplKFwidGlja1wiKTtqPWEuaGFzRGF0YSgpO2Euc2hvd0F4aXM9az1qfHxwKGQuc2hvd0VtcHR5LCEwKTthLnN0YWdnZXJMaW5lcz1hLmhvcml6JiZ6LnN0YWdnZXJMaW5lcztpZighYS5heGlzR3JvdXApYS5ncmlkR3JvdXA9XG5jLmcoXCJncmlkXCIpLmF0dHIoe3pJbmRleDpkLmdyaWRaSW5kZXh8fDF9KS5hZGQodSksYS5heGlzR3JvdXA9Yy5nKFwiYXhpc1wiKS5hdHRyKHt6SW5kZXg6ZC56SW5kZXh8fDJ9KS5hZGQodSksYS5sYWJlbEdyb3VwPWMuZyhcImF4aXMtbGFiZWxzXCIpLmF0dHIoe3pJbmRleDp6LnpJbmRleHx8N30pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIithLmNvbGwudG9Mb3dlckNhc2UoKStcIi1sYWJlbHNcIikuYWRkKHUpO2lmKGp8fGEuaXNMaW5rZWQpe2lmKHEoZSxmdW5jdGlvbihiKXtmW2JdP2ZbYl0uYWRkTGFiZWwoKTpmW2JdPW5ldyBYYShhLGIpfSksYS5yZW5kZXJVbnNxdWlzaCgpLHoucmVzZXJ2ZVNwYWNlIT09ITEmJihoPT09MHx8aD09PTJ8fHsxOlwibGVmdFwiLDM6XCJyaWdodFwifVtoXT09PWEubGFiZWxBbGlnbnx8YS5sYWJlbEFsaWduPT09XCJjZW50ZXJcIikmJnEoZSxmdW5jdGlvbihhKXtyPXQoZlthXS5nZXRMYWJlbFNpemUoKSxyKX0pLGEuc3RhZ2dlckxpbmVzKXIqPWEuc3RhZ2dlckxpbmVzLFxuYS5sYWJlbE9mZnNldD1yKihhLm9wcG9zaXRlPy0xOjEpfWVsc2UgZm9yKHggaW4gZilmW3hdLmRlc3Ryb3koKSxkZWxldGUgZlt4XTtpZihvJiZvLnRleHQmJm8uZW5hYmxlZCE9PSExKXtpZighYS5heGlzVGl0bGUpKHg9by50ZXh0QWxpZ24pfHwoeD0oZz97bG93OlwibGVmdFwiLG1pZGRsZTpcImNlbnRlclwiLGhpZ2g6XCJyaWdodFwifTp7bG93Okc/XCJyaWdodFwiOlwibGVmdFwiLG1pZGRsZTpcImNlbnRlclwiLGhpZ2g6Rz9cImxlZnRcIjpcInJpZ2h0XCJ9KVtvLmFsaWduXSksYS5heGlzVGl0bGU9Yy50ZXh0KG8udGV4dCwwLDAsby51c2VIVE1MKS5hdHRyKHt6SW5kZXg6Nyxyb3RhdGlvbjpvLnJvdGF0aW9ufHwwLGFsaWduOnh9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrdGhpcy5jb2xsLnRvTG93ZXJDYXNlKCkrXCItdGl0bGVcIikuY3NzKG8uc3R5bGUpLmFkZChhLmF4aXNHcm91cCksYS5heGlzVGl0bGUuaXNOZXc9ITA7aWYoaylsPWEuYXhpc1RpdGxlLmdldEJCb3goKVtnP1wiaGVpZ2h0XCI6XCJ3aWR0aFwiXSxcbm09by5vZmZzZXQsbj1zKG0pPzA6cChvLm1hcmdpbixnPzU6MTApO2EuYXhpc1RpdGxlW2s/XCJzaG93XCI6XCJoaWRlXCJdKCEwKX1hLm9mZnNldD12KnAoZC5vZmZzZXQsd1toXSk7YS50aWNrUm90Q29ycj1hLnRpY2tSb3RDb3JyfHx7eDowLHk6MH07Yz1oPT09MD8tYS5sYWJlbE1ldHJpY3MoKS5oOmg9PT0yP2EudGlja1JvdENvcnIueTowO249TWF0aC5hYnMocikrbjtyJiYobi09YyxuKz12KihnP3Aoei55LGEudGlja1JvdENvcnIueSt2KjgpOnoueCkpO2EuYXhpc1RpdGxlTWFyZ2luPXAobSxuKTt3W2hdPXQod1toXSxhLmF4aXNUaXRsZU1hcmdpbitsK3YqYS5vZmZzZXQsbixqJiZlLmxlbmd0aCYmYmE/YmFbMF06MCk7ZD1kLm9mZnNldD8wOlYoZC5saW5lV2lkdGgvMikqMjtiW2ldPXQoYltpXSxkKX0sZ2V0TGluZVBhdGg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPXRoaXMub3Bwb3NpdGUsZD10aGlzLm9mZnNldCxlPXRoaXMuaG9yaXosZj10aGlzLmxlZnQrKGM/dGhpcy53aWR0aDpcbjApK2QsZD1iLmNoYXJ0SGVpZ2h0LXRoaXMuYm90dG9tLShjP3RoaXMuaGVpZ2h0OjApK2Q7YyYmKGEqPS0xKTtyZXR1cm4gYi5yZW5kZXJlci5jcmlzcExpbmUoW1gsZT90aGlzLmxlZnQ6ZixlP2Q6dGhpcy50b3AsUyxlP2IuY2hhcnRXaWR0aC10aGlzLnJpZ2h0OmYsZT9kOmIuY2hhcnRIZWlnaHQtdGhpcy5ib3R0b21dLGEpfSxnZXRUaXRsZVBvc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ob3JpeixiPXRoaXMubGVmdCxjPXRoaXMudG9wLGQ9dGhpcy5sZW4sZT10aGlzLm9wdGlvbnMudGl0bGUsZj1hP2I6YyxnPXRoaXMub3Bwb3NpdGUsaD10aGlzLm9mZnNldCxpPWUueHx8MCxqPWUueXx8MCxrPXRoaXMuY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3MoZS5zdHlsZS5mb250U2l6ZSkuZixkPXtsb3c6ZisoYT8wOmQpLG1pZGRsZTpmK2QvMixoaWdoOmYrKGE/ZDowKX1bZS5hbGlnbl0sYj0oYT9jK3RoaXMuaGVpZ2h0OmIpKyhhPzE6LTEpKihnPy0xOjEpKnRoaXMuYXhpc1RpdGxlTWFyZ2luK1xuKHRoaXMuc2lkZT09PTI/azowKTtyZXR1cm57eDphP2QraTpiKyhnP3RoaXMud2lkdGg6MCkraCtpLHk6YT9iK2otKGc/dGhpcy5oZWlnaHQ6MCkraDpkK2p9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydCxjPWIucmVuZGVyZXIsZD1hLm9wdGlvbnMsZT1hLmlzTG9nLGY9YS5saW4ybG9nLGc9YS5pc0xpbmtlZCxoPWEudGlja1Bvc2l0aW9ucyxpPWEuYXhpc1RpdGxlLGo9YS50aWNrcyxrPWEubWlub3JUaWNrcyxsPWEuYWx0ZXJuYXRlQmFuZHMsbT1kLnN0YWNrTGFiZWxzLG49ZC5hbHRlcm5hdGVHcmlkQ29sb3Isbz1hLnRpY2ttYXJrT2Zmc2V0LHo9ZC5saW5lV2lkdGgscixwPWIuaGFzUmVuZGVyZWQmJkooYS5vbGRNaW4pLHc9YS5zaG93QXhpcyx2PWJiKGMuZ2xvYmFsQW5pbWF0aW9uKSx0LHM7YS5sYWJlbEVkZ2UubGVuZ3RoPTA7YS5vdmVybGFwPSExO3EoW2osayxsXSxmdW5jdGlvbihhKXtmb3IodmFyIGIgaW4gYSlhW2JdLmlzQWN0aXZlPSExfSk7XG5pZihhLmhhc0RhdGEoKXx8Zyl7YS5taW5vclRpY2tJbnRlcnZhbCYmIWEuY2F0ZWdvcmllcyYmcShhLmdldE1pbm9yVGlja1Bvc2l0aW9ucygpLGZ1bmN0aW9uKGIpe2tbYl18fChrW2JdPW5ldyBYYShhLGIsXCJtaW5vclwiKSk7cCYma1tiXS5pc05ldyYma1tiXS5yZW5kZXIobnVsbCwhMCk7a1tiXS5yZW5kZXIobnVsbCwhMSwxKX0pO2lmKGgubGVuZ3RoJiYocShoLGZ1bmN0aW9uKGIsYyl7aWYoIWd8fGI+PWEubWluJiZiPD1hLm1heClqW2JdfHwoaltiXT1uZXcgWGEoYSxiKSkscCYmaltiXS5pc05ldyYmaltiXS5yZW5kZXIoYywhMCwwLjEpLGpbYl0ucmVuZGVyKGMpfSksbyYmKGEubWluPT09MHx8YS5zaW5nbGUpKSlqWy0xXXx8KGpbLTFdPW5ldyBYYShhLC0xLG51bGwsITApKSxqWy0xXS5yZW5kZXIoLTEpO24mJnEoaCxmdW5jdGlvbihjLGQpe3M9aFtkKzFdIT09QT9oW2QrMV0rbzphLm1heC1vO2lmKGQlMj09PTAmJmM8YS5tYXgmJnM8PWEubWF4KyhiLnBvbGFyPy1vOm8pKWxbY118fFxuKGxbY109bmV3IHUuUGxvdExpbmVPckJhbmQoYSkpLHQ9YytvLGxbY10ub3B0aW9ucz17ZnJvbTplP2YodCk6dCx0bzplP2Yocyk6cyxjb2xvcjpufSxsW2NdLnJlbmRlcigpLGxbY10uaXNBY3RpdmU9ITB9KTtpZighYS5fYWRkZWRQbG90TEIpcSgoZC5wbG90TGluZXN8fFtdKS5jb25jYXQoZC5wbG90QmFuZHN8fFtdKSxmdW5jdGlvbihiKXthLmFkZFBsb3RCYW5kT3JMaW5lKGIpfSksYS5fYWRkZWRQbG90TEI9ITB9cShbaixrLGxdLGZ1bmN0aW9uKGEpe3ZhciBjLGQsZT1bXSxmPXYuZHVyYXRpb247Zm9yKGMgaW4gYSlpZighYVtjXS5pc0FjdGl2ZSlhW2NdLnJlbmRlcihjLCExLDApLGFbY10uaXNBY3RpdmU9ITEsZS5wdXNoKGMpO1JhKGZ1bmN0aW9uKCl7Zm9yKGQ9ZS5sZW5ndGg7ZC0tOylhW2VbZF1dJiYhYVtlW2RdXS5pc0FjdGl2ZSYmKGFbZVtkXV0uZGVzdHJveSgpLGRlbGV0ZSBhW2VbZF1dKX0sYT09PWx8fCFiLmhhc1JlbmRlcmVkfHwhZj8wOmYpfSk7aWYoeilyPWEuZ2V0TGluZVBhdGgoeiksXG5hLmF4aXNMaW5lP2EuYXhpc0xpbmUuYW5pbWF0ZSh7ZDpyfSk6YS5heGlzTGluZT1jLnBhdGgocikuYXR0cih7c3Ryb2tlOmQubGluZUNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6eix6SW5kZXg6N30pLmFkZChhLmF4aXNHcm91cCksYS5heGlzTGluZVt3P1wic2hvd1wiOlwiaGlkZVwiXSghMCk7aWYoaSYmdylpW2kuaXNOZXc/XCJhdHRyXCI6XCJhbmltYXRlXCJdKGEuZ2V0VGl0bGVQb3NpdGlvbigpKSxpLmlzTmV3PSExO20mJm0uZW5hYmxlZCYmYS5yZW5kZXJTdGFja1RvdGFscygpO2EuaXNEaXJ0eT0hMX0scmVkcmF3OmZ1bmN0aW9uKCl7dGhpcy52aXNpYmxlJiYodGhpcy5yZW5kZXIoKSxxKHRoaXMucGxvdExpbmVzQW5kQmFuZHMsZnVuY3Rpb24oYSl7YS5yZW5kZXIoKX0pKTtxKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGEpe2EuaXNEaXJ0eT0hMH0pfSxkZXN0cm95OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLnN0YWNrcyxkLGU9Yi5wbG90TGluZXNBbmRCYW5kczthfHxZKGIpO2ZvcihkIGluIGMpVGEoY1tkXSksXG5jW2RdPW51bGw7cShbYi50aWNrcyxiLm1pbm9yVGlja3MsYi5hbHRlcm5hdGVCYW5kc10sZnVuY3Rpb24oYSl7VGEoYSl9KTtmb3IoYT1lLmxlbmd0aDthLS07KWVbYV0uZGVzdHJveSgpO3EoXCJzdGFja1RvdGFsR3JvdXAsYXhpc0xpbmUsYXhpc1RpdGxlLGF4aXNHcm91cCxncmlkR3JvdXAsbGFiZWxHcm91cCxjcm9zc1wiLnNwbGl0KFwiLFwiKSxmdW5jdGlvbihhKXtiW2FdJiYoYlthXT1iW2FdLmRlc3Ryb3koKSl9KTt0aGlzLl9hZGRlZFBsb3RMQj10aGlzLmNoYXJ0Ll9sYWJlbFBhbmVzPXRoaXMub3JkaW5hbFNsb3BlPXZvaWQgMH0sZHJhd0Nyb3NzaGFpcjpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9dGhpcy5jcm9zc2hhaXIsZSxmO2F8fChhPXRoaXMuY3Jvc3MmJnRoaXMuY3Jvc3MuZSk7aWYoIXRoaXMuY3Jvc3NoYWlyfHwocyhiKXx8IXAoZC5zbmFwLCEwKSk9PT0hMSl0aGlzLmhpZGVDcm9zc2hhaXIoKTtlbHNlIGlmKHAoZC5zbmFwLCEwKT9zKGIpJiYoYz10aGlzLmlzWEF4aXM/XG5iLnBsb3RYOnRoaXMubGVuLWIucGxvdFkpOmM9dGhpcy5ob3Jpej9hLmNoYXJ0WC10aGlzLnBvczp0aGlzLmxlbi1hLmNoYXJ0WSt0aGlzLnBvcyxjPXRoaXMuaXNSYWRpYWw/dGhpcy5nZXRQbG90TGluZVBhdGgodGhpcy5pc1hBeGlzP2IueDpwKGIuc3RhY2tZLGIueSkpfHxudWxsOnRoaXMuZ2V0UGxvdExpbmVQYXRoKG51bGwsbnVsbCxudWxsLG51bGwsYyl8fG51bGwsYz09PW51bGwpdGhpcy5oaWRlQ3Jvc3NoYWlyKCk7ZWxzZXtlPXRoaXMuY2F0ZWdvcmllcyYmIXRoaXMuaXNSYWRpYWw7Zj1wKGQud2lkdGgsZT90aGlzLnRyYW5zQToxKTtpZih0aGlzLmNyb3NzKXRoaXMuY3Jvc3MuYXR0cih7ZDpjLHZpc2liaWxpdHk6XCJ2aXNpYmxlXCIsXCJzdHJva2Utd2lkdGhcIjpmfSk7ZWxzZXtlPXtcInBvaW50ZXItZXZlbnRzXCI6XCJub25lXCIsXCJzdHJva2Utd2lkdGhcIjpmLHN0cm9rZTpkLmNvbG9yfHwoZT9cInJnYmEoMTU1LDIwMCwyNTUsMC4yKVwiOlwiI0MwQzBDMFwiKSx6SW5kZXg6cChkLnpJbmRleCxcbjIpfTtpZihkLmRhc2hTdHlsZSllLmRhc2hzdHlsZT1kLmRhc2hTdHlsZTt0aGlzLmNyb3NzPXRoaXMuY2hhcnQucmVuZGVyZXIucGF0aChjKS5hdHRyKGUpLmFkZCgpfXRoaXMuY3Jvc3MuZT1hfX0saGlkZUNyb3NzaGFpcjpmdW5jdGlvbigpe3RoaXMuY3Jvc3MmJnRoaXMuY3Jvc3MuaGlkZSgpfX07eChpYS5wcm90b3R5cGUse2dldFBsb3RCYW5kUGF0aDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ2V0UGxvdExpbmVQYXRoKGIsbnVsbCxudWxsLCEwKSxkPXRoaXMuZ2V0UGxvdExpbmVQYXRoKGEsbnVsbCxudWxsLCEwKTtkJiZjPyhkLmZsYXQ9ZC50b1N0cmluZygpPT09Yy50b1N0cmluZygpLGQucHVzaChjWzRdLGNbNV0sY1sxXSxjWzJdKSk6ZD1udWxsO3JldHVybiBkfSxhZGRQbG90QmFuZDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShhLFwicGxvdEJhbmRzXCIpfSxhZGRQbG90TGluZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShhLFxuXCJwbG90TGluZXNcIil9LGFkZFBsb3RCYW5kT3JMaW5lOmZ1bmN0aW9uKGEsYil7dmFyIGM9KG5ldyB1LlBsb3RMaW5lT3JCYW5kKHRoaXMsYSkpLnJlbmRlcigpLGQ9dGhpcy51c2VyT3B0aW9ucztjJiYoYiYmKGRbYl09ZFtiXXx8W10sZFtiXS5wdXNoKGEpKSx0aGlzLnBsb3RMaW5lc0FuZEJhbmRzLnB1c2goYykpO3JldHVybiBjfSxyZW1vdmVQbG90QmFuZE9yTGluZTpmdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5wbG90TGluZXNBbmRCYW5kcyxjPXRoaXMub3B0aW9ucyxkPXRoaXMudXNlck9wdGlvbnMsZT1iLmxlbmd0aDtlLS07KWJbZV0uaWQ9PT1hJiZiW2VdLmRlc3Ryb3koKTtxKFtjLnBsb3RMaW5lc3x8W10sZC5wbG90TGluZXN8fFtdLGMucGxvdEJhbmRzfHxbXSxkLnBsb3RCYW5kc3x8W11dLGZ1bmN0aW9uKGIpe2ZvcihlPWIubGVuZ3RoO2UtLTspYltlXS5pZD09PWEmJnJhKGIsYltlXSl9KX19KTtpYS5wcm90b3R5cGUuZ2V0VGltZVRpY2tzPWZ1bmN0aW9uKGEsYixcbmMsZCl7dmFyIGU9W10sZj17fSxnPVUuZ2xvYmFsLnVzZVVUQyxoLGk9bmV3IG1hKGItJGEoYikpLGo9YS51bml0UmFuZ2Usaz1hLmNvdW50O2lmKHMoYikpe2lbSGJdKGo+PUguc2Vjb25kPzA6aypWKGkuZ2V0TWlsbGlzZWNvbmRzKCkvaykpO2lmKGo+PUguc2Vjb25kKWlbSWJdKGo+PUgubWludXRlPzA6aypWKGkuZ2V0U2Vjb25kcygpL2spKTtpZihqPj1ILm1pbnV0ZSlpW0piXShqPj1ILmhvdXI/MDprKlYoaVt3Yl0oKS9rKSk7aWYoaj49SC5ob3VyKWlbS2JdKGo+PUguZGF5PzA6aypWKGlbeGJdKCkvaykpO2lmKGo+PUguZGF5KWlbbWJdKGo+PUgubW9udGg/MTprKlYoaVtXYV0oKS9rKSk7aj49SC5tb250aCYmKGlbemJdKGo+PUgueWVhcj8wOmsqVihpW2NiXSgpL2spKSxoPWlbZGJdKCkpO2o+PUgueWVhciYmKGgtPWglayxpW0FiXShoKSk7aWYoaj09PUgud2VlaylpW21iXShpW1dhXSgpLWlbeWJdKCkrcChkLDEpKTtiPTE7aWYodGJ8fGFiKWk9aS5nZXRUaW1lKCksaT1uZXcgbWEoaStcbiRhKGkpKTtoPWlbZGJdKCk7Zm9yKHZhciBkPWkuZ2V0VGltZSgpLGw9aVtjYl0oKSxtPWlbV2FdKCksbj0hZ3x8ISFhYixvPShILmRheSsoZz8kYShpKTppLmdldFRpbWV6b25lT2Zmc2V0KCkqNkU0KSklSC5kYXk7ZDxjOyllLnB1c2goZCksaj09PUgueWVhcj9kPWxiKGgrYiprLDApOmo9PT1ILm1vbnRoP2Q9bGIoaCxsK2Iqayk6biYmKGo9PT1ILmRheXx8aj09PUgud2Vlayk/ZD1sYihoLGwsbStiKmsqKGo9PT1ILmRheT8xOjcpKTpkKz1qKmssYisrO2UucHVzaChkKTtxKENhKGUsZnVuY3Rpb24oYSl7cmV0dXJuIGo8PUguaG91ciYmYSVILmRheT09PW99KSxmdW5jdGlvbihhKXtmW2FdPVwiZGF5XCJ9KX1lLmluZm89eChhLHtoaWdoZXJSYW5rczpmLHRvdGFsUmFuZ2U6aiprfSk7cmV0dXJuIGV9O2lhLnByb3RvdHlwZS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsPWZ1bmN0aW9uKGEsYil7dmFyIGM9Ynx8W1tcIm1pbGxpc2Vjb25kXCIsWzEsMiw1LDEwLDIwLDI1LDUwLDEwMCwyMDAsXG41MDBdXSxbXCJzZWNvbmRcIixbMSwyLDUsMTAsMTUsMzBdXSxbXCJtaW51dGVcIixbMSwyLDUsMTAsMTUsMzBdXSxbXCJob3VyXCIsWzEsMiwzLDQsNiw4LDEyXV0sW1wiZGF5XCIsWzEsMl1dLFtcIndlZWtcIixbMSwyXV0sW1wibW9udGhcIixbMSwyLDMsNCw2XV0sW1wieWVhclwiLG51bGxdXSxkPWNbYy5sZW5ndGgtMV0sZT1IW2RbMF1dLGY9ZFsxXSxnO2ZvcihnPTA7ZzxjLmxlbmd0aDtnKyspaWYoZD1jW2ddLGU9SFtkWzBdXSxmPWRbMV0sY1tnKzFdJiZhPD0oZSpmW2YubGVuZ3RoLTFdK0hbY1tnKzFdWzBdXSkvMilicmVhaztlPT09SC55ZWFyJiZhPDUqZSYmKGY9WzEsMiw1XSk7Yz12YihhL2UsZixkWzBdPT09XCJ5ZWFyXCI/dCh1YihhL2UpLDEpOjEpO3JldHVybnt1bml0UmFuZ2U6ZSxjb3VudDpjLHVuaXROYW1lOmRbMF19fTtpYS5wcm90b3R5cGUuZ2V0TG9nVGlja1Bvc2l0aW9ucz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLm9wdGlvbnMsZj10aGlzLmxlbixnPXRoaXMubGluMmxvZyxoPVxudGhpcy5sb2cybGluLGk9W107aWYoIWQpdGhpcy5fbWlub3JBdXRvSW50ZXJ2YWw9bnVsbDtpZihhPj0wLjUpYT1DKGEpLGk9dGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKGEsYixjKTtlbHNlIGlmKGE+PTAuMDgpZm9yKHZhciBmPVYoYiksaixrLGwsbSxuLGU9YT4wLjM/WzEsMiw0XTphPjAuMTU/WzEsMiw0LDYsOF06WzEsMiwzLDQsNSw2LDcsOCw5XTtmPGMrMSYmIW47ZisrKXtrPWUubGVuZ3RoO2ZvcihqPTA7ajxrJiYhbjtqKyspbD1oKGcoZikqZVtqXSksbD5iJiYoIWR8fG08PWMpJiZtIT09QSYmaS5wdXNoKG0pLG0+YyYmKG49ITApLG09bH1lbHNlIGlmKGI9ZyhiKSxjPWcoYyksYT1lW2Q/XCJtaW5vclRpY2tJbnRlcnZhbFwiOlwidGlja0ludGVydmFsXCJdLGE9cChhPT09XCJhdXRvXCI/bnVsbDphLHRoaXMuX21pbm9yQXV0b0ludGVydmFsLChjLWIpKihlLnRpY2tQaXhlbEludGVydmFsLyhkPzU6MSkpLygoZD9mL3RoaXMudGlja1Bvc2l0aW9ucy5sZW5ndGg6Zil8fDEpKSxhPVxudmIoYSxudWxsLHViKGEpKSxpPURhKHRoaXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhhLGIsYyksaCksIWQpdGhpcy5fbWlub3JBdXRvSW50ZXJ2YWw9YS81O2lmKCFkKXRoaXMudGlja0ludGVydmFsPWE7cmV0dXJuIGl9O2lhLnByb3RvdHlwZS5sb2cybGluPWZ1bmN0aW9uKGEpe3JldHVybiBaLmxvZyhhKS9aLkxOMTB9O2lhLnByb3RvdHlwZS5saW4ybG9nPWZ1bmN0aW9uKGEpe3JldHVybiBaLnBvdygxMCxhKX07dmFyIFFiPXUuVG9vbHRpcD1mdW5jdGlvbigpe3RoaXMuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O1FiLnByb3RvdHlwZT17aW5pdDpmdW5jdGlvbihhLGIpe3ZhciBjPWIuYm9yZGVyV2lkdGgsZD1iLnN0eWxlLGU9QihkLnBhZGRpbmcpO3RoaXMuY2hhcnQ9YTt0aGlzLm9wdGlvbnM9Yjt0aGlzLmNyb3NzaGFpcnM9W107dGhpcy5ub3c9e3g6MCx5OjB9O3RoaXMuaXNIaWRkZW49ITA7dGhpcy5sYWJlbD1hLnJlbmRlcmVyLmxhYmVsKFwiXCIsMCwwLGIuc2hhcGV8fFxuXCJjYWxsb3V0XCIsbnVsbCxudWxsLGIudXNlSFRNTCxudWxsLFwidG9vbHRpcFwiKS5hdHRyKHtwYWRkaW5nOmUsZmlsbDpiLmJhY2tncm91bmRDb2xvcixcInN0cm9rZS13aWR0aFwiOmMscjpiLmJvcmRlclJhZGl1cyx6SW5kZXg6OH0pLmNzcyhkKS5jc3Moe3BhZGRpbmc6MH0pLmFkZCgpLmF0dHIoe3k6LTlFOX0pO2xhfHx0aGlzLmxhYmVsLnNoYWRvdyhiLnNoYWRvdyk7dGhpcy5zaGFyZWQ9Yi5zaGFyZWR9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtpZih0aGlzLmxhYmVsKXRoaXMubGFiZWw9dGhpcy5sYWJlbC5kZXN0cm95KCk7Y2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtjbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCl9LG1vdmU6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcyxmPWUubm93LGc9ZS5vcHRpb25zLmFuaW1hdGlvbiE9PSExJiYhZS5pc0hpZGRlbiYmKFEoYS1mLngpPjF8fFEoYi1mLnkpPjEpLGg9ZS5mb2xsb3dQb2ludGVyfHxlLmxlbj4xO3goZix7eDpnP1xuKDIqZi54K2EpLzM6YSx5Omc/KGYueStiKS8yOmIsYW5jaG9yWDpoP0E6Zz8oMipmLmFuY2hvclgrYykvMzpjLGFuY2hvclk6aD9BOmc/KGYuYW5jaG9yWStkKS8yOmR9KTtlLmxhYmVsLmF0dHIoZik7aWYoZyljbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCksdGhpcy50b29sdGlwVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZSYmZS5tb3ZlKGEsYixjLGQpfSwzMil9LGhpZGU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO2E9cChhLHRoaXMub3B0aW9ucy5oaWRlRGVsYXksNTAwKTtpZighdGhpcy5pc0hpZGRlbil0aGlzLmhpZGVUaW1lcj1SYShmdW5jdGlvbigpe2IubGFiZWxbYT9cImZhZGVPdXRcIjpcImhpZGVcIl0oKTtiLmlzSGlkZGVuPSEwfSxhKX0sZ2V0QW5jaG9yOmZ1bmN0aW9uKGEsYil7dmFyIGMsZD10aGlzLmNoYXJ0LGU9ZC5pbnZlcnRlZCxmPWQucGxvdFRvcCxnPWQucGxvdExlZnQsaD0wLGk9MCxqLGssYT1cbnVhKGEpO2M9YVswXS50b29sdGlwUG9zO3RoaXMuZm9sbG93UG9pbnRlciYmYiYmKGIuY2hhcnRYPT09QSYmKGI9ZC5wb2ludGVyLm5vcm1hbGl6ZShiKSksYz1bYi5jaGFydFgtZC5wbG90TGVmdCxiLmNoYXJ0WS1mXSk7Y3x8KHEoYSxmdW5jdGlvbihhKXtqPWEuc2VyaWVzLnlBeGlzO2s9YS5zZXJpZXMueEF4aXM7aCs9YS5wbG90WCsoIWUmJms/ay5sZWZ0LWc6MCk7aSs9KGEucGxvdExvdz8oYS5wbG90TG93K2EucGxvdEhpZ2gpLzI6YS5wbG90WSkrKCFlJiZqP2oudG9wLWY6MCl9KSxoLz1hLmxlbmd0aCxpLz1hLmxlbmd0aCxjPVtlP2QucGxvdFdpZHRoLWk6aCx0aGlzLnNoYXJlZCYmIWUmJmEubGVuZ3RoPjEmJmI/Yi5jaGFydFktZjplP2QucGxvdEhlaWdodC1oOmldKTtyZXR1cm4gRGEoYyxDKX0sZ2V0UG9zaXRpb246ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuY2hhcnQsZT10aGlzLmRpc3RhbmNlLGY9e30sZz1jLmh8fDAsaCxpPVtcInlcIixkLmNoYXJ0SGVpZ2h0LGIsXG5jLnBsb3RZK2QucGxvdFRvcCxkLnBsb3RUb3AsZC5wbG90VG9wK2QucGxvdEhlaWdodF0saj1bXCJ4XCIsZC5jaGFydFdpZHRoLGEsYy5wbG90WCtkLnBsb3RMZWZ0LGQucGxvdExlZnQsZC5wbG90TGVmdCtkLnBsb3RXaWR0aF0saz0hdGhpcy5mb2xsb3dQb2ludGVyJiZwKGMudHRCZWxvdywhZC5pbnZlcnRlZD09PSEhYy5uZWdhdGl2ZSksbD1mdW5jdGlvbihhLGIsYyxkLGgsaSl7dmFyIGo9YzxkLWUsbT1kK2UrYzxiLGw9ZC1lLWM7ZCs9ZTtpZihrJiZtKWZbYV09ZDtlbHNlIGlmKCFrJiZqKWZbYV09bDtlbHNlIGlmKGopZlthXT1GKGktYyxsLWc8MD9sOmwtZyk7ZWxzZSBpZihtKWZbYV09dChoLGQrZytjPmI/ZDpkK2cpO2Vsc2UgcmV0dXJuITF9LG09ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGc7ZDxlfHxkPmItZT9nPSExOmZbYV09ZDxjLzI/MTpkPmItYy8yP2ItYy0yOmQtYy8yO3JldHVybiBnfSxuPWZ1bmN0aW9uKGEpe3ZhciBiPWk7aT1qO2o9YjtoPWF9LG89ZnVuY3Rpb24oKXtsLmFwcGx5KDAsXG5pKSE9PSExP20uYXBwbHkoMCxqKT09PSExJiYhaCYmKG4oITApLG8oKSk6aD9mLng9Zi55PTA6KG4oITApLG8oKSl9OyhkLmludmVydGVkfHx0aGlzLmxlbj4xKSYmbigpO28oKTtyZXR1cm4gZn0sZGVmYXVsdEZvcm1hdHRlcjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnBvaW50c3x8dWEodGhpcyksYztjPVthLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIoYlswXSldO2M9Yy5jb25jYXQoYS5ib2R5Rm9ybWF0dGVyKGIpKTtjLnB1c2goYS50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGJbMF0sITApKTtyZXR1cm4gYy5qb2luKFwiXCIpfSxyZWZyZXNoOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jaGFydCxkPXRoaXMubGFiZWwsZT10aGlzLm9wdGlvbnMsZixnLGgsaT17fSxqLGs9W107aj1lLmZvcm1hdHRlcnx8dGhpcy5kZWZhdWx0Rm9ybWF0dGVyO3ZhciBpPWMuaG92ZXJQb2ludHMsbCxtPXRoaXMuc2hhcmVkO2NsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7dGhpcy5mb2xsb3dQb2ludGVyPVxudWEoYSlbMF0uc2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7aD10aGlzLmdldEFuY2hvcihhLGIpO2Y9aFswXTtnPWhbMV07bSYmKCFhLnNlcmllc3x8IWEuc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCk/KGMuaG92ZXJQb2ludHM9YSxpJiZxKGksZnVuY3Rpb24oYSl7YS5zZXRTdGF0ZSgpfSkscShhLGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoXCJob3ZlclwiKTtrLnB1c2goYS5nZXRMYWJlbENvbmZpZygpKX0pLGk9e3g6YVswXS5jYXRlZ29yeSx5OmFbMF0ueX0saS5wb2ludHM9ayx0aGlzLmxlbj1rLmxlbmd0aCxhPWFbMF0pOmk9YS5nZXRMYWJlbENvbmZpZygpO2o9ai5jYWxsKGksdGhpcyk7aT1hLnNlcmllczt0aGlzLmRpc3RhbmNlPXAoaS50b29sdGlwT3B0aW9ucy5kaXN0YW5jZSwxNik7aj09PSExP3RoaXMuaGlkZSgpOih0aGlzLmlzSGlkZGVuJiYoS2EoZCksZC5hdHRyKFwib3BhY2l0eVwiLDEpLnNob3coKSksZC5hdHRyKHt0ZXh0Omp9KSxsPWUuYm9yZGVyQ29sb3J8fFxuYS5jb2xvcnx8aS5jb2xvcnx8XCIjNjA2MDYwXCIsZC5hdHRyKHtzdHJva2U6bH0pLHRoaXMudXBkYXRlUG9zaXRpb24oe3Bsb3RYOmYscGxvdFk6ZyxuZWdhdGl2ZTphLm5lZ2F0aXZlLHR0QmVsb3c6YS50dEJlbG93LGg6aFsyXXx8MH0pLHRoaXMuaXNIaWRkZW49ITEpO0koYyxcInRvb2x0aXBSZWZyZXNoXCIse3RleHQ6aix4OmYrYy5wbG90TGVmdCx5OmcrYy5wbG90VG9wLGJvcmRlckNvbG9yOmx9KX0sdXBkYXRlUG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPXRoaXMubGFiZWwsYz0odGhpcy5vcHRpb25zLnBvc2l0aW9uZXJ8fHRoaXMuZ2V0UG9zaXRpb24pLmNhbGwodGhpcyxjLndpZHRoLGMuaGVpZ2h0LGEpO3RoaXMubW92ZShDKGMueCksQyhjLnl8fDApLGEucGxvdFgrYi5wbG90TGVmdCxhLnBsb3RZK2IucGxvdFRvcCl9LGdldFhEYXRlRm9ybWF0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxiPWIuZGF0ZVRpbWVMYWJlbEZvcm1hdHMsZT1jJiZjLmNsb3Nlc3RQb2ludFJhbmdlLFxuZixnPXttaWxsaXNlY29uZDoxNSxzZWNvbmQ6MTIsbWludXRlOjksaG91cjo2LGRheTozfSxoLGk9XCJtaWxsaXNlY29uZFwiO2lmKGUpe2g9U2EoXCIlbS0lZCAlSDolTTolUy4lTFwiLGEueCk7Zm9yKGYgaW4gSCl7aWYoZT09PUgud2VlayYmK1NhKFwiJXdcIixhLngpPT09Yy5vcHRpb25zLnN0YXJ0T2ZXZWVrJiZoLnN1YnN0cig2KT09PVwiMDA6MDA6MDAuMDAwXCIpe2Y9XCJ3ZWVrXCI7YnJlYWt9aWYoSFtmXT5lKXtmPWk7YnJlYWt9aWYoZ1tmXSYmaC5zdWJzdHIoZ1tmXSkhPT1cIjAxLTAxIDAwOjAwOjAwLjAwMFwiLnN1YnN0cihnW2ZdKSlicmVhaztmIT09XCJ3ZWVrXCImJihpPWYpfWYmJihkPWJbZl0pfWVsc2UgZD1iLmRheTtyZXR1cm4gZHx8Yi55ZWFyfSx0b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9Yj9cImZvb3RlclwiOlwiaGVhZGVyXCIsZD1hLnNlcmllcyxlPWQudG9vbHRpcE9wdGlvbnMsZj1lLnhEYXRlRm9ybWF0LGc9ZC54QXhpcyxoPWcmJmcub3B0aW9ucy50eXBlPT09XG5cImRhdGV0aW1lXCImJkooYS5rZXkpLGM9ZVtjK1wiRm9ybWF0XCJdO2gmJiFmJiYoZj10aGlzLmdldFhEYXRlRm9ybWF0KGEsZSxnKSk7aCYmZiYmKGM9Yy5yZXBsYWNlKFwie3BvaW50LmtleX1cIixcIntwb2ludC5rZXk6XCIrZitcIn1cIikpO3JldHVybiBOYShjLHtwb2ludDphLHNlcmllczpkfSl9LGJvZHlGb3JtYXR0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIERhKGEsZnVuY3Rpb24oYSl7dmFyIGM9YS5zZXJpZXMudG9vbHRpcE9wdGlvbnM7cmV0dXJuKGMucG9pbnRGb3JtYXR0ZXJ8fGEucG9pbnQudG9vbHRpcEZvcm1hdHRlcikuY2FsbChhLnBvaW50LGMucG9pbnRGb3JtYXQpfSl9fTt2YXIgamE7ZmI9eSYmeS5kb2N1bWVudEVsZW1lbnQub250b3VjaHN0YXJ0IT09QTt2YXIgWmE9dS5Qb2ludGVyPWZ1bmN0aW9uKGEsYil7dGhpcy5pbml0KGEsYil9O1phLnByb3RvdHlwZT17aW5pdDpmdW5jdGlvbihhLGIpe3ZhciBjPWIuY2hhcnQsZD1jLmV2ZW50cyxlPWxhP1wiXCI6Yy56b29tVHlwZSxjPWEuaW52ZXJ0ZWQsXG5mO3RoaXMub3B0aW9ucz1iO3RoaXMuY2hhcnQ9YTt0aGlzLnpvb21YPWY9L3gvLnRlc3QoZSk7dGhpcy56b29tWT1lPS95Ly50ZXN0KGUpO3RoaXMuem9vbUhvcj1mJiYhY3x8ZSYmYzt0aGlzLnpvb21WZXJ0PWUmJiFjfHxmJiZjO3RoaXMuaGFzWm9vbT1mfHxlO3RoaXMucnVuQ2hhcnRDbGljaz1kJiYhIWQuY2xpY2s7dGhpcy5waW5jaERvd249W107dGhpcy5sYXN0VmFsaWRUb3VjaD17fTtpZih1LlRvb2x0aXAmJmIudG9vbHRpcC5lbmFibGVkKWEudG9vbHRpcD1uZXcgUWIoYSxiLnRvb2x0aXApLHRoaXMuZm9sbG93VG91Y2hNb3ZlPXAoYi50b29sdGlwLmZvbGxvd1RvdWNoTW92ZSwhMCk7dGhpcy5zZXRET01FdmVudHMoKX0sbm9ybWFsaXplOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxhPWF8fEQuZXZlbnQ7aWYoIWEudGFyZ2V0KWEudGFyZ2V0PWEuc3JjRWxlbWVudDtkPWEudG91Y2hlcz9hLnRvdWNoZXMubGVuZ3RoP2EudG91Y2hlcy5pdGVtKDApOmEuY2hhbmdlZFRvdWNoZXNbMF06XG5hO2lmKCFiKXRoaXMuY2hhcnRQb3NpdGlvbj1iPUNiKHRoaXMuY2hhcnQuY29udGFpbmVyKTtkLnBhZ2VYPT09QT8oYz10KGEueCxhLmNsaWVudFgtYi5sZWZ0KSxkPWEueSk6KGM9ZC5wYWdlWC1iLmxlZnQsZD1kLnBhZ2VZLWIudG9wKTtyZXR1cm4geChhLHtjaGFydFg6QyhjKSxjaGFydFk6QyhkKX0pfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbihhKXt2YXIgYj17eEF4aXM6W10seUF4aXM6W119O3EodGhpcy5jaGFydC5heGVzLGZ1bmN0aW9uKGMpe2JbYy5pc1hBeGlzP1wieEF4aXNcIjpcInlBeGlzXCJdLnB1c2goe2F4aXM6Yyx2YWx1ZTpjLnRvVmFsdWUoYVtjLmhvcml6P1wiY2hhcnRYXCI6XCJjaGFydFlcIl0pfSl9KTtyZXR1cm4gYn0scnVuUG9pbnRBY3Rpb25zOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz1iLnNlcmllcyxkPWIudG9vbHRpcCxlPWQ/ZC5zaGFyZWQ6ITEsZj1iLmhvdmVyUG9pbnQsZz1iLmhvdmVyU2VyaWVzLGgsaT1bTnVtYmVyLk1BWF9WQUxVRSxOdW1iZXIuTUFYX1ZBTFVFXSxcbmosayxsPVtdLG09W10sbjtpZighZSYmIWcpZm9yKGg9MDtoPGMubGVuZ3RoO2grKylpZihjW2hdLmRpcmVjdFRvdWNofHwhY1toXS5vcHRpb25zLnN0aWNreVRyYWNraW5nKWM9W107ZyYmKGU/Zy5ub1NoYXJlZFRvb2x0aXA6Zy5kaXJlY3RUb3VjaCkmJmY/bT1bZl06KHEoYyxmdW5jdGlvbihiKXtqPWIubm9TaGFyZWRUb29sdGlwJiZlO2s9IWUmJmIuZGlyZWN0VG91Y2g7Yi52aXNpYmxlJiYhaiYmIWsmJnAoYi5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcsITApJiYobj1iLnNlYXJjaFBvaW50KGEsIWomJmIua2REaW1lbnNpb25zPT09MSkpJiZuLnNlcmllcyYmbC5wdXNoKG4pfSkscShsLGZ1bmN0aW9uKGEpe2EmJnEoW1wiZGlzdFwiLFwiZGlzdFhcIl0sZnVuY3Rpb24oYixjKXtpZihKKGFbYl0pKXt2YXIgZD1hW2JdPT09aVtjXSYmYS5zZXJpZXMuZ3JvdXAuekluZGV4Pj1tW2NdLnNlcmllcy5ncm91cC56SW5kZXg7aWYoYVtiXTxpW2NdfHxkKWlbY109YVtiXSxtW2NdPWF9fSl9KSk7XG5pZihlKWZvcihoPWwubGVuZ3RoO2gtLTspKGxbaF0uY2xpZW50WCE9PW1bMV0uY2xpZW50WHx8bFtoXS5zZXJpZXMubm9TaGFyZWRUb29sdGlwKSYmbC5zcGxpY2UoaCwxKTtpZihtWzBdJiYobVswXSE9PXRoaXMucHJldktEUG9pbnR8fGQmJmQuaXNIaWRkZW4pKWlmKGUmJiFtWzBdLnNlcmllcy5ub1NoYXJlZFRvb2x0aXApbC5sZW5ndGgmJmQmJmQucmVmcmVzaChsLGEpLHEobCxmdW5jdGlvbihiKXtiLm9uTW91c2VPdmVyKGEsYiE9PShnJiZnLmRpcmVjdFRvdWNoJiZmfHxtWzBdKSl9KSx0aGlzLnByZXZLRFBvaW50PW1bMV07ZWxzZXtkJiZkLnJlZnJlc2gobVswXSxhKTtpZighZ3x8IWcuZGlyZWN0VG91Y2gpbVswXS5vbk1vdXNlT3ZlcihhKTt0aGlzLnByZXZLRFBvaW50PW1bMF19ZWxzZSBjPWcmJmcudG9vbHRpcE9wdGlvbnMuZm9sbG93UG9pbnRlcixkJiZjJiYhZC5pc0hpZGRlbiYmKGM9ZC5nZXRBbmNob3IoW3t9XSxhKSxkLnVwZGF0ZVBvc2l0aW9uKHtwbG90WDpjWzBdLFxucGxvdFk6Y1sxXX0pKTtpZighdGhpcy5fb25Eb2N1bWVudE1vdXNlTW92ZSl0aGlzLl9vbkRvY3VtZW50TW91c2VNb3ZlPWZ1bmN0aW9uKGEpe2lmKFRbamFdKVRbamFdLnBvaW50ZXIub25Eb2N1bWVudE1vdXNlTW92ZShhKX0sTih5LFwibW91c2Vtb3ZlXCIsdGhpcy5fb25Eb2N1bWVudE1vdXNlTW92ZSk7cShlP2w6W3AoZixtWzFdKV0sZnVuY3Rpb24oYyl7cShiLmF4ZXMsZnVuY3Rpb24oYil7KCFjfHxjLnNlcmllc1tiLmNvbGxdPT09YikmJmIuZHJhd0Nyb3NzaGFpcihhLGMpfSl9KX0scmVzZXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNoYXJ0LGQ9Yy5ob3ZlclNlcmllcyxlPWMuaG92ZXJQb2ludCxmPWMuaG92ZXJQb2ludHMsZz1jLnRvb2x0aXAsaD1nJiZnLnNoYXJlZD9mOmU7YSYmaCYmcSh1YShoKSxmdW5jdGlvbihiKXtiLnNlcmllcy5pc0NhcnRlc2lhbiYmYi5wbG90WD09PXZvaWQgMCYmKGE9ITEpfSk7aWYoYSlnJiZoJiYoZy5yZWZyZXNoKGgpLGUmJihlLnNldFN0YXRlKGUuc3RhdGUsXG4hMCkscShjLmF4ZXMsZnVuY3Rpb24oYSl7YS5jcm9zc2hhaXImJmEuZHJhd0Nyb3NzaGFpcihudWxsLGUpfSkpKTtlbHNle2lmKGUpZS5vbk1vdXNlT3V0KCk7ZiYmcShmLGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoKX0pO2lmKGQpZC5vbk1vdXNlT3V0KCk7ZyYmZy5oaWRlKGIpO2lmKHRoaXMuX29uRG9jdW1lbnRNb3VzZU1vdmUpWSh5LFwibW91c2Vtb3ZlXCIsdGhpcy5fb25Eb2N1bWVudE1vdXNlTW92ZSksdGhpcy5fb25Eb2N1bWVudE1vdXNlTW92ZT1udWxsO3EoYy5heGVzLGZ1bmN0aW9uKGEpe2EuaGlkZUNyb3NzaGFpcigpfSk7dGhpcy5ob3Zlclg9dGhpcy5wcmV2S0RQb2ludD1jLmhvdmVyUG9pbnRzPWMuaG92ZXJQb2ludD1udWxsfX0sc2NhbGVHcm91cHM6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNoYXJ0LGQ7cShjLnNlcmllcyxmdW5jdGlvbihlKXtkPWF8fGUuZ2V0UGxvdEJveCgpO2UueEF4aXMmJmUueEF4aXMuem9vbUVuYWJsZWQmJihlLmdyb3VwLmF0dHIoZCksZS5tYXJrZXJHcm91cCYmXG4oZS5tYXJrZXJHcm91cC5hdHRyKGQpLGUubWFya2VyR3JvdXAuY2xpcChiP2MuY2xpcFJlY3Q6bnVsbCkpLGUuZGF0YUxhYmVsc0dyb3VwJiZlLmRhdGFMYWJlbHNHcm91cC5hdHRyKGQpKX0pO2MuY2xpcFJlY3QuYXR0cihifHxjLmNsaXBCb3gpfSxkcmFnU3RhcnQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydDtiLm1vdXNlSXNEb3duPWEudHlwZTtiLmNhbmNlbENsaWNrPSExO2IubW91c2VEb3duWD10aGlzLm1vdXNlRG93blg9YS5jaGFydFg7Yi5tb3VzZURvd25ZPXRoaXMubW91c2VEb3duWT1hLmNoYXJ0WX0sZHJhZzpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9Yi5vcHRpb25zLmNoYXJ0LGQ9YS5jaGFydFgsZT1hLmNoYXJ0WSxmPXRoaXMuem9vbUhvcixnPXRoaXMuem9vbVZlcnQsaD1iLnBsb3RMZWZ0LGk9Yi5wbG90VG9wLGo9Yi5wbG90V2lkdGgsaz1iLnBsb3RIZWlnaHQsbCxtPXRoaXMuc2VsZWN0aW9uTWFya2VyLG49dGhpcy5tb3VzZURvd25YLG89dGhpcy5tb3VzZURvd25ZLFxucD1jLnBhbktleSYmYVtjLnBhbktleStcIktleVwiXTtpZighbXx8IW0udG91Y2gpaWYoZDxoP2Q9aDpkPmgraiYmKGQ9aCtqKSxlPGk/ZT1pOmU+aStrJiYoZT1pK2spLHRoaXMuaGFzRHJhZ2dlZD1NYXRoLnNxcnQoTWF0aC5wb3cobi1kLDIpK01hdGgucG93KG8tZSwyKSksdGhpcy5oYXNEcmFnZ2VkPjEwKXtsPWIuaXNJbnNpZGVQbG90KG4taCxvLWkpO2lmKGIuaGFzQ2FydGVzaWFuU2VyaWVzJiYodGhpcy56b29tWHx8dGhpcy56b29tWSkmJmwmJiFwJiYhbSl0aGlzLnNlbGVjdGlvbk1hcmtlcj1tPWIucmVuZGVyZXIucmVjdChoLGksZj8xOmosZz8xOmssMCkuYXR0cih7ZmlsbDpjLnNlbGVjdGlvbk1hcmtlckZpbGx8fFwicmdiYSg2OSwxMTQsMTY3LDAuMjUpXCIsekluZGV4Ojd9KS5hZGQoKTttJiZmJiYoZC09bixtLmF0dHIoe3dpZHRoOlEoZCkseDooZD4wPzA6ZCkrbn0pKTttJiZnJiYoZD1lLW8sbS5hdHRyKHtoZWlnaHQ6UShkKSx5OihkPjA/MDpkKStvfSkpO2wmJiFtJiZjLnBhbm5pbmcmJlxuYi5wYW4oYSxjLnBhbm5pbmcpfX0sZHJvcDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9dGhpcy5jaGFydCxkPXRoaXMuaGFzUGluY2hlZDtpZih0aGlzLnNlbGVjdGlvbk1hcmtlcil7dmFyIGU9e29yaWdpbmFsRXZlbnQ6YSx4QXhpczpbXSx5QXhpczpbXX0sZj10aGlzLnNlbGVjdGlvbk1hcmtlcixnPWYuYXR0cj9mLmF0dHIoXCJ4XCIpOmYueCxoPWYuYXR0cj9mLmF0dHIoXCJ5XCIpOmYueSxpPWYuYXR0cj9mLmF0dHIoXCJ3aWR0aFwiKTpmLndpZHRoLGo9Zi5hdHRyP2YuYXR0cihcImhlaWdodFwiKTpmLmhlaWdodCxrO2lmKHRoaXMuaGFzRHJhZ2dlZHx8ZClxKGMuYXhlcyxmdW5jdGlvbihjKXtpZihjLnpvb21FbmFibGVkJiZzKGMubWluKSYmKGR8fGJbe3hBeGlzOlwiem9vbVhcIix5QXhpczpcInpvb21ZXCJ9W2MuY29sbF1dKSl7dmFyIGY9Yy5ob3JpeixuPWEudHlwZT09PVwidG91Y2hlbmRcIj9jLm1pblBpeGVsUGFkZGluZzowLG89Yy50b1ZhbHVlKChmP2c6aCkrbiksZj1jLnRvVmFsdWUoKGY/XG5nK2k6aCtqKS1uKTtlW2MuY29sbF0ucHVzaCh7YXhpczpjLG1pbjpGKG8sZiksbWF4OnQobyxmKX0pO2s9ITB9fSksayYmSShjLFwic2VsZWN0aW9uXCIsZSxmdW5jdGlvbihhKXtjLnpvb20oeChhLGQ/e2FuaW1hdGlvbjohMX06bnVsbCkpfSk7dGhpcy5zZWxlY3Rpb25NYXJrZXI9dGhpcy5zZWxlY3Rpb25NYXJrZXIuZGVzdHJveSgpO2QmJnRoaXMuc2NhbGVHcm91cHMoKX1pZihjKU0oYy5jb250YWluZXIse2N1cnNvcjpjLl9jdXJzb3J9KSxjLmNhbmNlbENsaWNrPXRoaXMuaGFzRHJhZ2dlZD4xMCxjLm1vdXNlSXNEb3duPXRoaXMuaGFzRHJhZ2dlZD10aGlzLmhhc1BpbmNoZWQ9ITEsdGhpcy5waW5jaERvd249W119LG9uQ29udGFpbmVyTW91c2VEb3duOmZ1bmN0aW9uKGEpe2E9dGhpcy5ub3JtYWxpemUoYSk7YS5wcmV2ZW50RGVmYXVsdCYmYS5wcmV2ZW50RGVmYXVsdCgpO3RoaXMuZHJhZ1N0YXJ0KGEpfSxvbkRvY3VtZW50TW91c2VVcDpmdW5jdGlvbihhKXtUW2phXSYmVFtqYV0ucG9pbnRlci5kcm9wKGEpfSxcbm9uRG9jdW1lbnRNb3VzZU1vdmU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPXRoaXMuY2hhcnRQb3NpdGlvbixhPXRoaXMubm9ybWFsaXplKGEsYyk7YyYmIXRoaXMuaW5DbGFzcyhhLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKSYmIWIuaXNJbnNpZGVQbG90KGEuY2hhcnRYLWIucGxvdExlZnQsYS5jaGFydFktYi5wbG90VG9wKSYmdGhpcy5yZXNldCgpfSxvbkNvbnRhaW5lck1vdXNlTGVhdmU6ZnVuY3Rpb24oYSl7dmFyIGI9VFtqYV07aWYoYiYmKGEucmVsYXRlZFRhcmdldHx8YS50b0VsZW1lbnQpKWIucG9pbnRlci5yZXNldCgpLGIucG9pbnRlci5jaGFydFBvc2l0aW9uPW51bGx9LG9uQ29udGFpbmVyTW91c2VNb3ZlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQ7aWYoIXMoamEpfHwhVFtqYV18fCFUW2phXS5tb3VzZUlzRG93bilqYT1iLmluZGV4O2E9dGhpcy5ub3JtYWxpemUoYSk7YS5yZXR1cm5WYWx1ZT0hMTtiLm1vdXNlSXNEb3duPT09XCJtb3VzZWRvd25cIiYmXG50aGlzLmRyYWcoYSk7KHRoaXMuaW5DbGFzcyhhLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKXx8Yi5pc0luc2lkZVBsb3QoYS5jaGFydFgtYi5wbG90TGVmdCxhLmNoYXJ0WS1iLnBsb3RUb3ApKSYmIWIub3Blbk1lbnUmJnRoaXMucnVuUG9pbnRBY3Rpb25zKGEpfSxpbkNsYXNzOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjO2E7KXtpZihjPVAoYSxcImNsYXNzXCIpKXtpZihjLmluZGV4T2YoYikhPT0tMSlyZXR1cm4hMDtpZihjLmluZGV4T2YoXCJoaWdoY2hhcnRzLWNvbnRhaW5lclwiKSE9PS0xKXJldHVybiExfWE9YS5wYXJlbnROb2RlfX0sb25UcmFja2VyTW91c2VPdXQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydC5ob3ZlclNlcmllcyxhPWEucmVsYXRlZFRhcmdldHx8YS50b0VsZW1lbnQ7aWYoYiYmYSYmIWIub3B0aW9ucy5zdGlja3lUcmFja2luZyYmIXRoaXMuaW5DbGFzcyhhLFwiaGlnaGNoYXJ0cy10b29sdGlwXCIpJiYhdGhpcy5pbkNsYXNzKGEsXCJoaWdoY2hhcnRzLXNlcmllcy1cIitcbmIuaW5kZXgpKWIub25Nb3VzZU91dCgpfSxvbkNvbnRhaW5lckNsaWNrOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz1iLmhvdmVyUG9pbnQsZD1iLnBsb3RMZWZ0LGU9Yi5wbG90VG9wLGE9dGhpcy5ub3JtYWxpemUoYSk7Yi5jYW5jZWxDbGlja3x8KGMmJnRoaXMuaW5DbGFzcyhhLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKT8oSShjLnNlcmllcyxcImNsaWNrXCIseChhLHtwb2ludDpjfSkpLGIuaG92ZXJQb2ludCYmYy5maXJlUG9pbnRFdmVudChcImNsaWNrXCIsYSkpOih4KGEsdGhpcy5nZXRDb29yZGluYXRlcyhhKSksYi5pc0luc2lkZVBsb3QoYS5jaGFydFgtZCxhLmNoYXJ0WS1lKSYmSShiLFwiY2xpY2tcIixhKSkpfSxzZXRET01FdmVudHM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydC5jb250YWluZXI7Yi5vbm1vdXNlZG93bj1mdW5jdGlvbihiKXthLm9uQ29udGFpbmVyTW91c2VEb3duKGIpfTtiLm9ubW91c2Vtb3ZlPWZ1bmN0aW9uKGIpe2Eub25Db250YWluZXJNb3VzZU1vdmUoYil9O1xuYi5vbmNsaWNrPWZ1bmN0aW9uKGIpe2Eub25Db250YWluZXJDbGljayhiKX07TihiLFwibW91c2VsZWF2ZVwiLGEub25Db250YWluZXJNb3VzZUxlYXZlKTtnYj09PTEmJk4oeSxcIm1vdXNldXBcIixhLm9uRG9jdW1lbnRNb3VzZVVwKTtpZihmYiliLm9udG91Y2hzdGFydD1mdW5jdGlvbihiKXthLm9uQ29udGFpbmVyVG91Y2hTdGFydChiKX0sYi5vbnRvdWNobW92ZT1mdW5jdGlvbihiKXthLm9uQ29udGFpbmVyVG91Y2hNb3ZlKGIpfSxnYj09PTEmJk4oeSxcInRvdWNoZW5kXCIsYS5vbkRvY3VtZW50VG91Y2hFbmQpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGE7WSh0aGlzLmNoYXJ0LmNvbnRhaW5lcixcIm1vdXNlbGVhdmVcIix0aGlzLm9uQ29udGFpbmVyTW91c2VMZWF2ZSk7Z2J8fChZKHksXCJtb3VzZXVwXCIsdGhpcy5vbkRvY3VtZW50TW91c2VVcCksWSh5LFwidG91Y2hlbmRcIix0aGlzLm9uRG9jdW1lbnRUb3VjaEVuZCkpO2NsZWFySW50ZXJ2YWwodGhpcy50b29sdGlwVGltZW91dCk7Zm9yKGEgaW4gdGhpcyl0aGlzW2FdPVxubnVsbH19O3godS5Qb2ludGVyLnByb3RvdHlwZSx7cGluY2hUcmFuc2xhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpeyh0aGlzLnpvb21Ib3J8fHRoaXMucGluY2hIb3IpJiZ0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCEwLGEsYixjLGQsZSxmKTsodGhpcy56b29tVmVydHx8dGhpcy5waW5jaFZlcnQpJiZ0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCExLGEsYixjLGQsZSxmKX0scGluY2hUcmFuc2xhdGVEaXJlY3Rpb246ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoKXt2YXIgaT10aGlzLmNoYXJ0LGo9YT9cInhcIjpcInlcIixrPWE/XCJYXCI6XCJZXCIsbD1cImNoYXJ0XCIrayxtPWE/XCJ3aWR0aFwiOlwiaGVpZ2h0XCIsbj1pW1wicGxvdFwiKyhhP1wiTGVmdFwiOlwiVG9wXCIpXSxvLHAscj1ofHwxLHE9aS5pbnZlcnRlZCx3PWkuYm91bmRzW2E/XCJoXCI6XCJ2XCJdLHY9Yi5sZW5ndGg9PT0xLHM9YlswXVtsXSx0PWNbMF1bbF0seD0hdiYmYlsxXVtsXSx1PSF2JiZjWzFdW2xdLEMsYz1mdW5jdGlvbigpeyF2JiZcblEocy14KT4yMCYmKHI9aHx8USh0LXUpL1Eocy14KSk7cD0obi10KS9yK3M7bz1pW1wicGxvdFwiKyhhP1wiV2lkdGhcIjpcIkhlaWdodFwiKV0vcn07YygpO2I9cDtiPHcubWluPyhiPXcubWluLEM9ITApOmIrbz53Lm1heCYmKGI9dy5tYXgtbyxDPSEwKTtDPyh0LT0wLjgqKHQtZ1tqXVswXSksdnx8KHUtPTAuOCoodS1nW2pdWzFdKSksYygpKTpnW2pdPVt0LHVdO3F8fChmW2pdPXAtbixmW21dPW8pO2Y9cT8xL3I6cjtlW21dPW87ZVtqXT1iO2RbcT9hP1wic2NhbGVZXCI6XCJzY2FsZVhcIjpcInNjYWxlXCIra109cjtkW1widHJhbnNsYXRlXCIra109ZipuKyh0LWYqcyl9LHBpbmNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLmNoYXJ0LGQ9Yi5waW5jaERvd24sZT1hLnRvdWNoZXMsZj1lLmxlbmd0aCxnPWIubGFzdFZhbGlkVG91Y2gsaD1iLmhhc1pvb20saT1iLnNlbGVjdGlvbk1hcmtlcixqPXt9LGs9Zj09PTEmJihiLmluQ2xhc3MoYS50YXJnZXQsXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikmJmMucnVuVHJhY2tlckNsaWNrfHxcbmIucnVuQ2hhcnRDbGljayksbD17fTtpZihmPjEpYi5pbml0aWF0ZWQ9ITA7aCYmYi5pbml0aWF0ZWQmJiFrJiZhLnByZXZlbnREZWZhdWx0KCk7RGEoZSxmdW5jdGlvbihhKXtyZXR1cm4gYi5ub3JtYWxpemUoYSl9KTtpZihhLnR5cGU9PT1cInRvdWNoc3RhcnRcIilxKGUsZnVuY3Rpb24oYSxiKXtkW2JdPXtjaGFydFg6YS5jaGFydFgsY2hhcnRZOmEuY2hhcnRZfX0pLGcueD1bZFswXS5jaGFydFgsZFsxXSYmZFsxXS5jaGFydFhdLGcueT1bZFswXS5jaGFydFksZFsxXSYmZFsxXS5jaGFydFldLHEoYy5heGVzLGZ1bmN0aW9uKGEpe2lmKGEuem9vbUVuYWJsZWQpe3ZhciBiPWMuYm91bmRzW2EuaG9yaXo/XCJoXCI6XCJ2XCJdLGQ9YS5taW5QaXhlbFBhZGRpbmcsZT1hLnRvUGl4ZWxzKHAoYS5vcHRpb25zLm1pbixhLmRhdGFNaW4pKSxmPWEudG9QaXhlbHMocChhLm9wdGlvbnMubWF4LGEuZGF0YU1heCkpLGc9RihlLGYpLGU9dChlLGYpO2IubWluPUYoYS5wb3MsZy1kKTtiLm1heD10KGEucG9zK1xuYS5sZW4sZStkKX19KSxiLnJlcz0hMDtlbHNlIGlmKGQubGVuZ3RoKXtpZighaSliLnNlbGVjdGlvbk1hcmtlcj1pPXgoe2Rlc3Ryb3k6QmEsdG91Y2g6ITB9LGMucGxvdEJveCk7Yi5waW5jaFRyYW5zbGF0ZShkLGUsaixpLGwsZyk7Yi5oYXNQaW5jaGVkPWg7Yi5zY2FsZUdyb3VwcyhqLGwpO2lmKCFoJiZiLmZvbGxvd1RvdWNoTW92ZSYmZj09PTEpdGhpcy5ydW5Qb2ludEFjdGlvbnMoYi5ub3JtYWxpemUoYSkpO2Vsc2UgaWYoYi5yZXMpYi5yZXM9ITEsdGhpcy5yZXNldCghMSwwKX19LHRvdWNoOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jaGFydCxkO2phPWMuaW5kZXg7aWYoYS50b3VjaGVzLmxlbmd0aD09PTEpaWYoYT10aGlzLm5vcm1hbGl6ZShhKSxjLmlzSW5zaWRlUGxvdChhLmNoYXJ0WC1jLnBsb3RMZWZ0LGEuY2hhcnRZLWMucGxvdFRvcCkmJiFjLm9wZW5NZW51KXtiJiZ0aGlzLnJ1blBvaW50QWN0aW9ucyhhKTtpZihhLnR5cGU9PT1cInRvdWNobW92ZVwiKWM9dGhpcy5waW5jaERvd24sXG5kPWNbMF0/TWF0aC5zcXJ0KE1hdGgucG93KGNbMF0uY2hhcnRYLWEuY2hhcnRYLDIpK01hdGgucG93KGNbMF0uY2hhcnRZLWEuY2hhcnRZLDIpKT49NDohMTtwKGQsITApJiZ0aGlzLnBpbmNoKGEpfWVsc2UgYiYmdGhpcy5yZXNldCgpO2Vsc2UgYS50b3VjaGVzLmxlbmd0aD09PTImJnRoaXMucGluY2goYSl9LG9uQ29udGFpbmVyVG91Y2hTdGFydDpmdW5jdGlvbihhKXt0aGlzLnRvdWNoKGEsITApfSxvbkNvbnRhaW5lclRvdWNoTW92ZTpmdW5jdGlvbihhKXt0aGlzLnRvdWNoKGEpfSxvbkRvY3VtZW50VG91Y2hFbmQ6ZnVuY3Rpb24oYSl7VFtqYV0mJlRbamFdLnBvaW50ZXIuZHJvcChhKX19KTtpZihELlBvaW50ZXJFdmVudHx8RC5NU1BvaW50ZXJFdmVudCl7dmFyIHdhPXt9LEViPSEhRC5Qb2ludGVyRXZlbnQsVGI9ZnVuY3Rpb24oKXt2YXIgYSxiPVtdO2IuaXRlbT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpc1thXX07Zm9yKGEgaW4gd2Epd2EuaGFzT3duUHJvcGVydHkoYSkmJmIucHVzaCh7cGFnZVg6d2FbYV0ucGFnZVgsXG5wYWdlWTp3YVthXS5wYWdlWSx0YXJnZXQ6d2FbYV0udGFyZ2V0fSk7cmV0dXJuIGJ9LEZiPWZ1bmN0aW9uKGEsYixjLGQpe2lmKChhLnBvaW50ZXJUeXBlPT09XCJ0b3VjaFwifHxhLnBvaW50ZXJUeXBlPT09YS5NU1BPSU5URVJfVFlQRV9UT1VDSCkmJlRbamFdKWQoYSksZD1UW2phXS5wb2ludGVyLGRbYl0oe3R5cGU6Yyx0YXJnZXQ6YS5jdXJyZW50VGFyZ2V0LHByZXZlbnREZWZhdWx0OkJhLHRvdWNoZXM6VGIoKX0pfTt4KFphLnByb3RvdHlwZSx7b25Db250YWluZXJQb2ludGVyRG93bjpmdW5jdGlvbihhKXtGYihhLFwib25Db250YWluZXJUb3VjaFN0YXJ0XCIsXCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oYSl7d2FbYS5wb2ludGVySWRdPXtwYWdlWDphLnBhZ2VYLHBhZ2VZOmEucGFnZVksdGFyZ2V0OmEuY3VycmVudFRhcmdldH19KX0sb25Db250YWluZXJQb2ludGVyTW92ZTpmdW5jdGlvbihhKXtGYihhLFwib25Db250YWluZXJUb3VjaE1vdmVcIixcInRvdWNobW92ZVwiLGZ1bmN0aW9uKGEpe3dhW2EucG9pbnRlcklkXT1cbntwYWdlWDphLnBhZ2VYLHBhZ2VZOmEucGFnZVl9O2lmKCF3YVthLnBvaW50ZXJJZF0udGFyZ2V0KXdhW2EucG9pbnRlcklkXS50YXJnZXQ9YS5jdXJyZW50VGFyZ2V0fSl9LG9uRG9jdW1lbnRQb2ludGVyVXA6ZnVuY3Rpb24oYSl7RmIoYSxcIm9uRG9jdW1lbnRUb3VjaEVuZFwiLFwidG91Y2hlbmRcIixmdW5jdGlvbihhKXtkZWxldGUgd2FbYS5wb2ludGVySWRdfSl9LGJhdGNoTVNFdmVudHM6ZnVuY3Rpb24oYSl7YSh0aGlzLmNoYXJ0LmNvbnRhaW5lcixFYj9cInBvaW50ZXJkb3duXCI6XCJNU1BvaW50ZXJEb3duXCIsdGhpcy5vbkNvbnRhaW5lclBvaW50ZXJEb3duKTthKHRoaXMuY2hhcnQuY29udGFpbmVyLEViP1wicG9pbnRlcm1vdmVcIjpcIk1TUG9pbnRlck1vdmVcIix0aGlzLm9uQ29udGFpbmVyUG9pbnRlck1vdmUpO2EoeSxFYj9cInBvaW50ZXJ1cFwiOlwiTVNQb2ludGVyVXBcIix0aGlzLm9uRG9jdW1lbnRQb2ludGVyVXApfX0pO2hiKFphLnByb3RvdHlwZSxcImluaXRcIixmdW5jdGlvbihhLGIsYyl7YS5jYWxsKHRoaXMsXG5iLGMpO3RoaXMuaGFzWm9vbSYmTShiLmNvbnRhaW5lcix7XCItbXMtdG91Y2gtYWN0aW9uXCI6XCJub25lXCIsXCJ0b3VjaC1hY3Rpb25cIjpcIm5vbmVcIn0pfSk7aGIoWmEucHJvdG90eXBlLFwic2V0RE9NRXZlbnRzXCIsZnVuY3Rpb24oYSl7YS5hcHBseSh0aGlzKTsodGhpcy5oYXNab29tfHx0aGlzLmZvbGxvd1RvdWNoTW92ZSkmJnRoaXMuYmF0Y2hNU0V2ZW50cyhOKX0pO2hiKFphLnByb3RvdHlwZSxcImRlc3Ryb3lcIixmdW5jdGlvbihhKXt0aGlzLmJhdGNoTVNFdmVudHMoWSk7YS5jYWxsKHRoaXMpfSl9dmFyIHJiPXUuTGVnZW5kPWZ1bmN0aW9uKGEsYil7dGhpcy5pbml0KGEsYil9O3JiLnByb3RvdHlwZT17aW5pdDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1iLml0ZW1TdHlsZSxlPWIuaXRlbU1hcmdpblRvcHx8MDt0aGlzLm9wdGlvbnM9YjtpZihiLmVuYWJsZWQpYy5pdGVtU3R5bGU9ZCxjLml0ZW1IaWRkZW5TdHlsZT1FKGQsYi5pdGVtSGlkZGVuU3R5bGUpLGMuaXRlbU1hcmdpblRvcD1cbmUsYy5wYWRkaW5nPWQ9cChiLnBhZGRpbmcsOCksYy5pbml0aWFsSXRlbVg9ZCxjLmluaXRpYWxJdGVtWT1kLTUsYy5tYXhJdGVtV2lkdGg9MCxjLmNoYXJ0PWEsYy5pdGVtSGVpZ2h0PTAsYy5zeW1ib2xXaWR0aD1wKGIuc3ltYm9sV2lkdGgsMTYpLGMucGFnZXM9W10sYy5yZW5kZXIoKSxOKGMuY2hhcnQsXCJlbmRSZXNpemVcIixmdW5jdGlvbigpe2MucG9zaXRpb25DaGVja2JveGVzKCl9KX0sY29sb3JpemVJdGVtOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5vcHRpb25zLGQ9YS5sZWdlbmRJdGVtLGU9YS5sZWdlbmRMaW5lLGY9YS5sZWdlbmRTeW1ib2wsZz10aGlzLml0ZW1IaWRkZW5TdHlsZS5jb2xvcixjPWI/Yy5pdGVtU3R5bGUuY29sb3I6ZyxoPWI/YS5sZWdlbmRDb2xvcnx8YS5jb2xvcnx8XCIjQ0NDXCI6ZyxnPWEub3B0aW9ucyYmYS5vcHRpb25zLm1hcmtlcixpPXtmaWxsOmh9LGo7ZCYmZC5jc3Moe2ZpbGw6Yyxjb2xvcjpjfSk7ZSYmZS5hdHRyKHtzdHJva2U6aH0pO2lmKGYpe2lmKGcmJlxuZi5pc01hcmtlcilmb3IoaiBpbiBpLnN0cm9rZT1oLGc9YS5jb252ZXJ0QXR0cmlicyhnKSxnKWQ9Z1tqXSxkIT09QSYmKGlbal09ZCk7Zi5hdHRyKGkpfX0scG9zaXRpb25JdGVtOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucyxjPWIuc3ltYm9sUGFkZGluZyxiPSFiLnJ0bCxkPWEuX2xlZ2VuZEl0ZW1Qb3MsZT1kWzBdLGQ9ZFsxXSxmPWEuY2hlY2tib3g7KGE9YS5sZWdlbmRHcm91cCkmJmEuZWxlbWVudCYmYS50cmFuc2xhdGUoYj9lOnRoaXMubGVnZW5kV2lkdGgtZS0yKmMtNCxkKTtpZihmKWYueD1lLGYueT1kfSxkZXN0cm95SXRlbTpmdW5jdGlvbihhKXt2YXIgYj1hLmNoZWNrYm94O3EoW1wibGVnZW5kSXRlbVwiLFwibGVnZW5kTGluZVwiLFwibGVnZW5kU3ltYm9sXCIsXCJsZWdlbmRHcm91cFwiXSxmdW5jdGlvbihiKXthW2JdJiYoYVtiXT1hW2JdLmRlc3Ryb3koKSl9KTtiJiZVYShhLmNoZWNrYm94KX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZ3JvdXAsYj10aGlzLmJveDtcbmlmKGIpdGhpcy5ib3g9Yi5kZXN0cm95KCk7aWYoYSl0aGlzLmdyb3VwPWEuZGVzdHJveSgpfSxwb3NpdGlvbkNoZWNrYm94ZXM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncm91cC5hbGlnbkF0dHIsYyxkPXRoaXMuY2xpcEhlaWdodHx8dGhpcy5sZWdlbmRIZWlnaHQsZT10aGlzLnRpdGxlSGVpZ2h0O2lmKGIpYz1iLnRyYW5zbGF0ZVkscSh0aGlzLmFsbEl0ZW1zLGZ1bmN0aW9uKGYpe3ZhciBnPWYuY2hlY2tib3gsaDtnJiYoaD1jK2UrZy55KyhhfHwwKSszLE0oZyx7bGVmdDpiLnRyYW5zbGF0ZVgrZi5jaGVja2JveE9mZnNldCtnLngtMjArXCJweFwiLHRvcDpoK1wicHhcIixkaXNwbGF5Omg+Yy02JiZoPGMrZC02P1wiXCI6XCJub25lXCJ9KSl9KX0scmVuZGVyVGl0bGU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnBhZGRpbmcsYj10aGlzLm9wdGlvbnMudGl0bGUsYz0wO2lmKGIudGV4dCl7aWYoIXRoaXMudGl0bGUpdGhpcy50aXRsZT10aGlzLmNoYXJ0LnJlbmRlcmVyLmxhYmVsKGIudGV4dCxhLVxuMyxhLTQsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLFwibGVnZW5kLXRpdGxlXCIpLmF0dHIoe3pJbmRleDoxfSkuY3NzKGIuc3R5bGUpLmFkZCh0aGlzLmdyb3VwKTthPXRoaXMudGl0bGUuZ2V0QkJveCgpO2M9YS5oZWlnaHQ7dGhpcy5vZmZzZXRXaWR0aD1hLndpZHRoO3RoaXMuY29udGVudEdyb3VwLmF0dHIoe3RyYW5zbGF0ZVk6Y30pfXRoaXMudGl0bGVIZWlnaHQ9Y30sc2V0VGV4dDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnM7YS5sZWdlbmRJdGVtLmF0dHIoe3RleHQ6Yi5sYWJlbEZvcm1hdD9OYShiLmxhYmVsRm9ybWF0LGEpOmIubGFiZWxGb3JtYXR0ZXIuY2FsbChhKX0pfSxyZW5kZXJJdGVtOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz1iLnJlbmRlcmVyLGQ9dGhpcy5vcHRpb25zLGU9ZC5sYXlvdXQ9PT1cImhvcml6b250YWxcIixmPXRoaXMuc3ltYm9sV2lkdGgsZz1kLnN5bWJvbFBhZGRpbmcsaD10aGlzLml0ZW1TdHlsZSxpPXRoaXMuaXRlbUhpZGRlblN0eWxlLFxuaj10aGlzLnBhZGRpbmcsaz1lP3AoZC5pdGVtRGlzdGFuY2UsMjApOjAsbD0hZC5ydGwsbT1kLndpZHRoLG49ZC5pdGVtTWFyZ2luQm90dG9tfHwwLG89dGhpcy5pdGVtTWFyZ2luVG9wLHo9dGhpcy5pbml0aWFsSXRlbVgscj1hLmxlZ2VuZEl0ZW0scT1hLnNlcmllcyYmYS5zZXJpZXMuZHJhd0xlZ2VuZFN5bWJvbD9hLnNlcmllczphLHc9cS5vcHRpb25zLHc9dGhpcy5jcmVhdGVDaGVja2JveEZvckl0ZW0mJncmJncuc2hvd0NoZWNrYm94LHY9ZC51c2VIVE1MO2lmKCFyKXthLmxlZ2VuZEdyb3VwPWMuZyhcImxlZ2VuZC1pdGVtXCIpLmF0dHIoe3pJbmRleDoxfSkuYWRkKHRoaXMuc2Nyb2xsR3JvdXApO2EubGVnZW5kSXRlbT1yPWMudGV4dChcIlwiLGw/ZitnOi1nLHRoaXMuYmFzZWxpbmV8fDAsdikuY3NzKEUoYS52aXNpYmxlP2g6aSkpLmF0dHIoe2FsaWduOmw/XCJsZWZ0XCI6XCJyaWdodFwiLHpJbmRleDoyfSkuYWRkKGEubGVnZW5kR3JvdXApO2lmKCF0aGlzLmJhc2VsaW5lKXRoaXMuZm9udE1ldHJpY3M9XG5jLmZvbnRNZXRyaWNzKGguZm9udFNpemUsciksdGhpcy5iYXNlbGluZT10aGlzLmZvbnRNZXRyaWNzLmYrMytvLHIuYXR0cihcInlcIix0aGlzLmJhc2VsaW5lKTtxLmRyYXdMZWdlbmRTeW1ib2wodGhpcyxhKTt0aGlzLnNldEl0ZW1FdmVudHMmJnRoaXMuc2V0SXRlbUV2ZW50cyhhLHIsdixoLGkpO3cmJnRoaXMuY3JlYXRlQ2hlY2tib3hGb3JJdGVtKGEpfXRoaXMuY29sb3JpemVJdGVtKGEsYS52aXNpYmxlKTt0aGlzLnNldFRleHQoYSk7Yz1yLmdldEJCb3goKTtmPWEuY2hlY2tib3hPZmZzZXQ9ZC5pdGVtV2lkdGh8fGEubGVnZW5kSXRlbVdpZHRofHxmK2crYy53aWR0aCtrKyh3PzIwOjApO3RoaXMuaXRlbUhlaWdodD1nPUMoYS5sZWdlbmRJdGVtSGVpZ2h0fHxjLmhlaWdodCk7aWYoZSYmdGhpcy5pdGVtWC16K2Y+KG18fGIuY2hhcnRXaWR0aC0yKmotei1kLngpKXRoaXMuaXRlbVg9eix0aGlzLml0ZW1ZKz1vK3RoaXMubGFzdExpbmVIZWlnaHQrbix0aGlzLmxhc3RMaW5lSGVpZ2h0PVxuMDt0aGlzLm1heEl0ZW1XaWR0aD10KHRoaXMubWF4SXRlbVdpZHRoLGYpO3RoaXMubGFzdEl0ZW1ZPW8rdGhpcy5pdGVtWStuO3RoaXMubGFzdExpbmVIZWlnaHQ9dChnLHRoaXMubGFzdExpbmVIZWlnaHQpO2EuX2xlZ2VuZEl0ZW1Qb3M9W3RoaXMuaXRlbVgsdGhpcy5pdGVtWV07ZT90aGlzLml0ZW1YKz1mOih0aGlzLml0ZW1ZKz1vK2crbix0aGlzLmxhc3RMaW5lSGVpZ2h0PWcpO3RoaXMub2Zmc2V0V2lkdGg9bXx8dCgoZT90aGlzLml0ZW1YLXotazpmKStqLHRoaXMub2Zmc2V0V2lkdGgpfSxnZXRBbGxJdGVtczpmdW5jdGlvbigpe3ZhciBhPVtdO3EodGhpcy5jaGFydC5zZXJpZXMsZnVuY3Rpb24oYil7dmFyIGM9Yi5vcHRpb25zO2lmKHAoYy5zaG93SW5MZWdlbmQsIXMoYy5saW5rZWRUbyk/QTohMSwhMCkpYT1hLmNvbmNhdChiLmxlZ2VuZEl0ZW1zfHwoYy5sZWdlbmRUeXBlPT09XCJwb2ludFwiP2IuZGF0YTpiKSl9KTtyZXR1cm4gYX0sYWRqdXN0TWFyZ2luczpmdW5jdGlvbihhLFxuYil7dmFyIGM9dGhpcy5jaGFydCxkPXRoaXMub3B0aW9ucyxlPWQuYWxpZ24uY2hhckF0KDApK2QudmVydGljYWxBbGlnbi5jaGFyQXQoMCkrZC5sYXlvdXQuY2hhckF0KDApO2QuZmxvYXRpbmd8fHEoWy8obHRofGN0fHJ0aCkvLC8ocnR2fHJtfHJidikvLC8ocmJofGNifGxiaCkvLC8obGJ2fGxtfGx0dikvXSxmdW5jdGlvbihmLGcpe2YudGVzdChlKSYmIXMoYVtnXSkmJihjW3BiW2ddXT10KGNbcGJbZ11dLGMubGVnZW5kWyhnKzEpJTI/XCJsZWdlbmRIZWlnaHRcIjpcImxlZ2VuZFdpZHRoXCJdK1sxLC0xLC0xLDFdW2ddKmRbZyUyP1wieFwiOlwieVwiXStwKGQubWFyZ2luLDEyKStiW2ddKSl9KX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY2hhcnQsYz1iLnJlbmRlcmVyLGQ9YS5ncm91cCxlLGYsZyxoLGk9YS5ib3gsaj1hLm9wdGlvbnMsaz1hLnBhZGRpbmcsbD1qLmJvcmRlcldpZHRoLG09ai5iYWNrZ3JvdW5kQ29sb3I7YS5pdGVtWD1hLmluaXRpYWxJdGVtWDthLml0ZW1ZPVxuYS5pbml0aWFsSXRlbVk7YS5vZmZzZXRXaWR0aD0wO2EubGFzdEl0ZW1ZPTA7aWYoIWQpYS5ncm91cD1kPWMuZyhcImxlZ2VuZFwiKS5hdHRyKHt6SW5kZXg6N30pLmFkZCgpLGEuY29udGVudEdyb3VwPWMuZygpLmF0dHIoe3pJbmRleDoxfSkuYWRkKGQpLGEuc2Nyb2xsR3JvdXA9Yy5nKCkuYWRkKGEuY29udGVudEdyb3VwKTthLnJlbmRlclRpdGxlKCk7ZT1hLmdldEFsbEl0ZW1zKCk7amIoZSxmdW5jdGlvbihhLGIpe3JldHVybihhLm9wdGlvbnMmJmEub3B0aW9ucy5sZWdlbmRJbmRleHx8MCktKGIub3B0aW9ucyYmYi5vcHRpb25zLmxlZ2VuZEluZGV4fHwwKX0pO2oucmV2ZXJzZWQmJmUucmV2ZXJzZSgpO2EuYWxsSXRlbXM9ZTthLmRpc3BsYXk9Zj0hIWUubGVuZ3RoO2EubGFzdExpbmVIZWlnaHQ9MDtxKGUsZnVuY3Rpb24oYil7YS5yZW5kZXJJdGVtKGIpfSk7Zz0oai53aWR0aHx8YS5vZmZzZXRXaWR0aCkraztoPWEubGFzdEl0ZW1ZK2EubGFzdExpbmVIZWlnaHQrYS50aXRsZUhlaWdodDtcbmg9YS5oYW5kbGVPdmVyZmxvdyhoKTtoKz1rO2lmKGx8fG0pe2lmKGkpe2lmKGc+MCYmaD4wKWlbaS5pc05ldz9cImF0dHJcIjpcImFuaW1hdGVcIl0oaS5jcmlzcCh7d2lkdGg6ZyxoZWlnaHQ6aH0pKSxpLmlzTmV3PSExfWVsc2UgYS5ib3g9aT1jLnJlY3QoMCwwLGcsaCxqLmJvcmRlclJhZGl1cyxsfHwwKS5hdHRyKHtzdHJva2U6ai5ib3JkZXJDb2xvcixcInN0cm9rZS13aWR0aFwiOmx8fDAsZmlsbDptfHxcIm5vbmVcIn0pLmFkZChkKS5zaGFkb3coai5zaGFkb3cpLGkuaXNOZXc9ITA7aVtmP1wic2hvd1wiOlwiaGlkZVwiXSgpfWEubGVnZW5kV2lkdGg9ZzthLmxlZ2VuZEhlaWdodD1oO3EoZSxmdW5jdGlvbihiKXthLnBvc2l0aW9uSXRlbShiKX0pO2YmJmQuYWxpZ24oeCh7d2lkdGg6ZyxoZWlnaHQ6aH0saiksITAsXCJzcGFjaW5nQm94XCIpO2IuaXNSZXNpemluZ3x8dGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoKX0saGFuZGxlT3ZlcmZsb3c6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMuY2hhcnQsXG5kPWMucmVuZGVyZXIsZT10aGlzLm9wdGlvbnMsZj1lLnksZj1jLnNwYWNpbmdCb3guaGVpZ2h0KyhlLnZlcnRpY2FsQWxpZ249PT1cInRvcFwiPy1mOmYpLXRoaXMucGFkZGluZyxnPWUubWF4SGVpZ2h0LGgsaT10aGlzLmNsaXBSZWN0LGo9ZS5uYXZpZ2F0aW9uLGs9cChqLmFuaW1hdGlvbiwhMCksbD1qLmFycm93U2l6ZXx8MTIsbT10aGlzLm5hdixuPXRoaXMucGFnZXMsbz10aGlzLnBhZGRpbmcseixyPXRoaXMuYWxsSXRlbXMscz1mdW5jdGlvbihhKXtpLmF0dHIoe2hlaWdodDphfSk7aWYoYi5jb250ZW50R3JvdXAuZGl2KWIuY29udGVudEdyb3VwLmRpdi5zdHlsZS5jbGlwPVwicmVjdChcIitvK1wicHgsOTk5OXB4LFwiKyhvK2EpK1wicHgsMClcIn07ZS5sYXlvdXQ9PT1cImhvcml6b250YWxcIiYmKGYvPTIpO2cmJihmPUYoZixnKSk7bi5sZW5ndGg9MDtpZihhPmYmJmouZW5hYmxlZCE9PSExKXt0aGlzLmNsaXBIZWlnaHQ9aD10KGYtMjAtdGhpcy50aXRsZUhlaWdodC1vLDApO3RoaXMuY3VycmVudFBhZ2U9XG5wKHRoaXMuY3VycmVudFBhZ2UsMSk7dGhpcy5mdWxsSGVpZ2h0PWE7cShyLGZ1bmN0aW9uKGEsYil7dmFyIGM9YS5fbGVnZW5kSXRlbVBvc1sxXSxkPUMoYS5sZWdlbmRJdGVtLmdldEJCb3goKS5oZWlnaHQpLGU9bi5sZW5ndGg7aWYoIWV8fGMtbltlLTFdPmgmJih6fHxjKSE9PW5bZS0xXSluLnB1c2goenx8YyksZSsrO2I9PT1yLmxlbmd0aC0xJiZjK2QtbltlLTFdPmgmJm4ucHVzaChjKTtjIT09eiYmKHo9Yyl9KTtpZighaSlpPWIuY2xpcFJlY3Q9ZC5jbGlwUmVjdCgwLG8sOTk5OSwwKSxiLmNvbnRlbnRHcm91cC5jbGlwKGkpO3MoaCk7aWYoIW0pdGhpcy5uYXY9bT1kLmcoKS5hdHRyKHt6SW5kZXg6MX0pLmFkZCh0aGlzLmdyb3VwKSx0aGlzLnVwPWQuc3ltYm9sKFwidHJpYW5nbGVcIiwwLDAsbCxsKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtiLnNjcm9sbCgtMSxrKX0pLmFkZChtKSx0aGlzLnBhZ2VyPWQudGV4dChcIlwiLDE1LDEwKS5jc3Moai5zdHlsZSkuYWRkKG0pLHRoaXMuZG93bj1cbmQuc3ltYm9sKFwidHJpYW5nbGUtZG93blwiLDAsMCxsLGwpLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe2Iuc2Nyb2xsKDEsayl9KS5hZGQobSk7Yi5zY3JvbGwoMCk7YT1mfWVsc2UgaWYobSlzKGMuY2hhcnRIZWlnaHQpLG0uaGlkZSgpLHRoaXMuc2Nyb2xsR3JvdXAuYXR0cih7dHJhbnNsYXRlWToxfSksdGhpcy5jbGlwSGVpZ2h0PTA7cmV0dXJuIGF9LHNjcm9sbDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMucGFnZXMsZD1jLmxlbmd0aCxlPXRoaXMuY3VycmVudFBhZ2UrYSxmPXRoaXMuY2xpcEhlaWdodCxnPXRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uLGg9Zy5hY3RpdmVDb2xvcixnPWcuaW5hY3RpdmVDb2xvcixpPXRoaXMucGFnZXIsaj10aGlzLnBhZGRpbmc7ZT5kJiYoZT1kKTtpZihlPjApYiE9PUEmJlZhKGIsdGhpcy5jaGFydCksdGhpcy5uYXYuYXR0cih7dHJhbnNsYXRlWDpqLHRyYW5zbGF0ZVk6Zit0aGlzLnBhZGRpbmcrNyt0aGlzLnRpdGxlSGVpZ2h0LHZpc2liaWxpdHk6XCJ2aXNpYmxlXCJ9KSxcbnRoaXMudXAuYXR0cih7ZmlsbDplPT09MT9nOmh9KS5jc3Moe2N1cnNvcjplPT09MT9cImRlZmF1bHRcIjpcInBvaW50ZXJcIn0pLGkuYXR0cih7dGV4dDplK1wiL1wiK2R9KSx0aGlzLmRvd24uYXR0cih7eDoxOCt0aGlzLnBhZ2VyLmdldEJCb3goKS53aWR0aCxmaWxsOmU9PT1kP2c6aH0pLmNzcyh7Y3Vyc29yOmU9PT1kP1wiZGVmYXVsdFwiOlwicG9pbnRlclwifSksYz0tY1tlLTFdK3RoaXMuaW5pdGlhbEl0ZW1ZLHRoaXMuc2Nyb2xsR3JvdXAuYW5pbWF0ZSh7dHJhbnNsYXRlWTpjfSksdGhpcy5jdXJyZW50UGFnZT1lLHRoaXMucG9zaXRpb25DaGVja2JveGVzKGMpfX07Sz11LkxlZ2VuZFN5bWJvbE1peGluPXtkcmF3UmVjdGFuZ2xlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5vcHRpb25zLnN5bWJvbEhlaWdodHx8YS5mb250TWV0cmljcy5mO2IubGVnZW5kU3ltYm9sPXRoaXMuY2hhcnQucmVuZGVyZXIucmVjdCgwLGEuYmFzZWxpbmUtYysxLGEuc3ltYm9sV2lkdGgsYyxhLm9wdGlvbnMuc3ltYm9sUmFkaXVzfHxcbjApLmF0dHIoe3pJbmRleDozfSkuYWRkKGIubGVnZW5kR3JvdXApfSxkcmF3TGluZU1hcmtlcjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMsYz1iLm1hcmtlcixkPWEuc3ltYm9sV2lkdGgsZT10aGlzLmNoYXJ0LnJlbmRlcmVyLGY9dGhpcy5sZWdlbmRHcm91cCxhPWEuYmFzZWxpbmUtQyhhLmZvbnRNZXRyaWNzLmIqMC4zKSxnO2lmKGIubGluZVdpZHRoKXtnPXtcInN0cm9rZS13aWR0aFwiOmIubGluZVdpZHRofTtpZihiLmRhc2hTdHlsZSlnLmRhc2hzdHlsZT1iLmRhc2hTdHlsZTt0aGlzLmxlZ2VuZExpbmU9ZS5wYXRoKFtYLDAsYSxTLGQsYV0pLmF0dHIoZykuYWRkKGYpfWlmKGMmJmMuZW5hYmxlZCE9PSExKWI9Yy5yYWRpdXMsdGhpcy5sZWdlbmRTeW1ib2w9Yz1lLnN5bWJvbCh0aGlzLnN5bWJvbCxkLzItYixhLWIsMipiLDIqYixjKS5hZGQoZiksYy5pc01hcmtlcj0hMH19OygvVHJpZGVudFxcLzdcXC4wLy50ZXN0KEFhKXx8UWEpJiZoYihyYi5wcm90b3R5cGUsXCJwb3NpdGlvbkl0ZW1cIixcbmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPWZ1bmN0aW9uKCl7Yi5fbGVnZW5kSXRlbVBvcyYmYS5jYWxsKGMsYil9O2QoKTtzZXRUaW1lb3V0KGQpfSk7dmFyIGliPXUuQ2hhcnQ9ZnVuY3Rpb24oKXt0aGlzLmdldEFyZ3MuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt1LmNoYXJ0PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IGliKGEsYixjKX07aWIucHJvdG90eXBlPXtjYWxsYmFja3M6W10sZ2V0QXJnczpmdW5jdGlvbigpe3ZhciBhPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtpZih5YShhWzBdKXx8YVswXS5ub2RlTmFtZSl0aGlzLnJlbmRlclRvPWEuc2hpZnQoKTt0aGlzLmluaXQoYVswXSxhWzFdKX0saW5pdDpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9YS5zZXJpZXM7YS5zZXJpZXM9bnVsbDtjPUUoVSxhKTtjLnNlcmllcz1hLnNlcmllcz1kO3RoaXMudXNlck9wdGlvbnM9YTtkPWMuY2hhcnQ7dGhpcy5tYXJnaW49dGhpcy5zcGxhc2hBcnJheShcIm1hcmdpblwiLGQpO3RoaXMuc3BhY2luZz1cbnRoaXMuc3BsYXNoQXJyYXkoXCJzcGFjaW5nXCIsZCk7dmFyIGU9ZC5ldmVudHM7dGhpcy5ib3VuZHM9e2g6e30sdjp7fX07dGhpcy5jYWxsYmFjaz1iO3RoaXMuaXNSZXNpemluZz0wO3RoaXMub3B0aW9ucz1jO3RoaXMuYXhlcz1bXTt0aGlzLnNlcmllcz1bXTt0aGlzLmhhc0NhcnRlc2lhblNlcmllcz1kLnNob3dBeGVzO3ZhciBmPXRoaXMsZztmLmluZGV4PVQubGVuZ3RoO1QucHVzaChmKTtnYisrO2QucmVmbG93IT09ITEmJk4oZixcImxvYWRcIixmdW5jdGlvbigpe2YuaW5pdFJlZmxvdygpfSk7aWYoZSlmb3IoZyBpbiBlKU4oZixnLGVbZ10pO2YueEF4aXM9W107Zi55QXhpcz1bXTtmLmFuaW1hdGlvbj1sYT8hMTpwKGQuYW5pbWF0aW9uLCEwKTtmLnBvaW50Q291bnQ9Zi5jb2xvckNvdW50ZXI9Zi5zeW1ib2xDb3VudGVyPTA7Zi5maXJzdFJlbmRlcigpfSxpbml0U2VyaWVzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucy5jaGFydDsoYj1MW2EudHlwZXx8Yi50eXBlfHxiLmRlZmF1bHRTZXJpZXNUeXBlXSl8fFxuY2EoMTcsITApO2I9bmV3IGI7Yi5pbml0KHRoaXMsYSk7cmV0dXJuIGJ9LGlzSW5zaWRlUGxvdDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9Yz9iOmEsYT1jP2E6YjtyZXR1cm4gZD49MCYmZDw9dGhpcy5wbG90V2lkdGgmJmE+PTAmJmE8PXRoaXMucGxvdEhlaWdodH0scmVkcmF3OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYXhlcyxjPXRoaXMuc2VyaWVzLGQ9dGhpcy5wb2ludGVyLGU9dGhpcy5sZWdlbmQsZj10aGlzLmlzRGlydHlMZWdlbmQsZyxoLGk9dGhpcy5oYXNDYXJ0ZXNpYW5TZXJpZXMsaj10aGlzLmlzRGlydHlCb3gsaz1jLmxlbmd0aCxsPWssbT10aGlzLnJlbmRlcmVyLG49bS5pc0hpZGRlbigpLG89W107VmEoYSx0aGlzKTtuJiZ0aGlzLmNsb25lUmVuZGVyVG8oKTtmb3IodGhpcy5sYXlPdXRUaXRsZXMoKTtsLS07KWlmKGE9Y1tsXSxhLm9wdGlvbnMuc3RhY2tpbmcmJihnPSEwLGEuaXNEaXJ0eSkpe2g9ITA7YnJlYWt9aWYoaClmb3IobD1rO2wtLTspaWYoYT1jW2xdLGEub3B0aW9ucy5zdGFja2luZylhLmlzRGlydHk9XG4hMDtxKGMsZnVuY3Rpb24oYSl7YS5pc0RpcnR5JiZhLm9wdGlvbnMubGVnZW5kVHlwZT09PVwicG9pbnRcIiYmKGEudXBkYXRlVG90YWxzJiZhLnVwZGF0ZVRvdGFscygpLGY9ITApO2EuaXNEaXJ0eURhdGEmJkkoYSxcInVwZGF0ZWREYXRhXCIpfSk7aWYoZiYmZS5vcHRpb25zLmVuYWJsZWQpZS5yZW5kZXIoKSx0aGlzLmlzRGlydHlMZWdlbmQ9ITE7ZyYmdGhpcy5nZXRTdGFja3MoKTtpZihpJiYhdGhpcy5pc1Jlc2l6aW5nKXRoaXMubWF4VGlja3M9bnVsbCxxKGIsZnVuY3Rpb24oYSl7YS5zZXRTY2FsZSgpfSk7dGhpcy5nZXRNYXJnaW5zKCk7aSYmKHEoYixmdW5jdGlvbihhKXthLmlzRGlydHkmJihqPSEwKX0pLHEoYixmdW5jdGlvbihhKXt2YXIgYj1hLm1pbitcIixcIithLm1heDtpZihhLmV4dEtleSE9PWIpYS5leHRLZXk9YixvLnB1c2goZnVuY3Rpb24oKXtJKGEsXCJhZnRlclNldEV4dHJlbWVzXCIseChhLmV2ZW50QXJncyxhLmdldEV4dHJlbWVzKCkpKTtkZWxldGUgYS5ldmVudEFyZ3N9KTtcbihqfHxnKSYmYS5yZWRyYXcoKX0pKTtqJiZ0aGlzLmRyYXdDaGFydEJveCgpO3EoYyxmdW5jdGlvbihhKXthLmlzRGlydHkmJmEudmlzaWJsZSYmKCFhLmlzQ2FydGVzaWFufHxhLnhBeGlzKSYmYS5yZWRyYXcoKX0pO2QmJmQucmVzZXQoITApO20uZHJhdygpO0kodGhpcyxcInJlZHJhd1wiKTtuJiZ0aGlzLmNsb25lUmVuZGVyVG8oITApO3EobyxmdW5jdGlvbihhKXthLmNhbGwoKX0pfSxnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5heGVzLGM9dGhpcy5zZXJpZXMsZCxlO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspaWYoYltkXS5vcHRpb25zLmlkPT09YSlyZXR1cm4gYltkXTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWlmKGNbZF0ub3B0aW9ucy5pZD09PWEpcmV0dXJuIGNbZF07Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyl7ZT1jW2RdLnBvaW50c3x8W107Zm9yKGI9MDtiPGUubGVuZ3RoO2IrKylpZihlW2JdLmlkPT09YSlyZXR1cm4gZVtiXX1yZXR1cm4gbnVsbH0sZ2V0QXhlczpmdW5jdGlvbigpe3ZhciBhPVxudGhpcyxiPXRoaXMub3B0aW9ucyxjPWIueEF4aXM9dWEoYi54QXhpc3x8e30pLGI9Yi55QXhpcz11YShiLnlBeGlzfHx7fSk7cShjLGZ1bmN0aW9uKGEsYil7YS5pbmRleD1iO2EuaXNYPSEwfSk7cShiLGZ1bmN0aW9uKGEsYil7YS5pbmRleD1ifSk7Yz1jLmNvbmNhdChiKTtxKGMsZnVuY3Rpb24oYil7bmV3IGlhKGEsYil9KX0sZ2V0U2VsZWN0ZWRQb2ludHM6ZnVuY3Rpb24oKXt2YXIgYT1bXTtxKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGIpe2E9YS5jb25jYXQoQ2EoYi5wb2ludHN8fFtdLGZ1bmN0aW9uKGEpe3JldHVybiBhLnNlbGVjdGVkfSkpfSk7cmV0dXJuIGF9LGdldFNlbGVjdGVkU2VyaWVzOmZ1bmN0aW9uKCl7cmV0dXJuIENhKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGEpe3JldHVybiBhLnNlbGVjdGVkfSl9LHNldFRpdGxlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZzt2YXIgZD10aGlzLGU9ZC5vcHRpb25zLGY7Zj1lLnRpdGxlPUUoZS50aXRsZSxhKTtnPWUuc3VidGl0bGU9RShlLnN1YnRpdGxlLFxuYiksZT1nO3EoW1tcInRpdGxlXCIsYSxmXSxbXCJzdWJ0aXRsZVwiLGIsZV1dLGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF0sYz1kW2JdLGU9YVsxXSxhPWFbMl07YyYmZSYmKGRbYl09Yz1jLmRlc3Ryb3koKSk7YSYmYS50ZXh0JiYhYyYmKGRbYl09ZC5yZW5kZXJlci50ZXh0KGEudGV4dCwwLDAsYS51c2VIVE1MKS5hdHRyKHthbGlnbjphLmFsaWduLFwiY2xhc3NcIjpcImhpZ2hjaGFydHMtXCIrYix6SW5kZXg6YS56SW5kZXh8fDR9KS5jc3MoYS5zdHlsZSkuYWRkKCkpfSk7ZC5sYXlPdXRUaXRsZXMoYyl9LGxheU91dFRpdGxlczpmdW5jdGlvbihhKXt2YXIgYj0wLGM9dGhpcy50aXRsZSxkPXRoaXMuc3VidGl0bGUsZT10aGlzLm9wdGlvbnMsZj1lLnRpdGxlLGU9ZS5zdWJ0aXRsZSxnPXRoaXMucmVuZGVyZXIsaD10aGlzLnNwYWNpbmdCb3g7aWYoYyYmKGMuY3NzKHt3aWR0aDooZi53aWR0aHx8aC53aWR0aCtmLndpZHRoQWRqdXN0KStcInB4XCJ9KS5hbGlnbih4KHt5OmcuZm9udE1ldHJpY3MoZi5zdHlsZS5mb250U2l6ZSxcbmMpLmItM30sZiksITEsaCksIWYuZmxvYXRpbmcmJiFmLnZlcnRpY2FsQWxpZ24pKWI9Yy5nZXRCQm94KCkuaGVpZ2h0O2QmJihkLmNzcyh7d2lkdGg6KGUud2lkdGh8fGgud2lkdGgrZS53aWR0aEFkanVzdCkrXCJweFwifSkuYWxpZ24oeCh7eTpiKyhmLm1hcmdpbi0xMykrZy5mb250TWV0cmljcyhlLnN0eWxlLmZvbnRTaXplLGMpLmJ9LGUpLCExLGgpLCFlLmZsb2F0aW5nJiYhZS52ZXJ0aWNhbEFsaWduJiYoYj12YShiK2QuZ2V0QkJveCgpLmhlaWdodCkpKTtjPXRoaXMudGl0bGVPZmZzZXQhPT1iO3RoaXMudGl0bGVPZmZzZXQ9YjtpZighdGhpcy5pc0RpcnR5Qm94JiZjKXRoaXMuaXNEaXJ0eUJveD1jLHRoaXMuaGFzUmVuZGVyZWQmJnAoYSwhMCkmJnRoaXMuaXNEaXJ0eUJveCYmdGhpcy5yZWRyYXcoKX0sZ2V0Q2hhcnRTaXplOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLmNoYXJ0LGI9YS53aWR0aCxhPWEuaGVpZ2h0LGM9dGhpcy5yZW5kZXJUb0Nsb25lfHx0aGlzLnJlbmRlclRvO1xuaWYoIXMoYikpdGhpcy5jb250YWluZXJXaWR0aD1vYShjLFwid2lkdGhcIik7aWYoIXMoYSkpdGhpcy5jb250YWluZXJIZWlnaHQ9b2EoYyxcImhlaWdodFwiKTt0aGlzLmNoYXJ0V2lkdGg9dCgwLGJ8fHRoaXMuY29udGFpbmVyV2lkdGh8fDYwMCk7dGhpcy5jaGFydEhlaWdodD10KDAscChhLHRoaXMuY29udGFpbmVySGVpZ2h0PjE5P3RoaXMuY29udGFpbmVySGVpZ2h0OjQwMCkpfSxjbG9uZVJlbmRlclRvOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMucmVuZGVyVG9DbG9uZSxjPXRoaXMuY29udGFpbmVyO2E/YiYmKHRoaXMucmVuZGVyVG8uYXBwZW5kQ2hpbGQoYyksVWEoYiksZGVsZXRlIHRoaXMucmVuZGVyVG9DbG9uZSk6KGMmJmMucGFyZW50Tm9kZT09PXRoaXMucmVuZGVyVG8mJnRoaXMucmVuZGVyVG8ucmVtb3ZlQ2hpbGQoYyksdGhpcy5yZW5kZXJUb0Nsb25lPWI9dGhpcy5yZW5kZXJUby5jbG9uZU5vZGUoMCksTShiLHtwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOlwiLTk5OTlweFwiLGRpc3BsYXk6XCJibG9ja1wifSksXG5iLnN0eWxlLnNldFByb3BlcnR5JiZiLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwiYmxvY2tcIixcImltcG9ydGFudFwiKSx5LmJvZHkuYXBwZW5kQ2hpbGQoYiksYyYmYi5hcHBlbmRDaGlsZChjKSl9LGdldENvbnRhaW5lcjpmdW5jdGlvbigpe3ZhciBhLGI9dGhpcy5vcHRpb25zLGM9Yi5jaGFydCxkLGU7YT10aGlzLnJlbmRlclRvO3ZhciBmPVwiaGlnaGNoYXJ0cy1cIitCYisrO2lmKCFhKXRoaXMucmVuZGVyVG89YT1jLnJlbmRlclRvO2lmKHlhKGEpKXRoaXMucmVuZGVyVG89YT15LmdldEVsZW1lbnRCeUlkKGEpO2F8fGNhKDEzLCEwKTtkPUIoUChhLFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpKTtKKGQpJiZUW2RdJiZUW2RdLmhhc1JlbmRlcmVkJiZUW2RdLmRlc3Ryb3koKTtQKGEsXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIix0aGlzLmluZGV4KTthLmlubmVySFRNTD1cIlwiOyFjLnNraXBDbG9uZSYmIWEub2Zmc2V0V2lkdGgmJnRoaXMuY2xvbmVSZW5kZXJUbygpO3RoaXMuZ2V0Q2hhcnRTaXplKCk7XG5kPXRoaXMuY2hhcnRXaWR0aDtlPXRoaXMuY2hhcnRIZWlnaHQ7dGhpcy5jb250YWluZXI9YT1kYShQYSx7Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1jb250YWluZXJcIisoYy5jbGFzc05hbWU/XCIgXCIrYy5jbGFzc05hbWU6XCJcIiksaWQ6Zn0seCh7cG9zaXRpb246XCJyZWxhdGl2ZVwiLG92ZXJmbG93OlwiaGlkZGVuXCIsd2lkdGg6ZCtcInB4XCIsaGVpZ2h0OmUrXCJweFwiLHRleHRBbGlnbjpcImxlZnRcIixsaW5lSGVpZ2h0Olwibm9ybWFsXCIsekluZGV4OjAsXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIjpcInJnYmEoMCwwLDAsMClcIn0sYy5zdHlsZSksdGhpcy5yZW5kZXJUb0Nsb25lfHxhKTt0aGlzLl9jdXJzb3I9YS5zdHlsZS5jdXJzb3I7dGhpcy5yZW5kZXJlcj1uZXcgKHVbYy5yZW5kZXJlcl18fGViKShhLGQsZSxjLnN0eWxlLGMuZm9yRXhwb3J0LGIuZXhwb3J0aW5nJiZiLmV4cG9ydGluZy5hbGxvd0hUTUwpO2xhJiZ0aGlzLnJlbmRlcmVyLmNyZWF0ZSh0aGlzLGEsZCxlKTt0aGlzLnJlbmRlcmVyLmNoYXJ0SW5kZXg9XG50aGlzLmluZGV4fSxnZXRNYXJnaW5zOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3BhY2luZyxjPXRoaXMubWFyZ2luLGQ9dGhpcy50aXRsZU9mZnNldDt0aGlzLnJlc2V0TWFyZ2lucygpO2lmKGQmJiFzKGNbMF0pKXRoaXMucGxvdFRvcD10KHRoaXMucGxvdFRvcCxkK3RoaXMub3B0aW9ucy50aXRsZS5tYXJnaW4rYlswXSk7dGhpcy5sZWdlbmQuZGlzcGxheSYmdGhpcy5sZWdlbmQuYWRqdXN0TWFyZ2lucyhjLGIpO3RoaXMuZXh0cmFCb3R0b21NYXJnaW4mJih0aGlzLm1hcmdpbkJvdHRvbSs9dGhpcy5leHRyYUJvdHRvbU1hcmdpbik7dGhpcy5leHRyYVRvcE1hcmdpbiYmKHRoaXMucGxvdFRvcCs9dGhpcy5leHRyYVRvcE1hcmdpbik7YXx8dGhpcy5nZXRBeGlzTWFyZ2lucygpfSxnZXRBeGlzTWFyZ2luczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmF4aXNPZmZzZXQ9WzAsMCwwLDBdLGM9YS5tYXJnaW47YS5oYXNDYXJ0ZXNpYW5TZXJpZXMmJnEoYS5heGVzLGZ1bmN0aW9uKGEpe2EudmlzaWJsZSYmXG5hLmdldE9mZnNldCgpfSk7cShwYixmdW5jdGlvbihkLGUpe3MoY1tlXSl8fChhW2RdKz1iW2VdKX0pO2Euc2V0Q2hhcnRTaXplKCl9LHJlZmxvdzpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9Yi5vcHRpb25zLmNoYXJ0LGQ9Yi5yZW5kZXJUbyxlPXMoYy53aWR0aCksZj1jLndpZHRofHxvYShkLFwid2lkdGhcIiksYz1jLmhlaWdodHx8b2EoZCxcImhlaWdodFwiKSxkPWE/YS50YXJnZXQ6RDtpZighZSYmIWIuaXNQcmludGluZyYmZiYmYyYmKGQ9PT1EfHxkPT09eSkpe2lmKGYhPT1iLmNvbnRhaW5lcldpZHRofHxjIT09Yi5jb250YWluZXJIZWlnaHQpY2xlYXJUaW1lb3V0KGIucmVmbG93VGltZW91dCksYi5yZWZsb3dUaW1lb3V0PVJhKGZ1bmN0aW9uKCl7Yi5jb250YWluZXImJmIuc2V0U2l6ZSh2b2lkIDAsdm9pZCAwLCExKX0sYT8xMDA6MCk7Yi5jb250YWluZXJXaWR0aD1mO2IuY29udGFpbmVySGVpZ2h0PWN9fSxpbml0UmVmbG93OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWZ1bmN0aW9uKGIpe2EucmVmbG93KGIpfTtcbk4oRCxcInJlc2l6ZVwiLGIpO04oYSxcImRlc3Ryb3lcIixmdW5jdGlvbigpe1koRCxcInJlc2l6ZVwiLGIpfSl9LHNldFNpemU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMsZT1kLnJlbmRlcmVyO2QuaXNSZXNpemluZys9MTtWYShjLGQpO2Qub2xkQ2hhcnRIZWlnaHQ9ZC5jaGFydEhlaWdodDtkLm9sZENoYXJ0V2lkdGg9ZC5jaGFydFdpZHRoO2lmKGEhPT12b2lkIDApZC5vcHRpb25zLmNoYXJ0LndpZHRoPWE7aWYoYiE9PXZvaWQgMClkLm9wdGlvbnMuY2hhcnQuaGVpZ2h0PWI7ZC5nZXRDaGFydFNpemUoKTthPWUuZ2xvYmFsQW5pbWF0aW9uOyhhP1lhOk0pKGQuY29udGFpbmVyLHt3aWR0aDpkLmNoYXJ0V2lkdGgrXCJweFwiLGhlaWdodDpkLmNoYXJ0SGVpZ2h0K1wicHhcIn0sYSk7ZC5zZXRDaGFydFNpemUoITApO2Uuc2V0U2l6ZShkLmNoYXJ0V2lkdGgsZC5jaGFydEhlaWdodCxjKTtkLm1heFRpY2tzPW51bGw7cShkLmF4ZXMsZnVuY3Rpb24oYSl7YS5pc0RpcnR5PSEwO2Euc2V0U2NhbGUoKX0pO1xucShkLnNlcmllcyxmdW5jdGlvbihhKXthLmlzRGlydHk9ITB9KTtkLmlzRGlydHlMZWdlbmQ9ITA7ZC5pc0RpcnR5Qm94PSEwO2QubGF5T3V0VGl0bGVzKCk7ZC5nZXRNYXJnaW5zKCk7ZC5yZWRyYXcoYyk7ZC5vbGRDaGFydEhlaWdodD1udWxsO0koZCxcInJlc2l6ZVwiKTtSYShmdW5jdGlvbigpe2QmJkkoZCxcImVuZFJlc2l6ZVwiLG51bGwsZnVuY3Rpb24oKXtkLmlzUmVzaXppbmctPTF9KX0sYmIoYSkuZHVyYXRpb24pfSxzZXRDaGFydFNpemU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5pbnZlcnRlZCxjPXRoaXMucmVuZGVyZXIsZD10aGlzLmNoYXJ0V2lkdGgsZT10aGlzLmNoYXJ0SGVpZ2h0LGY9dGhpcy5vcHRpb25zLmNoYXJ0LGc9dGhpcy5zcGFjaW5nLGg9dGhpcy5jbGlwT2Zmc2V0LGksaixrLGw7dGhpcy5wbG90TGVmdD1pPUModGhpcy5wbG90TGVmdCk7dGhpcy5wbG90VG9wPWo9Qyh0aGlzLnBsb3RUb3ApO3RoaXMucGxvdFdpZHRoPWs9dCgwLEMoZC1pLXRoaXMubWFyZ2luUmlnaHQpKTtcbnRoaXMucGxvdEhlaWdodD1sPXQoMCxDKGUtai10aGlzLm1hcmdpbkJvdHRvbSkpO3RoaXMucGxvdFNpemVYPWI/bDprO3RoaXMucGxvdFNpemVZPWI/azpsO3RoaXMucGxvdEJvcmRlcldpZHRoPWYucGxvdEJvcmRlcldpZHRofHwwO3RoaXMuc3BhY2luZ0JveD1jLnNwYWNpbmdCb3g9e3g6Z1szXSx5OmdbMF0sd2lkdGg6ZC1nWzNdLWdbMV0saGVpZ2h0OmUtZ1swXS1nWzJdfTt0aGlzLnBsb3RCb3g9Yy5wbG90Qm94PXt4OmkseTpqLHdpZHRoOmssaGVpZ2h0Omx9O2Q9MipWKHRoaXMucGxvdEJvcmRlcldpZHRoLzIpO2I9dmEodChkLGhbM10pLzIpO2M9dmEodChkLGhbMF0pLzIpO3RoaXMuY2xpcEJveD17eDpiLHk6Yyx3aWR0aDpWKHRoaXMucGxvdFNpemVYLXQoZCxoWzFdKS8yLWIpLGhlaWdodDp0KDAsVih0aGlzLnBsb3RTaXplWS10KGQsaFsyXSkvMi1jKSl9O2F8fHEodGhpcy5heGVzLGZ1bmN0aW9uKGEpe2Euc2V0QXhpc1NpemUoKTthLnNldEF4aXNUcmFuc2xhdGlvbigpfSl9LFxucmVzZXRNYXJnaW5zOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcztxKHBiLGZ1bmN0aW9uKGIsYyl7YVtiXT1wKGEubWFyZ2luW2NdLGEuc3BhY2luZ1tjXSl9KTthLmF4aXNPZmZzZXQ9WzAsMCwwLDBdO2EuY2xpcE9mZnNldD1bMCwwLDAsMF19LGRyYXdDaGFydEJveDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5jaGFydCxiPXRoaXMucmVuZGVyZXIsYz10aGlzLmNoYXJ0V2lkdGgsZD10aGlzLmNoYXJ0SGVpZ2h0LGU9dGhpcy5jaGFydEJhY2tncm91bmQsZj10aGlzLnBsb3RCYWNrZ3JvdW5kLGc9dGhpcy5wbG90Qm9yZGVyLGg9dGhpcy5wbG90QkdJbWFnZSxpPWEuYm9yZGVyV2lkdGh8fDAsaj1hLmJhY2tncm91bmRDb2xvcixrPWEucGxvdEJhY2tncm91bmRDb2xvcixsPWEucGxvdEJhY2tncm91bmRJbWFnZSxtPWEucGxvdEJvcmRlcldpZHRofHwwLG4sbz10aGlzLnBsb3RMZWZ0LHA9dGhpcy5wbG90VG9wLHI9dGhpcy5wbG90V2lkdGgscT10aGlzLnBsb3RIZWlnaHQsdz10aGlzLnBsb3RCb3gsXG52PXRoaXMuY2xpcFJlY3Qscz10aGlzLmNsaXBCb3g7bj1pKyhhLnNoYWRvdz84OjApO2lmKGl8fGopaWYoZSllLmFuaW1hdGUoZS5jcmlzcCh7d2lkdGg6Yy1uLGhlaWdodDpkLW59KSk7ZWxzZXtlPXtmaWxsOmp8fFwibm9uZVwifTtpZihpKWUuc3Ryb2tlPWEuYm9yZGVyQ29sb3IsZVtcInN0cm9rZS13aWR0aFwiXT1pO3RoaXMuY2hhcnRCYWNrZ3JvdW5kPWIucmVjdChuLzIsbi8yLGMtbixkLW4sYS5ib3JkZXJSYWRpdXMsaSkuYXR0cihlKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYmFja2dyb3VuZFwiKS5hZGQoKS5zaGFkb3coYS5zaGFkb3cpfWlmKGspZj9mLmFuaW1hdGUodyk6dGhpcy5wbG90QmFja2dyb3VuZD1iLnJlY3QobyxwLHIscSwwKS5hdHRyKHtmaWxsOmt9KS5hZGQoKS5zaGFkb3coYS5wbG90U2hhZG93KTtpZihsKWg/aC5hbmltYXRlKHcpOnRoaXMucGxvdEJHSW1hZ2U9Yi5pbWFnZShsLG8scCxyLHEpLmFkZCgpO3Y/di5hbmltYXRlKHt3aWR0aDpzLndpZHRoLGhlaWdodDpzLmhlaWdodH0pOlxudGhpcy5jbGlwUmVjdD1iLmNsaXBSZWN0KHMpO2lmKG0pZz8oZy5zdHJva2VXaWR0aD0tbSxnLmFuaW1hdGUoZy5jcmlzcCh7eDpvLHk6cCx3aWR0aDpyLGhlaWdodDpxfSkpKTp0aGlzLnBsb3RCb3JkZXI9Yi5yZWN0KG8scCxyLHEsMCwtbSkuYXR0cih7c3Ryb2tlOmEucGxvdEJvcmRlckNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6bSxmaWxsOlwibm9uZVwiLHpJbmRleDoxfSkuYWRkKCk7dGhpcy5pc0RpcnR5Qm94PSExfSxwcm9wRnJvbVNlcmllczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMuY2hhcnQsYyxkPWEub3B0aW9ucy5zZXJpZXMsZSxmO3EoW1wiaW52ZXJ0ZWRcIixcImFuZ3VsYXJcIixcInBvbGFyXCJdLGZ1bmN0aW9uKGcpe2M9TFtiLnR5cGV8fGIuZGVmYXVsdFNlcmllc1R5cGVdO2Y9YVtnXXx8YltnXXx8YyYmYy5wcm90b3R5cGVbZ107Zm9yKGU9ZCYmZC5sZW5ndGg7IWYmJmUtLTspKGM9TFtkW2VdLnR5cGVdKSYmYy5wcm90b3R5cGVbZ10mJihmPSEwKTthW2ddPWZ9KX0sXG5saW5rU2VyaWVzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuc2VyaWVzO3EoYixmdW5jdGlvbihhKXthLmxpbmtlZFNlcmllcy5sZW5ndGg9MH0pO3EoYixmdW5jdGlvbihiKXt2YXIgZD1iLm9wdGlvbnMubGlua2VkVG87aWYoeWEoZCkmJihkPWQ9PT1cIjpwcmV2aW91c1wiP2Euc2VyaWVzW2IuaW5kZXgtMV06YS5nZXQoZCkpKWQubGlua2VkU2VyaWVzLnB1c2goYiksYi5saW5rZWRQYXJlbnQ9ZCxiLnZpc2libGU9cChiLm9wdGlvbnMudmlzaWJsZSxkLm9wdGlvbnMudmlzaWJsZSxiLnZpc2libGUpfSl9LHJlbmRlclNlcmllczpmdW5jdGlvbigpe3EodGhpcy5zZXJpZXMsZnVuY3Rpb24oYSl7YS50cmFuc2xhdGUoKTthLnJlbmRlcigpfSl9LHJlbmRlckxhYmVsczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMubGFiZWxzO2IuaXRlbXMmJnEoYi5pdGVtcyxmdW5jdGlvbihjKXt2YXIgZD14KGIuc3R5bGUsYy5zdHlsZSksZT1CKGQubGVmdCkrYS5wbG90TGVmdCxmPVxuQihkLnRvcCkrYS5wbG90VG9wKzEyO2RlbGV0ZSBkLmxlZnQ7ZGVsZXRlIGQudG9wO2EucmVuZGVyZXIudGV4dChjLmh0bWwsZSxmKS5hdHRyKHt6SW5kZXg6Mn0pLmNzcyhkKS5hZGQoKX0pfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmF4ZXMsYj10aGlzLnJlbmRlcmVyLGM9dGhpcy5vcHRpb25zLGQsZSxmLGc7dGhpcy5zZXRUaXRsZSgpO3RoaXMubGVnZW5kPW5ldyByYih0aGlzLGMubGVnZW5kKTt0aGlzLmdldFN0YWNrcyYmdGhpcy5nZXRTdGFja3MoKTt0aGlzLmdldE1hcmdpbnMoITApO3RoaXMuc2V0Q2hhcnRTaXplKCk7ZD10aGlzLnBsb3RXaWR0aDtlPXRoaXMucGxvdEhlaWdodC09MjE7cShhLGZ1bmN0aW9uKGEpe2Euc2V0U2NhbGUoKX0pO3RoaXMuZ2V0QXhpc01hcmdpbnMoKTtmPWQvdGhpcy5wbG90V2lkdGg+MS4xO2c9ZS90aGlzLnBsb3RIZWlnaHQ+MS4wNTtpZihmfHxnKXRoaXMubWF4VGlja3M9bnVsbCxxKGEsZnVuY3Rpb24oYSl7KGEuaG9yaXomJmZ8fFxuIWEuaG9yaXomJmcpJiZhLnNldFRpY2tJbnRlcnZhbCghMCl9KSx0aGlzLmdldE1hcmdpbnMoKTt0aGlzLmRyYXdDaGFydEJveCgpO3RoaXMuaGFzQ2FydGVzaWFuU2VyaWVzJiZxKGEsZnVuY3Rpb24oYSl7YS52aXNpYmxlJiZhLnJlbmRlcigpfSk7aWYoIXRoaXMuc2VyaWVzR3JvdXApdGhpcy5zZXJpZXNHcm91cD1iLmcoXCJzZXJpZXMtZ3JvdXBcIikuYXR0cih7ekluZGV4OjN9KS5hZGQoKTt0aGlzLnJlbmRlclNlcmllcygpO3RoaXMucmVuZGVyTGFiZWxzKCk7dGhpcy5zaG93Q3JlZGl0cyhjLmNyZWRpdHMpO3RoaXMuaGFzUmVuZGVyZWQ9ITB9LHNob3dDcmVkaXRzOmZ1bmN0aW9uKGEpe2lmKGEuZW5hYmxlZCYmIXRoaXMuY3JlZGl0cyl0aGlzLmNyZWRpdHM9dGhpcy5yZW5kZXJlci50ZXh0KGEudGV4dCwwLDApLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe2lmKGEuaHJlZilELmxvY2F0aW9uLmhyZWY9YS5ocmVmfSkuYXR0cih7YWxpZ246YS5wb3NpdGlvbi5hbGlnbix6SW5kZXg6OH0pLmNzcyhhLnN0eWxlKS5hZGQoKS5hbGlnbihhLnBvc2l0aW9uKX0sXG5kZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuYXhlcyxjPWEuc2VyaWVzLGQ9YS5jb250YWluZXIsZSxmPWQmJmQucGFyZW50Tm9kZTtJKGEsXCJkZXN0cm95XCIpO1RbYS5pbmRleF09QTtnYi0tO2EucmVuZGVyVG8ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpO1koYSk7Zm9yKGU9Yi5sZW5ndGg7ZS0tOyliW2VdPWJbZV0uZGVzdHJveSgpO2ZvcihlPWMubGVuZ3RoO2UtLTspY1tlXT1jW2VdLmRlc3Ryb3koKTtxKFwidGl0bGUsc3VidGl0bGUsY2hhcnRCYWNrZ3JvdW5kLHBsb3RCYWNrZ3JvdW5kLHBsb3RCR0ltYWdlLHBsb3RCb3JkZXIsc2VyaWVzR3JvdXAsY2xpcFJlY3QsY3JlZGl0cyxwb2ludGVyLHNjcm9sbGVyLHJhbmdlU2VsZWN0b3IsbGVnZW5kLHJlc2V0Wm9vbUJ1dHRvbix0b29sdGlwLHJlbmRlcmVyXCIuc3BsaXQoXCIsXCIpLGZ1bmN0aW9uKGIpe3ZhciBjPWFbYl07YyYmYy5kZXN0cm95JiYoYVtiXT1jLmRlc3Ryb3koKSl9KTtpZihkKWQuaW5uZXJIVE1MPVxuXCJcIixZKGQpLGYmJlVhKGQpO2ZvcihlIGluIGEpZGVsZXRlIGFbZV19LGlzUmVhZHlUb1JlbmRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIWdhJiZEPT1ELnRvcCYmeS5yZWFkeVN0YXRlIT09XCJjb21wbGV0ZVwifHxsYSYmIUQuY2Fudmc/KGxhP1BiLnB1c2goZnVuY3Rpb24oKXthLmZpcnN0UmVuZGVyKCl9LGEub3B0aW9ucy5nbG9iYWwuY2FudmFzVG9vbHNVUkwpOnkuYXR0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbigpe3kuZGV0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixhLmZpcnN0UmVuZGVyKTt5LnJlYWR5U3RhdGU9PT1cImNvbXBsZXRlXCImJmEuZmlyc3RSZW5kZXIoKX0pLCExKTohMH0sZmlyc3RSZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5vcHRpb25zO2lmKGEuaXNSZWFkeVRvUmVuZGVyKCkpe2EuZ2V0Q29udGFpbmVyKCk7SShhLFwiaW5pdFwiKTthLnJlc2V0TWFyZ2lucygpO2Euc2V0Q2hhcnRTaXplKCk7YS5wcm9wRnJvbVNlcmllcygpO1xuYS5nZXRBeGVzKCk7cShiLnNlcmllc3x8W10sZnVuY3Rpb24oYil7YS5pbml0U2VyaWVzKGIpfSk7YS5saW5rU2VyaWVzKCk7SShhLFwiYmVmb3JlUmVuZGVyXCIpO2lmKHUuUG9pbnRlcilhLnBvaW50ZXI9bmV3IFphKGEsYik7YS5yZW5kZXIoKTthLnJlbmRlcmVyLmRyYXcoKTtpZighYS5yZW5kZXJlci5pbWdDb3VudCYmYS5vbmxvYWQpYS5vbmxvYWQoKTthLmNsb25lUmVuZGVyVG8oITApfX0sb25sb2FkOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcztxKFt0aGlzLmNhbGxiYWNrXS5jb25jYXQodGhpcy5jYWxsYmFja3MpLGZ1bmN0aW9uKGIpe2ImJmEuaW5kZXghPT12b2lkIDAmJmIuYXBwbHkoYSxbYV0pfSk7SShhLFwibG9hZFwiKTt0aGlzLm9ubG9hZD1udWxsfSxzcGxhc2hBcnJheTpmdW5jdGlvbihhLGIpe3ZhciBjPWJbYV0sYz0kKGMpP2M6W2MsYyxjLGNdO3JldHVybltwKGJbYStcIlRvcFwiXSxjWzBdKSxwKGJbYStcIlJpZ2h0XCJdLGNbMV0pLHAoYlthK1wiQm90dG9tXCJdLGNbMl0pLHAoYlthK1xuXCJMZWZ0XCJdLGNbM10pXX19O3ZhciBEYj11LkNlbnRlcmVkU2VyaWVzTWl4aW49e2dldENlbnRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiPXRoaXMuY2hhcnQsYz0yKihhLnNsaWNlZE9mZnNldHx8MCksZD1iLnBsb3RXaWR0aC0yKmMsYj1iLnBsb3RIZWlnaHQtMipjLGU9YS5jZW50ZXIsZT1bcChlWzBdLFwiNTAlXCIpLHAoZVsxXSxcIjUwJVwiKSxhLnNpemV8fFwiMTAwJVwiLGEuaW5uZXJTaXplfHwwXSxmPUYoZCxiKSxnLGg7Zm9yKGc9MDtnPDQ7KytnKWg9ZVtnXSxhPWc8Mnx8Zz09PTImJi8lJC8udGVzdChoKSxlW2ddPSgvJSQvLnRlc3QoaCk/W2QsYixmLGVbMl1dW2ddKnBhcnNlRmxvYXQoaCkvMTAwOnBhcnNlRmxvYXQoaCkpKyhhP2M6MCk7ZVszXT5lWzJdJiYoZVszXT1lWzJdKTtyZXR1cm4gZX19LE1hPWZ1bmN0aW9uKCl7fTtNYS5wcm90b3R5cGU9e2luaXQ6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuc2VyaWVzPWE7dGhpcy5jb2xvcj1hLmNvbG9yO3RoaXMuYXBwbHlPcHRpb25zKGIsXG5jKTt0aGlzLnBvaW50QXR0cj17fTtpZihhLm9wdGlvbnMuY29sb3JCeVBvaW50JiYoYj1hLm9wdGlvbnMuY29sb3JzfHxhLmNoYXJ0Lm9wdGlvbnMuY29sb3JzLHRoaXMuY29sb3I9dGhpcy5jb2xvcnx8YlthLmNvbG9yQ291bnRlcisrXSxhLmNvbG9yQ291bnRlcj09PWIubGVuZ3RoKSlhLmNvbG9yQ291bnRlcj0wO2EuY2hhcnQucG9pbnRDb3VudCsrO3JldHVybiB0aGlzfSxhcHBseU9wdGlvbnM6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnNlcmllcyxkPWMub3B0aW9ucy5wb2ludFZhbEtleXx8Yy5wb2ludFZhbEtleSxhPU1hLnByb3RvdHlwZS5vcHRpb25zVG9PYmplY3QuY2FsbCh0aGlzLGEpO3godGhpcyxhKTt0aGlzLm9wdGlvbnM9dGhpcy5vcHRpb25zP3godGhpcy5vcHRpb25zLGEpOmE7aWYoZCl0aGlzLnk9dGhpc1tkXTt0aGlzLmlzTnVsbD10aGlzLng9PT1udWxsfHwhSih0aGlzLnksITApO2lmKHRoaXMueD09PXZvaWQgMCYmYyl0aGlzLng9Yj09PXZvaWQgMD9jLmF1dG9JbmNyZW1lbnQodGhpcyk6XG5iO2lmKGMueEF4aXMmJmMueEF4aXMubmFtZXMpYy54QXhpcy5uYW1lc1t0aGlzLnhdPXRoaXMubmFtZTtyZXR1cm4gdGhpc30sb3B0aW9uc1RvT2JqZWN0OmZ1bmN0aW9uKGEpe3ZhciBiPXt9LGM9dGhpcy5zZXJpZXMsZD1jLm9wdGlvbnMua2V5cyxlPWR8fGMucG9pbnRBcnJheU1hcHx8W1wieVwiXSxmPWUubGVuZ3RoLGc9MCxoPTA7aWYoSihhKXx8YT09PW51bGwpYltlWzBdXT1hO2Vsc2UgaWYoRmEoYSkpe2lmKCFkJiZhLmxlbmd0aD5mKXtjPXR5cGVvZiBhWzBdO2lmKGM9PT1cInN0cmluZ1wiKWIubmFtZT1hWzBdO2Vsc2UgaWYoYz09PVwibnVtYmVyXCIpYi54PWFbMF07ZysrfWZvcig7aDxmOyl7aWYoIWR8fGFbZ10hPT12b2lkIDApYltlW2hdXT1hW2ddO2crKztoKyt9fWVsc2UgaWYodHlwZW9mIGE9PT1cIm9iamVjdFwiKXtiPWE7aWYoYS5kYXRhTGFiZWxzKWMuX2hhc1BvaW50TGFiZWxzPSEwO2lmKGEubWFya2VyKWMuX2hhc1BvaW50TWFya2Vycz0hMH1yZXR1cm4gYn0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBhPVxudGhpcy5zZXJpZXMuY2hhcnQsYj1hLmhvdmVyUG9pbnRzLGM7YS5wb2ludENvdW50LS07aWYoYiYmKHRoaXMuc2V0U3RhdGUoKSxyYShiLHRoaXMpLCFiLmxlbmd0aCkpYS5ob3ZlclBvaW50cz1udWxsO2lmKHRoaXM9PT1hLmhvdmVyUG9pbnQpdGhpcy5vbk1vdXNlT3V0KCk7aWYodGhpcy5ncmFwaGljfHx0aGlzLmRhdGFMYWJlbClZKHRoaXMpLHRoaXMuZGVzdHJveUVsZW1lbnRzKCk7dGhpcy5sZWdlbmRJdGVtJiZhLmxlZ2VuZC5kZXN0cm95SXRlbSh0aGlzKTtmb3IoYyBpbiB0aGlzKXRoaXNbY109bnVsbH0sZGVzdHJveUVsZW1lbnRzOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtcImdyYXBoaWNcIixcImRhdGFMYWJlbFwiLFwiZGF0YUxhYmVsVXBwZXJcIixcImNvbm5lY3RvclwiLFwic2hhZG93R3JvdXBcIl0sYixjPTY7Yy0tOyliPWFbY10sdGhpc1tiXSYmKHRoaXNbYl09dGhpc1tiXS5kZXN0cm95KCkpfSxnZXRMYWJlbENvbmZpZzpmdW5jdGlvbigpe3JldHVybnt4OnRoaXMuY2F0ZWdvcnkseTp0aGlzLnksXG5jb2xvcjp0aGlzLmNvbG9yLGtleTp0aGlzLm5hbWV8fHRoaXMuY2F0ZWdvcnksc2VyaWVzOnRoaXMuc2VyaWVzLHBvaW50OnRoaXMscGVyY2VudGFnZTp0aGlzLnBlcmNlbnRhZ2UsdG90YWw6dGhpcy50b3RhbHx8dGhpcy5zdGFja1RvdGFsfX0sdG9vbHRpcEZvcm1hdHRlcjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnNlcmllcyxjPWIudG9vbHRpcE9wdGlvbnMsZD1wKGMudmFsdWVEZWNpbWFscyxcIlwiKSxlPWMudmFsdWVQcmVmaXh8fFwiXCIsZj1jLnZhbHVlU3VmZml4fHxcIlwiO3EoYi5wb2ludEFycmF5TWFwfHxbXCJ5XCJdLGZ1bmN0aW9uKGIpe2I9XCJ7cG9pbnQuXCIrYjtpZihlfHxmKWE9YS5yZXBsYWNlKGIrXCJ9XCIsZStiK1wifVwiK2YpO2E9YS5yZXBsYWNlKGIrXCJ9XCIsYitcIjosLlwiK2QrXCJmfVwiKX0pO3JldHVybiBOYShhLHtwb2ludDp0aGlzLHNlcmllczp0aGlzLnNlcmllc30pfSxmaXJlUG9pbnRFdmVudDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcyxlPXRoaXMuc2VyaWVzLm9wdGlvbnM7XG4oZS5wb2ludC5ldmVudHNbYV18fGQub3B0aW9ucyYmZC5vcHRpb25zLmV2ZW50cyYmZC5vcHRpb25zLmV2ZW50c1thXSkmJnRoaXMuaW1wb3J0RXZlbnRzKCk7YT09PVwiY2xpY2tcIiYmZS5hbGxvd1BvaW50U2VsZWN0JiYoYz1mdW5jdGlvbihhKXtkLnNlbGVjdCYmZC5zZWxlY3QobnVsbCxhLmN0cmxLZXl8fGEubWV0YUtleXx8YS5zaGlmdEtleSl9KTtJKHRoaXMsYSxiLGMpfSx2aXNpYmxlOiEwfTt2YXIgUj11LlNlcmllcz1mdW5jdGlvbigpe307Ui5wcm90b3R5cGU9e2lzQ2FydGVzaWFuOiEwLHR5cGU6XCJsaW5lXCIscG9pbnRDbGFzczpNYSxzb3J0ZWQ6ITAscmVxdWlyZVNvcnRpbmc6ITAscG9pbnRBdHRyVG9PcHRpb25zOntzdHJva2U6XCJsaW5lQ29sb3JcIixcInN0cm9rZS13aWR0aFwiOlwibGluZVdpZHRoXCIsZmlsbDpcImZpbGxDb2xvclwiLHI6XCJyYWRpdXNcIn0sZGlyZWN0VG91Y2g6ITEsYXhpc1R5cGVzOltcInhBeGlzXCIsXCJ5QXhpc1wiXSxjb2xvckNvdW50ZXI6MCxwYXJhbGxlbEFycmF5czpbXCJ4XCIsXG5cInlcIl0saW5pdDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZCxlLGY9YS5zZXJpZXMsZz1mdW5jdGlvbihhLGIpe3JldHVybiBwKGEub3B0aW9ucy5pbmRleCxhLl9pKS1wKGIub3B0aW9ucy5pbmRleCxiLl9pKX07Yy5jaGFydD1hO2Mub3B0aW9ucz1iPWMuc2V0T3B0aW9ucyhiKTtjLmxpbmtlZFNlcmllcz1bXTtjLmJpbmRBeGVzKCk7eChjLHtuYW1lOmIubmFtZSxzdGF0ZTpcIlwiLHBvaW50QXR0cjp7fSx2aXNpYmxlOmIudmlzaWJsZSE9PSExLHNlbGVjdGVkOmIuc2VsZWN0ZWQ9PT0hMH0pO2lmKGxhKWIuYW5pbWF0aW9uPSExO2U9Yi5ldmVudHM7Zm9yKGQgaW4gZSlOKGMsZCxlW2RdKTtpZihlJiZlLmNsaWNrfHxiLnBvaW50JiZiLnBvaW50LmV2ZW50cyYmYi5wb2ludC5ldmVudHMuY2xpY2t8fGIuYWxsb3dQb2ludFNlbGVjdClhLnJ1blRyYWNrZXJDbGljaz0hMDtjLmdldENvbG9yKCk7Yy5nZXRTeW1ib2woKTtxKGMucGFyYWxsZWxBcnJheXMsZnVuY3Rpb24oYSl7Y1thK1wiRGF0YVwiXT1cbltdfSk7Yy5zZXREYXRhKGIuZGF0YSwhMSk7aWYoYy5pc0NhcnRlc2lhbilhLmhhc0NhcnRlc2lhblNlcmllcz0hMDtmLnB1c2goYyk7Yy5faT1mLmxlbmd0aC0xO2piKGYsZyk7dGhpcy55QXhpcyYmamIodGhpcy55QXhpcy5zZXJpZXMsZyk7cShmLGZ1bmN0aW9uKGEsYil7YS5pbmRleD1iO2EubmFtZT1hLm5hbWV8fFwiU2VyaWVzIFwiKyhiKzEpfSl9LGJpbmRBeGVzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEub3B0aW9ucyxjPWEuY2hhcnQsZDtxKGEuYXhpc1R5cGVzfHxbXSxmdW5jdGlvbihlKXtxKGNbZV0sZnVuY3Rpb24oYyl7ZD1jLm9wdGlvbnM7aWYoYltlXT09PWQuaW5kZXh8fGJbZV0hPT1BJiZiW2VdPT09ZC5pZHx8YltlXT09PUEmJmQuaW5kZXg9PT0wKWMuc2VyaWVzLnB1c2goYSksYVtlXT1jLGMuaXNEaXJ0eT0hMH0pOyFhW2VdJiZhLm9wdGlvbmFsQXhpcyE9PWUmJmNhKDE4LCEwKX0pfSx1cGRhdGVQYXJhbGxlbEFycmF5czpmdW5jdGlvbihhLGIpe3ZhciBjPWEuc2VyaWVzLFxuZD1hcmd1bWVudHMsZT1KKGIpP2Z1bmN0aW9uKGQpe3ZhciBlPWQ9PT1cInlcIiYmYy50b1lEYXRhP2MudG9ZRGF0YShhKTphW2RdO2NbZCtcIkRhdGFcIl1bYl09ZX06ZnVuY3Rpb24oYSl7QXJyYXkucHJvdG90eXBlW2JdLmFwcGx5KGNbYStcIkRhdGFcIl0sQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZCwyKSl9O3EoYy5wYXJhbGxlbEFycmF5cyxlKX0sYXV0b0luY3JlbWVudDpmdW5jdGlvbihhKXt2YXIgZzt2YXIgYj10aGlzLm9wdGlvbnMsYz10aGlzLnhJbmNyZW1lbnQsZD1iLnBvaW50SW50ZXJ2YWxVbml0LGU9dGhpcy54QXhpcyxmLGM9cChjLGIucG9pbnRTdGFydCwwKTt0aGlzLnBvaW50SW50ZXJ2YWw9Yj1wKHRoaXMucG9pbnRJbnRlcnZhbCxiLnBvaW50SW50ZXJ2YWwsMSk7aWYoZSYmZS5jYXRlZ29yaWVzJiZhLm5hbWUpaWYodGhpcy5yZXF1aXJlU29ydGluZz0hMSxnPShmPUZhKGUuY2F0ZWdvcmllcykpP2UuY2F0ZWdvcmllczplLm5hbWVzLGU9ZyxhPXBhKGEubmFtZSxlKSxcbmE9PT0tMSl7aWYoIWYpYz1lLmxlbmd0aH1lbHNlIGM9YTtkJiYoYT1uZXcgbWEoYyksZD09PVwiZGF5XCI/YT0rYVttYl0oYVtXYV0oKStiKTpkPT09XCJtb250aFwiP2E9K2FbemJdKGFbY2JdKCkrYik6ZD09PVwieWVhclwiJiYoYT0rYVtBYl0oYVtkYl0oKStiKSksYj1hLWMpO3RoaXMueEluY3JlbWVudD1jK2I7cmV0dXJuIGN9LHNldE9wdGlvbnM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPWIub3B0aW9ucy5wbG90T3B0aW9ucyxiPWIudXNlck9wdGlvbnN8fHt9LGQ9Yi5wbG90T3B0aW9uc3x8e30sZT1jW3RoaXMudHlwZV07dGhpcy51c2VyT3B0aW9ucz1hO2M9RShlLGMuc2VyaWVzLGEpO3RoaXMudG9vbHRpcE9wdGlvbnM9RShVLnRvb2x0aXAsVS5wbG90T3B0aW9uc1t0aGlzLnR5cGVdLnRvb2x0aXAsYi50b29sdGlwLGQuc2VyaWVzJiZkLnNlcmllcy50b29sdGlwLGRbdGhpcy50eXBlXSYmZFt0aGlzLnR5cGVdLnRvb2x0aXAsYS50b29sdGlwKTtlLm1hcmtlcj09PW51bGwmJlxuZGVsZXRlIGMubWFya2VyO3RoaXMuem9uZUF4aXM9Yy56b25lQXhpczthPXRoaXMuem9uZXM9KGMuem9uZXN8fFtdKS5zbGljZSgpO2lmKChjLm5lZ2F0aXZlQ29sb3J8fGMubmVnYXRpdmVGaWxsQ29sb3IpJiYhYy56b25lcylhLnB1c2goe3ZhbHVlOmNbdGhpcy56b25lQXhpcytcIlRocmVzaG9sZFwiXXx8Yy50aHJlc2hvbGR8fDAsY29sb3I6Yy5uZWdhdGl2ZUNvbG9yLGZpbGxDb2xvcjpjLm5lZ2F0aXZlRmlsbENvbG9yfSk7YS5sZW5ndGgmJnMoYVthLmxlbmd0aC0xXS52YWx1ZSkmJmEucHVzaCh7Y29sb3I6dGhpcy5jb2xvcixmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3J9KTtyZXR1cm4gY30sZ2V0Q3ljbGljOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLnVzZXJPcHRpb25zLGU9XCJfXCIrYStcIkluZGV4XCIsZj1hK1wiQ291bnRlclwiO2J8fChzKGRbZV0pP2I9ZFtlXTooZFtlXT1iPXRoaXMuY2hhcnRbZl0lYy5sZW5ndGgsdGhpcy5jaGFydFtmXSs9MSksYj1jW2JdKTt0aGlzW2FdPWJ9LFxuZ2V0Q29sb3I6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuY29sb3JCeVBvaW50P3RoaXMub3B0aW9ucy5jb2xvcj1udWxsOnRoaXMuZ2V0Q3ljbGljKFwiY29sb3JcIix0aGlzLm9wdGlvbnMuY29sb3J8fGZhW3RoaXMudHlwZV0uY29sb3IsdGhpcy5jaGFydC5vcHRpb25zLmNvbG9ycyl9LGdldFN5bWJvbDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5tYXJrZXI7dGhpcy5nZXRDeWNsaWMoXCJzeW1ib2xcIixhLnN5bWJvbCx0aGlzLmNoYXJ0Lm9wdGlvbnMuc3ltYm9scyk7aWYoL151cmwvLnRlc3QodGhpcy5zeW1ib2wpKWEucmFkaXVzPTB9LGRyYXdMZWdlbmRTeW1ib2w6Sy5kcmF3TGluZU1hcmtlcixzZXREYXRhOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMsZj1lLnBvaW50cyxnPWYmJmYubGVuZ3RofHwwLGgsaT1lLm9wdGlvbnMsaj1lLmNoYXJ0LGs9bnVsbCxsPWUueEF4aXMsbT1pLnR1cmJvVGhyZXNob2xkLG49dGhpcy54RGF0YSxvPXRoaXMueURhdGEsej0oaD1lLnBvaW50QXJyYXlNYXApJiZcbmgubGVuZ3RoLGE9YXx8W107aD1hLmxlbmd0aDtiPXAoYiwhMCk7aWYoZCE9PSExJiZoJiZnPT09aCYmIWUuY3JvcHBlZCYmIWUuaGFzR3JvdXBlZERhdGEmJmUudmlzaWJsZSlxKGEsZnVuY3Rpb24oYSxiKXtmW2JdLnVwZGF0ZSYmYSE9PWkuZGF0YVtiXSYmZltiXS51cGRhdGUoYSwhMSxudWxsLCExKX0pO2Vsc2V7ZS54SW5jcmVtZW50PW51bGw7ZS5jb2xvckNvdW50ZXI9MDtxKHRoaXMucGFyYWxsZWxBcnJheXMsZnVuY3Rpb24oYSl7ZVthK1wiRGF0YVwiXS5sZW5ndGg9MH0pO2lmKG0mJmg+bSl7Zm9yKGM9MDtrPT09bnVsbCYmYzxoOylrPWFbY10sYysrO2lmKEooaykpe2s9cChpLnBvaW50U3RhcnQsMCk7ej1wKGkucG9pbnRJbnRlcnZhbCwxKTtmb3IoYz0wO2M8aDtjKyspbltjXT1rLG9bY109YVtjXSxrKz16O2UueEluY3JlbWVudD1rfWVsc2UgaWYoRmEoaykpaWYoeilmb3IoYz0wO2M8aDtjKyspaz1hW2NdLG5bY109a1swXSxvW2NdPWsuc2xpY2UoMSx6KzEpO2Vsc2UgZm9yKGM9XG4wO2M8aDtjKyspaz1hW2NdLG5bY109a1swXSxvW2NdPWtbMV07ZWxzZSBjYSgxMil9ZWxzZSBmb3IoYz0wO2M8aDtjKyspYVtjXSE9PUEmJihrPXtzZXJpZXM6ZX0sZS5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkoayxbYVtjXV0pLGUudXBkYXRlUGFyYWxsZWxBcnJheXMoayxjKSk7eWEob1swXSkmJmNhKDE0LCEwKTtlLmRhdGE9W107ZS5vcHRpb25zLmRhdGE9ZS51c2VyT3B0aW9ucy5kYXRhPWE7Zm9yKGM9ZztjLS07KWZbY10mJmZbY10uZGVzdHJveSYmZltjXS5kZXN0cm95KCk7aWYobClsLm1pblJhbmdlPWwudXNlck1pblJhbmdlO2UuaXNEaXJ0eT1lLmlzRGlydHlEYXRhPWouaXNEaXJ0eUJveD0hMDtjPSExfWkubGVnZW5kVHlwZT09PVwicG9pbnRcIiYmKHRoaXMucHJvY2Vzc0RhdGEoKSx0aGlzLmdlbmVyYXRlUG9pbnRzKCkpO2ImJmoucmVkcmF3KGMpfSxwcm9jZXNzRGF0YTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnhEYXRhLGM9dGhpcy55RGF0YSxcbmQ9Yi5sZW5ndGgsZTtlPTA7dmFyIGYsZyxoPXRoaXMueEF4aXMsaSxqPXRoaXMub3B0aW9ucztpPWouY3JvcFRocmVzaG9sZDt2YXIgaz10aGlzLmdldEV4dHJlbWVzRnJvbUFsbHx8ai5nZXRFeHRyZW1lc0Zyb21BbGwsbD10aGlzLmlzQ2FydGVzaWFuLGo9aCYmaC52YWwybGluLG09aCYmaC5pc0xvZyxuLG87aWYobCYmIXRoaXMuaXNEaXJ0eSYmIWguaXNEaXJ0eSYmIXRoaXMueUF4aXMuaXNEaXJ0eSYmIWEpcmV0dXJuITE7aWYoaClhPWguZ2V0RXh0cmVtZXMoKSxuPWEubWluLG89YS5tYXg7aWYobCYmdGhpcy5zb3J0ZWQmJiFrJiYoIWl8fGQ+aXx8dGhpcy5mb3JjZUNyb3ApKWlmKGJbZC0xXTxufHxiWzBdPm8pYj1bXSxjPVtdO2Vsc2UgaWYoYlswXTxufHxiW2QtMV0+byllPXRoaXMuY3JvcERhdGEodGhpcy54RGF0YSx0aGlzLnlEYXRhLG4sbyksYj1lLnhEYXRhLGM9ZS55RGF0YSxlPWUuc3RhcnQsZj0hMDtmb3IoaT1iLmxlbmd0aHx8MTstLWk7KWQ9bT9qKGJbaV0pLWooYltpLVxuMV0pOmJbaV0tYltpLTFdLGQ+MCYmKGc9PT1BfHxkPGcpP2c9ZDpkPDAmJnRoaXMucmVxdWlyZVNvcnRpbmcmJmNhKDE1KTt0aGlzLmNyb3BwZWQ9Zjt0aGlzLmNyb3BTdGFydD1lO3RoaXMucHJvY2Vzc2VkWERhdGE9Yjt0aGlzLnByb2Nlc3NlZFlEYXRhPWM7dGhpcy5jbG9zZXN0UG9pbnRSYW5nZT1nfSxjcm9wRGF0YTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1hLmxlbmd0aCxmPTAsZz1lLGg9cCh0aGlzLmNyb3BTaG91bGRlciwxKSxpO2ZvcihpPTA7aTxlO2krKylpZihhW2ldPj1jKXtmPXQoMCxpLWgpO2JyZWFrfWZvcihjPWk7YzxlO2MrKylpZihhW2NdPmQpe2c9YytoO2JyZWFrfXJldHVybnt4RGF0YTphLnNsaWNlKGYsZykseURhdGE6Yi5zbGljZShmLGcpLHN0YXJ0OmYsZW5kOmd9fSxnZW5lcmF0ZVBvaW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5kYXRhLGI9dGhpcy5kYXRhLGMsZD10aGlzLnByb2Nlc3NlZFhEYXRhLGU9dGhpcy5wcm9jZXNzZWRZRGF0YSxcbmY9dGhpcy5wb2ludENsYXNzLGc9ZC5sZW5ndGgsaD10aGlzLmNyb3BTdGFydHx8MCxpLGo9dGhpcy5oYXNHcm91cGVkRGF0YSxrLGw9W10sbTtpZighYiYmIWopYj1bXSxiLmxlbmd0aD1hLmxlbmd0aCxiPXRoaXMuZGF0YT1iO2ZvcihtPTA7bTxnO20rKylpPWgrbSxqPyhsW21dPShuZXcgZikuaW5pdCh0aGlzLFtkW21dXS5jb25jYXQodWEoZVttXSkpKSxsW21dLmRhdGFHcm91cD10aGlzLmdyb3VwTWFwW21dKTooYltpXT9rPWJbaV06YVtpXSE9PUEmJihiW2ldPWs9KG5ldyBmKS5pbml0KHRoaXMsYVtpXSxkW21dKSksbFttXT1rKSxsW21dLmluZGV4PWk7aWYoYiYmKGchPT0oYz1iLmxlbmd0aCl8fGopKWZvcihtPTA7bTxjO20rKylpZihtPT09aCYmIWomJihtKz1nKSxiW21dKWJbbV0uZGVzdHJveUVsZW1lbnRzKCksYlttXS5wbG90WD1BO3RoaXMuZGF0YT1iO3RoaXMucG9pbnRzPWx9LGdldEV4dHJlbWVzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMueUF4aXMsYz10aGlzLnByb2Nlc3NlZFhEYXRhLFxuZCxlPVtdLGY9MDtkPXRoaXMueEF4aXMuZ2V0RXh0cmVtZXMoKTt2YXIgZz1kLm1pbixoPWQubWF4LGksaixrLGwsYT1hfHx0aGlzLnN0YWNrZWRZRGF0YXx8dGhpcy5wcm9jZXNzZWRZRGF0YXx8W107ZD1hLmxlbmd0aDtmb3IobD0wO2w8ZDtsKyspaWYoaj1jW2xdLGs9YVtsXSxpPWshPT1udWxsJiZrIT09QSYmKCFiLmlzTG9nfHxrLmxlbmd0aHx8az4wKSxqPXRoaXMuZ2V0RXh0cmVtZXNGcm9tQWxsfHx0aGlzLm9wdGlvbnMuZ2V0RXh0cmVtZXNGcm9tQWxsfHx0aGlzLmNyb3BwZWR8fChjW2wrMV18fGopPj1nJiYoY1tsLTFdfHxqKTw9aCxpJiZqKWlmKGk9ay5sZW5ndGgpZm9yKDtpLS07KWtbaV0hPT1udWxsJiYoZVtmKytdPWtbaV0pO2Vsc2UgZVtmKytdPWs7dGhpcy5kYXRhTWluPU9hKGUpO3RoaXMuZGF0YU1heD1IYShlKX0sdHJhbnNsYXRlOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRYRGF0YXx8dGhpcy5wcm9jZXNzRGF0YSgpO3RoaXMuZ2VuZXJhdGVQb2ludHMoKTtmb3IodmFyIGE9XG50aGlzLm9wdGlvbnMsYj1hLnN0YWNraW5nLGM9dGhpcy54QXhpcyxkPWMuY2F0ZWdvcmllcyxlPXRoaXMueUF4aXMsZj10aGlzLnBvaW50cyxnPWYubGVuZ3RoLGg9ISF0aGlzLm1vZGlmeVZhbHVlLGk9YS5wb2ludFBsYWNlbWVudCxqPWk9PT1cImJldHdlZW5cInx8SihpKSxrPWEudGhyZXNob2xkLGw9YS5zdGFydEZyb21UaHJlc2hvbGQ/azowLG0sbixvLHEscj1OdW1iZXIuTUFYX1ZBTFVFLGE9MDthPGc7YSsrKXt2YXIgRz1mW2FdLHc9Ry54LHY9Ry55O249Ry5sb3c7dmFyIHg9YiYmZS5zdGFja3NbKHRoaXMubmVnU3RhY2tzJiZ2PChsPzA6ayk/XCItXCI6XCJcIikrdGhpcy5zdGFja0tleV0sdTtpZihlLmlzTG9nJiZ2IT09bnVsbCYmdjw9MClHLnk9dj1udWxsLGNhKDEwKTtHLnBsb3RYPW09YWEoRih0KC0xRTUsYy50cmFuc2xhdGUodywwLDAsMCwxLGksdGhpcy50eXBlPT09XCJmbGFnc1wiKSksMUU1KSk7aWYoYiYmdGhpcy52aXNpYmxlJiYhRy5pc051bGwmJngmJnhbd10pcT10aGlzLmdldFN0YWNrSW5kaWNhdG9yKHEsXG53LHRoaXMuaW5kZXgpLHU9eFt3XSx2PXUucG9pbnRzW3Eua2V5XSxuPXZbMF0sdj12WzFdLG49PT1sJiZxLmtleT09PXhbd10uYmFzZSYmKG49cChrLGUubWluKSksZS5pc0xvZyYmbjw9MCYmKG49bnVsbCksRy50b3RhbD1HLnN0YWNrVG90YWw9dS50b3RhbCxHLnBlcmNlbnRhZ2U9dS50b3RhbCYmRy55L3UudG90YWwqMTAwLEcuc3RhY2tZPXYsdS5zZXRPZmZzZXQodGhpcy5wb2ludFhPZmZzZXR8fDAsdGhpcy5iYXJXfHwwKTtHLnlCb3R0b209cyhuKT9lLnRyYW5zbGF0ZShuLDAsMSwwLDEpOm51bGw7aCYmKHY9dGhpcy5tb2RpZnlWYWx1ZSh2LEcpKTtHLnBsb3RZPW49dHlwZW9mIHY9PT1cIm51bWJlclwiJiZ2IT09SW5maW5pdHk/Rih0KC0xRTUsZS50cmFuc2xhdGUodiwwLDEsMCwxKSksMUU1KTpBO0cuaXNJbnNpZGU9biE9PUEmJm4+PTAmJm48PWUubGVuJiZtPj0wJiZtPD1jLmxlbjtHLmNsaWVudFg9aj9hYShjLnRyYW5zbGF0ZSh3LDAsMCwwLDEpKTptO0cubmVnYXRpdmU9Ry55PFxuKGt8fDApO0cuY2F0ZWdvcnk9ZCYmZFtHLnhdIT09QT9kW0cueF06Ry54O0cuaXNOdWxsfHwobyE9PXZvaWQgMCYmKHI9RihyLFEobS1vKSkpLG89bSl9dGhpcy5jbG9zZXN0UG9pbnRSYW5nZVB4PXJ9LGdldFZhbGlkUG9pbnRzOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jaGFydDtyZXR1cm4gQ2EoYXx8dGhpcy5wb2ludHN8fFtdLGZ1bmN0aW9uKGEpe3JldHVybiBiJiYhYy5pc0luc2lkZVBsb3QoYS5wbG90WCxhLnBsb3RZLGMuaW52ZXJ0ZWQpPyExOiFhLmlzTnVsbH0pfSxzZXRDbGlwOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz10aGlzLm9wdGlvbnMsZD1iLnJlbmRlcmVyLGU9Yi5pbnZlcnRlZCxmPXRoaXMuY2xpcEJveCxnPWZ8fGIuY2xpcEJveCxoPXRoaXMuc2hhcmVkQ2xpcEtleXx8W1wiX3NoYXJlZENsaXBcIixhJiZhLmR1cmF0aW9uLGEmJmEuZWFzaW5nLGcuaGVpZ2h0LGMueEF4aXMsYy55QXhpc10uam9pbihcIixcIiksaT1iW2hdLGo9YltoK1wibVwiXTtpZighaSl7aWYoYSlnLndpZHRoPVxuMCxiW2grXCJtXCJdPWo9ZC5jbGlwUmVjdCgtOTksZT8tYi5wbG90TGVmdDotYi5wbG90VG9wLDk5LGU/Yi5jaGFydFdpZHRoOmIuY2hhcnRIZWlnaHQpO2JbaF09aT1kLmNsaXBSZWN0KGcpO2kuY291bnQ9e2xlbmd0aDowfX1hJiYhaS5jb3VudFt0aGlzLmluZGV4XSYmKGkuY291bnRbdGhpcy5pbmRleF09ITAsaS5jb3VudC5sZW5ndGgrPTEpO2lmKGMuY2xpcCE9PSExKXRoaXMuZ3JvdXAuY2xpcChhfHxmP2k6Yi5jbGlwUmVjdCksdGhpcy5tYXJrZXJHcm91cC5jbGlwKGopLHRoaXMuc2hhcmVkQ2xpcEtleT1oO2F8fChpLmNvdW50W3RoaXMuaW5kZXhdJiYoZGVsZXRlIGkuY291bnRbdGhpcy5pbmRleF0saS5jb3VudC5sZW5ndGgtPTEpLGkuY291bnQubGVuZ3RoPT09MCYmaCYmYltoXSYmKGZ8fChiW2hdPWJbaF0uZGVzdHJveSgpKSxiW2grXCJtXCJdJiYoYltoK1wibVwiXT1iW2grXCJtXCJdLmRlc3Ryb3koKSkpKX0sYW5pbWF0ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9dGhpcy5vcHRpb25zLmFuaW1hdGlvbixcbmQ7aWYoYyYmISQoYykpYz1mYVt0aGlzLnR5cGVdLmFuaW1hdGlvbjthP3RoaXMuc2V0Q2xpcChjKTooZD10aGlzLnNoYXJlZENsaXBLZXksKGE9YltkXSkmJmEuYW5pbWF0ZSh7d2lkdGg6Yi5wbG90U2l6ZVh9LGMpLGJbZCtcIm1cIl0mJmJbZCtcIm1cIl0uYW5pbWF0ZSh7d2lkdGg6Yi5wbG90U2l6ZVgrOTl9LGMpLHRoaXMuYW5pbWF0ZT1udWxsKX0sYWZ0ZXJBbmltYXRlOmZ1bmN0aW9uKCl7dGhpcy5zZXRDbGlwKCk7SSh0aGlzLFwiYWZ0ZXJBbmltYXRlXCIpfSxkcmF3UG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGEsYj10aGlzLnBvaW50cyxjPXRoaXMuY2hhcnQsZCxlLGYsZyxoLGksaixrLGw9dGhpcy5vcHRpb25zLm1hcmtlcixtPXRoaXMucG9pbnRBdHRyW1wiXCJdLG4sbyxxLHI9dGhpcy5tYXJrZXJHcm91cCxzPXAobC5lbmFibGVkLHRoaXMueEF4aXMuaXNSYWRpYWwsdGhpcy5jbG9zZXN0UG9pbnRSYW5nZVB4PjIqbC5yYWRpdXMpO2lmKGwuZW5hYmxlZCE9PSExfHx0aGlzLl9oYXNQb2ludE1hcmtlcnMpZm9yKGY9XG5iLmxlbmd0aDtmLS07KWlmKGc9YltmXSxkPVYoZy5wbG90WCksZT1nLnBsb3RZLGs9Zy5ncmFwaGljLG49Zy5tYXJrZXJ8fHt9LG89ISFnLm1hcmtlcixhPXMmJm4uZW5hYmxlZD09PUF8fG4uZW5hYmxlZCxxPWcuaXNJbnNpZGUsYSYmSihlKSYmZy55IT09bnVsbClpZihhPWcucG9pbnRBdHRyW2cuc2VsZWN0ZWQ/XCJzZWxlY3RcIjpcIlwiXXx8bSxoPWEucixpPXAobi5zeW1ib2wsdGhpcy5zeW1ib2wpLGo9aS5pbmRleE9mKFwidXJsXCIpPT09MCxrKWtbcT9cInNob3dcIjpcImhpZGVcIl0oITApLmF0dHIoYSkuYW5pbWF0ZSh4KHt4OmQtaCx5OmUtaH0say5zeW1ib2xOYW1lP3t3aWR0aDoyKmgsaGVpZ2h0OjIqaH06e30pKTtlbHNle2lmKHEmJihoPjB8fGopKWcuZ3JhcGhpYz1jLnJlbmRlcmVyLnN5bWJvbChpLGQtaCxlLWgsMipoLDIqaCxvP246bCkuYXR0cihhKS5hZGQocil9ZWxzZSBpZihrKWcuZ3JhcGhpYz1rLmRlc3Ryb3koKX0sY29udmVydEF0dHJpYnM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9XG50aGlzLnBvaW50QXR0clRvT3B0aW9ucyxmLGcsaD17fSxhPWF8fHt9LGI9Ynx8e30sYz1jfHx7fSxkPWR8fHt9O2ZvcihmIGluIGUpZz1lW2ZdLGhbZl09cChhW2ddLGJbZl0sY1tmXSxkW2ZdKTtyZXR1cm4gaH0sZ2V0QXR0cmliczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMsYz1mYVthLnR5cGVdLm1hcmtlcj9iLm1hcmtlcjpiLGQ9Yy5zdGF0ZXMsZT1kLmhvdmVyLGYsZz1hLmNvbG9yLGg9YS5vcHRpb25zLm5lZ2F0aXZlQ29sb3IsaT17c3Ryb2tlOmcsZmlsbDpnfSxqPWEucG9pbnRzfHxbXSxrLGw9W10sbSxuPWEucG9pbnRBdHRyVG9PcHRpb25zO2Y9YS5oYXNQb2ludFNwZWNpZmljT3B0aW9uczt2YXIgbz1jLmxpbmVDb2xvcix6PWMuZmlsbENvbG9yO2s9Yi50dXJib1RocmVzaG9sZDt2YXIgcj1hLnpvbmVzLHQ9YS56b25lQXhpc3x8XCJ5XCIsdyx2O2IubWFya2VyPyhlLnJhZGl1cz0rZS5yYWRpdXN8fCtjLnJhZGl1cysgK2UucmFkaXVzUGx1cyxlLmxpbmVXaWR0aD1cbmUubGluZVdpZHRofHxjLmxpbmVXaWR0aCtlLmxpbmVXaWR0aFBsdXMpOihlLmNvbG9yPWUuY29sb3J8fG5hKGUuY29sb3J8fGcpLmJyaWdodGVuKGUuYnJpZ2h0bmVzcykuZ2V0KCksZS5uZWdhdGl2ZUNvbG9yPWUubmVnYXRpdmVDb2xvcnx8bmEoZS5uZWdhdGl2ZUNvbG9yfHxoKS5icmlnaHRlbihlLmJyaWdodG5lc3MpLmdldCgpKTtsW1wiXCJdPWEuY29udmVydEF0dHJpYnMoYyxpKTtxKFtcImhvdmVyXCIsXCJzZWxlY3RcIl0sZnVuY3Rpb24oYil7bFtiXT1hLmNvbnZlcnRBdHRyaWJzKGRbYl0sbFtcIlwiXSl9KTthLnBvaW50QXR0cj1sO2c9ai5sZW5ndGg7aWYoIWt8fGc8a3x8Zilmb3IoO2ctLTspe2s9altnXTtpZigoYz1rLm9wdGlvbnMmJmsub3B0aW9ucy5tYXJrZXJ8fGsub3B0aW9ucykmJmMuZW5hYmxlZD09PSExKWMucmFkaXVzPTA7aT1udWxsO2lmKHIubGVuZ3RoKXtmPTA7Zm9yKGk9cltmXTtrW3RdPj1pLnZhbHVlOylpPXJbKytmXTtrLmNvbG9yPWsuZmlsbENvbG9yPWk9cChpLmNvbG9yLFxuYS5jb2xvcil9Zj1iLmNvbG9yQnlQb2ludHx8ay5jb2xvcjtpZihrLm9wdGlvbnMpZm9yKHYgaW4gbilzKGNbblt2XV0pJiYoZj0hMCk7aWYoZil7Yz1jfHx7fTttPVtdO2Q9Yy5zdGF0ZXN8fHt9O2Y9ZC5ob3Zlcj1kLmhvdmVyfHx7fTtpZighYi5tYXJrZXJ8fGsubmVnYXRpdmUmJiFmLmZpbGxDb2xvciYmIWUuZmlsbENvbG9yKWZbYS5wb2ludEF0dHJUb09wdGlvbnMuZmlsbF09Zi5jb2xvcnx8IWsub3B0aW9ucy5jb2xvciYmZVtrLm5lZ2F0aXZlJiZoP1wibmVnYXRpdmVDb2xvclwiOlwiY29sb3JcIl18fG5hKGsuY29sb3IpLmJyaWdodGVuKGYuYnJpZ2h0bmVzc3x8ZS5icmlnaHRuZXNzKS5nZXQoKTt3PXtjb2xvcjprLmNvbG9yfTtpZigheil3LmZpbGxDb2xvcj1rLmNvbG9yO2lmKCFvKXcubGluZUNvbG9yPWsuY29sb3I7Yy5oYXNPd25Qcm9wZXJ0eShcImNvbG9yXCIpJiYhYy5jb2xvciYmZGVsZXRlIGMuY29sb3I7aWYoaSYmIWUuZmlsbENvbG9yKWYuZmlsbENvbG9yPWk7bVtcIlwiXT1cbmEuY29udmVydEF0dHJpYnMoeCh3LGMpLGxbXCJcIl0pO20uaG92ZXI9YS5jb252ZXJ0QXR0cmlicyhkLmhvdmVyLGwuaG92ZXIsbVtcIlwiXSk7bS5zZWxlY3Q9YS5jb252ZXJ0QXR0cmlicyhkLnNlbGVjdCxsLnNlbGVjdCxtW1wiXCJdKX1lbHNlIG09bDtrLnBvaW50QXR0cj1tfX0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0LGM9L0FwcGxlV2ViS2l0XFwvNTMzLy50ZXN0KEFhKSxkLGU9YS5kYXRhfHxbXSxmLGcsaDtJKGEsXCJkZXN0cm95XCIpO1koYSk7cShhLmF4aXNUeXBlc3x8W10sZnVuY3Rpb24oYil7aWYoaD1hW2JdKXJhKGguc2VyaWVzLGEpLGguaXNEaXJ0eT1oLmZvcmNlUmVkcmF3PSEwfSk7YS5sZWdlbmRJdGVtJiZhLmNoYXJ0LmxlZ2VuZC5kZXN0cm95SXRlbShhKTtmb3IoZD1lLmxlbmd0aDtkLS07KShmPWVbZF0pJiZmLmRlc3Ryb3kmJmYuZGVzdHJveSgpO2EucG9pbnRzPW51bGw7Y2xlYXJUaW1lb3V0KGEuYW5pbWF0aW9uVGltZW91dCk7Zm9yKGcgaW4gYSlhW2ddaW5zdGFuY2VvZlxuTyYmIWFbZ10uc3Vydml2ZSYmKGQ9YyYmZz09PVwiZ3JvdXBcIj9cImhpZGVcIjpcImRlc3Ryb3lcIixhW2ddW2RdKCkpO2lmKGIuaG92ZXJTZXJpZXM9PT1hKWIuaG92ZXJTZXJpZXM9bnVsbDtyYShiLnNlcmllcyxhKTtmb3IoZyBpbiBhKWRlbGV0ZSBhW2ddfSxnZXRHcmFwaFBhdGg6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMsZT1kLm9wdGlvbnMsZj1lLnN0ZXAsZyxoPVtdLGk9W10saixhPWF8fGQucG9pbnRzOyhnPWEucmV2ZXJzZWQpJiZhLnJldmVyc2UoKTsoZj17cmlnaHQ6MSxjZW50ZXI6Mn1bZl18fGYmJjMpJiZnJiYoZj00LWYpO2UuY29ubmVjdE51bGxzJiYhYiYmIWMmJihhPXRoaXMuZ2V0VmFsaWRQb2ludHMoYSkpO3EoYSxmdW5jdGlvbihnLGwpe3ZhciBtPWcucGxvdFgsbj1nLnBsb3RZLG89YVtsLTFdO2lmKChnLmxlZnRDbGlmZnx8byYmby5yaWdodENsaWZmKSYmIWMpaj0hMDtnLmlzTnVsbCYmIXMoYikmJmw+MD9qPSFlLmNvbm5lY3ROdWxsczpnLmlzTnVsbCYmIWI/XG5qPSEwOihsPT09MHx8aj9vPVtYLGcucGxvdFgsZy5wbG90WV06ZC5nZXRQb2ludFNwbGluZT9vPWQuZ2V0UG9pbnRTcGxpbmUoYSxnLGwpOmY/KG89Zj09PTE/W1Msby5wbG90WCxuXTpmPT09Mj9bUywoby5wbG90WCttKS8yLG8ucGxvdFksUywoby5wbG90WCttKS8yLG5dOltTLG0sby5wbG90WV0sby5wdXNoKFMsbSxuKSk6bz1bUyxtLG5dLGkucHVzaChnLngpLGYmJmkucHVzaChnLngpLGgucHVzaC5hcHBseShoLG8pLGo9ITEpfSk7aC54TWFwPWk7cmV0dXJuIGQuZ3JhcGhQYXRoPWh9LGRyYXdHcmFwaDpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLm9wdGlvbnMsYz1bW1wiZ3JhcGhcIixiLmxpbmVDb2xvcnx8dGhpcy5jb2xvcixiLmRhc2hTdHlsZV1dLGQ9Yi5saW5lV2lkdGgsZT1iLmxpbmVjYXAhPT1cInNxdWFyZVwiLGY9KHRoaXMuZ2FwcGVkUGF0aHx8dGhpcy5nZXRHcmFwaFBhdGgpLmNhbGwodGhpcyk7cSh0aGlzLnpvbmVzLGZ1bmN0aW9uKGQsZSl7Yy5wdXNoKFtcInpvbmVHcmFwaFwiK1xuZSxkLmNvbG9yfHxhLmNvbG9yLGQuZGFzaFN0eWxlfHxiLmRhc2hTdHlsZV0pfSk7cShjLGZ1bmN0aW9uKGMsaCl7dmFyIGk9Y1swXSxqPWFbaV07aWYoailqLmVuZFg9Zi54TWFwLGouYW5pbWF0ZSh7ZDpmfSk7ZWxzZSBpZihkJiZmLmxlbmd0aClqPXtzdHJva2U6Y1sxXSxcInN0cm9rZS13aWR0aFwiOmQsZmlsbDpcIm5vbmVcIix6SW5kZXg6MX0sY1syXT9qLmRhc2hzdHlsZT1jWzJdOmUmJihqW1wic3Ryb2tlLWxpbmVjYXBcIl09altcInN0cm9rZS1saW5lam9pblwiXT1cInJvdW5kXCIpLGo9YVtpXT1hLmNoYXJ0LnJlbmRlcmVyLnBhdGgoZikuYXR0cihqKS5hZGQoYS5ncm91cCkuc2hhZG93KGg8MiYmYi5zaGFkb3cpO2lmKGopai5zdGFydFg9Zi54TWFwLGouaXNBcmVhPWYuaXNBcmVhfSl9LGFwcGx5Wm9uZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5jaGFydCxjPWIucmVuZGVyZXIsZD10aGlzLnpvbmVzLGUsZixnPXRoaXMuY2xpcHN8fFtdLGgsaT10aGlzLmdyYXBoLGo9dGhpcy5hcmVhLFxuaz10KGIuY2hhcnRXaWR0aCxiLmNoYXJ0SGVpZ2h0KSxsPXRoaXNbKHRoaXMuem9uZUF4aXN8fFwieVwiKStcIkF4aXNcIl0sbSxuPWwucmV2ZXJzZWQsbz1iLmludmVydGVkLHo9bC5ob3JpeixyLHMsdyx2PSExO2lmKGQubGVuZ3RoJiYoaXx8aikmJmwubWluIT09QSlpJiZpLmhpZGUoKSxqJiZqLmhpZGUoKSxtPWwuZ2V0RXh0cmVtZXMoKSxxKGQsZnVuY3Rpb24oZCxxKXtlPW4/ej9iLnBsb3RXaWR0aDowOno/MDpsLnRvUGl4ZWxzKG0ubWluKTtlPUYodChwKGYsZSksMCksayk7Zj1GKHQoQyhsLnRvUGl4ZWxzKHAoZC52YWx1ZSxtLm1heCksITApKSwwKSxrKTt2JiYoZT1mPWwudG9QaXhlbHMobS5tYXgpKTtyPU1hdGguYWJzKGUtZik7cz1GKGUsZik7dz10KGUsZik7aWYobC5pc1hBeGlzKXtpZihoPXt4Om8/dzpzLHk6MCx3aWR0aDpyLGhlaWdodDprfSwheiloLng9Yi5wbG90SGVpZ2h0LWgueH1lbHNlIGlmKGg9e3g6MCx5Om8/dzpzLHdpZHRoOmssaGVpZ2h0OnJ9LHopaC55PWIucGxvdFdpZHRoLVxuaC55O2IuaW52ZXJ0ZWQmJmMuaXNWTUwmJihoPWwuaXNYQXhpcz97eDowLHk6bj9zOncsaGVpZ2h0Omgud2lkdGgsd2lkdGg6Yi5jaGFydFdpZHRofTp7eDpoLnktYi5wbG90TGVmdC1iLnNwYWNpbmdCb3gueCx5OjAsd2lkdGg6aC5oZWlnaHQsaGVpZ2h0OmIuY2hhcnRIZWlnaHR9KTtnW3FdP2dbcV0uYW5pbWF0ZShoKTooZ1txXT1jLmNsaXBSZWN0KGgpLGkmJmFbXCJ6b25lR3JhcGhcIitxXS5jbGlwKGdbcV0pLGomJmFbXCJ6b25lQXJlYVwiK3FdLmNsaXAoZ1txXSkpO3Y9ZC52YWx1ZT5tLm1heH0pLHRoaXMuY2xpcHM9Z30saW52ZXJ0R3JvdXBzOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3ZhciBhPXt3aWR0aDpiLnlBeGlzLmxlbixoZWlnaHQ6Yi54QXhpcy5sZW59O3EoW1wiZ3JvdXBcIixcIm1hcmtlckdyb3VwXCJdLGZ1bmN0aW9uKGMpe2JbY10mJmJbY10uYXR0cihhKS5pbnZlcnQoKX0pfXZhciBiPXRoaXMsYz1iLmNoYXJ0O2lmKGIueEF4aXMpTihjLFwicmVzaXplXCIsYSksTihiLFwiZGVzdHJveVwiLFxuZnVuY3Rpb24oKXtZKGMsXCJyZXNpemVcIixhKX0pLGEoKSxiLmludmVydEdyb3Vwcz1hfSxwbG90R3JvdXA6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzW2FdLGc9IWY7ZyYmKHRoaXNbYV09Zj10aGlzLmNoYXJ0LnJlbmRlcmVyLmcoYikuYXR0cih7ekluZGV4OmR8fDAuMX0pLmFkZChlKSxmLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1zZXJpZXMtXCIrdGhpcy5pbmRleCkpO2YuYXR0cih7dmlzaWJpbGl0eTpjfSlbZz9cImF0dHJcIjpcImFuaW1hdGVcIl0odGhpcy5nZXRQbG90Qm94KCkpO3JldHVybiBmfSxnZXRQbG90Qm94OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydCxiPXRoaXMueEF4aXMsYz10aGlzLnlBeGlzO2lmKGEuaW52ZXJ0ZWQpYj1jLGM9dGhpcy54QXhpcztyZXR1cm57dHJhbnNsYXRlWDpiP2IubGVmdDphLnBsb3RMZWZ0LHRyYW5zbGF0ZVk6Yz9jLnRvcDphLnBsb3RUb3Asc2NhbGVYOjEsc2NhbGVZOjF9fSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydCxcbmMsZD1hLm9wdGlvbnMsZT0hIWEuYW5pbWF0ZSYmYi5yZW5kZXJlci5pc1NWRyYmYmIoZC5hbmltYXRpb24pLmR1cmF0aW9uLGY9YS52aXNpYmxlP1wiaW5oZXJpdFwiOlwiaGlkZGVuXCIsZz1kLnpJbmRleCxoPWEuaGFzUmVuZGVyZWQsaT1iLnNlcmllc0dyb3VwO2M9YS5wbG90R3JvdXAoXCJncm91cFwiLFwic2VyaWVzXCIsZixnLGkpO2EubWFya2VyR3JvdXA9YS5wbG90R3JvdXAoXCJtYXJrZXJHcm91cFwiLFwibWFya2Vyc1wiLGYsZyxpKTtlJiZhLmFuaW1hdGUoITApO2EuZ2V0QXR0cmlicygpO2MuaW52ZXJ0ZWQ9YS5pc0NhcnRlc2lhbj9iLmludmVydGVkOiExO2EuZHJhd0dyYXBoJiYoYS5kcmF3R3JhcGgoKSxhLmFwcGx5Wm9uZXMoKSk7cShhLnBvaW50cyxmdW5jdGlvbihhKXthLnJlZHJhdyYmYS5yZWRyYXcoKX0pO2EuZHJhd0RhdGFMYWJlbHMmJmEuZHJhd0RhdGFMYWJlbHMoKTthLnZpc2libGUmJmEuZHJhd1BvaW50cygpO2EuZHJhd1RyYWNrZXImJmEub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nIT09XG4hMSYmYS5kcmF3VHJhY2tlcigpO2IuaW52ZXJ0ZWQmJmEuaW52ZXJ0R3JvdXBzKCk7ZC5jbGlwIT09ITEmJiFhLnNoYXJlZENsaXBLZXkmJiFoJiZjLmNsaXAoYi5jbGlwUmVjdCk7ZSYmYS5hbmltYXRlKCk7aWYoIWgpYS5hbmltYXRpb25UaW1lb3V0PVJhKGZ1bmN0aW9uKCl7YS5hZnRlckFuaW1hdGUoKX0sZSk7YS5pc0RpcnR5PWEuaXNEaXJ0eURhdGE9ITE7YS5oYXNSZW5kZXJlZD0hMH0scmVkcmF3OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydCxiPXRoaXMuaXNEaXJ0eXx8dGhpcy5pc0RpcnR5RGF0YSxjPXRoaXMuZ3JvdXAsZD10aGlzLnhBeGlzLGU9dGhpcy55QXhpcztjJiYoYS5pbnZlcnRlZCYmYy5hdHRyKHt3aWR0aDphLnBsb3RXaWR0aCxoZWlnaHQ6YS5wbG90SGVpZ2h0fSksYy5hbmltYXRlKHt0cmFuc2xhdGVYOnAoZCYmZC5sZWZ0LGEucGxvdExlZnQpLHRyYW5zbGF0ZVk6cChlJiZlLnRvcCxhLnBsb3RUb3ApfSkpO3RoaXMudHJhbnNsYXRlKCk7dGhpcy5yZW5kZXIoKTtcbmImJmRlbGV0ZSB0aGlzLmtkVHJlZX0sa2REaW1lbnNpb25zOjEsa2RBeGlzQXJyYXk6W1wiY2xpZW50WFwiLFwicGxvdFlcIl0sc2VhcmNoUG9pbnQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnhBeGlzLGQ9dGhpcy55QXhpcyxlPXRoaXMuY2hhcnQuaW52ZXJ0ZWQ7cmV0dXJuIHRoaXMuc2VhcmNoS0RUcmVlKHtjbGllbnRYOmU/Yy5sZW4tYS5jaGFydFkrYy5wb3M6YS5jaGFydFgtYy5wb3MscGxvdFk6ZT9kLmxlbi1hLmNoYXJ0WCtkLnBvczphLmNoYXJ0WS1kLnBvc30sYil9LGJ1aWxkS0RUcmVlOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShjLGUsZil7dmFyIGcsaDtpZihoPWMmJmMubGVuZ3RoKXJldHVybiBnPWIua2RBeGlzQXJyYXlbZSVmXSxjLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYVtnXS1iW2ddfSksaD1NYXRoLmZsb29yKGgvMikse3BvaW50OmNbaF0sbGVmdDphKGMuc2xpY2UoMCxoKSxlKzEsZikscmlnaHQ6YShjLnNsaWNlKGgrMSksZSsxLGYpfX12YXIgYj10aGlzLGM9XG5iLmtkRGltZW5zaW9ucztkZWxldGUgYi5rZFRyZWU7UmEoZnVuY3Rpb24oKXtiLmtkVHJlZT1hKGIuZ2V0VmFsaWRQb2ludHMobnVsbCwhYi5kaXJlY3RUb3VjaCksYyxjKX0sYi5vcHRpb25zLmtkTm93PzA6MSl9LHNlYXJjaEtEVHJlZTpmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGosayl7dmFyIGw9Yi5wb2ludCxtPWQua2RBeGlzQXJyYXlbaiVrXSxuLG8scD1sO289cyhhW2VdKSYmcyhsW2VdKT9NYXRoLnBvdyhhW2VdLWxbZV0sMik6bnVsbDtuPXMoYVtmXSkmJnMobFtmXSk/TWF0aC5wb3coYVtmXS1sW2ZdLDIpOm51bGw7bj0ob3x8MCkrKG58fDApO2wuZGlzdD1zKG4pP01hdGguc3FydChuKTpOdW1iZXIuTUFYX1ZBTFVFO2wuZGlzdFg9cyhvKT9NYXRoLnNxcnQobyk6TnVtYmVyLk1BWF9WQUxVRTttPWFbbV0tbFttXTtuPW08MD9cImxlZnRcIjpcInJpZ2h0XCI7bz1tPDA/XCJyaWdodFwiOlwibGVmdFwiO2Jbbl0mJihuPWMoYSxiW25dLGorMSxrKSxwPW5bZ108cFtnXT9uOmwpO1xuYltvXSYmTWF0aC5zcXJ0KG0qbSk8cFtnXSYmKGE9YyhhLGJbb10saisxLGspLHA9YVtnXTxwW2ddP2E6cCk7cmV0dXJuIHB9dmFyIGQ9dGhpcyxlPXRoaXMua2RBeGlzQXJyYXlbMF0sZj10aGlzLmtkQXhpc0FycmF5WzFdLGc9Yj9cImRpc3RYXCI6XCJkaXN0XCI7dGhpcy5rZFRyZWV8fHRoaXMuYnVpbGRLRFRyZWUoKTtpZih0aGlzLmtkVHJlZSlyZXR1cm4gYyhhLHRoaXMua2RUcmVlLHRoaXMua2REaW1lbnNpb25zLHRoaXMua2REaW1lbnNpb25zKX19O0xiLnByb3RvdHlwZT17ZGVzdHJveTpmdW5jdGlvbigpe1RhKHRoaXMsdGhpcy5heGlzKX0scmVuZGVyOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucyxjPWIuZm9ybWF0LGM9Yz9OYShjLHRoaXMpOmIuZm9ybWF0dGVyLmNhbGwodGhpcyk7dGhpcy5sYWJlbD90aGlzLmxhYmVsLmF0dHIoe3RleHQ6Yyx2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9KTp0aGlzLmxhYmVsPXRoaXMuYXhpcy5jaGFydC5yZW5kZXJlci50ZXh0KGMsbnVsbCxudWxsLFxuYi51c2VIVE1MKS5jc3MoYi5zdHlsZSkuYXR0cih7YWxpZ246dGhpcy50ZXh0QWxpZ24scm90YXRpb246Yi5yb3RhdGlvbix2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9KS5hZGQoYSl9LHNldE9mZnNldDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuYXhpcyxkPWMuY2hhcnQsZT1kLmludmVydGVkLGY9Yy5yZXZlcnNlZCxmPXRoaXMuaXNOZWdhdGl2ZSYmIWZ8fCF0aGlzLmlzTmVnYXRpdmUmJmYsZz1jLnRyYW5zbGF0ZShjLnVzZVBlcmNlbnRhZ2U/MTAwOnRoaXMudG90YWwsMCwwLDAsMSksYz1jLnRyYW5zbGF0ZSgwKSxjPVEoZy1jKSxoPWQueEF4aXNbMF0udHJhbnNsYXRlKHRoaXMueCkrYSxpPWQucGxvdEhlaWdodCxmPXt4OmU/Zj9nOmctYzpoLHk6ZT9pLWgtYjpmP2ktZy1jOmktZyx3aWR0aDplP2M6YixoZWlnaHQ6ZT9iOmN9O2lmKGU9dGhpcy5sYWJlbCllLmFsaWduKHRoaXMuYWxpZ25PcHRpb25zLG51bGwsZiksZj1lLmFsaWduQXR0cixlW3RoaXMub3B0aW9ucy5jcm9wPT09ITF8fFxuZC5pc0luc2lkZVBsb3QoZi54LGYueSk/XCJzaG93XCI6XCJoaWRlXCJdKCEwKX19O2liLnByb3RvdHlwZS5nZXRTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3EoYS55QXhpcyxmdW5jdGlvbihhKXtpZihhLnN0YWNrcyYmYS5oYXNWaXNpYmxlU2VyaWVzKWEub2xkU3RhY2tzPWEuc3RhY2tzfSk7cShhLnNlcmllcyxmdW5jdGlvbihiKXtpZihiLm9wdGlvbnMuc3RhY2tpbmcmJihiLnZpc2libGU9PT0hMHx8YS5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcz09PSExKSliLnN0YWNrS2V5PWIudHlwZStwKGIub3B0aW9ucy5zdGFjayxcIlwiKX0pfTtpYS5wcm90b3R5cGUuYnVpbGRTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllcyxiLGM9cCh0aGlzLm9wdGlvbnMucmV2ZXJzZWRTdGFja3MsITApLGQ9YS5sZW5ndGgsZTtpZighdGhpcy5pc1hBeGlzKXt0aGlzLnVzZVBlcmNlbnRhZ2U9ITE7Zm9yKGU9ZDtlLS07KWFbYz9lOmQtZS0xXS5zZXRTdGFja2VkUG9pbnRzKCk7XG5mb3IoZT1kO2UtLTspYj1hW2M/ZTpkLWUtMV0sYi5zZXRTdGFja0NsaWZmcyYmYi5zZXRTdGFja0NsaWZmcygpO2lmKHRoaXMudXNlUGVyY2VudGFnZSlmb3IoZT0wO2U8ZDtlKyspYVtlXS5zZXRQZXJjZW50U3RhY2tzKCl9fTtpYS5wcm90b3R5cGUucmVuZGVyU3RhY2tUb3RhbHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9YS5yZW5kZXJlcixjPXRoaXMuc3RhY2tzLGQsZSxmPXRoaXMuc3RhY2tUb3RhbEdyb3VwO2lmKCFmKXRoaXMuc3RhY2tUb3RhbEdyb3VwPWY9Yi5nKFwic3RhY2stbGFiZWxzXCIpLmF0dHIoe3Zpc2liaWxpdHk6XCJ2aXNpYmxlXCIsekluZGV4OjZ9KS5hZGQoKTtmLnRyYW5zbGF0ZShhLnBsb3RMZWZ0LGEucGxvdFRvcCk7Zm9yKGQgaW4gYylmb3IoZSBpbiBhPWNbZF0sYSlhW2VdLnJlbmRlcihmKX07aWEucHJvdG90eXBlLnJlc2V0U3RhY2tzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zdGFja3MsYixjO2lmKCF0aGlzLmlzWEF4aXMpZm9yKGIgaW4gYSlmb3IoYyBpbiBhW2JdKWFbYl1bY10udG91Y2hlZDxcbnRoaXMuc3RhY2tzVG91Y2hlZD8oYVtiXVtjXS5kZXN0cm95KCksZGVsZXRlIGFbYl1bY10pOihhW2JdW2NdLnRvdGFsPW51bGwsYVtiXVtjXS5jdW09MCl9O2lhLnByb3RvdHlwZS5jbGVhblN0YWNrcz1mdW5jdGlvbigpe3ZhciBhLGIsYztpZighdGhpcy5pc1hBeGlzKXtpZih0aGlzLm9sZFN0YWNrcylhPXRoaXMuc3RhY2tzPXRoaXMub2xkU3RhY2tzO2ZvcihiIGluIGEpZm9yKGMgaW4gYVtiXSlhW2JdW2NdLmN1bT1hW2JdW2NdLnRvdGFsfX07Ui5wcm90b3R5cGUuc2V0U3RhY2tlZFBvaW50cz1mdW5jdGlvbigpe2lmKHRoaXMub3B0aW9ucy5zdGFja2luZyYmISh0aGlzLnZpc2libGUhPT0hMCYmdGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyE9PSExKSl7dmFyIGE9dGhpcy5wcm9jZXNzZWRYRGF0YSxiPXRoaXMucHJvY2Vzc2VkWURhdGEsYz1bXSxkPWIubGVuZ3RoLGU9dGhpcy5vcHRpb25zLGY9ZS50aHJlc2hvbGQsZz1lLnN0YXJ0RnJvbVRocmVzaG9sZD9cbmY6MCxoPWUuc3RhY2ssZT1lLnN0YWNraW5nLGk9dGhpcy5zdGFja0tleSxqPVwiLVwiK2ksaz10aGlzLm5lZ1N0YWNrcyxsPXRoaXMueUF4aXMsbT1sLnN0YWNrcyxuPWwub2xkU3RhY2tzLG8scSxyLHgsdyx2LHU7bC5zdGFja3NUb3VjaGVkKz0xO2Zvcih3PTA7dzxkO3crKyl7dj1hW3ddO3U9Ylt3XTtvPXRoaXMuZ2V0U3RhY2tJbmRpY2F0b3Iobyx2LHRoaXMuaW5kZXgpO3g9by5rZXk7cj0ocT1rJiZ1PChnPzA6ZikpP2o6aTttW3JdfHwobVtyXT17fSk7aWYoIW1bcl1bdl0pbltyXSYmbltyXVt2XT8obVtyXVt2XT1uW3JdW3ZdLG1bcl1bdl0udG90YWw9bnVsbCk6bVtyXVt2XT1uZXcgTGIobCxsLm9wdGlvbnMuc3RhY2tMYWJlbHMscSx2LGgpO3I9bVtyXVt2XTtpZih1IT09bnVsbCl7ci5wb2ludHNbeF09ci5wb2ludHNbdGhpcy5pbmRleF09W3Aoci5jdW0sZyldO2lmKCFzKHIuY3VtKSlyLmJhc2U9eDtyLnRvdWNoZWQ9bC5zdGFja3NUb3VjaGVkO28uaW5kZXg+MCYmdGhpcy5zaW5nbGVTdGFja3M9PT1cbiExJiYoci5wb2ludHNbeF1bMF09ci5wb2ludHNbdGhpcy5pbmRleCtcIixcIit2K1wiLDBcIl1bMF0pfWU9PT1cInBlcmNlbnRcIj8ocT1xP2k6aixrJiZtW3FdJiZtW3FdW3ZdPyhxPW1bcV1bdl0sci50b3RhbD1xLnRvdGFsPXQocS50b3RhbCxyLnRvdGFsKStRKHUpfHwwKTpyLnRvdGFsPWFhKHIudG90YWwrKFEodSl8fDApKSk6ci50b3RhbD1hYShyLnRvdGFsKyh1fHwwKSk7ci5jdW09cChyLmN1bSxnKSsodXx8MCk7aWYodSE9PW51bGwpci5wb2ludHNbeF0ucHVzaChyLmN1bSksY1t3XT1yLmN1bX1pZihlPT09XCJwZXJjZW50XCIpbC51c2VQZXJjZW50YWdlPSEwO3RoaXMuc3RhY2tlZFlEYXRhPWM7bC5vbGRTdGFja3M9e319fTtSLnByb3RvdHlwZS5zZXRQZXJjZW50U3RhY2tzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuc3RhY2tLZXksYz1hLnlBeGlzLnN0YWNrcyxkPWEucHJvY2Vzc2VkWERhdGEsZTtxKFtiLFwiLVwiK2JdLGZ1bmN0aW9uKGIpe3ZhciBmO2Zvcih2YXIgZz1kLmxlbmd0aCxcbmgsaTtnLS07KWlmKGg9ZFtnXSxlPWEuZ2V0U3RhY2tJbmRpY2F0b3IoZSxoLGEuaW5kZXgpLGY9KGk9Y1tiXSYmY1tiXVtoXSkmJmkucG9pbnRzW2Uua2V5XSxoPWYpaT1pLnRvdGFsPzEwMC9pLnRvdGFsOjAsaFswXT1hYShoWzBdKmkpLGhbMV09YWEoaFsxXSppKSxhLnN0YWNrZWRZRGF0YVtnXT1oWzFdfSl9O1IucHJvdG90eXBlLmdldFN0YWNrSW5kaWNhdG9yPWZ1bmN0aW9uKGEsYixjKXshcyhhKXx8YS54IT09Yj9hPXt4OmIsaW5kZXg6MH06YS5pbmRleCsrO2Eua2V5PVtjLGIsYS5pbmRleF0uam9pbihcIixcIik7cmV0dXJuIGF9O3goaWIucHJvdG90eXBlLHthZGRTZXJpZXM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU9dGhpczthJiYoYj1wKGIsITApLEkoZSxcImFkZFNlcmllc1wiLHtvcHRpb25zOmF9LGZ1bmN0aW9uKCl7ZD1lLmluaXRTZXJpZXMoYSk7ZS5pc0RpcnR5TGVnZW5kPSEwO2UubGlua1NlcmllcygpO2ImJmUucmVkcmF3KGMpfSkpO3JldHVybiBkfSxhZGRBeGlzOmZ1bmN0aW9uKGEsXG5iLGMsZCl7dmFyIGU9Yj9cInhBeGlzXCI6XCJ5QXhpc1wiLGY9dGhpcy5vcHRpb25zLGE9RShhLHtpbmRleDp0aGlzW2VdLmxlbmd0aCxpc1g6Yn0pO25ldyBpYSh0aGlzLGEpO2ZbZV09dWEoZltlXXx8e30pO2ZbZV0ucHVzaChhKTtwKGMsITApJiZ0aGlzLnJlZHJhdyhkKX0sc2hvd0xvYWRpbmc6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWIub3B0aW9ucyxkPWIubG9hZGluZ0RpdixlPWMubG9hZGluZyxmPWZ1bmN0aW9uKCl7ZCYmTShkLHtsZWZ0OmIucGxvdExlZnQrXCJweFwiLHRvcDpiLnBsb3RUb3ArXCJweFwiLHdpZHRoOmIucGxvdFdpZHRoK1wicHhcIixoZWlnaHQ6Yi5wbG90SGVpZ2h0K1wicHhcIn0pfTtpZighZCliLmxvYWRpbmdEaXY9ZD1kYShQYSx7Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1sb2FkaW5nXCJ9LHgoZS5zdHlsZSx7ekluZGV4OjEwLGRpc3BsYXk6XCJub25lXCJ9KSxiLmNvbnRhaW5lciksYi5sb2FkaW5nU3Bhbj1kYShcInNwYW5cIixudWxsLGUubGFiZWxTdHlsZSxkKSxOKGIsXCJyZWRyYXdcIixcbmYpO2IubG9hZGluZ1NwYW4uaW5uZXJIVE1MPWF8fGMubGFuZy5sb2FkaW5nO2lmKCFiLmxvYWRpbmdTaG93bilNKGQse29wYWNpdHk6MCxkaXNwbGF5OlwiXCJ9KSxZYShkLHtvcGFjaXR5OmUuc3R5bGUub3BhY2l0eX0se2R1cmF0aW9uOmUuc2hvd0R1cmF0aW9ufHwwfSksYi5sb2FkaW5nU2hvd249ITA7ZigpfSxoaWRlTG9hZGluZzpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiPXRoaXMubG9hZGluZ0RpdjtiJiZZYShiLHtvcGFjaXR5OjB9LHtkdXJhdGlvbjphLmxvYWRpbmcuaGlkZUR1cmF0aW9ufHwxMDAsY29tcGxldGU6ZnVuY3Rpb24oKXtNKGIse2Rpc3BsYXk6XCJub25lXCJ9KX19KTt0aGlzLmxvYWRpbmdTaG93bj0hMX19KTt4KE1hLnByb3RvdHlwZSx7dXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQpe2Z1bmN0aW9uIGUoKXtmLmFwcGx5T3B0aW9ucyhhKTtpZihmLnk9PT1udWxsJiZoKWYuZ3JhcGhpYz1oLmRlc3Ryb3koKTtpZigkKGEsITApKWYucmVkcmF3PWZ1bmN0aW9uKCl7aWYoaCYmXG5oLmVsZW1lbnQmJmEmJmEubWFya2VyJiZhLm1hcmtlci5zeW1ib2wpZi5ncmFwaGljPWguZGVzdHJveSgpO2lmKGEmJmEuZGF0YUxhYmVscyYmZi5kYXRhTGFiZWwpZi5kYXRhTGFiZWw9Zi5kYXRhTGFiZWwuZGVzdHJveSgpO2YucmVkcmF3PW51bGx9O2k9Zi5pbmRleDtnLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGYsaSk7aWYobCYmZi5uYW1lKWxbZi54XT1mLm5hbWU7ay5kYXRhW2ldPSQoay5kYXRhW2ldLCEwKT9mLm9wdGlvbnM6YTtnLmlzRGlydHk9Zy5pc0RpcnR5RGF0YT0hMDtpZighZy5maXhlZEJveCYmZy5oYXNDYXJ0ZXNpYW5TZXJpZXMpai5pc0RpcnR5Qm94PSEwO2lmKGsubGVnZW5kVHlwZT09PVwicG9pbnRcIilqLmlzRGlydHlMZWdlbmQ9ITA7YiYmai5yZWRyYXcoYyl9dmFyIGY9dGhpcyxnPWYuc2VyaWVzLGg9Zi5ncmFwaGljLGksaj1nLmNoYXJ0LGs9Zy5vcHRpb25zLGw9Zy54QXhpcyYmZy54QXhpcy5uYW1lcyxiPXAoYiwhMCk7ZD09PSExP2UoKTpmLmZpcmVQb2ludEV2ZW50KFwidXBkYXRlXCIsXG57b3B0aW9uczphfSxlKX0scmVtb3ZlOmZ1bmN0aW9uKGEsYil7dGhpcy5zZXJpZXMucmVtb3ZlUG9pbnQocGEodGhpcyx0aGlzLnNlcmllcy5kYXRhKSxhLGIpfX0pO3goUi5wcm90b3R5cGUse2FkZFBvaW50OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMub3B0aW9ucyxmPXRoaXMuZGF0YSxnPXRoaXMuY2hhcnQsaD10aGlzLnhBeGlzJiZ0aGlzLnhBeGlzLm5hbWVzLGk9ZS5kYXRhLGosaz10aGlzLnhEYXRhLGwsbTtWYShkLGcpO2I9cChiLCEwKTtkPXtzZXJpZXM6dGhpc307dGhpcy5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkoZCxbYV0pO209ZC54O2w9ay5sZW5ndGg7aWYodGhpcy5yZXF1aXJlU29ydGluZyYmbTxrW2wtMV0pZm9yKGo9ITA7bCYma1tsLTFdPm07KWwtLTt0aGlzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGQsXCJzcGxpY2VcIixsLDAsMCk7dGhpcy51cGRhdGVQYXJhbGxlbEFycmF5cyhkLGwpO2lmKGgmJmQubmFtZSloW21dPWQubmFtZTtcbmkuc3BsaWNlKGwsMCxhKTtqJiYodGhpcy5kYXRhLnNwbGljZShsLDAsbnVsbCksdGhpcy5wcm9jZXNzRGF0YSgpKTtlLmxlZ2VuZFR5cGU9PT1cInBvaW50XCImJnRoaXMuZ2VuZXJhdGVQb2ludHMoKTtjJiYoZlswXSYmZlswXS5yZW1vdmU/ZlswXS5yZW1vdmUoITEpOihmLnNoaWZ0KCksdGhpcy51cGRhdGVQYXJhbGxlbEFycmF5cyhkLFwic2hpZnRcIiksaS5zaGlmdCgpKSk7dGhpcy5pc0RpcnR5RGF0YT10aGlzLmlzRGlydHk9ITA7YiYmKHRoaXMuZ2V0QXR0cmlicygpLGcucmVkcmF3KCkpfSxyZW1vdmVQb2ludDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcyxlPWQuZGF0YSxmPWVbYV0sZz1kLnBvaW50cyxoPWQuY2hhcnQsaT1mdW5jdGlvbigpe2cmJmcubGVuZ3RoPT09ZS5sZW5ndGgmJmcuc3BsaWNlKGEsMSk7ZS5zcGxpY2UoYSwxKTtkLm9wdGlvbnMuZGF0YS5zcGxpY2UoYSwxKTtkLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGZ8fHtzZXJpZXM6ZH0sXCJzcGxpY2VcIixhLDEpO2YmJlxuZi5kZXN0cm95KCk7ZC5pc0RpcnR5PSEwO2QuaXNEaXJ0eURhdGE9ITA7YiYmaC5yZWRyYXcoKX07VmEoYyxoKTtiPXAoYiwhMCk7Zj9mLmZpcmVQb2ludEV2ZW50KFwicmVtb3ZlXCIsbnVsbCxpKTppKCl9LHJlbW92ZTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1jLmNoYXJ0O0koYyxcInJlbW92ZVwiLG51bGwsZnVuY3Rpb24oKXtjLmRlc3Ryb3koKTtkLmlzRGlydHlMZWdlbmQ9ZC5pc0RpcnR5Qm94PSEwO2QubGlua1NlcmllcygpO3AoYSwhMCkmJmQucmVkcmF3KGIpfSl9LHVwZGF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD10aGlzLmNoYXJ0LGU9dGhpcy51c2VyT3B0aW9ucyxmPXRoaXMudHlwZSxnPUxbZl0ucHJvdG90eXBlLGg9W1wiZ3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIl0saTtpZihhLnR5cGUmJmEudHlwZSE9PWZ8fGEuekluZGV4IT09dm9pZCAwKWgubGVuZ3RoPTA7cShoLGZ1bmN0aW9uKGEpe2hbYV09Y1thXTtkZWxldGUgY1thXX0pO1xuYT1FKGUse2FuaW1hdGlvbjohMSxpbmRleDp0aGlzLmluZGV4LHBvaW50U3RhcnQ6dGhpcy54RGF0YVswXX0se2RhdGE6dGhpcy5vcHRpb25zLmRhdGF9LGEpO3RoaXMucmVtb3ZlKCExKTtmb3IoaSBpbiBnKXRoaXNbaV09QTt4KHRoaXMsTFthLnR5cGV8fGZdLnByb3RvdHlwZSk7cShoLGZ1bmN0aW9uKGEpe2NbYV09aFthXX0pO3RoaXMuaW5pdChkLGEpO2QubGlua1NlcmllcygpO3AoYiwhMCkmJmQucmVkcmF3KCExKX19KTt4KGlhLnByb3RvdHlwZSx7dXBkYXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jaGFydCxhPWMub3B0aW9uc1t0aGlzLmNvbGxdW3RoaXMub3B0aW9ucy5pbmRleF09RSh0aGlzLnVzZXJPcHRpb25zLGEpO3RoaXMuZGVzdHJveSghMCk7dGhpcy5pbml0KGMseChhLHtldmVudHM6QX0pKTtjLmlzRGlydHlCb3g9ITA7cChiLCEwKSYmYy5yZWRyYXcoKX0scmVtb3ZlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmNoYXJ0LGM9dGhpcy5jb2xsLGQ9dGhpcy5zZXJpZXMsXG5lPWQubGVuZ3RoO2UtLTspZFtlXSYmZFtlXS5yZW1vdmUoITEpO3JhKGIuYXhlcyx0aGlzKTtyYShiW2NdLHRoaXMpO2Iub3B0aW9uc1tjXS5zcGxpY2UodGhpcy5vcHRpb25zLmluZGV4LDEpO3EoYltjXSxmdW5jdGlvbihhLGIpe2Eub3B0aW9ucy5pbmRleD1ifSk7dGhpcy5kZXN0cm95KCk7Yi5pc0RpcnR5Qm94PSEwO3AoYSwhMCkmJmIucmVkcmF3KCl9LHNldFRpdGxlOmZ1bmN0aW9uKGEsYil7dGhpcy51cGRhdGUoe3RpdGxlOmF9LGIpfSxzZXRDYXRlZ29yaWVzOmZ1bmN0aW9uKGEsYil7dGhpcy51cGRhdGUoe2NhdGVnb3JpZXM6YX0sYil9fSk7dmFyIHhhPXNhKFIpO0wubGluZT14YTtmYS5hcmVhPUUoaGEse3NvZnRUaHJlc2hvbGQ6ITEsdGhyZXNob2xkOjB9KTt2YXIgcWE9c2EoUix7dHlwZTpcImFyZWFcIixzaW5nbGVTdGFja3M6ITEsZ2V0U3RhY2tQb2ludHM6ZnVuY3Rpb24oKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy54QXhpcyxkPXRoaXMueUF4aXMsZT1kLnN0YWNrc1t0aGlzLnN0YWNrS2V5XSxcbmY9e30sZz10aGlzLnBvaW50cyxoPXRoaXMuaW5kZXgsaT1kLnNlcmllcyxqPWkubGVuZ3RoLGssbD1wKGQub3B0aW9ucy5yZXZlcnNlZFN0YWNrcywhMCk/MTotMSxtLG47aWYodGhpcy5vcHRpb25zLnN0YWNraW5nKXtmb3IobT0wO208Zy5sZW5ndGg7bSsrKWZbZ1ttXS54XT1nW21dO2ZvcihuIGluIGUpZVtuXS50b3RhbCE9PW51bGwmJmIucHVzaChuKTtiLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS1ifSk7az1EYShpLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlzaWJsZX0pO3EoYixmdW5jdGlvbihnLGkpe3ZhciBuPTAscCxzO2lmKGZbZ10mJiFmW2ddLmlzTnVsbClhLnB1c2goZltnXSkscShbLTEsMV0sZnVuY3Rpb24oYSl7dmFyIGM9YT09PTE/XCJyaWdodE51bGxcIjpcImxlZnROdWxsXCIsZD0wLG49ZVtiW2krYV1dO2lmKG4pZm9yKG09aDttPj0wJiZtPGo7KXA9bi5wb2ludHNbbV0scHx8KG09PT1oP2ZbZ11bY109ITA6a1ttXSYmKHM9ZVtnXS5wb2ludHNbbV0pJiYoZC09XG5zWzFdLXNbMF0pKSxtKz1sO2ZbZ11bYT09PTE/XCJyaWdodENsaWZmXCI6XCJsZWZ0Q2xpZmZcIl09ZH0pO2Vsc2V7Zm9yKG09aDttPj0wJiZtPGo7KXtpZihwPWVbZ10ucG9pbnRzW21dKXtuPXBbMV07YnJlYWt9bSs9bH1uPWQudG9QaXhlbHMobiwhMCk7YS5wdXNoKHtpc051bGw6ITAscGxvdFg6Yy50b1BpeGVscyhnLCEwKSxwbG90WTpuLHlCb3R0b206bn0pfX0pfXJldHVybiBhfSxnZXRHcmFwaFBhdGg6ZnVuY3Rpb24oYSl7dmFyIGI9Ui5wcm90b3R5cGUuZ2V0R3JhcGhQYXRoLGM9dGhpcy5vcHRpb25zLGQ9Yy5zdGFja2luZyxlPXRoaXMueUF4aXMsZixnLGg9W10saT1bXSxqPXRoaXMuaW5kZXgsayxsPWUuc3RhY2tzW3RoaXMuc3RhY2tLZXldLG09Yy50aHJlc2hvbGQsbj1lLmdldFRocmVzaG9sZChjLnRocmVzaG9sZCksbyxjPWMuY29ubmVjdE51bGxzfHxkPT09XCJwZXJjZW50XCIscT1mdW5jdGlvbihiLGMsZil7dmFyIGc9YVtiXSxiPWQmJmxbZy54XS5wb2ludHNbal0sbz1nW2YrXG5cIk51bGxcIl18fDAsZj1nW2YrXCJDbGlmZlwiXXx8MCxwLHEsZz0hMDtmfHxvPyhwPShvP2JbMF06YlsxXSkrZixxPWJbMF0rZixnPSEhbyk6IWQmJmFbY10mJmFbY10uaXNOdWxsJiYocD1xPW0pO3AhPT12b2lkIDAmJihpLnB1c2goe3Bsb3RYOmsscGxvdFk6cD09PW51bGw/bjplLmdldFRocmVzaG9sZChwKSxpc051bGw6Z30pLGgucHVzaCh7cGxvdFg6ayxwbG90WTpxPT09bnVsbD9uOmUuZ2V0VGhyZXNob2xkKHEpfSkpfSxhPWF8fHRoaXMucG9pbnRzO2QmJihhPXRoaXMuZ2V0U3RhY2tQb2ludHMoKSk7Zm9yKGY9MDtmPGEubGVuZ3RoO2YrKylpZihnPWFbZl0uaXNOdWxsLGs9cChhW2ZdLnJlY3RQbG90WCxhW2ZdLnBsb3RYKSxvPXAoYVtmXS55Qm90dG9tLG4pLCFnfHxjKXtjfHxxKGYsZi0xLFwibGVmdFwiKTtpZighZ3x8ZHx8IWMpaS5wdXNoKGFbZl0pLGgucHVzaCh7eDpmLHBsb3RYOmsscGxvdFk6b30pO2N8fHEoZixmKzEsXCJyaWdodFwiKX1mPWIuY2FsbCh0aGlzLGksITAsITApO1xuaC5yZXZlcnNlZD0hMDtnPWIuY2FsbCh0aGlzLGgsITAsITApO2cubGVuZ3RoJiYoZ1swXT1TKTtnPWYuY29uY2F0KGcpO2I9Yi5jYWxsKHRoaXMsaSwhMSxjKTtnLnhNYXA9Zi54TWFwO3RoaXMuYXJlYVBhdGg9ZztyZXR1cm4gYn0sZHJhd0dyYXBoOmZ1bmN0aW9uKCl7dGhpcy5hcmVhUGF0aD1bXTtSLnByb3RvdHlwZS5kcmF3R3JhcGguYXBwbHkodGhpcyk7dmFyIGE9dGhpcyxiPXRoaXMuYXJlYVBhdGgsYz10aGlzLm9wdGlvbnMsZD1bW1wiYXJlYVwiLHRoaXMuY29sb3IsYy5maWxsQ29sb3JdXTtxKHRoaXMuem9uZXMsZnVuY3Rpb24oYixmKXtkLnB1c2goW1wiem9uZUFyZWFcIitmLGIuY29sb3J8fGEuY29sb3IsYi5maWxsQ29sb3J8fGMuZmlsbENvbG9yXSl9KTtxKGQsZnVuY3Rpb24oZCl7dmFyIGY9ZFswXSxnPWFbZl07Zz8oZy5lbmRYPWIueE1hcCxnLmFuaW1hdGUoe2Q6Yn0pKTooZz17ZmlsbDpkWzJdfHxkWzFdLHpJbmRleDowfSxkWzJdfHwoZ1tcImZpbGwtb3BhY2l0eVwiXT1wKGMuZmlsbE9wYWNpdHksXG4wLjc1KSksZz1hW2ZdPWEuY2hhcnQucmVuZGVyZXIucGF0aChiKS5hdHRyKGcpLmFkZChhLmdyb3VwKSxnLmlzQXJlYT0hMCk7Zy5zdGFydFg9Yi54TWFwO2cuc2hpZnRVbml0PWMuc3RlcD8yOjF9KX0sZHJhd0xlZ2VuZFN5bWJvbDpLLmRyYXdSZWN0YW5nbGV9KTtMLmFyZWE9cWE7ZmEuc3BsaW5lPUUoaGEpO3hhPXNhKFIse3R5cGU6XCJzcGxpbmVcIixnZXRQb2ludFNwbGluZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9Yi5wbG90WCxlPWIucGxvdFksZj1hW2MtMV0sYz1hW2MrMV0sZyxoLGksajtpZihmJiYhZi5pc051bGwmJmMmJiFjLmlzTnVsbCl7YT1mLnBsb3RZO2k9Yy5wbG90WDt2YXIgYz1jLnBsb3RZLGs9MDtnPSgxLjUqZCtmLnBsb3RYKS8yLjU7aD0oMS41KmUrYSkvMi41O2k9KDEuNSpkK2kpLzIuNTtqPSgxLjUqZStjKS8yLjU7aSE9PWcmJihrPShqLWgpKihpLWQpLyhpLWcpK2Utaik7aCs9aztqKz1rO2g+YSYmaD5lPyhoPXQoYSxlKSxqPTIqZS1oKTpoPGEmJmg8ZSYmKGg9XG5GKGEsZSksaj0yKmUtaCk7aj5jJiZqPmU/KGo9dChjLGUpLGg9MiplLWopOmo8YyYmajxlJiYoaj1GKGMsZSksaD0yKmUtaik7Yi5yaWdodENvbnRYPWk7Yi5yaWdodENvbnRZPWp9Yj1bXCJDXCIscChmLnJpZ2h0Q29udFgsZi5wbG90WCkscChmLnJpZ2h0Q29udFksZi5wbG90WSkscChnLGQpLHAoaCxlKSxkLGVdO2YucmlnaHRDb250WD1mLnJpZ2h0Q29udFk9bnVsbDtyZXR1cm4gYn19KTtMLnNwbGluZT14YTtmYS5hcmVhc3BsaW5lPUUoZmEuYXJlYSk7cWE9cWEucHJvdG90eXBlO3hhPXNhKHhhLHt0eXBlOlwiYXJlYXNwbGluZVwiLGdldFN0YWNrUG9pbnRzOnFhLmdldFN0YWNrUG9pbnRzLGdldEdyYXBoUGF0aDpxYS5nZXRHcmFwaFBhdGgsc2V0U3RhY2tDbGlmZnM6cWEuc2V0U3RhY2tDbGlmZnMsZHJhd0dyYXBoOnFhLmRyYXdHcmFwaCxkcmF3TGVnZW5kU3ltYm9sOksuZHJhd1JlY3RhbmdsZX0pO0wuYXJlYXNwbGluZT14YTtmYS5jb2x1bW49RShoYSx7Ym9yZGVyQ29sb3I6XCIjRkZGRkZGXCIsXG5ib3JkZXJSYWRpdXM6MCxncm91cFBhZGRpbmc6MC4yLG1hcmtlcjpudWxsLHBvaW50UGFkZGluZzowLjEsbWluUG9pbnRMZW5ndGg6MCxjcm9wVGhyZXNob2xkOjUwLHBvaW50UmFuZ2U6bnVsbCxzdGF0ZXM6e2hvdmVyOnticmlnaHRuZXNzOjAuMSxzaGFkb3c6ITEsaGFsbzohMX0sc2VsZWN0Ontjb2xvcjpcIiNDMEMwQzBcIixib3JkZXJDb2xvcjpcIiMwMDAwMDBcIixzaGFkb3c6ITF9fSxkYXRhTGFiZWxzOnthbGlnbjpudWxsLHZlcnRpY2FsQWxpZ246bnVsbCx5Om51bGx9LHNvZnRUaHJlc2hvbGQ6ITEsc3RhcnRGcm9tVGhyZXNob2xkOiEwLHN0aWNreVRyYWNraW5nOiExLHRvb2x0aXA6e2Rpc3RhbmNlOjZ9LHRocmVzaG9sZDowfSk7eGE9c2EoUix7dHlwZTpcImNvbHVtblwiLHBvaW50QXR0clRvT3B0aW9uczp7c3Ryb2tlOlwiYm9yZGVyQ29sb3JcIixmaWxsOlwiY29sb3JcIixyOlwiYm9yZGVyUmFkaXVzXCJ9LGNyb3BTaG91bGRlcjowLGRpcmVjdFRvdWNoOiEwLHRyYWNrZXJHcm91cHM6W1wiZ3JvdXBcIixcblwiZGF0YUxhYmVsc0dyb3VwXCJdLG5lZ1N0YWNrczohMCxpbml0OmZ1bmN0aW9uKCl7Ui5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGE9dGhpcyxiPWEuY2hhcnQ7Yi5oYXNSZW5kZXJlZCYmcShiLnNlcmllcyxmdW5jdGlvbihiKXtpZihiLnR5cGU9PT1hLnR5cGUpYi5pc0RpcnR5PSEwfSl9LGdldENvbHVtbk1ldHJpY3M6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5vcHRpb25zLGM9YS54QXhpcyxkPWEueUF4aXMsZT1jLnJldmVyc2VkLGYsZz17fSxoPTA7Yi5ncm91cGluZz09PSExP2g9MTpxKGEuY2hhcnQuc2VyaWVzLGZ1bmN0aW9uKGIpe3ZhciBjPWIub3B0aW9ucyxlPWIueUF4aXMsaTtpZihiLnR5cGU9PT1hLnR5cGUmJmIudmlzaWJsZSYmZC5sZW49PT1lLmxlbiYmZC5wb3M9PT1lLnBvcyljLnN0YWNraW5nPyhmPWIuc3RhY2tLZXksZ1tmXT09PUEmJihnW2ZdPWgrKyksaT1nW2ZdKTpjLmdyb3VwaW5nIT09ITEmJihpPWgrKyksYi5jb2x1bW5JbmRleD1cbml9KTt2YXIgaT1GKFEoYy50cmFuc0EpKihjLm9yZGluYWxTbG9wZXx8Yi5wb2ludFJhbmdlfHxjLmNsb3Nlc3RQb2ludFJhbmdlfHxjLnRpY2tJbnRlcnZhbHx8MSksYy5sZW4pLGo9aSpiLmdyb3VwUGFkZGluZyxrPShpLTIqaikvaCxiPUYoYi5tYXhQb2ludFdpZHRofHxjLmxlbixwKGIucG9pbnRXaWR0aCxrKigxLTIqYi5wb2ludFBhZGRpbmcpKSk7YS5jb2x1bW5NZXRyaWNzPXt3aWR0aDpiLG9mZnNldDooay1iKS8yKyhqKygoYS5jb2x1bW5JbmRleHx8MCkrKGU/MTowKSkqay1pLzIpKihlPy0xOjEpfTtyZXR1cm4gYS5jb2x1bW5NZXRyaWNzfSxjcmlzcENvbDpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmNoYXJ0LGY9dGhpcy5ib3JkZXJXaWR0aCxnPS0oZiUyPzAuNTowKSxmPWYlMj8wLjU6MTtlLmludmVydGVkJiZlLnJlbmRlcmVyLmlzVk1MJiYoZis9MSk7Yz1NYXRoLnJvdW5kKGErYykrZzthPU1hdGgucm91bmQoYSkrZztjLT1hO2Q9TWF0aC5yb3VuZChiK2QpK1xuZjtnPVEoYik8PTAuNSYmZD4wLjU7Yj1NYXRoLnJvdW5kKGIpK2Y7ZC09YjtnJiZkJiYoYi09MSxkKz0xKTtyZXR1cm57eDphLHk6Yix3aWR0aDpjLGhlaWdodDpkfX0sdHJhbnNsYXRlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY2hhcnQsYz1hLm9wdGlvbnMsZD1hLmJvcmRlcldpZHRoPXAoYy5ib3JkZXJXaWR0aCxhLmNsb3Nlc3RQb2ludFJhbmdlKmEueEF4aXMudHJhbnNBPDI/MDoxKSxlPWEueUF4aXMsZj1hLnRyYW5zbGF0ZWRUaHJlc2hvbGQ9ZS5nZXRUaHJlc2hvbGQoYy50aHJlc2hvbGQpLGc9cChjLm1pblBvaW50TGVuZ3RoLDUpLGg9YS5nZXRDb2x1bW5NZXRyaWNzKCksaT1oLndpZHRoLGo9YS5iYXJXPXQoaSwxKzIqZCksaz1hLnBvaW50WE9mZnNldD1oLm9mZnNldDtiLmludmVydGVkJiYoZi09MC41KTtjLnBvaW50UGFkZGluZyYmKGo9dmEoaikpO1IucHJvdG90eXBlLnRyYW5zbGF0ZS5hcHBseShhKTtxKGEucG9pbnRzLGZ1bmN0aW9uKGMpe3ZhciBkPUYocChjLnlCb3R0b20sXG5mKSw5RTQpLGg9OTk5K1EoZCksaD1GKHQoLWgsYy5wbG90WSksZS5sZW4raCksbz1jLnBsb3RYK2sscT1qLHI9RihoLGQpLHMsdz10KGgsZCktcjtRKHcpPGcmJmcmJih3PWcscz0hZS5yZXZlcnNlZCYmIWMubmVnYXRpdmV8fGUucmV2ZXJzZWQmJmMubmVnYXRpdmUscj1RKHItZik+Zz9kLWc6Zi0ocz9nOjApKTtjLmJhclg9bztjLnBvaW50V2lkdGg9aTtjLnRvb2x0aXBQb3M9Yi5pbnZlcnRlZD9bZS5sZW4rZS5wb3MtYi5wbG90TGVmdC1oLGEueEF4aXMubGVuLW8tcS8yLHddOltvK3EvMixoK2UucG9zLWIucGxvdFRvcCx3XTtjLnNoYXBlVHlwZT1cInJlY3RcIjtjLnNoYXBlQXJncz1hLmNyaXNwQ29sKG8scixxLHcpfSl9LGdldFN5bWJvbDpCYSxkcmF3TGVnZW5kU3ltYm9sOksuZHJhd1JlY3RhbmdsZSxkcmF3R3JhcGg6QmEsZHJhd1BvaW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLmNoYXJ0LGM9YS5vcHRpb25zLGQ9Yi5yZW5kZXJlcixlPWMuYW5pbWF0aW9uTGltaXR8fFxuMjUwLGYsZztxKGEucG9pbnRzLGZ1bmN0aW9uKGgpe3ZhciBpPWguZ3JhcGhpYyxqO2lmKEooaC5wbG90WSkmJmgueSE9PW51bGwpZj1oLnNoYXBlQXJncyxqPXMoYS5ib3JkZXJXaWR0aCk/e1wic3Ryb2tlLXdpZHRoXCI6YS5ib3JkZXJXaWR0aH06e30sZz1oLnBvaW50QXR0cltoLnNlbGVjdGVkP1wic2VsZWN0XCI6XCJcIl18fGEucG9pbnRBdHRyW1wiXCJdLGk/KEthKGkpLGkuYXR0cihqKS5hdHRyKGcpW2IucG9pbnRDb3VudDxlP1wiYW5pbWF0ZVwiOlwiYXR0clwiXShFKGYpKSk6aC5ncmFwaGljPWRbaC5zaGFwZVR5cGVdKGYpLmF0dHIoaikuYXR0cihnKS5hZGQoaC5ncm91cHx8YS5ncm91cCkuc2hhZG93KGMuc2hhZG93LG51bGwsYy5zdGFja2luZyYmIWMuYm9yZGVyUmFkaXVzKTtlbHNlIGlmKGkpaC5ncmFwaGljPWkuZGVzdHJveSgpfSl9LGFuaW1hdGU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMueUF4aXMsZD1iLm9wdGlvbnMsZT10aGlzLmNoYXJ0LmludmVydGVkLGY9e307aWYoZ2EpYT9cbihmLnNjYWxlWT0wLjAwMSxhPUYoYy5wb3MrYy5sZW4sdChjLnBvcyxjLnRvUGl4ZWxzKGQudGhyZXNob2xkKSkpLGU/Zi50cmFuc2xhdGVYPWEtYy5sZW46Zi50cmFuc2xhdGVZPWEsYi5ncm91cC5hdHRyKGYpKTooZltlP1widHJhbnNsYXRlWFwiOlwidHJhbnNsYXRlWVwiXT1jLnBvcyxiLmdyb3VwLmFuaW1hdGUoZix4KGJiKGIub3B0aW9ucy5hbmltYXRpb24pLHtzdGVwOmZ1bmN0aW9uKGEsYyl7Yi5ncm91cC5hdHRyKHtzY2FsZVk6dCgwLjAwMSxjLnBvcyl9KX19KSksYi5hbmltYXRlPW51bGwpfSxyZW1vdmU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydDtiLmhhc1JlbmRlcmVkJiZxKGIuc2VyaWVzLGZ1bmN0aW9uKGIpe2lmKGIudHlwZT09PWEudHlwZSliLmlzRGlydHk9ITB9KTtSLnByb3RvdHlwZS5yZW1vdmUuYXBwbHkoYSxhcmd1bWVudHMpfX0pO0wuY29sdW1uPXhhO2ZhLmJhcj1FKGZhLmNvbHVtbik7cWE9c2EoeGEse3R5cGU6XCJiYXJcIixpbnZlcnRlZDohMH0pO1xuTC5iYXI9cWE7ZmEuc2NhdHRlcj1FKGhhLHtsaW5lV2lkdGg6MCxtYXJrZXI6e2VuYWJsZWQ6ITB9LHRvb2x0aXA6e2hlYWRlckZvcm1hdDonPHNwYW4gc3R5bGU9XCJjb2xvcjp7cG9pbnQuY29sb3J9XCI+XFx1MjVjZjwvc3Bhbj4gPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEwcHg7XCI+IHtzZXJpZXMubmFtZX08L3NwYW4+PGJyLz4nLHBvaW50Rm9ybWF0OlwieDogPGI+e3BvaW50Lnh9PC9iPjxici8+eTogPGI+e3BvaW50Lnl9PC9iPjxici8+XCJ9fSk7cWE9c2EoUix7dHlwZTpcInNjYXR0ZXJcIixzb3J0ZWQ6ITEscmVxdWlyZVNvcnRpbmc6ITEsbm9TaGFyZWRUb29sdGlwOiEwLHRyYWNrZXJHcm91cHM6W1wiZ3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIl0sdGFrZU9yZGluYWxQb3NpdGlvbjohMSxrZERpbWVuc2lvbnM6MixkcmF3R3JhcGg6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMubGluZVdpZHRoJiZSLnByb3RvdHlwZS5kcmF3R3JhcGguY2FsbCh0aGlzKX19KTtMLnNjYXR0ZXI9XG5xYTtmYS5waWU9RShoYSx7Ym9yZGVyQ29sb3I6XCIjRkZGRkZGXCIsYm9yZGVyV2lkdGg6MSxjZW50ZXI6W251bGwsbnVsbF0sY2xpcDohMSxjb2xvckJ5UG9pbnQ6ITAsZGF0YUxhYmVsczp7ZGlzdGFuY2U6MzAsZW5hYmxlZDohMCxmb3JtYXR0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy55PT09bnVsbD92b2lkIDA6dGhpcy5wb2ludC5uYW1lfSx4OjB9LGlnbm9yZUhpZGRlblBvaW50OiEwLGxlZ2VuZFR5cGU6XCJwb2ludFwiLG1hcmtlcjpudWxsLHNpemU6bnVsbCxzaG93SW5MZWdlbmQ6ITEsc2xpY2VkT2Zmc2V0OjEwLHN0YXRlczp7aG92ZXI6e2JyaWdodG5lc3M6MC4xLHNoYWRvdzohMX19LHN0aWNreVRyYWNraW5nOiExLHRvb2x0aXA6e2ZvbGxvd1BvaW50ZXI6ITB9fSk7aGE9e3R5cGU6XCJwaWVcIixpc0NhcnRlc2lhbjohMSxwb2ludENsYXNzOnNhKE1hLHtpbml0OmZ1bmN0aW9uKCl7TWEucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBhPXRoaXMsYjtcbmEubmFtZT1wKGEubmFtZSxcIlNsaWNlXCIpO2I9ZnVuY3Rpb24oYil7YS5zbGljZShiLnR5cGU9PT1cInNlbGVjdFwiKX07TihhLFwic2VsZWN0XCIsYik7TihhLFwidW5zZWxlY3RcIixiKTtyZXR1cm4gYX0sc2V0VmlzaWJsZTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1jLnNlcmllcyxlPWQuY2hhcnQsZj1kLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQsYj1wKGIsZik7aWYoYSE9PWMudmlzaWJsZSl7Yy52aXNpYmxlPWMub3B0aW9ucy52aXNpYmxlPWE9YT09PUE/IWMudmlzaWJsZTphO2Qub3B0aW9ucy5kYXRhW3BhKGMsZC5kYXRhKV09Yy5vcHRpb25zO3EoW1wiZ3JhcGhpY1wiLFwiZGF0YUxhYmVsXCIsXCJjb25uZWN0b3JcIixcInNoYWRvd0dyb3VwXCJdLGZ1bmN0aW9uKGIpe2lmKGNbYl0pY1tiXVthP1wic2hvd1wiOlwiaGlkZVwiXSghMCl9KTtjLmxlZ2VuZEl0ZW0mJmUubGVnZW5kLmNvbG9yaXplSXRlbShjLGEpOyFhJiZjLnN0YXRlPT09XCJob3ZlclwiJiZjLnNldFN0YXRlKFwiXCIpO2lmKGYpZC5pc0RpcnR5PVxuITA7YiYmZS5yZWRyYXcoKX19LHNsaWNlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLnNlcmllcztWYShjLGQuY2hhcnQpO3AoYiwhMCk7dGhpcy5zbGljZWQ9dGhpcy5vcHRpb25zLnNsaWNlZD1hPXMoYSk/YTohdGhpcy5zbGljZWQ7ZC5vcHRpb25zLmRhdGFbcGEodGhpcyxkLmRhdGEpXT10aGlzLm9wdGlvbnM7YT1hP3RoaXMuc2xpY2VkVHJhbnNsYXRpb246e3RyYW5zbGF0ZVg6MCx0cmFuc2xhdGVZOjB9O3RoaXMuZ3JhcGhpYy5hbmltYXRlKGEpO3RoaXMuc2hhZG93R3JvdXAmJnRoaXMuc2hhZG93R3JvdXAuYW5pbWF0ZShhKX0saGFsb1BhdGg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zaGFwZUFyZ3MsYz10aGlzLnNlcmllcy5jaGFydDtyZXR1cm4gdGhpcy5zbGljZWR8fCF0aGlzLnZpc2libGU/W106dGhpcy5zZXJpZXMuY2hhcnQucmVuZGVyZXIuc3ltYm9scy5hcmMoYy5wbG90TGVmdCtiLngsYy5wbG90VG9wK2IueSxiLnIrYSxiLnIrYSx7aW5uZXJSOnRoaXMuc2hhcGVBcmdzLnIsXG5zdGFydDpiLnN0YXJ0LGVuZDpiLmVuZH0pfX0pLHJlcXVpcmVTb3J0aW5nOiExLGRpcmVjdFRvdWNoOiEwLG5vU2hhcmVkVG9vbHRpcDohMCx0cmFja2VyR3JvdXBzOltcImdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIl0sYXhpc1R5cGVzOltdLHBvaW50QXR0clRvT3B0aW9uczp7c3Ryb2tlOlwiYm9yZGVyQ29sb3JcIixcInN0cm9rZS13aWR0aFwiOlwiYm9yZGVyV2lkdGhcIixmaWxsOlwiY29sb3JcIn0sYW5pbWF0ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9Yi5wb2ludHMsZD1iLnN0YXJ0QW5nbGVSYWQ7aWYoIWEpcShjLGZ1bmN0aW9uKGEpe3ZhciBjPWEuZ3JhcGhpYyxnPWEuc2hhcGVBcmdzO2MmJihjLmF0dHIoe3I6YS5zdGFydFJ8fGIuY2VudGVyWzNdLzIsc3RhcnQ6ZCxlbmQ6ZH0pLGMuYW5pbWF0ZSh7cjpnLnIsc3RhcnQ6Zy5zdGFydCxlbmQ6Zy5lbmR9LGIub3B0aW9ucy5hbmltYXRpb24pKX0pLGIuYW5pbWF0ZT1udWxsfSx1cGRhdGVUb3RhbHM6ZnVuY3Rpb24oKXt2YXIgYSxiPTAsXG5jPXRoaXMucG9pbnRzLGQ9Yy5sZW5ndGgsZSxmPXRoaXMub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtmb3IoYT0wO2E8ZDthKyspe2U9Y1thXTtpZihlLnk8MCllLnk9bnVsbDtiKz1mJiYhZS52aXNpYmxlPzA6ZS55fXRoaXMudG90YWw9Yjtmb3IoYT0wO2E8ZDthKyspZT1jW2FdLGUucGVyY2VudGFnZT1iPjAmJihlLnZpc2libGV8fCFmKT9lLnkvYioxMDA6MCxlLnRvdGFsPWJ9LGdlbmVyYXRlUG9pbnRzOmZ1bmN0aW9uKCl7Ui5wcm90b3R5cGUuZ2VuZXJhdGVQb2ludHMuY2FsbCh0aGlzKTt0aGlzLnVwZGF0ZVRvdGFscygpfSx0cmFuc2xhdGU6ZnVuY3Rpb24oYSl7dGhpcy5nZW5lcmF0ZVBvaW50cygpO3ZhciBiPTAsYz10aGlzLm9wdGlvbnMsZD1jLnNsaWNlZE9mZnNldCxlPWQrYy5ib3JkZXJXaWR0aCxmLGcsaCxpPWMuc3RhcnRBbmdsZXx8MCxqPXRoaXMuc3RhcnRBbmdsZVJhZD10YS8xODAqKGktOTApLGk9KHRoaXMuZW5kQW5nbGVSYWQ9dGEvMTgwKihwKGMuZW5kQW5nbGUsXG5pKzM2MCktOTApKS1qLGs9dGhpcy5wb2ludHMsbD1jLmRhdGFMYWJlbHMuZGlzdGFuY2UsYz1jLmlnbm9yZUhpZGRlblBvaW50LG0sbj1rLmxlbmd0aCxvO2lmKCFhKXRoaXMuY2VudGVyPWE9dGhpcy5nZXRDZW50ZXIoKTt0aGlzLmdldFg9ZnVuY3Rpb24oYixjKXtoPVouYXNpbihGKChiLWFbMV0pLyhhWzJdLzIrbCksMSkpO3JldHVybiBhWzBdKyhjPy0xOjEpKlcoaCkqKGFbMl0vMitsKX07Zm9yKG09MDttPG47bSsrKXtvPWtbbV07Zj1qK2IqaTtpZighY3x8by52aXNpYmxlKWIrPW8ucGVyY2VudGFnZS8xMDA7Zz1qK2IqaTtvLnNoYXBlVHlwZT1cImFyY1wiO28uc2hhcGVBcmdzPXt4OmFbMF0seTphWzFdLHI6YVsyXS8yLGlubmVyUjphWzNdLzIsc3RhcnQ6QyhmKjFFMykvMUUzLGVuZDpDKGcqMUUzKS8xRTN9O2g9KGcrZikvMjtoPjEuNSp0YT9oLT0yKnRhOmg8LXRhLzImJihoKz0yKnRhKTtvLnNsaWNlZFRyYW5zbGF0aW9uPXt0cmFuc2xhdGVYOkMoVyhoKSpkKSx0cmFuc2xhdGVZOkMoZWEoaCkqXG5kKX07Zj1XKGgpKmFbMl0vMjtnPWVhKGgpKmFbMl0vMjtvLnRvb2x0aXBQb3M9W2FbMF0rZiowLjcsYVsxXStnKjAuN107by5oYWxmPWg8LXRhLzJ8fGg+dGEvMj8xOjA7by5hbmdsZT1oO2U9RihlLGwvMik7by5sYWJlbFBvcz1bYVswXStmK1coaCkqbCxhWzFdK2crZWEoaCkqbCxhWzBdK2YrVyhoKSplLGFbMV0rZytlYShoKSplLGFbMF0rZixhWzFdK2csbDwwP1wiY2VudGVyXCI6by5oYWxmP1wicmlnaHRcIjpcImxlZnRcIixoXX19LGRyYXdHcmFwaDpudWxsLGRyYXdQb2ludHM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydC5yZW5kZXJlcixjLGQsZT1hLm9wdGlvbnMuc2hhZG93LGYsZyxoLGk7aWYoZSYmIWEuc2hhZG93R3JvdXApYS5zaGFkb3dHcm91cD1iLmcoXCJzaGFkb3dcIikuYWRkKGEuZ3JvdXApO3EoYS5wb2ludHMsZnVuY3Rpb24oail7aWYoai55IT09bnVsbCl7ZD1qLmdyYXBoaWM7aD1qLnNoYXBlQXJncztmPWouc2hhZG93R3JvdXA7Zz1qLnBvaW50QXR0cltqLnNlbGVjdGVkP1xuXCJzZWxlY3RcIjpcIlwiXTtpZighZy5zdHJva2UpZy5zdHJva2U9Zy5maWxsO2lmKGUmJiFmKWY9ai5zaGFkb3dHcm91cD1iLmcoXCJzaGFkb3dcIikuYWRkKGEuc2hhZG93R3JvdXApO2M9ai5zbGljZWQ/ai5zbGljZWRUcmFuc2xhdGlvbjp7dHJhbnNsYXRlWDowLHRyYW5zbGF0ZVk6MH07ZiYmZi5hdHRyKGMpO2lmKGQpZC5zZXRSYWRpYWxSZWZlcmVuY2UoYS5jZW50ZXIpLmF0dHIoZykuYW5pbWF0ZSh4KGgsYykpO2Vsc2V7aT17XCJzdHJva2UtbGluZWpvaW5cIjpcInJvdW5kXCJ9O2lmKCFqLnZpc2libGUpaS52aXNpYmlsaXR5PVwiaGlkZGVuXCI7ai5ncmFwaGljPWQ9YltqLnNoYXBlVHlwZV0oaCkuc2V0UmFkaWFsUmVmZXJlbmNlKGEuY2VudGVyKS5hdHRyKGcpLmF0dHIoaSkuYXR0cihjKS5hZGQoYS5ncm91cCkuc2hhZG93KGUsZil9fX0pfSxzZWFyY2hQb2ludDpCYSxzb3J0QnlBbmdsZTpmdW5jdGlvbihhLGIpe2Euc29ydChmdW5jdGlvbihhLGQpe3JldHVybiBhLmFuZ2xlIT09dm9pZCAwJiZcbihkLmFuZ2xlLWEuYW5nbGUpKmJ9KX0sZHJhd0xlZ2VuZFN5bWJvbDpLLmRyYXdSZWN0YW5nbGUsZ2V0Q2VudGVyOkRiLmdldENlbnRlcixnZXRTeW1ib2w6QmF9O2hhPXNhKFIsaGEpO0wucGllPWhhO1IucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEub3B0aW9ucyxjPWIuY3Vyc29yLGQ9Yi5kYXRhTGFiZWxzLGU9YS5wb2ludHMsZixnLGg9YS5oYXNSZW5kZXJlZHx8MCxpLGosaz1wKGQuZGVmZXIsITApLGw9YS5jaGFydC5yZW5kZXJlcjtpZihkLmVuYWJsZWR8fGEuX2hhc1BvaW50TGFiZWxzKWEuZGxQcm9jZXNzT3B0aW9ucyYmYS5kbFByb2Nlc3NPcHRpb25zKGQpLGo9YS5wbG90R3JvdXAoXCJkYXRhTGFiZWxzR3JvdXBcIixcImRhdGEtbGFiZWxzXCIsayYmIWg/XCJoaWRkZW5cIjpcInZpc2libGVcIixkLnpJbmRleHx8NiksayYmKGouYXR0cih7b3BhY2l0eToraH0pLGh8fE4oYSxcImFmdGVyQW5pbWF0ZVwiLGZ1bmN0aW9uKCl7YS52aXNpYmxlJiZcbmouc2hvdyghMCk7altiLmFuaW1hdGlvbj9cImFuaW1hdGVcIjpcImF0dHJcIl0oe29wYWNpdHk6MX0se2R1cmF0aW9uOjIwMH0pfSkpLGc9ZCxxKGUsZnVuY3Rpb24oZSl7dmFyIGgsaz1lLmRhdGFMYWJlbCxxLHIsdD1lLmNvbm5lY3Rvcix3PSEwLHYsdT17fTtmPWUuZGxPcHRpb25zfHxlLm9wdGlvbnMmJmUub3B0aW9ucy5kYXRhTGFiZWxzO2g9cChmJiZmLmVuYWJsZWQsZy5lbmFibGVkKSYmZS55IT09bnVsbDtpZihrJiYhaCllLmRhdGFMYWJlbD1rLmRlc3Ryb3koKTtlbHNlIGlmKGgpe2Q9RShnLGYpO3Y9ZC5zdHlsZTtoPWQucm90YXRpb247cT1lLmdldExhYmVsQ29uZmlnKCk7aT1kLmZvcm1hdD9OYShkLmZvcm1hdCxxKTpkLmZvcm1hdHRlci5jYWxsKHEsZCk7di5jb2xvcj1wKGQuY29sb3Isdi5jb2xvcixhLmNvbG9yLFwiYmxhY2tcIik7aWYoaylpZihzKGkpKWsuYXR0cih7dGV4dDppfSksdz0hMTtlbHNle2lmKGUuZGF0YUxhYmVsPWs9ay5kZXN0cm95KCksdCllLmNvbm5lY3Rvcj1cbnQuZGVzdHJveSgpfWVsc2UgaWYocyhpKSl7az17ZmlsbDpkLmJhY2tncm91bmRDb2xvcixzdHJva2U6ZC5ib3JkZXJDb2xvcixcInN0cm9rZS13aWR0aFwiOmQuYm9yZGVyV2lkdGgscjpkLmJvcmRlclJhZGl1c3x8MCxyb3RhdGlvbjpoLHBhZGRpbmc6ZC5wYWRkaW5nLHpJbmRleDoxfTtpZih2LmNvbG9yPT09XCJjb250cmFzdFwiKXUuY29sb3I9ZC5pbnNpZGV8fGQuZGlzdGFuY2U8MHx8Yi5zdGFja2luZz9sLmdldENvbnRyYXN0KGUuY29sb3J8fGEuY29sb3IpOlwiIzAwMDAwMFwiO2lmKGMpdS5jdXJzb3I9Yztmb3IociBpbiBrKWtbcl09PT1BJiZkZWxldGUga1tyXTtrPWUuZGF0YUxhYmVsPWxbaD9cInRleHRcIjpcImxhYmVsXCJdKGksMCwtOTk5OSxkLnNoYXBlLG51bGwsbnVsbCxkLnVzZUhUTUwpLmF0dHIoaykuY3NzKHgodix1KSkuYWRkKGopLnNoYWRvdyhkLnNoYWRvdyl9ayYmYS5hbGlnbkRhdGFMYWJlbChlLGssZCxudWxsLHcpfX0pfTtSLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbD1cbmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy5jaGFydCxnPWYuaW52ZXJ0ZWQsaD1wKGEucGxvdFgsLTk5OTkpLGk9cChhLnBsb3RZLC05OTk5KSxqPWIuZ2V0QkJveCgpLGs9Zi5yZW5kZXJlci5mb250TWV0cmljcyhjLnN0eWxlLmZvbnRTaXplKS5iLGw9Yy5yb3RhdGlvbixtPWMuYWxpZ24sbj10aGlzLnZpc2libGUmJihhLnNlcmllcy5mb3JjZURMfHxmLmlzSW5zaWRlUGxvdChoLEMoaSksZyl8fGQmJmYuaXNJbnNpZGVQbG90KGgsZz9kLngrMTpkLnkrZC5oZWlnaHQtMSxnKSksbz1wKGMub3ZlcmZsb3csXCJqdXN0aWZ5XCIpPT09XCJqdXN0aWZ5XCI7aWYobilkPXgoe3g6Zz9mLnBsb3RXaWR0aC1pOmgseTpDKGc/Zi5wbG90SGVpZ2h0LWg6aSksd2lkdGg6MCxoZWlnaHQ6MH0sZCkseChjLHt3aWR0aDpqLndpZHRoLGhlaWdodDpqLmhlaWdodH0pLGw/KG89ITEsZz1mLnJlbmRlcmVyLnJvdENvcnIoayxsKSxnPXt4OmQueCtjLngrZC53aWR0aC8yK2cueCx5OmQueStjLnkre3RvcDowLFxubWlkZGxlOjAuNSxib3R0b206MX1bYy52ZXJ0aWNhbEFsaWduXSpkLmhlaWdodH0sYltlP1wiYXR0clwiOlwiYW5pbWF0ZVwiXShnKS5hdHRyKHthbGlnbjptfSksaD0obCs3MjApJTM2MCxoPWg+MTgwJiZoPDM2MCxtPT09XCJsZWZ0XCI/Zy55LT1oP2ouaGVpZ2h0OjA6bT09PVwiY2VudGVyXCI/KGcueC09ai53aWR0aC8yLGcueS09ai5oZWlnaHQvMik6bT09PVwicmlnaHRcIiYmKGcueC09ai53aWR0aCxnLnktPWg/MDpqLmhlaWdodCkpOihiLmFsaWduKGMsbnVsbCxkKSxnPWIuYWxpZ25BdHRyKSxvP3RoaXMuanVzdGlmeURhdGFMYWJlbChiLGMsZyxqLGQsZSk6cChjLmNyb3AsITApJiYobj1mLmlzSW5zaWRlUGxvdChnLngsZy55KSYmZi5pc0luc2lkZVBsb3QoZy54K2oud2lkdGgsZy55K2ouaGVpZ2h0KSksYy5zaGFwZSYmIWwmJmIuYXR0cih7YW5jaG9yWDphLnBsb3RYLGFuY2hvclk6YS5wbG90WX0pO2lmKCFuKUthKGIpLGIuYXR0cih7eTotOTk5OX0pLGIucGxhY2VkPSExfTtSLnByb3RvdHlwZS5qdXN0aWZ5RGF0YUxhYmVsPVxuZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPXRoaXMuY2hhcnQsaD1iLmFsaWduLGk9Yi52ZXJ0aWNhbEFsaWduLGosayxsPWEuYm94PzA6YS5wYWRkaW5nfHwwO2o9Yy54K2w7aWYoajwwKWg9PT1cInJpZ2h0XCI/Yi5hbGlnbj1cImxlZnRcIjpiLng9LWosaz0hMDtqPWMueCtkLndpZHRoLWw7aWYoaj5nLnBsb3RXaWR0aCloPT09XCJsZWZ0XCI/Yi5hbGlnbj1cInJpZ2h0XCI6Yi54PWcucGxvdFdpZHRoLWosaz0hMDtqPWMueStsO2lmKGo8MClpPT09XCJib3R0b21cIj9iLnZlcnRpY2FsQWxpZ249XCJ0b3BcIjpiLnk9LWosaz0hMDtqPWMueStkLmhlaWdodC1sO2lmKGo+Zy5wbG90SGVpZ2h0KWk9PT1cInRvcFwiP2IudmVydGljYWxBbGlnbj1cImJvdHRvbVwiOmIueT1nLnBsb3RIZWlnaHQtaixrPSEwO2lmKGspYS5wbGFjZWQ9IWYsYS5hbGlnbihiLG51bGwsZSl9O2lmKEwucGllKUwucGllLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmRhdGEsYyxkPWEuY2hhcnQsXG5lPWEub3B0aW9ucy5kYXRhTGFiZWxzLGY9cChlLmNvbm5lY3RvclBhZGRpbmcsMTApLGc9cChlLmNvbm5lY3RvcldpZHRoLDEpLGg9ZC5wbG90V2lkdGgsaT1kLnBsb3RIZWlnaHQsaixrLGw9cChlLnNvZnRDb25uZWN0b3IsITApLG09ZS5kaXN0YW5jZSxuPWEuY2VudGVyLG89blsyXS8yLHM9blsxXSxyPW0+MCx1LHcsdix4PVtbXSxbXV0sQSx5LEQsRSxCLEg9WzAsMCwwLDBdLE09ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi55LWEueX07aWYoYS52aXNpYmxlJiYoZS5lbmFibGVkfHxhLl9oYXNQb2ludExhYmVscykpe1IucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzLmFwcGx5KGEpO3EoYixmdW5jdGlvbihhKXtpZihhLmRhdGFMYWJlbCYmYS52aXNpYmxlKXhbYS5oYWxmXS5wdXNoKGEpLGEuZGF0YUxhYmVsLl9wb3M9bnVsbH0pO2ZvcihFPTI7RS0tOyl7dmFyIEk9W10sTj1bXSxKPXhbRV0sTD1KLmxlbmd0aCxLO2lmKEwpe2Euc29ydEJ5QW5nbGUoSixFLTAuNSk7Zm9yKEI9Yj0wOyFiJiZcbkpbQl07KWI9SltCXSYmSltCXS5kYXRhTGFiZWwmJihKW0JdLmRhdGFMYWJlbC5nZXRCQm94KCkuaGVpZ2h0fHwyMSksQisrO2lmKG0+MCl7dz1GKHMrbyttLGQucGxvdEhlaWdodCk7Zm9yKEI9dCgwLHMtby1tKTtCPD13O0IrPWIpSS5wdXNoKEIpO3c9SS5sZW5ndGg7aWYoTD53KXtjPVtdLmNvbmNhdChKKTtjLnNvcnQoTSk7Zm9yKEI9TDtCLS07KWNbQl0ucmFuaz1CO2ZvcihCPUw7Qi0tOylKW0JdLnJhbms+PXcmJkouc3BsaWNlKEIsMSk7TD1KLmxlbmd0aH1mb3IoQj0wO0I8TDtCKyspe2M9SltCXTt2PWMubGFiZWxQb3M7Yz05OTk5O3ZhciBQLE87Zm9yKE89MDtPPHc7TysrKVA9UShJW09dLXZbMV0pLFA8YyYmKGM9UCxLPU8pO2lmKEs8QiYmSVtCXSE9PW51bGwpSz1CO2Vsc2UgZm9yKHc8TC1CK0smJklbQl0hPT1udWxsJiYoSz13LUwrQik7SVtLXT09PW51bGw7KUsrKztOLnB1c2goe2k6Syx5OklbS119KTtJW0tdPW51bGx9Ti5zb3J0KE0pfWZvcihCPTA7QjxMO0IrKyl7Yz1cbkpbQl07dj1jLmxhYmVsUG9zO3U9Yy5kYXRhTGFiZWw7RD1jLnZpc2libGU9PT0hMT9cImhpZGRlblwiOlwiaW5oZXJpdFwiO2M9dlsxXTtpZihtPjApe2lmKHc9Ti5wb3AoKSxLPXcuaSx5PXcueSxjPnkmJklbSysxXSE9PW51bGx8fGM8eSYmSVtLLTFdIT09bnVsbCl5PUYodCgwLGMpLGQucGxvdEhlaWdodCl9ZWxzZSB5PWM7QT1lLmp1c3RpZnk/blswXSsoRT8tMToxKSoobyttKTphLmdldFgoeT09PXMtby1tfHx5PT09cytvK20/Yzp5LEUpO3UuX2F0dHI9e3Zpc2liaWxpdHk6RCxhbGlnbjp2WzZdfTt1Ll9wb3M9e3g6QStlLngrKHtsZWZ0OmYscmlnaHQ6LWZ9W3ZbNl1dfHwwKSx5OnkrZS55LTEwfTt1LmNvbm5YPUE7dS5jb25uWT15O2lmKHRoaXMub3B0aW9ucy5zaXplPT09bnVsbCl3PXUud2lkdGgsQS13PGY/SFszXT10KEMody1BK2YpLEhbM10pOkErdz5oLWYmJihIWzFdPXQoQyhBK3ctaCtmKSxIWzFdKSkseS1iLzI8MD9IWzBdPXQoQygteStiLzIpLEhbMF0pOnkrYi8yPmkmJihIWzJdPVxudChDKHkrYi8yLWkpLEhbMl0pKX19fWlmKEhhKEgpPT09MHx8dGhpcy52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdyhIKSl0aGlzLnBsYWNlRGF0YUxhYmVscygpLHImJmcmJnEodGhpcy5wb2ludHMsZnVuY3Rpb24oYil7aj1iLmNvbm5lY3Rvcjt2PWIubGFiZWxQb3M7aWYoKHU9Yi5kYXRhTGFiZWwpJiZ1Ll9wb3MmJmIudmlzaWJsZSlEPXUuX2F0dHIudmlzaWJpbGl0eSxBPXUuY29ublgseT11LmNvbm5ZLGs9bD9bWCxBKyh2WzZdPT09XCJsZWZ0XCI/NTotNSkseSxcIkNcIixBLHksMip2WzJdLXZbNF0sMip2WzNdLXZbNV0sdlsyXSx2WzNdLFMsdls0XSx2WzVdXTpbWCxBKyh2WzZdPT09XCJsZWZ0XCI/NTotNSkseSxTLHZbMl0sdlszXSxTLHZbNF0sdls1XV0saj8oai5hbmltYXRlKHtkOmt9KSxqLmF0dHIoXCJ2aXNpYmlsaXR5XCIsRCkpOmIuY29ubmVjdG9yPWo9YS5jaGFydC5yZW5kZXJlci5wYXRoKGspLmF0dHIoe1wic3Ryb2tlLXdpZHRoXCI6ZyxzdHJva2U6ZS5jb25uZWN0b3JDb2xvcnx8Yi5jb2xvcnx8XG5cIiM2MDYwNjBcIix2aXNpYmlsaXR5OkR9KS5hZGQoYS5kYXRhTGFiZWxzR3JvdXApO2Vsc2UgaWYoailiLmNvbm5lY3Rvcj1qLmRlc3Ryb3koKX0pfX0sTC5waWUucHJvdG90eXBlLnBsYWNlRGF0YUxhYmVscz1mdW5jdGlvbigpe3EodGhpcy5wb2ludHMsZnVuY3Rpb24oYSl7dmFyIGI9YS5kYXRhTGFiZWw7aWYoYiYmYS52aXNpYmxlKShhPWIuX3Bvcyk/KGIuYXR0cihiLl9hdHRyKSxiW2IubW92ZWQ/XCJhbmltYXRlXCI6XCJhdHRyXCJdKGEpLGIubW92ZWQ9ITApOmImJmIuYXR0cih7eTotOTk5OX0pfSl9LEwucGllLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbD1CYSxMLnBpZS5wcm90b3R5cGUudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3c9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jZW50ZXIsYz10aGlzLm9wdGlvbnMsZD1jLmNlbnRlcixlPWMubWluU2l6ZXx8ODAsZj1lLGc7ZFswXSE9PW51bGw/Zj10KGJbMl0tdChhWzFdLGFbM10pLGUpOihmPXQoYlsyXS1hWzFdLWFbM10sZSksYlswXSs9XG4oYVszXS1hWzFdKS8yKTtkWzFdIT09bnVsbD9mPXQoRihmLGJbMl0tdChhWzBdLGFbMl0pKSxlKTooZj10KEYoZixiWzJdLWFbMF0tYVsyXSksZSksYlsxXSs9KGFbMF0tYVsyXSkvMik7ZjxiWzJdPyhiWzJdPWYsYlszXT1NYXRoLm1pbigvJSQvLnRlc3QoYy5pbm5lclNpemV8fDApP2YqcGFyc2VGbG9hdChjLmlubmVyU2l6ZXx8MCkvMTAwOnBhcnNlRmxvYXQoYy5pbm5lclNpemV8fDApLGYpLHRoaXMudHJhbnNsYXRlKGIpLHRoaXMuZHJhd0RhdGFMYWJlbHMmJnRoaXMuZHJhd0RhdGFMYWJlbHMoKSk6Zz0hMDtyZXR1cm4gZ307aWYoTC5jb2x1bW4pTC5jb2x1bW4ucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy5jaGFydC5pbnZlcnRlZCxnPWEuc2VyaWVzLGg9YS5kbEJveHx8YS5zaGFwZUFyZ3MsaT1wKGEuYmVsb3csYS5wbG90WT5wKHRoaXMudHJhbnNsYXRlZFRocmVzaG9sZCxnLnlBeGlzLmxlbikpLGo9cChjLmluc2lkZSxcbiEhdGhpcy5vcHRpb25zLnN0YWNraW5nKTtpZihoKXtkPUUoaCk7aWYoZC55PDApZC5oZWlnaHQrPWQueSxkLnk9MDtoPWQueStkLmhlaWdodC1nLnlBeGlzLmxlbjtoPjAmJihkLmhlaWdodC09aCk7ZiYmKGQ9e3g6Zy55QXhpcy5sZW4tZC55LWQuaGVpZ2h0LHk6Zy54QXhpcy5sZW4tZC54LWQud2lkdGgsd2lkdGg6ZC5oZWlnaHQsaGVpZ2h0OmQud2lkdGh9KTtpZighailmPyhkLngrPWk/MDpkLndpZHRoLGQud2lkdGg9MCk6KGQueSs9aT9kLmhlaWdodDowLGQuaGVpZ2h0PTApfWMuYWxpZ249cChjLmFsaWduLCFmfHxqP1wiY2VudGVyXCI6aT9cInJpZ2h0XCI6XCJsZWZ0XCIpO2MudmVydGljYWxBbGlnbj1wKGMudmVydGljYWxBbGlnbixmfHxqP1wibWlkZGxlXCI6aT9cInRvcFwiOlwiYm90dG9tXCIpO1IucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsLmNhbGwodGhpcyxhLGIsYyxkLGUpfTsoZnVuY3Rpb24oYSl7dmFyIGI9YS5DaGFydCxjPWEuZWFjaCxkPWEucGljayxlPWEuYWRkRXZlbnQ7Yi5wcm90b3R5cGUuY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe3ZhciBlPVxuW107YyhhLnNlcmllcyxmdW5jdGlvbihhKXt2YXIgYj1hLm9wdGlvbnMuZGF0YUxhYmVscyxmPWEuZGF0YUxhYmVsQ29sbGVjdGlvbnN8fFtcImRhdGFMYWJlbFwiXTsoYi5lbmFibGVkfHxhLl9oYXNQb2ludExhYmVscykmJiFiLmFsbG93T3ZlcmxhcCYmYS52aXNpYmxlJiZjKGYsZnVuY3Rpb24oYil7YyhhLnBvaW50cyxmdW5jdGlvbihhKXtpZihhW2JdKWFbYl0ubGFiZWxyYW5rPWQoYS5sYWJlbHJhbmssYS5zaGFwZUFyZ3MmJmEuc2hhcGVBcmdzLmhlaWdodCksZS5wdXNoKGFbYl0pfSl9KX0pO2EuaGlkZU92ZXJsYXBwaW5nTGFiZWxzKGUpfWIoKTtlKGEsXCJyZWRyYXdcIixiKX0pO2IucHJvdG90eXBlLmhpZGVPdmVybGFwcGluZ0xhYmVscz1mdW5jdGlvbihhKXt2YXIgYj1hLmxlbmd0aCxkLGUsaixrLGwsbSxuLG8scDtmb3IoZT0wO2U8YjtlKyspaWYoZD1hW2VdKWQub2xkT3BhY2l0eT1kLm9wYWNpdHksZC5uZXdPcGFjaXR5PTE7YS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuKGIubGFiZWxyYW5rfHxcbjApLShhLmxhYmVscmFua3x8MCl9KTtmb3IoZT0wO2U8YjtlKyspe2o9YVtlXTtmb3IoZD1lKzE7ZDxiOysrZClpZihrPWFbZF0saiYmayYmai5wbGFjZWQmJmsucGxhY2VkJiZqLm5ld09wYWNpdHkhPT0wJiZrLm5ld09wYWNpdHkhPT0wJiYobD1qLmFsaWduQXR0cixtPWsuYWxpZ25BdHRyLG49ai5wYXJlbnRHcm91cCxvPWsucGFyZW50R3JvdXAscD0yKihqLmJveD8wOmoucGFkZGluZyksbD0hKG0ueCtvLnRyYW5zbGF0ZVg+bC54K24udHJhbnNsYXRlWCsoai53aWR0aC1wKXx8bS54K28udHJhbnNsYXRlWCsoay53aWR0aC1wKTxsLngrbi50cmFuc2xhdGVYfHxtLnkrby50cmFuc2xhdGVZPmwueStuLnRyYW5zbGF0ZVkrKGouaGVpZ2h0LXApfHxtLnkrby50cmFuc2xhdGVZKyhrLmhlaWdodC1wKTxsLnkrbi50cmFuc2xhdGVZKSkpKGoubGFiZWxyYW5rPGsubGFiZWxyYW5rP2o6aykubmV3T3BhY2l0eT0wfWMoYSxmdW5jdGlvbihhKXt2YXIgYixjO2lmKGEpe2M9YS5uZXdPcGFjaXR5O1xuaWYoYS5vbGRPcGFjaXR5IT09YyYmYS5wbGFjZWQpYz9hLnNob3coITApOmI9ZnVuY3Rpb24oKXthLmhpZGUoKX0sYS5hbGlnbkF0dHIub3BhY2l0eT1jLGFbYS5pc09sZD9cImFuaW1hdGVcIjpcImF0dHJcIl0oYS5hbGlnbkF0dHIsbnVsbCxiKTthLmlzT2xkPSEwfX0pfX0pKHUpO2hhPXUuVHJhY2tlck1peGluPXtkcmF3VHJhY2tlclBvaW50OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY2hhcnQsYz1iLnBvaW50ZXIsZD1hLm9wdGlvbnMuY3Vyc29yLGU9ZCYme2N1cnNvcjpkfSxmPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1hLnRhcmdldCxkO2MmJiFkOylkPWMucG9pbnQsYz1jLnBhcmVudE5vZGU7aWYoZCE9PUEmJmQhPT1iLmhvdmVyUG9pbnQpZC5vbk1vdXNlT3ZlcihhKX07cShhLnBvaW50cyxmdW5jdGlvbihhKXtpZihhLmdyYXBoaWMpYS5ncmFwaGljLmVsZW1lbnQucG9pbnQ9YTtpZihhLmRhdGFMYWJlbClhLmRhdGFMYWJlbC5lbGVtZW50LnBvaW50PWF9KTtpZighYS5faGFzVHJhY2tpbmcpcShhLnRyYWNrZXJHcm91cHMsXG5mdW5jdGlvbihiKXtpZihhW2JdJiYoYVtiXS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdHJhY2tlclwiKS5vbihcIm1vdXNlb3ZlclwiLGYpLm9uKFwibW91c2VvdXRcIixmdW5jdGlvbihhKXtjLm9uVHJhY2tlck1vdXNlT3V0KGEpfSkuY3NzKGUpLGZiKSlhW2JdLm9uKFwidG91Y2hzdGFydFwiLGYpfSksYS5faGFzVHJhY2tpbmc9ITB9LGRyYXdUcmFja2VyR3JhcGg6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5vcHRpb25zLGM9Yi50cmFja0J5QXJlYSxkPVtdLmNvbmNhdChjP2EuYXJlYVBhdGg6YS5ncmFwaFBhdGgpLGU9ZC5sZW5ndGgsZj1hLmNoYXJ0LGc9Zi5wb2ludGVyLGg9Zi5yZW5kZXJlcixpPWYub3B0aW9ucy50b29sdGlwLnNuYXAsaj1hLnRyYWNrZXIsaz1iLmN1cnNvcixsPWsmJntjdXJzb3I6a30sbT1mdW5jdGlvbigpe2lmKGYuaG92ZXJTZXJpZXMhPT1hKWEub25Nb3VzZU92ZXIoKX0sbj1cInJnYmEoMTkyLDE5MiwxOTIsXCIrKGdhPzEuMEUtNDowLjAwMikrXCIpXCI7aWYoZSYmIWMpZm9yKGs9XG5lKzE7ay0tOylkW2tdPT09WCYmZC5zcGxpY2UoaysxLDAsZFtrKzFdLWksZFtrKzJdLFMpLChrJiZkW2tdPT09WHx8az09PWUpJiZkLnNwbGljZShrLDAsUyxkW2stMl0raSxkW2stMV0pO2o/ai5hdHRyKHtkOmR9KTooYS50cmFja2VyPWgucGF0aChkKS5hdHRyKHtcInN0cm9rZS1saW5lam9pblwiOlwicm91bmRcIix2aXNpYmlsaXR5OmEudmlzaWJsZT9cInZpc2libGVcIjpcImhpZGRlblwiLHN0cm9rZTpuLGZpbGw6Yz9uOlwibm9uZVwiLFwic3Ryb2tlLXdpZHRoXCI6Yi5saW5lV2lkdGgrKGM/MDoyKmkpLHpJbmRleDoyfSkuYWRkKGEuZ3JvdXApLHEoW2EudHJhY2tlcixhLm1hcmtlckdyb3VwXSxmdW5jdGlvbihhKXthLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpLm9uKFwibW91c2VvdmVyXCIsbSkub24oXCJtb3VzZW91dFwiLGZ1bmN0aW9uKGEpe2cub25UcmFja2VyTW91c2VPdXQoYSl9KS5jc3MobCk7aWYoZmIpYS5vbihcInRvdWNoc3RhcnRcIixtKX0pKX19O2lmKEwuY29sdW1uKXhhLnByb3RvdHlwZS5kcmF3VHJhY2tlcj1cbmhhLmRyYXdUcmFja2VyUG9pbnQ7aWYoTC5waWUpTC5waWUucHJvdG90eXBlLmRyYXdUcmFja2VyPWhhLmRyYXdUcmFja2VyUG9pbnQ7aWYoTC5zY2F0dGVyKXFhLnByb3RvdHlwZS5kcmF3VHJhY2tlcj1oYS5kcmF3VHJhY2tlclBvaW50O3gocmIucHJvdG90eXBlLHtzZXRJdGVtRXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpczsoYz9iOmEubGVnZW5kR3JvdXApLm9uKFwibW91c2VvdmVyXCIsZnVuY3Rpb24oKXthLnNldFN0YXRlKFwiaG92ZXJcIik7Yi5jc3MoZi5vcHRpb25zLml0ZW1Ib3ZlclN0eWxlKX0pLm9uKFwibW91c2VvdXRcIixmdW5jdGlvbigpe2IuY3NzKGEudmlzaWJsZT9kOmUpO2Euc2V0U3RhdGUoKX0pLm9uKFwiY2xpY2tcIixmdW5jdGlvbihiKXt2YXIgYz1mdW5jdGlvbigpe2Euc2V0VmlzaWJsZSYmYS5zZXRWaXNpYmxlKCl9LGI9e2Jyb3dzZXJFdmVudDpifTthLmZpcmVQb2ludEV2ZW50P2EuZmlyZVBvaW50RXZlbnQoXCJsZWdlbmRJdGVtQ2xpY2tcIixiLGMpOlxuSShhLFwibGVnZW5kSXRlbUNsaWNrXCIsYixjKX0pfSxjcmVhdGVDaGVja2JveEZvckl0ZW06ZnVuY3Rpb24oYSl7YS5jaGVja2JveD1kYShcImlucHV0XCIse3R5cGU6XCJjaGVja2JveFwiLGNoZWNrZWQ6YS5zZWxlY3RlZCxkZWZhdWx0Q2hlY2tlZDphLnNlbGVjdGVkfSx0aGlzLm9wdGlvbnMuaXRlbUNoZWNrYm94U3R5bGUsdGhpcy5jaGFydC5jb250YWluZXIpO04oYS5jaGVja2JveCxcImNsaWNrXCIsZnVuY3Rpb24oYil7SShhLnNlcmllc3x8YSxcImNoZWNrYm94Q2xpY2tcIix7Y2hlY2tlZDpiLnRhcmdldC5jaGVja2VkLGl0ZW06YX0sZnVuY3Rpb24oKXthLnNlbGVjdCgpfSl9KX19KTtVLmxlZ2VuZC5pdGVtU3R5bGUuY3Vyc29yPVwicG9pbnRlclwiO3goaWIucHJvdG90eXBlLHtzaG93UmVzZXRab29tOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPVUubGFuZyxjPWEub3B0aW9ucy5jaGFydC5yZXNldFpvb21CdXR0b24sZD1jLnRoZW1lLGU9ZC5zdGF0ZXMsZj1jLnJlbGF0aXZlVG89PT1cImNoYXJ0XCI/XG5udWxsOlwicGxvdEJveFwiO3RoaXMucmVzZXRab29tQnV0dG9uPWEucmVuZGVyZXIuYnV0dG9uKGIucmVzZXRab29tLG51bGwsbnVsbCxmdW5jdGlvbigpe2Euem9vbU91dCgpfSxkLGUmJmUuaG92ZXIpLmF0dHIoe2FsaWduOmMucG9zaXRpb24uYWxpZ24sdGl0bGU6Yi5yZXNldFpvb21UaXRsZX0pLmFkZCgpLmFsaWduKGMucG9zaXRpb24sITEsZil9LHpvb21PdXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO0koYSxcInNlbGVjdGlvblwiLHtyZXNldFNlbGVjdGlvbjohMH0sZnVuY3Rpb24oKXthLnpvb20oKX0pfSx6b29tOmZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcy5wb2ludGVyLGQ9ITEsZTshYXx8YS5yZXNldFNlbGVjdGlvbj9xKHRoaXMuYXhlcyxmdW5jdGlvbihhKXtiPWEuem9vbSgpfSk6cShhLnhBeGlzLmNvbmNhdChhLnlBeGlzKSxmdW5jdGlvbihhKXt2YXIgZT1hLmF4aXMsaD1lLmlzWEF4aXM7aWYoY1toP1wiem9vbVhcIjpcInpvb21ZXCJdfHxjW2g/XCJwaW5jaFhcIjpcInBpbmNoWVwiXSliPVxuZS56b29tKGEubWluLGEubWF4KSxlLmRpc3BsYXlCdG4mJihkPSEwKX0pO2U9dGhpcy5yZXNldFpvb21CdXR0b247aWYoZCYmIWUpdGhpcy5zaG93UmVzZXRab29tKCk7ZWxzZSBpZighZCYmJChlKSl0aGlzLnJlc2V0Wm9vbUJ1dHRvbj1lLmRlc3Ryb3koKTtiJiZ0aGlzLnJlZHJhdyhwKHRoaXMub3B0aW9ucy5jaGFydC5hbmltYXRpb24sYSYmYS5hbmltYXRpb24sdGhpcy5wb2ludENvdW50PDEwMCkpfSxwYW46ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yy5ob3ZlclBvaW50cyxlO2QmJnEoZCxmdW5jdGlvbihhKXthLnNldFN0YXRlKCl9KTtxKGI9PT1cInh5XCI/WzEsMF06WzFdLGZ1bmN0aW9uKGIpe3ZhciBiPWNbYj9cInhBeGlzXCI6XCJ5QXhpc1wiXVswXSxkPWIuaG9yaXosaD1hW2Q/XCJjaGFydFhcIjpcImNoYXJ0WVwiXSxkPWQ/XCJtb3VzZURvd25YXCI6XCJtb3VzZURvd25ZXCIsaT1jW2RdLGo9KGIucG9pbnRSYW5nZXx8MCkvMixrPWIuZ2V0RXh0cmVtZXMoKSxsPWIudG9WYWx1ZShpLWgsXG4hMCkraixqPWIudG9WYWx1ZShpK2IubGVuLWgsITApLWosaT1pPmg7aWYoYi5zZXJpZXMubGVuZ3RoJiYoaXx8bD5GKGsuZGF0YU1pbixrLm1pbikpJiYoIWl8fGo8dChrLmRhdGFNYXgsay5tYXgpKSliLnNldEV4dHJlbWVzKGwsaiwhMSwhMSx7dHJpZ2dlcjpcInBhblwifSksZT0hMDtjW2RdPWh9KTtlJiZjLnJlZHJhdyghMSk7TShjLmNvbnRhaW5lcix7Y3Vyc29yOlwibW92ZVwifSl9fSk7eChNYS5wcm90b3R5cGUse3NlbGVjdDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1jLnNlcmllcyxlPWQuY2hhcnQsYT1wKGEsIWMuc2VsZWN0ZWQpO2MuZmlyZVBvaW50RXZlbnQoYT9cInNlbGVjdFwiOlwidW5zZWxlY3RcIix7YWNjdW11bGF0ZTpifSxmdW5jdGlvbigpe2Muc2VsZWN0ZWQ9Yy5vcHRpb25zLnNlbGVjdGVkPWE7ZC5vcHRpb25zLmRhdGFbcGEoYyxkLmRhdGEpXT1jLm9wdGlvbnM7Yy5zZXRTdGF0ZShhJiZcInNlbGVjdFwiKTtifHxxKGUuZ2V0U2VsZWN0ZWRQb2ludHMoKSxmdW5jdGlvbihhKXtpZihhLnNlbGVjdGVkJiZcbmEhPT1jKWEuc2VsZWN0ZWQ9YS5vcHRpb25zLnNlbGVjdGVkPSExLGQub3B0aW9ucy5kYXRhW3BhKGEsZC5kYXRhKV09YS5vcHRpb25zLGEuc2V0U3RhdGUoXCJcIiksYS5maXJlUG9pbnRFdmVudChcInVuc2VsZWN0XCIpfSl9KX0sb25Nb3VzZU92ZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnNlcmllcyxkPWMuY2hhcnQsZT1kLnRvb2x0aXAsZj1kLmhvdmVyUG9pbnQ7aWYoZC5ob3ZlclNlcmllcyE9PWMpYy5vbk1vdXNlT3ZlcigpO2lmKGYmJmYhPT10aGlzKWYub25Nb3VzZU91dCgpO2lmKHRoaXMuc2VyaWVzJiYodGhpcy5maXJlUG9pbnRFdmVudChcIm1vdXNlT3ZlclwiKSxlJiYoIWUuc2hhcmVkfHxjLm5vU2hhcmVkVG9vbHRpcCkmJmUucmVmcmVzaCh0aGlzLGEpLHRoaXMuc2V0U3RhdGUoXCJob3ZlclwiKSwhYikpZC5ob3ZlclBvaW50PXRoaXN9LG9uTW91c2VPdXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllcy5jaGFydCxiPWEuaG92ZXJQb2ludHM7dGhpcy5maXJlUG9pbnRFdmVudChcIm1vdXNlT3V0XCIpO1xuaWYoIWJ8fHBhKHRoaXMsYik9PT0tMSl0aGlzLnNldFN0YXRlKCksYS5ob3ZlclBvaW50PW51bGx9LGltcG9ydEV2ZW50czpmdW5jdGlvbigpe2lmKCF0aGlzLmhhc0ltcG9ydGVkRXZlbnRzKXt2YXIgYT1FKHRoaXMuc2VyaWVzLm9wdGlvbnMucG9pbnQsdGhpcy5vcHRpb25zKS5ldmVudHMsYjt0aGlzLmV2ZW50cz1hO2ZvcihiIGluIGEpTih0aGlzLGIsYVtiXSk7dGhpcy5oYXNJbXBvcnRlZEV2ZW50cz0hMH19LHNldFN0YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9Vih0aGlzLnBsb3RYKSxkPXRoaXMucGxvdFksZT10aGlzLnNlcmllcyxmPWUub3B0aW9ucy5zdGF0ZXMsZz1mYVtlLnR5cGVdLm1hcmtlciYmZS5vcHRpb25zLm1hcmtlcixoPWcmJiFnLmVuYWJsZWQsaT1nJiZnLnN0YXRlc1thXSxqPWkmJmkuZW5hYmxlZD09PSExLGs9ZS5zdGF0ZU1hcmtlckdyYXBoaWMsbD10aGlzLm1hcmtlcnx8e30sbT1lLmNoYXJ0LG49ZS5oYWxvLG8sYT1hfHxcIlwiO289dGhpcy5wb2ludEF0dHJbYV18fFxuZS5wb2ludEF0dHJbYV07aWYoIShhPT09dGhpcy5zdGF0ZSYmIWJ8fHRoaXMuc2VsZWN0ZWQmJmEhPT1cInNlbGVjdFwifHxmW2FdJiZmW2FdLmVuYWJsZWQ9PT0hMXx8YSYmKGp8fGgmJmkuZW5hYmxlZD09PSExKXx8YSYmbC5zdGF0ZXMmJmwuc3RhdGVzW2FdJiZsLnN0YXRlc1thXS5lbmFibGVkPT09ITEpKXtpZih0aGlzLmdyYXBoaWMpZz1nJiZ0aGlzLmdyYXBoaWMuc3ltYm9sTmFtZSYmby5yLHRoaXMuZ3JhcGhpYy5hdHRyKEUobyxnP3t4OmMtZyx5OmQtZyx3aWR0aDoyKmcsaGVpZ2h0OjIqZ306e30pKSxrJiZrLmhpZGUoKTtlbHNle2lmKGEmJmkpaWYoZz1pLnJhZGl1cyxsPWwuc3ltYm9sfHxlLnN5bWJvbCxrJiZrLmN1cnJlbnRTeW1ib2whPT1sJiYoaz1rLmRlc3Ryb3koKSksaylrW2I/XCJhbmltYXRlXCI6XCJhdHRyXCJdKHt4OmMtZyx5OmQtZ30pO2Vsc2UgaWYobCllLnN0YXRlTWFya2VyR3JhcGhpYz1rPW0ucmVuZGVyZXIuc3ltYm9sKGwsYy1nLGQtZywyKmcsMipnKS5hdHRyKG8pLmFkZChlLm1hcmtlckdyb3VwKSxcbmsuY3VycmVudFN5bWJvbD1sO2lmKGspa1thJiZtLmlzSW5zaWRlUGxvdChjLGQsbS5pbnZlcnRlZCk/XCJzaG93XCI6XCJoaWRlXCJdKCksay5lbGVtZW50LnBvaW50PXRoaXN9aWYoKGM9ZlthXSYmZlthXS5oYWxvKSYmYy5zaXplKXtpZighbillLmhhbG89bj1tLnJlbmRlcmVyLnBhdGgoKS5hZGQobS5zZXJpZXNHcm91cCk7bi5hdHRyKHgoe2ZpbGw6dGhpcy5jb2xvcnx8ZS5jb2xvcixcImZpbGwtb3BhY2l0eVwiOmMub3BhY2l0eSx6SW5kZXg6LTF9LGMuYXR0cmlidXRlcykpW2I/XCJhbmltYXRlXCI6XCJhdHRyXCJdKHtkOnRoaXMuaGFsb1BhdGgoYy5zaXplKX0pfWVsc2UgbiYmbi5hdHRyKHtkOltdfSk7dGhpcy5zdGF0ZT1hfX0saGFsb1BhdGg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zZXJpZXMsYz1iLmNoYXJ0LGQ9Yi5nZXRQbG90Qm94KCksZT1jLmludmVydGVkLGY9TWF0aC5mbG9vcih0aGlzLnBsb3RYKTtyZXR1cm4gYy5yZW5kZXJlci5zeW1ib2xzLmNpcmNsZShkLnRyYW5zbGF0ZVgrXG4oZT9iLnlBeGlzLmxlbi10aGlzLnBsb3RZOmYpLWEsZC50cmFuc2xhdGVZKyhlP2IueEF4aXMubGVuLWY6dGhpcy5wbG90WSktYSxhKjIsYSoyKX19KTt4KFIucHJvdG90eXBlLHtvbk1vdXNlT3ZlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj1hLmhvdmVyU2VyaWVzO2lmKGImJmIhPT10aGlzKWIub25Nb3VzZU91dCgpO3RoaXMub3B0aW9ucy5ldmVudHMubW91c2VPdmVyJiZJKHRoaXMsXCJtb3VzZU92ZXJcIik7dGhpcy5zZXRTdGF0ZShcImhvdmVyXCIpO2EuaG92ZXJTZXJpZXM9dGhpc30sb25Nb3VzZU91dDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiPXRoaXMuY2hhcnQsYz1iLnRvb2x0aXAsZD1iLmhvdmVyUG9pbnQ7Yi5ob3ZlclNlcmllcz1udWxsO2lmKGQpZC5vbk1vdXNlT3V0KCk7dGhpcyYmYS5ldmVudHMubW91c2VPdXQmJkkodGhpcyxcIm1vdXNlT3V0XCIpO2MmJiFhLnN0aWNreVRyYWNraW5nJiYoIWMuc2hhcmVkfHx0aGlzLm5vU2hhcmVkVG9vbHRpcCkmJlxuYy5oaWRlKCk7dGhpcy5zZXRTdGF0ZSgpfSxzZXRTdGF0ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMsYz10aGlzLmdyYXBoLGQ9Yi5zdGF0ZXMsZT1iLmxpbmVXaWR0aCxiPTAsYT1hfHxcIlwiO2lmKHRoaXMuc3RhdGUhPT1hJiYodGhpcy5zdGF0ZT1hLCEoZFthXSYmZFthXS5lbmFibGVkPT09ITEpJiYoYSYmKGU9ZFthXS5saW5lV2lkdGh8fGUrKGRbYV0ubGluZVdpZHRoUGx1c3x8MCkpLGMmJiFjLmRhc2hzdHlsZSkpKXthPXtcInN0cm9rZS13aWR0aFwiOmV9O2ZvcihjLmF0dHIoYSk7dGhpc1tcInpvbmVHcmFwaFwiK2JdOyl0aGlzW1wiem9uZUdyYXBoXCIrYl0uYXR0cihhKSxiKz0xfX0sc2V0VmlzaWJsZTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1jLmNoYXJ0LGU9Yy5sZWdlbmRJdGVtLGYsZz1kLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzLGg9Yy52aXNpYmxlO2Y9KGMudmlzaWJsZT1hPWMudXNlck9wdGlvbnMudmlzaWJsZT1hPT09QT8haDphKT9cInNob3dcIjpcblwiaGlkZVwiO3EoW1wiZ3JvdXBcIixcImRhdGFMYWJlbHNHcm91cFwiLFwibWFya2VyR3JvdXBcIixcInRyYWNrZXJcIl0sZnVuY3Rpb24oYSl7aWYoY1thXSljW2FdW2ZdKCl9KTtpZihkLmhvdmVyU2VyaWVzPT09Y3x8KGQuaG92ZXJQb2ludCYmZC5ob3ZlclBvaW50LnNlcmllcyk9PT1jKWMub25Nb3VzZU91dCgpO2UmJmQubGVnZW5kLmNvbG9yaXplSXRlbShjLGEpO2MuaXNEaXJ0eT0hMDtjLm9wdGlvbnMuc3RhY2tpbmcmJnEoZC5zZXJpZXMsZnVuY3Rpb24oYSl7aWYoYS5vcHRpb25zLnN0YWNraW5nJiZhLnZpc2libGUpYS5pc0RpcnR5PSEwfSk7cShjLmxpbmtlZFNlcmllcyxmdW5jdGlvbihiKXtiLnNldFZpc2libGUoYSwhMSl9KTtpZihnKWQuaXNEaXJ0eUJveD0hMDtiIT09ITEmJmQucmVkcmF3KCk7SShjLGYpfSxzaG93OmZ1bmN0aW9uKCl7dGhpcy5zZXRWaXNpYmxlKCEwKX0saGlkZTpmdW5jdGlvbigpe3RoaXMuc2V0VmlzaWJsZSghMSl9LHNlbGVjdDpmdW5jdGlvbihhKXt0aGlzLnNlbGVjdGVkPVxuYT1hPT09QT8hdGhpcy5zZWxlY3RlZDphO2lmKHRoaXMuY2hlY2tib3gpdGhpcy5jaGVja2JveC5jaGVja2VkPWE7SSh0aGlzLGE/XCJzZWxlY3RcIjpcInVuc2VsZWN0XCIpfSxkcmF3VHJhY2tlcjpoYS5kcmF3VHJhY2tlckdyYXBofSk7eCh1LHtDb2xvcjpuYSxQb2ludDpNYSxUaWNrOlhhLFJlbmRlcmVyOmViLFNWR0VsZW1lbnQ6TyxTVkdSZW5kZXJlcjpFYSxhcnJheU1pbjpPYSxhcnJheU1heDpIYSxjaGFydHM6VCxjb3JyZWN0RmxvYXQ6YWEsZGF0ZUZvcm1hdDpTYSxlcnJvcjpjYSxmb3JtYXQ6TmEscGF0aEFuaW06dm9pZCAwLGdldE9wdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gVX0saGFzQmlkaUJ1ZzpSYixpc1RvdWNoRGV2aWNlOk5iLHNldE9wdGlvbnM6ZnVuY3Rpb24oYSl7VT1FKCEwLFUsYSk7R2IoKTtyZXR1cm4gVX0sYWRkRXZlbnQ6TixyZW1vdmVFdmVudDpZLGNyZWF0ZUVsZW1lbnQ6ZGEsZGlzY2FyZEVsZW1lbnQ6VWEsY3NzOk0sZWFjaDpxLG1hcDpEYSxtZXJnZTpFLFxuc3BsYXQ6dWEsc3RhYmxlU29ydDpqYixleHRlbmRDbGFzczpzYSxwSW50OkIsc3ZnOmdhLGNhbnZhczpsYSx2bWw6IWdhJiYhbGEscHJvZHVjdDpcIkhpZ2hjaGFydHNcIix2ZXJzaW9uOlwiNC4yLjZcIn0pO3JldHVybiB1fSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaGlnaGNoYXJ0cy9oaWdoY2hhcnRzLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==');
}]);