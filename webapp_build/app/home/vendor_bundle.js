/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2);
	__webpack_require__(1);
	__webpack_require__(5);
	module.exports = __webpack_require__(9);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jquery = __webpack_require__(2);\nvar underscore = __webpack_require__(5);\n\n//     Backbone.js 1.1.2\n\n//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function (root, factory) {\n\n    // Set up Backbone appropriately for the environment. Start with AMD.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(2), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, exports) {\n            // Export global even in AMD case in case this script is loaded with\n            // others that may still expect a global Backbone.\n            root.Backbone = factory(root, exports, _, $);\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n        // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n    } else if (typeof exports !== 'undefined') {\n        var _ = require('underscore');\n        factory(root, exports, _);\n\n        // Finally, as a browser global.\n    } else {\n        root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\n    }\n\n}(this, function (root, Backbone, _, $) {\n\n    // Initial Setup\n    // -------------\n\n    // Save the previous value of the `Backbone` variable, so that it can be\n    // restored later on, if `noConflict` is used.\n    var previousBackbone = root.Backbone;\n\n    // Create local references to array methods we'll want to use later.\n    var array = [];\n    var push = array.push;\n    var slice = array.slice;\n    var splice = array.splice;\n\n    // Current version of the library. Keep in sync with `package.json`.\n    Backbone.VERSION = '1.1.2';\n\n    // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n    // the `$` variable.\n    Backbone.$ = $;\n\n    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n    // to its previous owner. Returns a reference to this Backbone object.\n    Backbone.noConflict = function () {\n        root.Backbone = previousBackbone;\n        return this;\n    };\n\n    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n    // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n    // set a `X-Http-Method-Override` header.\n    Backbone.emulateHTTP = false;\n\n    // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n    // `application/json` requests ... will encode the body as\n    // `application/x-www-form-urlencoded` instead and will send the model in a\n    // form param named `model`.\n    Backbone.emulateJSON = false;\n\n    // Backbone.Events\n    // ---------------\n\n    // A module that can be mixed in to *any object* in order to provide it with\n    // custom events. You may bind with `on` or remove with `off` callback\n    // functions to an event; `trigger`-ing an event fires all callbacks in\n    // succession.\n    //\n    //     var object = {};\n    //     _.extend(object, Backbone.Events);\n    //     object.on('expand', function(){ alert('expanded'); });\n    //     object.trigger('expand');\n    //\n    var Events = Backbone.Events = {\n        // Bind an event to a `callback` function. Passing `\"all\"` will bind\n        // the callback to all events fired.\n        on: function (name, callback, context) {\n            if (!eventsApi(this, 'on', name, [callback, context]) || !callback)\n                return this;\n            this._events || (this._events = {});\n            var events = this._events[name] || (this._events[name] = []);\n            events.push({callback: callback, context: context, ctx: context || this});\n            return this;\n        },\n        // Bind an event to only be triggered a single time. After the first time\n        // the callback is invoked, it will be removed.\n        once: function (name, callback, context) {\n            if (!eventsApi(this, 'once', name, [callback, context]) || !callback)\n                return this;\n            var self = this;\n            var once = _.once(function () {\n                self.off(name, once);\n                callback.apply(this, arguments);\n            });\n            once._callback = callback;\n            return this.on(name, once, context);\n        },\n        // Remove one or many callbacks. If `context` is null, removes all\n        // callbacks with that function. If `callback` is null, removes all\n        // callbacks for the event. If `name` is null, removes all bound\n        // callbacks for all events.\n        off: function (name, callback, context) {\n            var retain, ev, events, names, i, l, j, k;\n            if (!this._events || !eventsApi(this, 'off', name, [callback, context]))\n                return this;\n            if (!name && !callback && !context) {\n                this._events = void 0;\n                return this;\n            }\n            names = name ? [name] : _.keys(this._events);\n            for (i = 0, l = names.length; i < l; i++) {\n                name = names[i];\n                if (events = this._events[name]) {\n                    this._events[name] = retain = [];\n                    if (callback || context) {\n                        for (j = 0, k = events.length; j < k; j++) {\n                            ev = events[j];\n                            if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                                (context && context !== ev.context)) {\n                                retain.push(ev);\n                            }\n                        }\n                    }\n                    if (!retain.length)\n                        delete this._events[name];\n                }\n            }\n\n            return this;\n        },\n        // Trigger one or many events, firing all bound callbacks. Callbacks are\n        // passed the same arguments as `trigger` is, apart from the event name\n        // (unless you're listening on `\"all\"`, which will cause your callback to\n        // receive the true name of the event as the first argument).\n        trigger: function (name) {\n            if (!this._events)\n                return this;\n            var args = slice.call(arguments, 1);\n            if (!eventsApi(this, 'trigger', name, args))\n                return this;\n            var events = this._events[name];\n            var allEvents = this._events.all;\n            if (events)\n                triggerEvents(events, args);\n            if (allEvents)\n                triggerEvents(allEvents, arguments);\n            return this;\n        },\n        // Tell this object to stop listening to either specific events ... or\n        // to every object it's currently listening to.\n        stopListening: function (obj, name, callback) {\n            var listeningTo = this._listeningTo;\n            if (!listeningTo)\n                return this;\n            var remove = !name && !callback;\n            if (!callback && typeof name === 'object')\n                callback = this;\n            if (obj)\n                (listeningTo = {})[obj._listenId] = obj;\n            for (var id in listeningTo) {\n                obj = listeningTo[id];\n                obj.off(name, callback, this);\n                if (remove || _.isEmpty(obj._events))\n                    delete this._listeningTo[id];\n            }\n            return this;\n        }\n\n    };\n\n    // Regular expression used to split event strings.\n    var eventSplitter = /\\s+/;\n\n    // Implement fancy features of the Events API such as multiple event\n    // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n    // in terms of the existing API.\n    var eventsApi = function (obj, action, name, rest) {\n        if (!name)\n            return true;\n\n        // Handle event maps.\n        if (typeof name === 'object') {\n            for (var key in name) {\n                obj[action].apply(obj, [key, name[key]].concat(rest));\n            }\n            return false;\n        }\n\n        // Handle space separated event names.\n        if (eventSplitter.test(name)) {\n            var names = name.split(eventSplitter);\n            for (var i = 0, l = names.length; i < l; i++) {\n                obj[action].apply(obj, [names[i]].concat(rest));\n            }\n            return false;\n        }\n\n        return true;\n    };\n\n    // A difficult-to-believe, but optimized internal dispatch function for\n    // triggering events. Tries to keep the usual cases speedy (most internal\n    // Backbone events have 3 arguments).\n    var triggerEvents = function (events, args) {\n        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n        switch (args.length) {\n            case 0:\n                while (++i < l)\n                    (ev = events[i]).callback.call(ev.ctx);\n                return;\n            case 1:\n                while (++i < l)\n                    (ev = events[i]).callback.call(ev.ctx, a1);\n                return;\n            case 2:\n                while (++i < l)\n                    (ev = events[i]).callback.call(ev.ctx, a1, a2);\n                return;\n            case 3:\n                while (++i < l)\n                    (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n                return;\n            default:\n                while (++i < l)\n                    (ev = events[i]).callback.apply(ev.ctx, args);\n                return;\n        }\n    };\n\n    var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n    // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n    // listen to an event in another object ... keeping track of what it's\n    // listening to.\n    _.each(listenMethods, function (implementation, method) {\n        Events[method] = function (obj, name, callback) {\n            var listeningTo = this._listeningTo || (this._listeningTo = {});\n            var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n            listeningTo[id] = obj;\n            if (!callback && typeof name === 'object')\n                callback = this;\n            obj[implementation](name, callback, this);\n            return this;\n        };\n    });\n\n    // Aliases for backwards compatibility.\n    Events.bind = Events.on;\n    Events.unbind = Events.off;\n\n    // Allow the `Backbone` object to serve as a global event bus, for folks who\n    // want global \"pubsub\" in a convenient place.\n    _.extend(Backbone, Events);\n\n    // Backbone.Model\n    // --------------\n\n    // Backbone **Models** are the basic data object in the framework --\n    // frequently representing a row in a table in a database on your server.\n    // A discrete chunk of data and a bunch of useful, related methods for\n    // performing computations and transformations on that data.\n\n    // Create a new model with the specified attributes. A client id (`cid`)\n    // is automatically generated and assigned for you.\n    var Model = Backbone.Model = function (attributes, options) {\n        var attrs = attributes || {};\n        options || (options = {});\n        this.cid = _.uniqueId('c');\n        this.attributes = {};\n        if (options.collection)\n            this.collection = options.collection;\n        if (options.parse)\n            attrs = this.parse(attrs, options) || {};\n        attrs = _.defaults({}, attrs, _.result(this, 'defaults'));\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    };\n\n    // Attach all inheritable methods to the Model prototype.\n    _.extend(Model.prototype, Events, {\n        // A hash of attributes whose current and previous value differ.\n        changed: null,\n        // The value returned during the last failed validation.\n        validationError: null,\n        // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n        // CouchDB users may want to set this to `\"_id\"`.\n        idAttribute: 'id',\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function () {\n        },\n        // Return a copy of the model's `attributes` object.\n        toJSON: function (options) {\n            return _.clone(this.attributes);\n        },\n        // Proxy `Backbone.sync` by default -- but override this if you need\n        // custom syncing semantics for *this* particular model.\n        sync: function () {\n            return Backbone.sync.apply(this, arguments);\n        },\n        // Get the value of an attribute.\n        get: function (attr) {\n            return this.attributes[attr];\n        },\n        // Get the HTML-escaped value of an attribute.\n        escape: function (attr) {\n            return _.escape(this.get(attr));\n        },\n        // Returns `true` if the attribute contains a value that is not null\n        // or undefined.\n        has: function (attr) {\n            return this.get(attr) != null;\n        },\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\n        // the core primitive operation of a model, updating the data and notifying\n        // anyone who needs to know about the change in state. The heart of the beast.\n        set: function (key, val, options) {\n            var attr, attrs, unset, changes, silent, changing, prev, current;\n            if (key == null)\n                return this;\n\n            // Handle both `\"key\", value` and `{key: value}` -style arguments.\n            if (typeof key === 'object') {\n                attrs = key;\n                options = val;\n            } else {\n                (attrs = {})[key] = val;\n            }\n\n            options || (options = {});\n\n            // Run validation.\n            if (!this._validate(attrs, options))\n                return false;\n\n            // Extract attributes and options.\n            unset = options.unset;\n            silent = options.silent;\n            changes = [];\n            changing = this._changing;\n            this._changing = true;\n\n            if (!changing) {\n                this._previousAttributes = _.clone(this.attributes);\n                this.changed = {};\n            }\n            current = this.attributes, prev = this._previousAttributes;\n\n            // Check for changes of `id`.\n            if (this.idAttribute in attrs)\n                this.id = attrs[this.idAttribute];\n\n            // For each `set` attribute, update or delete the current value.\n            for (attr in attrs) {\n                val = attrs[attr];\n                if (!_.isEqual(current[attr], val))\n                    changes.push(attr);\n                if (!_.isEqual(prev[attr], val)) {\n                    this.changed[attr] = val;\n                } else {\n                    delete this.changed[attr];\n                }\n                unset ? delete current[attr] : current[attr] = val;\n            }\n\n            // Trigger all relevant attribute changes.\n            if (!silent) {\n                if (changes.length)\n                    this._pending = options;\n                for (var i = 0, l = changes.length; i < l; i++) {\n                    this.trigger('change:' + changes[i], this, current[changes[i]], options);\n                }\n            }\n\n            // You might be wondering why there's a `while` loop here. Changes can\n            // be recursively nested within `\"change\"` events.\n            if (changing)\n                return this;\n            if (!silent) {\n                while (this._pending) {\n                    options = this._pending;\n                    this._pending = false;\n                    this.trigger('change', this, options);\n                }\n            }\n            this._pending = false;\n            this._changing = false;\n            return this;\n        },\n        // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n        // if the attribute doesn't exist.\n        unset: function (attr, options) {\n            return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n        },\n        // Clear all attributes on the model, firing `\"change\"`.\n        clear: function (options) {\n            var attrs = {};\n            for (var key in this.attributes)\n                attrs[key] = void 0;\n            return this.set(attrs, _.extend({}, options, {unset: true}));\n        },\n        // Determine if the model has changed since the last `\"change\"` event.\n        // If you specify an attribute name, determine if that attribute has changed.\n        hasChanged: function (attr) {\n            if (attr == null)\n                return !_.isEmpty(this.changed);\n            return _.has(this.changed, attr);\n        },\n        // Return an object containing all the attributes that have changed, or\n        // false if there are no changed attributes. Useful for determining what\n        // parts of a view need to be updated and/or what attributes need to be\n        // persisted to the server. Unset attributes will be set to undefined.\n        // You can also pass an attributes object to diff against the model,\n        // determining if there *would be* a change.\n        changedAttributes: function (diff) {\n            if (!diff)\n                return this.hasChanged() ? _.clone(this.changed) : false;\n            var val, changed = false;\n            var old = this._changing ? this._previousAttributes : this.attributes;\n            for (var attr in diff) {\n                if (_.isEqual(old[attr], (val = diff[attr])))\n                    continue;\n                (changed || (changed = {}))[attr] = val;\n            }\n            return changed;\n        },\n        // Get the previous value of an attribute, recorded at the time the last\n        // `\"change\"` event was fired.\n        previous: function (attr) {\n            if (attr == null || !this._previousAttributes)\n                return null;\n            return this._previousAttributes[attr];\n        },\n        // Get all of the attributes of the model at the time of the previous\n        // `\"change\"` event.\n        previousAttributes: function () {\n            return _.clone(this._previousAttributes);\n        },\n        // Fetch the model from the server. If the server's representation of the\n        // model differs from its current attributes, they will be overridden,\n        // triggering a `\"change\"` event.\n        fetch: function (options) {\n            options = options ? _.clone(options) : {};\n            if (options.parse === void 0)\n                options.parse = true;\n            var model = this;\n            var success = options.success;\n            options.success = function (resp) {\n                if (!model.set(model.parse(resp, options), options))\n                    return false;\n                if (success)\n                    success(model, resp, options);\n                model.trigger('sync', model, resp, options);\n            };\n            wrapError(this, options);\n            return this.sync('read', this, options);\n        },\n        // Set a hash of model attributes, and sync the model to the server.\n        // If the server returns an attributes hash that differs, the model's\n        // state will be `set` again.\n        save: function (key, val, options) {\n            var attrs, method, xhr, attributes = this.attributes;\n\n            // Handle both `\"key\", value` and `{key: value}` -style arguments.\n            if (key == null || typeof key === 'object') {\n                attrs = key;\n                options = val;\n            } else {\n                (attrs = {})[key] = val;\n            }\n\n            options = _.extend({validate: true}, options);\n\n            // If we're not waiting and attributes exist, save acts as\n            // `set(attr).save(null, opts)` with validation. Otherwise, check if\n            // the model will be valid when the attributes, if any, are set.\n            if (attrs && !options.wait) {\n                if (!this.set(attrs, options))\n                    return false;\n            } else {\n                if (!this._validate(attrs, options))\n                    return false;\n            }\n\n            // Set temporary attributes if `{wait: true}`.\n            if (attrs && options.wait) {\n                this.attributes = _.extend({}, attributes, attrs);\n            }\n\n            // After a successful server-side save, the client is (optionally)\n            // updated with the server-side state.\n            if (options.parse === void 0)\n                options.parse = true;\n            var model = this;\n            var success = options.success;\n            options.success = function (resp) {\n                // Ensure attributes are restored during synchronous saves.\n                model.attributes = attributes;\n                var serverAttrs = model.parse(resp, options);\n                if (options.wait)\n                    serverAttrs = _.extend(attrs || {}, serverAttrs);\n                if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {\n                    return false;\n                }\n                if (success)\n                    success(model, resp, options);\n                model.trigger('sync', model, resp, options);\n            };\n            wrapError(this, options);\n\n            method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n            if (method === 'patch')\n                options.attrs = attrs;\n            xhr = this.sync(method, this, options);\n\n            // Restore attributes.\n            if (attrs && options.wait)\n                this.attributes = attributes;\n\n            return xhr;\n        },\n        // Destroy this model on the server if it was already persisted.\n        // Optimistically removes the model from its collection, if it has one.\n        // If `wait: true` is passed, waits for the server to respond before removal.\n        destroy: function (options) {\n            options = options ? _.clone(options) : {};\n            var model = this;\n            var success = options.success;\n\n            var destroy = function () {\n                model.trigger('destroy', model, model.collection, options);\n            };\n\n            options.success = function (resp) {\n                if (options.wait || model.isNew())\n                    destroy();\n                if (success)\n                    success(model, resp, options);\n                if (!model.isNew())\n                    model.trigger('sync', model, resp, options);\n            };\n\n            if (this.isNew()) {\n                options.success();\n                return false;\n            }\n            wrapError(this, options);\n\n            var xhr = this.sync('delete', this, options);\n            if (!options.wait)\n                destroy();\n            return xhr;\n        },\n        // Default URL for the model's representation on the server -- if you're\n        // using Backbone's restful methods, override this to change the endpoint\n        // that will be called.\n        url: function () {\n            var base =\n                _.result(this, 'urlRoot') ||\n                _.result(this.collection, 'url') ||\n                urlError();\n            if (this.isNew())\n                return base;\n            return base.replace(/([^\\/])$/, '$1/') + encodeURIComponent(this.id);\n        },\n        // **parse** converts a response into the hash of attributes to be `set` on\n        // the model. The default implementation is just to pass the response along.\n        parse: function (resp, options) {\n            return resp;\n        },\n        // Create a new model with identical attributes to this one.\n        clone: function () {\n            return new this.constructor(this.attributes);\n        },\n        // A model is new if it has never been saved to the server, and lacks an id.\n        isNew: function () {\n            return !this.has(this.idAttribute);\n        },\n        // Check if the model is currently in a valid state.\n        isValid: function (options) {\n            return this._validate({}, _.extend(options || {}, {validate: true}));\n        },\n        // Run validation against the next complete set of model attributes,\n        // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n        _validate: function (attrs, options) {\n            if (!options.validate || !this.validate)\n                return true;\n            attrs = _.extend({}, this.attributes, attrs);\n            var error = this.validationError = this.validate(attrs, options) || null;\n            if (!error)\n                return true;\n            this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n            return false;\n        }\n\n    });\n\n    // Underscore methods that we want to implement on the Model.\n    var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];\n\n    // Mix in each Underscore method as a proxy to `Model#attributes`.\n    _.each(modelMethods, function (method) {\n        Model.prototype[method] = function () {\n            var args = slice.call(arguments);\n            args.unshift(this.attributes);\n            return _[method].apply(_, args);\n        };\n    });\n\n    // Backbone.Collection\n    // -------------------\n\n    // If models tend to represent a single row of data, a Backbone Collection is\n    // more analagous to a table full of data ... or a small slice or page of that\n    // table, or a collection of rows that belong together for a particular reason\n    // -- all of the messages in this particular folder, all of the documents\n    // belonging to this particular author, and so on. Collections maintain\n    // indexes of their models, both in order, and for lookup by `id`.\n\n    // Create a new **Collection**, perhaps to contain a specific type of `model`.\n    // If a `comparator` is specified, the Collection will maintain\n    // its models in sort order, as they're added and removed.\n    var Collection = Backbone.Collection = function (models, options) {\n        options || (options = {});\n        if (options.model)\n            this.model = options.model;\n        if (options.comparator !== void 0)\n            this.comparator = options.comparator;\n        this._reset();\n        this.initialize.apply(this, arguments);\n        if (models)\n            this.reset(models, _.extend({silent: true}, options));\n    };\n\n    // Default options for `Collection#set`.\n    var setOptions = {add: true, remove: true, merge: true};\n    var addOptions = {add: true, remove: false};\n\n    // Define the Collection's inheritable methods.\n    _.extend(Collection.prototype, Events, {\n        // The default model for a collection is just a **Backbone.Model**.\n        // This should be overridden in most cases.\n        model: Model,\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function () {\n        },\n        // The JSON representation of a Collection is an array of the\n        // models' attributes.\n        toJSON: function (options) {\n            return this.map(function (model) {\n                return model.toJSON(options);\n            });\n        },\n        // Proxy `Backbone.sync` by default.\n        sync: function () {\n            return Backbone.sync.apply(this, arguments);\n        },\n        // Add a model, or list of models to the set.\n        add: function (models, options) {\n            return this.set(models, _.extend({merge: false}, options, addOptions));\n        },\n        // Remove a model, or a list of models from the set.\n        remove: function (models, options) {\n            var singular = !_.isArray(models);\n            models = singular ? [models] : _.clone(models);\n            options || (options = {});\n            var i, l, index, model;\n            for (i = 0, l = models.length; i < l; i++) {\n                model = models[i] = this.get(models[i]);\n                if (!model)\n                    continue;\n                delete this._byId[model.id];\n                delete this._byId[model.cid];\n                index = this.indexOf(model);\n                this.models.splice(index, 1);\n                this.length--;\n                if (!options.silent) {\n                    options.index = index;\n                    model.trigger('remove', model, this, options);\n                }\n                this._removeReference(model, options);\n            }\n            return singular ? models[0] : models;\n        },\n        // Update a collection by `set`-ing a new list of models, adding new ones,\n        // removing models that are no longer present, and merging models that\n        // already exist in the collection, as necessary. Similar to **Model#set**,\n        // the core operation for updating the data contained by the collection.\n        set: function (models, options) {\n            options = _.defaults({}, options, setOptions);\n            if (options.parse)\n                models = this.parse(models, options);\n            var singular = !_.isArray(models);\n            models = singular ? (models ? [models] : []) : _.clone(models);\n            var i, l, id, model, attrs, existing, sort;\n            var at = options.at;\n            var targetModel = this.model;\n            var sortable = this.comparator && (at == null) && options.sort !== false;\n            var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n            var toAdd = [], toRemove = [], modelMap = {};\n            var add = options.add, merge = options.merge, remove = options.remove;\n            var order = !sortable && add && remove ? [] : false;\n\n            // Turn bare objects into model references, and prevent invalid models\n            // from being added.\n            for (i = 0, l = models.length; i < l; i++) {\n                attrs = models[i] || {};\n                if (attrs instanceof Model) {\n                    id = model = attrs;\n                } else {\n                    id = attrs[targetModel.prototype.idAttribute || 'id'];\n                }\n\n                // If a duplicate is found, prevent it from being added and\n                // optionally merge it into the existing model.\n                if (existing = this.get(id)) {\n                    if (remove)\n                        modelMap[existing.cid] = true;\n                    if (merge) {\n                        attrs = attrs === model ? model.attributes : attrs;\n                        if (options.parse)\n                            attrs = existing.parse(attrs, options);\n                        existing.set(attrs, options);\n                        if (sortable && !sort && existing.hasChanged(sortAttr))\n                            sort = true;\n                    }\n                    models[i] = existing;\n\n                    // If this is a new, valid model, push it to the `toAdd` list.\n                } else if (add) {\n                    model = models[i] = this._prepareModel(attrs, options);\n                    if (!model)\n                        continue;\n                    toAdd.push(model);\n                    this._addReference(model, options);\n                }\n\n                // Do not add multiple models with the same `id`.\n                model = existing || model;\n                if (order && (model.isNew() || !modelMap[model.id]))\n                    order.push(model);\n                modelMap[model.id] = true;\n            }\n\n            // Remove nonexistent models if appropriate.\n            if (remove) {\n                for (i = 0, l = this.length; i < l; ++i) {\n                    if (!modelMap[(model = this.models[i]).cid])\n                        toRemove.push(model);\n                }\n                if (toRemove.length)\n                    this.remove(toRemove, options);\n            }\n\n            // See if sorting is needed, update `length` and splice in new models.\n            if (toAdd.length || (order && order.length)) {\n                if (sortable)\n                    sort = true;\n                this.length += toAdd.length;\n                if (at != null) {\n                    for (i = 0, l = toAdd.length; i < l; i++) {\n                        this.models.splice(at + i, 0, toAdd[i]);\n                    }\n                } else {\n                    if (order)\n                        this.models.length = 0;\n                    var orderedModels = order || toAdd;\n                    for (i = 0, l = orderedModels.length; i < l; i++) {\n                        this.models.push(orderedModels[i]);\n                    }\n                }\n            }\n\n            // Silently sort the collection if appropriate.\n            if (sort)\n                this.sort({silent: true});\n\n            // Unless silenced, it's time to fire all appropriate add/sort events.\n            if (!options.silent) {\n                for (i = 0, l = toAdd.length; i < l; i++) {\n                    (model = toAdd[i]).trigger('add', model, this, options);\n                }\n                if (sort || (order && order.length))\n                    this.trigger('sort', this, options);\n            }\n\n            // Return the added (or merged) model (or models).\n            return singular ? models[0] : models;\n        },\n        // When you have more items than you want to add or remove individually,\n        // you can reset the entire set with a new list of models, without firing\n        // any granular `add` or `remove` events. Fires `reset` when finished.\n        // Useful for bulk operations and optimizations.\n        reset: function (models, options) {\n            options || (options = {});\n            for (var i = 0, l = this.models.length; i < l; i++) {\n                this._removeReference(this.models[i], options);\n            }\n            options.previousModels = this.models;\n            this._reset();\n            models = this.add(models, _.extend({silent: true}, options));\n            if (!options.silent)\n                this.trigger('reset', this, options);\n            return models;\n        },\n        // Add a model to the end of the collection.\n        push: function (model, options) {\n            return this.add(model, _.extend({at: this.length}, options));\n        },\n        // Remove a model from the end of the collection.\n        pop: function (options) {\n            var model = this.at(this.length - 1);\n            this.remove(model, options);\n            return model;\n        },\n        // Add a model to the beginning of the collection.\n        unshift: function (model, options) {\n            return this.add(model, _.extend({at: 0}, options));\n        },\n        // Remove a model from the beginning of the collection.\n        shift: function (options) {\n            var model = this.at(0);\n            this.remove(model, options);\n            return model;\n        },\n        // Slice out a sub-array of models from the collection.\n        slice: function () {\n            return slice.apply(this.models, arguments);\n        },\n        // Get a model from the set by id.\n        get: function (obj) {\n            if (obj == null)\n                return void 0;\n            return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];\n        },\n        // Get the model at the given index.\n        at: function (index) {\n            return this.models[index];\n        },\n        // Return models with matching attributes. Useful for simple cases of\n        // `filter`.\n        where: function (attrs, first) {\n            if (_.isEmpty(attrs))\n                return first ? void 0 : [];\n            return this[first ? 'find' : 'filter'](function (model) {\n                for (var key in attrs) {\n                    if (attrs[key] !== model.get(key))\n                        return false;\n                }\n                return true;\n            });\n        },\n        // Return the first model with matching attributes. Useful for simple cases\n        // of `find`.\n        findWhere: function (attrs) {\n            return this.where(attrs, true);\n        },\n        // Force the collection to re-sort itself. You don't need to call this under\n        // normal circumstances, as the set will maintain sort order as each item\n        // is added.\n        sort: function (options) {\n            if (!this.comparator)\n                throw new Error('Cannot sort a set without a comparator');\n            options || (options = {});\n\n            // Run sort based on type of `comparator`.\n            if (_.isString(this.comparator) || this.comparator.length === 1) {\n                this.models = this.sortBy(this.comparator, this);\n            } else {\n                this.models.sort(_.bind(this.comparator, this));\n            }\n\n            if (!options.silent)\n                this.trigger('sort', this, options);\n            return this;\n        },\n        // Pluck an attribute from each model in the collection.\n        pluck: function (attr) {\n            return _.invoke(this.models, 'get', attr);\n        },\n        // Fetch the default set of models for this collection, resetting the\n        // collection when they arrive. If `reset: true` is passed, the response\n        // data will be passed through the `reset` method instead of `set`.\n        fetch: function (options) {\n            options = options ? _.clone(options) : {};\n            if (options.parse === void 0)\n                options.parse = true;\n            var success = options.success;\n            var collection = this;\n            options.success = function (resp) {\n                var method = options.reset ? 'reset' : 'set';\n                collection[method](resp, options);\n                if (success)\n                    success(collection, resp, options);\n                collection.trigger('sync', collection, resp, options);\n            };\n            wrapError(this, options);\n            return this.sync('read', this, options);\n        },\n        // Create a new instance of a model in this collection. Add the model to the\n        // collection immediately, unless `wait: true` is passed, in which case we\n        // wait for the server to agree.\n        create: function (model, options) {\n            options = options ? _.clone(options) : {};\n            if (!(model = this._prepareModel(model, options)))\n                return false;\n            if (!options.wait)\n                this.add(model, options);\n            var collection = this;\n            var success = options.success;\n            options.success = function (model, resp) {\n                if (options.wait)\n                    collection.add(model, options);\n                if (success)\n                    success(model, resp, options);\n            };\n            model.save(null, options);\n            return model;\n        },\n        // **parse** converts a response into a list of models to be added to the\n        // collection. The default implementation is just to pass it through.\n        parse: function (resp, options) {\n            return resp;\n        },\n        // Create a new collection with an identical list of models as this one.\n        clone: function () {\n            return new this.constructor(this.models);\n        },\n        // Private method to reset all internal state. Called when the collection\n        // is first initialized or reset.\n        _reset: function () {\n            this.length = 0;\n            this.models = [];\n            this._byId = {};\n        },\n        // Prepare a hash of attributes (or other model) to be added to this\n        // collection.\n        _prepareModel: function (attrs, options) {\n            if (attrs instanceof Model)\n                return attrs;\n            options = options ? _.clone(options) : {};\n            options.collection = this;\n            var model = new this.model(attrs, options);\n            if (!model.validationError)\n                return model;\n            this.trigger('invalid', this, model.validationError, options);\n            return false;\n        },\n        // Internal method to create a model's ties to a collection.\n        _addReference: function (model, options) {\n            this._byId[model.cid] = model;\n            if (model.id != null)\n                this._byId[model.id] = model;\n            if (!model.collection)\n                model.collection = this;\n            model.on('all', this._onModelEvent, this);\n        },\n        // Internal method to sever a model's ties to a collection.\n        _removeReference: function (model, options) {\n            if (this === model.collection)\n                delete model.collection;\n            model.off('all', this._onModelEvent, this);\n        },\n        // Internal method called every time a model in the set fires an event.\n        // Sets need to update their indexes when models change ids. All other\n        // events simply proxy through. \"add\" and \"remove\" events that originate\n        // in other collections are ignored.\n        _onModelEvent: function (event, model, collection, options) {\n            if ((event === 'add' || event === 'remove') && collection !== this)\n                return;\n            if (event === 'destroy')\n                this.remove(model, options);\n            if (model && event === 'change:' + model.idAttribute) {\n                delete this._byId[model.previous(model.idAttribute)];\n                if (model.id != null)\n                    this._byId[model.id] = model;\n            }\n            this.trigger.apply(this, arguments);\n        }\n\n    });\n\n    // Underscore methods that we want to implement on the Collection.\n    // 90% of the core usefulness of Backbone Collections is actually implemented\n    // right here:\n    var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n        'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n        'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n        'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\n        'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',\n        'lastIndexOf', 'isEmpty', 'chain', 'sample'];\n\n    // Mix in each Underscore method as a proxy to `Collection#models`.\n    _.each(methods, function (method) {\n        Collection.prototype[method] = function () {\n            var args = slice.call(arguments);\n            args.unshift(this.models);\n            return _[method].apply(_, args);\n        };\n    });\n\n    // Underscore methods that take a property name as an argument.\n    var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];\n\n    // Use attributes instead of properties.\n    _.each(attributeMethods, function (method) {\n        Collection.prototype[method] = function (value, context) {\n            var iterator = _.isFunction(value) ? value : function (model) {\n                return model.get(value);\n            };\n            return _[method](this.models, iterator, context);\n        };\n    });\n\n    // Backbone.View\n    // -------------\n\n    // Backbone Views are almost more convention than they are actual code. A View\n    // is simply a JavaScript object that represents a logical chunk of UI in the\n    // DOM. This might be a single item, an entire list, a sidebar or panel, or\n    // even the surrounding frame which wraps your whole app. Defining a chunk of\n    // UI as a **View** allows you to define your DOM events declaratively, without\n    // having to worry about render order ... and makes it easy for the view to\n    // react to specific changes in the state of your models.\n\n    // Creating a Backbone.View creates its initial element outside of the DOM,\n    // if an existing element is not provided...\n    var View = Backbone.View = function (options) {\n        this.cid = _.uniqueId('view');\n        options || (options = {});\n        _.extend(this, _.pick(options, viewOptions));\n        this._ensureElement();\n        this.initialize.apply(this, arguments);\n        this.delegateEvents();\n    };\n\n    // Cached regex to split keys for `delegate`.\n    var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n    // List of view options to be merged as properties.\n    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n    // Set up all inheritable **Backbone.View** properties and methods.\n    _.extend(View.prototype, Events, {\n        // The default `tagName` of a View's element is `\"div\"`.\n        tagName: 'div',\n        // jQuery delegate for element lookup, scoped to DOM elements within the\n        // current view. This should be preferred to global lookups where possible.\n        $: function (selector) {\n            return this.$el.find(selector);\n        },\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function () {\n        },\n        // **render** is the core function that your view should override, in order\n        // to populate its element (`this.el`), with the appropriate HTML. The\n        // convention is for **render** to always return `this`.\n        render: function () {\n            return this;\n        },\n        // Remove this view by taking the element out of the DOM, and removing any\n        // applicable Backbone.Events listeners.\n        remove: function () {\n            this.$el.remove();\n            this.stopListening();\n            return this;\n        },\n        // Change the view's element (`this.el` property), including event\n        // re-delegation.\n        setElement: function (element, delegate) {\n            if (this.$el)\n                this.undelegateEvents();\n            this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\n            this.el = this.$el[0];\n            if (delegate !== false)\n                this.delegateEvents();\n            return this;\n        },\n        // Set callbacks, where `this.events` is a hash of\n        //\n        // *{\"event selector\": \"callback\"}*\n        //\n        //     {\n        //       'mousedown .title':  'edit',\n        //       'click .button':     'save',\n        //       'click .open':       function(e) { ... }\n        //     }\n        //\n        // pairs. Callbacks will be bound to the view, with `this` set properly.\n        // Uses event delegation for efficiency.\n        // Omitting the selector binds the event to `this.el`.\n        // This only works for delegate-able events: not `focus`, `blur`, and\n        // not `change`, `submit`, and `reset` in Internet Explorer.\n        delegateEvents: function (events) {\n            if (!(events || (events = _.result(this, 'events'))))\n                return this;\n            this.undelegateEvents();\n            for (var key in events) {\n                var method = events[key];\n                if (!_.isFunction(method))\n                    method = this[events[key]];\n                if (!method)\n                    continue;\n\n                var match = key.match(delegateEventSplitter);\n                var eventName = match[1], selector = match[2];\n                method = _.bind(method, this);\n                eventName += '.delegateEvents' + this.cid;\n                if (selector === '') {\n                    this.$el.on(eventName, method);\n                } else {\n                    this.$el.on(eventName, selector, method);\n                }\n            }\n            return this;\n        },\n        // Clears all callbacks previously bound to the view with `delegateEvents`.\n        // You usually don't need to use this, but may wish to if you have multiple\n        // Backbone views attached to the same DOM element.\n        undelegateEvents: function () {\n            this.$el.off('.delegateEvents' + this.cid);\n            return this;\n        },\n        // Ensure that the View has a DOM element to render into.\n        // If `this.el` is a string, pass it through `$()`, take the first\n        // matching element, and re-assign it to `el`. Otherwise, create\n        // an element from the `id`, `className` and `tagName` properties.\n        _ensureElement: function () {\n            if (!this.el) {\n                var attrs = _.extend({}, _.result(this, 'attributes'));\n                if (this.id)\n                    attrs.id = _.result(this, 'id');\n                if (this.className)\n                    attrs['class'] = _.result(this, 'className');\n                var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);\n                this.setElement($el, false);\n            } else {\n                this.setElement(_.result(this, 'el'), false);\n            }\n        }\n\n    });\n\n    // Backbone.sync\n    // -------------\n\n    // Override this function to change the manner in which Backbone persists\n    // models to the server. You will be passed the type of request, and the\n    // model in question. By default, makes a RESTful Ajax request\n    // to the model's `url()`. Some possible customizations could be:\n    //\n    // * Use `setTimeout` to batch rapid-fire updates into a single request.\n    // * Send up the models as XML instead of JSON.\n    // * Persist models via WebSockets instead of Ajax.\n    //\n    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n    // as `POST`, with a `_method` parameter containing the true HTTP method,\n    // as well as all requests with the body as `application/x-www-form-urlencoded`\n    // instead of `application/json` with the model in a param named `model`.\n    // Useful when interfacing with server-side languages like **PHP** that make\n    // it difficult to read the body of `PUT` requests.\n    Backbone.sync = function (method, model, options) {\n        var type = methodMap[method];\n\n        // Default options, unless specified.\n        _.defaults(options || (options = {}), {\n            emulateHTTP: Backbone.emulateHTTP,\n            emulateJSON: Backbone.emulateJSON\n        });\n\n        // Default JSON-request options.\n        var params = {type: type, dataType: 'json'};\n\n        // Ensure that we have a URL.\n        if (!options.url) {\n            params.url = _.result(model, 'url') || urlError();\n        }\n\n        // Ensure that we have the appropriate request data.\n        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n            params.contentType = 'application/json';\n            params.data = JSON.stringify(options.attrs || model.toJSON(options));\n        }\n\n        // For older servers, emulate JSON by encoding the request into an HTML-form.\n        if (options.emulateJSON) {\n            params.contentType = 'application/x-www-form-urlencoded';\n            params.data = params.data ? {model: params.data} : {};\n        }\n\n        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n        // And an `X-HTTP-Method-Override` header.\n        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n            params.type = 'POST';\n            if (options.emulateJSON)\n                params.data._method = type;\n            var beforeSend = options.beforeSend;\n            options.beforeSend = function (xhr) {\n                xhr.setRequestHeader('X-HTTP-Method-Override', type);\n                if (beforeSend)\n                    return beforeSend.apply(this, arguments);\n            };\n        }\n\n        // Don't process data on a non-GET request.\n        if (params.type !== 'GET' && !options.emulateJSON) {\n            params.processData = false;\n        }\n\n        // If we're sending a `PATCH` request, and we're in an old Internet Explorer\n        // that still has ActiveX enabled by default, override jQuery to use that\n        // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.\n        if (params.type === 'PATCH' && noXhrPatch) {\n            params.xhr = function () {\n                return new ActiveXObject(\"Microsoft.XMLHTTP\");\n            };\n        }\n\n        // Make the request, allowing the user to override any Ajax options.\n        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n        model.trigger('request', model, xhr, options);\n        return xhr;\n    };\n\n    var noXhrPatch =\n        typeof window !== 'undefined' && !!window.ActiveXObject &&\n        !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);\n\n    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n    var methodMap = {\n        'create': 'POST',\n        'update': 'PUT',\n        'patch': 'PATCH',\n        'delete': 'DELETE',\n        'read': 'GET'\n    };\n\n    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n    // Override this if you'd like to use a different library.\n    Backbone.ajax = function () {\n        return Backbone.$.ajax.apply(Backbone.$, arguments);\n    };\n\n    // Backbone.Router\n    // ---------------\n\n    // Routers map faux-URLs to actions, and fire events when routes are\n    // matched. Creating a new one sets its `routes` hash, if not set statically.\n    var Router = Backbone.Router = function (options) {\n        options || (options = {});\n        if (options.routes)\n            this.routes = options.routes;\n        this._bindRoutes();\n        this.initialize.apply(this, arguments);\n    };\n\n    // Cached regular expressions for matching named param parts and splatted\n    // parts of route strings.\n    var optionalParam = /\\((.*?)\\)/g;\n    var namedParam = /(\\(\\?)?:\\w+/g;\n    var splatParam = /\\*\\w+/g;\n    var escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n    // Set up all inheritable **Backbone.Router** properties and methods.\n    _.extend(Router.prototype, Events, {\n        // Initialize is an empty function by default. Override it with your own\n        // initialization logic.\n        initialize: function () {\n        },\n        // Manually bind a single named route to a callback. For example:\n        //\n        //     this.route('search/:query/p:num', 'search', function(query, num) {\n        //       ...\n        //     });\n        //\n        route: function (route, name, callback) {\n            if (!_.isRegExp(route))\n                route = this._routeToRegExp(route);\n            if (_.isFunction(name)) {\n                callback = name;\n                name = '';\n            }\n            if (!callback)\n                callback = this[name];\n            var router = this;\n            Backbone.history.route(route, function (fragment) {\n                var args = router._extractParameters(route, fragment);\n                router.execute(callback, args);\n                router.trigger.apply(router, ['route:' + name].concat(args));\n                router.trigger('route', name, args);\n                Backbone.history.trigger('route', router, name, args);\n            });\n            return this;\n        },\n        // Execute a route handler with the provided parameters.  This is an\n        // excellent place to do pre-route setup or post-route cleanup.\n        execute: function (callback, args) {\n            if (callback)\n                callback.apply(this, args);\n        },\n        // Simple proxy to `Backbone.history` to save a fragment into the history.\n        navigate: function (fragment, options) {\n            Backbone.history.navigate(fragment, options);\n            return this;\n        },\n        // Bind all defined routes to `Backbone.history`. We have to reverse the\n        // order of the routes here to support behavior where the most general\n        // routes can be defined at the bottom of the route map.\n        _bindRoutes: function () {\n            if (!this.routes)\n                return;\n            this.routes = _.result(this, 'routes');\n            var route, routes = _.keys(this.routes);\n            while ((route = routes.pop()) != null) {\n                this.route(route, this.routes[route]);\n            }\n        },\n        // Convert a route string into a regular expression, suitable for matching\n        // against the current location hash.\n        _routeToRegExp: function (route) {\n            route = route.replace(escapeRegExp, '\\\\$&')\n                .replace(optionalParam, '(?:$1)?')\n                .replace(namedParam, function (match, optional) {\n                    return optional ? match : '([^/?]+)';\n                })\n                .replace(splatParam, '([^?]*?)');\n            return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n        },\n        // Given a route, and a URL fragment that it matches, return the array of\n        // extracted decoded parameters. Empty or unmatched parameters will be\n        // treated as `null` to normalize cross-browser behavior.\n        _extractParameters: function (route, fragment) {\n            var params = route.exec(fragment).slice(1);\n            return _.map(params, function (param, i) {\n                // Don't decode the search params.\n                if (i === params.length - 1)\n                    return param || null;\n                return param ? decodeURIComponent(param) : null;\n            });\n        }\n\n    });\n\n    // Backbone.History\n    // ----------------\n\n    // Handles cross-browser history management, based on either\n    // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n    // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n    // and URL fragments. If the browser supports neither (old IE, natch),\n    // falls back to polling.\n    var History = Backbone.History = function () {\n        this.handlers = [];\n        _.bindAll(this, 'checkUrl');\n\n        // Ensure that `History` can be used outside of the browser.\n        if (typeof window !== 'undefined') {\n            this.location = window.location;\n            this.history = window.history;\n        }\n    };\n\n    // Cached regex for stripping a leading hash/slash and trailing space.\n    var routeStripper = /^[#\\/]|\\s+$/g;\n\n    // Cached regex for stripping leading and trailing slashes.\n    var rootStripper = /^\\/+|\\/+$/g;\n\n    // Cached regex for detecting MSIE.\n    var isExplorer = /msie [\\w.]+/;\n\n    // Cached regex for removing a trailing slash.\n    var trailingSlash = /\\/$/;\n\n    // Cached regex for stripping urls of hash.\n    var pathStripper = /#.*$/;\n\n    // Has the history handling already been started?\n    History.started = false;\n\n    // Set up all inheritable **Backbone.History** properties and methods.\n    _.extend(History.prototype, Events, {\n        // The default interval to poll for hash changes, if necessary, is\n        // twenty times a second.\n        interval: 50,\n        // Are we at the app root?\n        atRoot: function () {\n            return this.location.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n        },\n        // Gets the true hash value. Cannot use location.hash directly due to bug\n        // in Firefox where location.hash will always be decoded.\n        getHash: function (window) {\n            var match = (window || this).location.href.match(/#(.*)$/);\n            return match ? match[1] : '';\n        },\n        // Get the cross-browser normalized URL fragment, either from the URL,\n        // the hash, or the override.\n        getFragment: function (fragment, forcePushState) {\n            if (fragment == null) {\n                if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n                    fragment = decodeURI(this.location.pathname + this.location.search);\n                    var root = this.root.replace(trailingSlash, '');\n                    if (!fragment.indexOf(root))\n                        fragment = fragment.slice(root.length);\n                } else {\n                    fragment = this.getHash();\n                }\n            }\n            return fragment.replace(routeStripper, '');\n        },\n        // Start the hash change handling, returning `true` if the current URL matches\n        // an existing route, and `false` otherwise.\n        start: function (options) {\n            if (History.started)\n                throw new Error(\"Backbone.history has already been started\");\n            History.started = true;\n\n            // Figure out the initial configuration. Do we need an iframe?\n            // Is pushState desired ... is it available?\n            this.options = _.extend({root: '/'}, this.options, options);\n            this.root = this.options.root;\n            this._wantsHashChange = this.options.hashChange !== false;\n            this._wantsPushState = !!this.options.pushState;\n            this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);\n            var fragment = this.getFragment();\n            var docMode = document.documentMode;\n            var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n            // Normalize root to always include a leading and trailing slash.\n            this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n            if (oldIE && this._wantsHashChange) {\n                var frame = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\">');\n                this.iframe = frame.hide().appendTo('body')[0].contentWindow;\n                this.navigate(fragment);\n            }\n\n            // Depending on whether we're using pushState or hashes, and whether\n            // 'onhashchange' is supported, determine how we check the URL state.\n            if (this._hasPushState) {\n                Backbone.$(window).on('popstate', this.checkUrl);\n            } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n                Backbone.$(window).on('hashchange', this.checkUrl);\n            } else if (this._wantsHashChange) {\n                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n            }\n\n            // Determine if we need to change the base url, for a pushState link\n            // opened by a non-pushState browser.\n            this.fragment = fragment;\n            var loc = this.location;\n\n            // Transition from hashChange to pushState or vice versa if both are\n            // requested.\n            if (this._wantsHashChange && this._wantsPushState) {\n\n                // If we've started off with a route from a `pushState`-enabled\n                // browser, but we're currently in a browser that doesn't support it...\n                if (!this._hasPushState && !this.atRoot()) {\n                    this.fragment = this.getFragment(null, true);\n                    this.location.replace(this.root + '#' + this.fragment);\n                    // Return immediately as browser will do redirect to new url\n                    return true;\n\n                    // Or if we've started out with a hash-based route, but we're currently\n                    // in a browser where it could be `pushState`-based instead...\n                } else if (this._hasPushState && this.atRoot() && loc.hash) {\n                    this.fragment = this.getHash().replace(routeStripper, '');\n                    this.history.replaceState({}, document.title, this.root + this.fragment);\n                }\n\n            }\n\n            if (!this.options.silent)\n                return this.loadUrl();\n        },\n        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n        // but possibly useful for unit testing Routers.\n        stop: function () {\n            Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);\n            if (this._checkUrlInterval)\n                clearInterval(this._checkUrlInterval);\n            History.started = false;\n        },\n        // Add a route to be tested when the fragment changes. Routes added later\n        // may override previous routes.\n        route: function (route, callback) {\n            this.handlers.unshift({route: route, callback: callback});\n        },\n        // Checks the current URL to see if it has changed, and if it has,\n        // calls `loadUrl`, normalizing across the hidden iframe.\n        checkUrl: function (e) {\n            var current = this.getFragment();\n            if (current === this.fragment && this.iframe) {\n                current = this.getFragment(this.getHash(this.iframe));\n            }\n            if (current === this.fragment)\n                return false;\n            if (this.iframe)\n                this.navigate(current);\n            this.loadUrl();\n        },\n        // Attempt to load the current URL fragment. If a route succeeds with a\n        // match, returns `true`. If no defined routes matches the fragment,\n        // returns `false`.\n        loadUrl: function (fragment) {\n            fragment = this.fragment = this.getFragment(fragment);\n            return _.any(this.handlers, function (handler) {\n                if (handler.route.test(fragment)) {\n                    handler.callback(fragment);\n                    return true;\n                }\n            });\n        },\n        // Save a fragment into the hash history, or replace the URL state if the\n        // 'replace' option is passed. You are responsible for properly URL-encoding\n        // the fragment in advance.\n        //\n        // The options object can contain `trigger: true` if you wish to have the\n        // route callback be fired (not usually desirable), or `replace: true`, if\n        // you wish to modify the current URL without adding an entry to the history.\n        navigate: function (fragment, options) {\n            if (!History.started)\n                return false;\n            if (!options || options === true)\n                options = {trigger: !!options};\n\n            var url = this.root + (fragment = this.getFragment(fragment || ''));\n\n            // Strip the hash for matching.\n            fragment = fragment.replace(pathStripper, '');\n\n            if (this.fragment === fragment)\n                return;\n            this.fragment = fragment;\n\n            // Don't include a trailing slash on the root.\n            if (fragment === '' && url !== '/')\n                url = url.slice(0, -1);\n\n            // If pushState is available, we use it to set the fragment as a real URL.\n            if (this._hasPushState) {\n                this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n                // If hash changes haven't been explicitly disabled, update the hash\n                // fragment to store history.\n            } else if (this._wantsHashChange) {\n                this._updateHash(this.location, fragment, options.replace);\n                if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\n                    // Opening and closing the iframe tricks IE7 and earlier to push a\n                    // history entry on hash-tag change.  When replace is true, we don't\n                    // want this.\n                    if (!options.replace)\n                        this.iframe.document.open().close();\n                    this._updateHash(this.iframe.location, fragment, options.replace);\n                }\n\n                // If you've told us that you explicitly don't want fallback hashchange-\n                // based history, then `navigate` becomes a page refresh.\n            } else {\n                return this.location.assign(url);\n            }\n            if (options.trigger)\n                return this.loadUrl(fragment);\n        },\n        // Update the hash location, either replacing the current entry, or adding\n        // a new one to the browser history.\n        _updateHash: function (location, fragment, replace) {\n            if (replace) {\n                var href = location.href.replace(/(javascript:|#).*$/, '');\n                location.replace(href + '#' + fragment);\n            } else {\n                // Some browsers require that `hash` contains a leading #.\n                location.hash = '#' + fragment;\n            }\n        }\n\n    });\n\n    // Create the default Backbone.history.\n    Backbone.history = new History;\n\n    // Helpers\n    // -------\n\n    // Helper function to correctly set up the prototype chain, for subclasses.\n    // Similar to `goog.inherits`, but uses a hash of prototype properties and\n    // class properties to be extended.\n    var extend = function (protoProps, staticProps) {\n        var parent = this;\n        var child;\n\n        // The constructor function for the new subclass is either defined by you\n        // (the \"constructor\" property in your `extend` definition), or defaulted\n        // by us to simply call the parent's constructor.\n        if (protoProps && _.has(protoProps, 'constructor')) {\n            child = protoProps.constructor;\n        } else {\n            child = function () {\n                return parent.apply(this, arguments);\n            };\n        }\n\n        // Add static properties to the constructor function, if supplied.\n        _.extend(child, parent, staticProps);\n\n        // Set the prototype chain to inherit from `parent`, without calling\n        // `parent`'s constructor function.\n        var Surrogate = function () {\n            this.constructor = child;\n        };\n        Surrogate.prototype = parent.prototype;\n        child.prototype = new Surrogate;\n\n        // Add prototype properties (instance properties) to the subclass,\n        // if supplied.\n        if (protoProps)\n            _.extend(child.prototype, protoProps);\n\n        // Set a convenience property in case the parent's prototype is needed\n        // later.\n        child.__super__ = parent.prototype;\n\n        return child;\n    };\n\n    // Set up inheritance for the model, collection, router, view and history.\n    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n    // Throw an error when a URL is needed, and none is supplied.\n    var urlError = function () {\n        throw new Error('A \"url\" property or function must be specified');\n    };\n\n    // Wrap an optional error callback with a fallback error event.\n    var wrapError = function (model, options) {\n        var error = options.error;\n        options.error = function (resp) {\n            if (error)\n                error(model, resp, options);\n            model.trigger('error', model, resp, options);\n        };\n    };\n\n    return Backbone;\n\n}));\n\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = Backbone;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdmVuZG9yL2JhY2tib25lLmpzPzQ0MjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0M7QUFDeEM7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUIsRUFBRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EseUJBQXlCLDJEQUEyRDtBQUNwRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxlQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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VDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrRUFBK0U7O0FBRS9FO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBqcXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xudmFyIHVuZGVyc2NvcmUgPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcblxuLy8gICAgIEJhY2tib25lLmpzIDEuMS4yXG5cbi8vICAgICAoYykgMjAxMC0yMDE0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblxuICAgIC8vIFNldCB1cCBCYWNrYm9uZSBhcHByb3ByaWF0ZWx5IGZvciB0aGUgZW52aXJvbm1lbnQuIFN0YXJ0IHdpdGggQU1ELlxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsndW5kZXJzY29yZScsICdqcXVlcnknLCAnZXhwb3J0cyddLCBmdW5jdGlvbiAoXywgJCwgZXhwb3J0cykge1xuICAgICAgICAgICAgLy8gRXhwb3J0IGdsb2JhbCBldmVuIGluIEFNRCBjYXNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIHdpdGhcbiAgICAgICAgICAgIC8vIG90aGVycyB0aGF0IG1heSBzdGlsbCBleHBlY3QgYSBnbG9iYWwgQmFja2JvbmUuXG4gICAgICAgICAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTmV4dCBmb3IgTm9kZS5qcyBvciBDb21tb25KUy4galF1ZXJ5IG1heSBub3QgYmUgbmVlZGVkIGFzIGEgbW9kdWxlLlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuICAgICAgICBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8pO1xuXG4gICAgICAgIC8vIEZpbmFsbHksIGFzIGEgYnJvd3NlciBnbG9iYWwuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuXywgKHJvb3QualF1ZXJ5IHx8IHJvb3QuWmVwdG8gfHwgcm9vdC5lbmRlciB8fCByb290LiQpKTtcbiAgICB9XG5cbn0odGhpcywgZnVuY3Rpb24gKHJvb3QsIEJhY2tib25lLCBfLCAkKSB7XG5cbiAgICAvLyBJbml0aWFsIFNldHVwXG4gICAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGUsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgLy8gcmVzdG9yZWQgbGF0ZXIgb24sIGlmIGBub0NvbmZsaWN0YCBpcyB1c2VkLlxuICAgIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAgIC8vIENyZWF0ZSBsb2NhbCByZWZlcmVuY2VzIHRvIGFycmF5IG1ldGhvZHMgd2UnbGwgd2FudCB0byB1c2UgbGF0ZXIuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIHB1c2ggPSBhcnJheS5wdXNoO1xuICAgIHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuICAgIHZhciBzcGxpY2UgPSBhcnJheS5zcGxpY2U7XG5cbiAgICAvLyBDdXJyZW50IHZlcnNpb24gb2YgdGhlIGxpYnJhcnkuIEtlZXAgaW4gc3luYyB3aXRoIGBwYWNrYWdlLmpzb25gLlxuICAgIEJhY2tib25lLlZFUlNJT04gPSAnMS4xLjInO1xuXG4gICAgLy8gRm9yIEJhY2tib25lJ3MgcHVycG9zZXMsIGpRdWVyeSwgWmVwdG8sIEVuZGVyLCBvciBNeSBMaWJyYXJ5IChraWRkaW5nKSBvd25zXG4gICAgLy8gdGhlIGAkYCB2YXJpYWJsZS5cbiAgICBCYWNrYm9uZS4kID0gJDtcblxuICAgIC8vIFJ1bnMgQmFja2JvbmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYEJhY2tib25lYCB2YXJpYWJsZVxuICAgIC8vIHRvIGl0cyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIEJhY2tib25lIG9iamVjdC5cbiAgICBCYWNrYm9uZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByb290LkJhY2tib25lID0gcHJldmlvdXNCYWNrYm9uZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIFR1cm4gb24gYGVtdWxhdGVIVFRQYCB0byBzdXBwb3J0IGxlZ2FjeSBIVFRQIHNlcnZlcnMuIFNldHRpbmcgdGhpcyBvcHRpb25cbiAgICAvLyB3aWxsIGZha2UgYFwiUEFUQ0hcImAsIGBcIlBVVFwiYCBhbmQgYFwiREVMRVRFXCJgIHJlcXVlc3RzIHZpYSB0aGUgYF9tZXRob2RgIHBhcmFtZXRlciBhbmRcbiAgICAvLyBzZXQgYSBgWC1IdHRwLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICAgIEJhY2tib25lLmVtdWxhdGVIVFRQID0gZmFsc2U7XG5cbiAgICAvLyBUdXJuIG9uIGBlbXVsYXRlSlNPTmAgdG8gc3VwcG9ydCBsZWdhY3kgc2VydmVycyB0aGF0IGNhbid0IGRlYWwgd2l0aCBkaXJlY3RcbiAgICAvLyBgYXBwbGljYXRpb24vanNvbmAgcmVxdWVzdHMgLi4uIHdpbGwgZW5jb2RlIHRoZSBib2R5IGFzXG4gICAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gICAgLy8gZm9ybSBwYXJhbSBuYW1lZCBgbW9kZWxgLlxuICAgIEJhY2tib25lLmVtdWxhdGVKU09OID0gZmFsc2U7XG5cbiAgICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIEEgbW9kdWxlIHRoYXQgY2FuIGJlIG1peGVkIGluIHRvICphbnkgb2JqZWN0KiBpbiBvcmRlciB0byBwcm92aWRlIGl0IHdpdGhcbiAgICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gICAgLy8gZnVuY3Rpb25zIHRvIGFuIGV2ZW50OyBgdHJpZ2dlcmAtaW5nIGFuIGV2ZW50IGZpcmVzIGFsbCBjYWxsYmFja3MgaW5cbiAgICAvLyBzdWNjZXNzaW9uLlxuICAgIC8vXG4gICAgLy8gICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAvLyAgICAgXy5leHRlbmQob2JqZWN0LCBCYWNrYm9uZS5FdmVudHMpO1xuICAgIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgICAvLyAgICAgb2JqZWN0LnRyaWdnZXIoJ2V4cGFuZCcpO1xuICAgIC8vXG4gICAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHtcbiAgICAgICAgLy8gQmluZCBhbiBldmVudCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uIFBhc3NpbmcgYFwiYWxsXCJgIHdpbGwgYmluZFxuICAgICAgICAvLyB0aGUgY2FsbGJhY2sgdG8gYWxsIGV2ZW50cyBmaXJlZC5cbiAgICAgICAgb246IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSk7XG4gICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdIHx8ICh0aGlzLl9ldmVudHNbbmFtZV0gPSBbXSk7XG4gICAgICAgICAgICBldmVudHMucHVzaCh7Y2FsbGJhY2s6IGNhbGxiYWNrLCBjb250ZXh0OiBjb250ZXh0LCBjdHg6IGNvbnRleHQgfHwgdGhpc30pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEJpbmQgYW4gZXZlbnQgdG8gb25seSBiZSB0cmlnZ2VyZWQgYSBzaW5nbGUgdGltZS4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgICAgb25jZTogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAnb25jZScsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pIHx8ICFjYWxsYmFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvbmNlID0gXy5vbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9mZihuYW1lLCBvbmNlKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgICAgICAvLyBjYWxsYmFja3Mgd2l0aCB0aGF0IGZ1bmN0aW9uLiBJZiBgY2FsbGJhY2tgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gICAgICAgIC8vIGNhbGxiYWNrcyBmb3IgdGhlIGV2ZW50LiBJZiBgbmFtZWAgaXMgbnVsbCwgcmVtb3ZlcyBhbGwgYm91bmRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICAgICAgICBvZmY6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJldGFpbiwgZXYsIGV2ZW50cywgbmFtZXMsIGksIGwsIGosIGs7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhZXZlbnRzQXBpKHRoaXMsICdvZmYnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBfLmtleXModGhpcy5fZXZlbnRzKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBuYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrIHx8IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGsgPSBldmVudHMubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gZXYuY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrLl9jYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQgJiYgY29udGV4dCAhPT0gZXYuY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0YWluLnB1c2goZXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgICAgICAvLyBwYXNzZWQgdGhlIHNhbWUgYXJndW1lbnRzIGFzIGB0cmlnZ2VyYCBpcywgYXBhcnQgZnJvbSB0aGUgZXZlbnQgbmFtZVxuICAgICAgICAvLyAodW5sZXNzIHlvdSdyZSBsaXN0ZW5pbmcgb24gYFwiYWxsXCJgLCB3aGljaCB3aWxsIGNhdXNlIHlvdXIgY2FsbGJhY2sgdG9cbiAgICAgICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICd0cmlnZ2VyJywgbmFtZSwgYXJncykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICAgICAgICBpZiAoZXZlbnRzKVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoZXZlbnRzLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChhbGxFdmVudHMpXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhhbGxFdmVudHMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVGVsbCB0aGlzIG9iamVjdCB0byBzdG9wIGxpc3RlbmluZyB0byBlaXRoZXIgc3BlY2lmaWMgZXZlbnRzIC4uLiBvclxuICAgICAgICAvLyB0byBldmVyeSBvYmplY3QgaXQncyBjdXJyZW50bHkgbGlzdGVuaW5nIHRvLlxuICAgICAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbiAob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmluZ1RvID0gdGhpcy5fbGlzdGVuaW5nVG87XG4gICAgICAgICAgICBpZiAoIWxpc3RlbmluZ1RvKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgdmFyIHJlbW92ZSA9ICFuYW1lICYmICFjYWxsYmFjaztcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdGhpcztcbiAgICAgICAgICAgIGlmIChvYmopXG4gICAgICAgICAgICAgICAgKGxpc3RlbmluZ1RvID0ge30pW29iai5fbGlzdGVuSWRdID0gb2JqO1xuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gbGlzdGVuaW5nVG8pIHtcbiAgICAgICAgICAgICAgICBvYmogPSBsaXN0ZW5pbmdUb1tpZF07XG4gICAgICAgICAgICAgICAgb2JqLm9mZihuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZSB8fCBfLmlzRW1wdHkob2JqLl9ldmVudHMpKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbGlzdGVuaW5nVG9baWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxuICAgIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gICAgLy8gSW1wbGVtZW50IGZhbmN5IGZlYXR1cmVzIG9mIHRoZSBFdmVudHMgQVBJIHN1Y2ggYXMgbXVsdGlwbGUgZXZlbnRcbiAgICAvLyBuYW1lcyBgXCJjaGFuZ2UgYmx1clwiYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50IG1hcHMgYHtjaGFuZ2U6IGFjdGlvbn1gXG4gICAgLy8gaW4gdGVybXMgb2YgdGhlIGV4aXN0aW5nIEFQSS5cbiAgICB2YXIgZXZlbnRzQXBpID0gZnVuY3Rpb24gKG9iaiwgYWN0aW9uLCBuYW1lLCByZXN0KSB7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICAgICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHNwYWNlIHNlcGFyYXRlZCBldmVudCBuYW1lcy5cbiAgICAgICAgaWYgKGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb2JqW2FjdGlvbl0uYXBwbHkob2JqLCBbbmFtZXNbaV1dLmNvbmNhdChyZXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgICAvLyB0cmlnZ2VyaW5nIGV2ZW50cy4gVHJpZXMgdG8ga2VlcCB0aGUgdXN1YWwgY2FzZXMgc3BlZWR5IChtb3N0IGludGVybmFsXG4gICAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxuICAgIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50cywgYXJncykge1xuICAgICAgICB2YXIgZXYsIGkgPSAtMSwgbCA9IGV2ZW50cy5sZW5ndGgsIGExID0gYXJnc1swXSwgYTIgPSBhcmdzWzFdLCBhMyA9IGFyZ3NbMl07XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbClcbiAgICAgICAgICAgICAgICAgICAgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsKVxuICAgICAgICAgICAgICAgICAgICAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsKVxuICAgICAgICAgICAgICAgICAgICAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbClcbiAgICAgICAgICAgICAgICAgICAgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyLCBhMyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbClcbiAgICAgICAgICAgICAgICAgICAgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGlzdGVuTWV0aG9kcyA9IHtsaXN0ZW5UbzogJ29uJywgbGlzdGVuVG9PbmNlOiAnb25jZSd9O1xuXG4gICAgLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uYCBhbmQgYG9uY2VgLiBUZWxsICp0aGlzKiBvYmplY3QgdG9cbiAgICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gICAgLy8gbGlzdGVuaW5nIHRvLlxuICAgIF8uZWFjaChsaXN0ZW5NZXRob2RzLCBmdW5jdGlvbiAoaW1wbGVtZW50YXRpb24sIG1ldGhvZCkge1xuICAgICAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uIChvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbyB8fCAodGhpcy5fbGlzdGVuaW5nVG8gPSB7fSk7XG4gICAgICAgICAgICB2YXIgaWQgPSBvYmouX2xpc3RlbklkIHx8IChvYmouX2xpc3RlbklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgICAgICAgIGxpc3RlbmluZ1RvW2lkXSA9IG9iajtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdGhpcztcbiAgICAgICAgICAgIG9ialtpbXBsZW1lbnRhdGlvbl0obmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBbGlhc2VzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICBFdmVudHMuYmluZCA9IEV2ZW50cy5vbjtcbiAgICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAgIC8vIEFsbG93IHRoZSBgQmFja2JvbmVgIG9iamVjdCB0byBzZXJ2ZSBhcyBhIGdsb2JhbCBldmVudCBidXMsIGZvciBmb2xrcyB3aG9cbiAgICAvLyB3YW50IGdsb2JhbCBcInB1YnN1YlwiIGluIGEgY29udmVuaWVudCBwbGFjZS5cbiAgICBfLmV4dGVuZChCYWNrYm9uZSwgRXZlbnRzKTtcblxuICAgIC8vIEJhY2tib25lLk1vZGVsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIEJhY2tib25lICoqTW9kZWxzKiogYXJlIHRoZSBiYXNpYyBkYXRhIG9iamVjdCBpbiB0aGUgZnJhbWV3b3JrIC0tXG4gICAgLy8gZnJlcXVlbnRseSByZXByZXNlbnRpbmcgYSByb3cgaW4gYSB0YWJsZSBpbiBhIGRhdGFiYXNlIG9uIHlvdXIgc2VydmVyLlxuICAgIC8vIEEgZGlzY3JldGUgY2h1bmsgb2YgZGF0YSBhbmQgYSBidW5jaCBvZiB1c2VmdWwsIHJlbGF0ZWQgbWV0aG9kcyBmb3JcbiAgICAvLyBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zIG9uIHRoYXQgZGF0YS5cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcy4gQSBjbGllbnQgaWQgKGBjaWRgKVxuICAgIC8vIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBmb3IgeW91LlxuICAgIHZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsID0gZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCdjJyk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5jb2xsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSlcbiAgICAgICAgICAgIGF0dHJzID0gdGhpcy5wYXJzZShhdHRycywgb3B0aW9ucykgfHwge307XG4gICAgICAgIGF0dHJzID0gXy5kZWZhdWx0cyh7fSwgYXR0cnMsIF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpKTtcbiAgICAgICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICAgIF8uZXh0ZW5kKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRzLCB7XG4gICAgICAgIC8vIEEgaGFzaCBvZiBhdHRyaWJ1dGVzIHdob3NlIGN1cnJlbnQgYW5kIHByZXZpb3VzIHZhbHVlIGRpZmZlci5cbiAgICAgICAgY2hhbmdlZDogbnVsbCxcbiAgICAgICAgLy8gVGhlIHZhbHVlIHJldHVybmVkIGR1cmluZyB0aGUgbGFzdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICAgICAgdmFsaWRhdGlvbkVycm9yOiBudWxsLFxuICAgICAgICAvLyBUaGUgZGVmYXVsdCBuYW1lIGZvciB0aGUgSlNPTiBgaWRgIGF0dHJpYnV0ZSBpcyBgXCJpZFwiYC4gTW9uZ29EQiBhbmRcbiAgICAgICAgLy8gQ291Y2hEQiB1c2VycyBtYXkgd2FudCB0byBzZXQgdGhpcyB0byBgXCJfaWRcImAuXG4gICAgICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuICAgICAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgbW9kZWwncyBgYXR0cmlidXRlc2Agb2JqZWN0LlxuICAgICAgICB0b0pTT046IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgICAgICAvLyBjdXN0b20gc3luY2luZyBzZW1hbnRpY3MgZm9yICp0aGlzKiBwYXJ0aWN1bGFyIG1vZGVsLlxuICAgICAgICBzeW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IHRoZSBIVE1MLWVzY2FwZWQgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuICAgICAgICBlc2NhcGU6IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5lc2NhcGUodGhpcy5nZXQoYXR0cikpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgbnVsbFxuICAgICAgICAvLyBvciB1bmRlZmluZWQuXG4gICAgICAgIGhhczogZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChhdHRyKSAhPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gVGhpcyBpc1xuICAgICAgICAvLyB0aGUgY29yZSBwcmltaXRpdmUgb3BlcmF0aW9uIG9mIGEgbW9kZWwsIHVwZGF0aW5nIHRoZSBkYXRhIGFuZCBub3RpZnlpbmdcbiAgICAgICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciwgYXR0cnMsIHVuc2V0LCBjaGFuZ2VzLCBzaWxlbnQsIGNoYW5naW5nLCBwcmV2LCBjdXJyZW50O1xuICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgICAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMuXG4gICAgICAgICAgICB1bnNldCA9IG9wdGlvbnMudW5zZXQ7XG4gICAgICAgICAgICBzaWxlbnQgPSBvcHRpb25zLnNpbGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGNoYW5naW5nID0gdGhpcy5fY2hhbmdpbmc7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghY2hhbmdpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgPSBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5hdHRyaWJ1dGVzLCBwcmV2ID0gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyBvZiBgaWRgLlxuICAgICAgICAgICAgaWYgKHRoaXMuaWRBdHRyaWJ1dGUgaW4gYXR0cnMpXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IGF0dHJzW3RoaXMuaWRBdHRyaWJ1dGVdO1xuXG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBgc2V0YCBhdHRyaWJ1dGUsIHVwZGF0ZSBvciBkZWxldGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNFcXVhbChjdXJyZW50W2F0dHJdLCB2YWwpKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goYXR0cik7XG4gICAgICAgICAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWRbYXR0cl0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlZFthdHRyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5zZXQgPyBkZWxldGUgY3VycmVudFthdHRyXSA6IGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYWxsIHJlbGV2YW50IGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6JyArIGNoYW5nZXNbaV0sIHRoaXMsIGN1cnJlbnRbY2hhbmdlc1tpXV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gWW91IG1pZ2h0IGJlIHdvbmRlcmluZyB3aHkgdGhlcmUncyBhIGB3aGlsZWAgbG9vcCBoZXJlLiBDaGFuZ2VzIGNhblxuICAgICAgICAgICAgLy8gYmUgcmVjdXJzaXZlbHkgbmVzdGVkIHdpdGhpbiBgXCJjaGFuZ2VcImAgZXZlbnRzLlxuICAgICAgICAgICAgaWYgKGNoYW5naW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5fcGVuZGluZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gYHVuc2V0YCBpcyBhIG5vb3BcbiAgICAgICAgLy8gaWYgdGhlIGF0dHJpYnV0ZSBkb2Vzbid0IGV4aXN0LlxuICAgICAgICB1bnNldDogZnVuY3Rpb24gKGF0dHIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChhdHRyLCB2b2lkIDAsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENsZWFyIGFsbCBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChhdHRycywgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtb2RlbCBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgICAgIGhhc0NoYW5nZWQ6IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ciA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAhXy5pc0VtcHR5KHRoaXMuY2hhbmdlZCk7XG4gICAgICAgICAgICByZXR1cm4gXy5oYXModGhpcy5jaGFuZ2VkLCBhdHRyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZCwgb3JcbiAgICAgICAgLy8gZmFsc2UgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZWQgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGF0XG4gICAgICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgICAgIC8vIHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLiBVbnNldCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAgICAgLy8gWW91IGNhbiBhbHNvIHBhc3MgYW4gYXR0cmlidXRlcyBvYmplY3QgdG8gZGlmZiBhZ2FpbnN0IHRoZSBtb2RlbCxcbiAgICAgICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICAgICAgICBpZiAoIWRpZmYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZCgpID8gXy5jbG9uZSh0aGlzLmNoYW5nZWQpIDogZmFsc2U7XG4gICAgICAgICAgICB2YXIgdmFsLCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgb2xkID0gdGhpcy5fY2hhbmdpbmcgPyB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgOiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0VxdWFsKG9sZFthdHRyXSwgKHZhbCA9IGRpZmZbYXR0cl0pKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgKGNoYW5nZWQgfHwgKGNoYW5nZWQgPSB7fSkpW2F0dHJdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYW4gYXR0cmlidXRlLCByZWNvcmRlZCBhdCB0aGUgdGltZSB0aGUgbGFzdFxuICAgICAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQgd2FzIGZpcmVkLlxuICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyID09IG51bGwgfHwgIXRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgICAgIHByZXZpb3VzQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlci4gSWYgdGhlIHNlcnZlcidzIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBtb2RlbCBkaWZmZXJzIGZyb20gaXRzIGN1cnJlbnQgYXR0cmlidXRlcywgdGhleSB3aWxsIGJlIG92ZXJyaWRkZW4sXG4gICAgICAgIC8vIHRyaWdnZXJpbmcgYSBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgICAgIGZldGNoOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZGVsLnNldChtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSwgb3B0aW9ucykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcywgYW5kIHN5bmMgdGhlIG1vZGVsIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhbiBhdHRyaWJ1dGVzIGhhc2ggdGhhdCBkaWZmZXJzLCB0aGUgbW9kZWwnc1xuICAgICAgICAvLyBzdGF0ZSB3aWxsIGJlIGBzZXRgIGFnYWluLlxuICAgICAgICBzYXZlOiBmdW5jdGlvbiAoa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBhdHRycywgbWV0aG9kLCB4aHIsIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt2YWxpZGF0ZTogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBhbmQgYXR0cmlidXRlcyBleGlzdCwgc2F2ZSBhY3RzIGFzXG4gICAgICAgICAgICAvLyBgc2V0KGF0dHIpLnNhdmUobnVsbCwgb3B0cylgIHdpdGggdmFsaWRhdGlvbi4gT3RoZXJ3aXNlLCBjaGVjayBpZlxuICAgICAgICAgICAgLy8gdGhlIG1vZGVsIHdpbGwgYmUgdmFsaWQgd2hlbiB0aGUgYXR0cmlidXRlcywgaWYgYW55LCBhcmUgc2V0LlxuICAgICAgICAgICAgaWYgKGF0dHJzICYmICFvcHRpb25zLndhaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2V0KGF0dHJzLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdGVtcG9yYXJ5IGF0dHJpYnV0ZXMgaWYgYHt3YWl0OiB0cnVlfWAuXG4gICAgICAgICAgICBpZiAoYXR0cnMgJiYgb3B0aW9ucy53YWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gXy5leHRlbmQoe30sIGF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWZ0ZXIgYSBzdWNjZXNzZnVsIHNlcnZlci1zaWRlIHNhdmUsIHRoZSBjbGllbnQgaXMgKG9wdGlvbmFsbHkpXG4gICAgICAgICAgICAvLyB1cGRhdGVkIHdpdGggdGhlIHNlcnZlci1zaWRlIHN0YXRlLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGF0dHJpYnV0ZXMgYXJlIHJlc3RvcmVkIGR1cmluZyBzeW5jaHJvbm91cyBzYXZlcy5cbiAgICAgICAgICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53YWl0KVxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJBdHRycyA9IF8uZXh0ZW5kKGF0dHJzIHx8IHt9LCBzZXJ2ZXJBdHRycyk7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNPYmplY3Qoc2VydmVyQXR0cnMpICYmICFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBtZXRob2QgPSB0aGlzLmlzTmV3KCkgPyAnY3JlYXRlJyA6IChvcHRpb25zLnBhdGNoID8gJ3BhdGNoJyA6ICd1cGRhdGUnKTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdwYXRjaCcpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgICAgICAgeGhyID0gdGhpcy5zeW5jKG1ldGhvZCwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cbiAgICAgICAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgICAgICAgICAgcmV0dXJuIHhocjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRGVzdHJveSB0aGlzIG1vZGVsIG9uIHRoZSBzZXJ2ZXIgaWYgaXQgd2FzIGFscmVhZHkgcGVyc2lzdGVkLlxuICAgICAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmVzIHRoZSBtb2RlbCBmcm9tIGl0cyBjb2xsZWN0aW9uLCBpZiBpdCBoYXMgb25lLlxuICAgICAgICAvLyBJZiBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCB3YWl0cyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kIGJlZm9yZSByZW1vdmFsLlxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG5cbiAgICAgICAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Rlc3Ryb3knLCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndhaXQgfHwgbW9kZWwuaXNOZXcoKSlcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZGVsLmlzTmV3KCkpXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc05ldygpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB2YXIgeGhyID0gdGhpcy5zeW5jKCdkZWxldGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy53YWl0KVxuICAgICAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIERlZmF1bHQgVVJMIGZvciB0aGUgbW9kZWwncyByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2VydmVyIC0tIGlmIHlvdSdyZVxuICAgICAgICAvLyB1c2luZyBCYWNrYm9uZSdzIHJlc3RmdWwgbWV0aG9kcywgb3ZlcnJpZGUgdGhpcyB0byBjaGFuZ2UgdGhlIGVuZHBvaW50XG4gICAgICAgIC8vIHRoYXQgd2lsbCBiZSBjYWxsZWQuXG4gICAgICAgIHVybDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2UgPVxuICAgICAgICAgICAgICAgIF8ucmVzdWx0KHRoaXMsICd1cmxSb290JykgfHxcbiAgICAgICAgICAgICAgICBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fFxuICAgICAgICAgICAgICAgIHVybEVycm9yKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc05ldygpKVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UucmVwbGFjZSgvKFteXFwvXSkkLywgJyQxLycpICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaWQpO1xuICAgICAgICB9LFxuICAgICAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIHRoZSBoYXNoIG9mIGF0dHJpYnV0ZXMgdG8gYmUgYHNldGAgb25cbiAgICAgICAgLy8gdGhlIG1vZGVsLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgdGhlIHJlc3BvbnNlIGFsb25nLlxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHJlc3AsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcyB0byB0aGlzIG9uZS5cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBIG1vZGVsIGlzIG5ldyBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzYXZlZCB0byB0aGUgc2VydmVyLCBhbmQgbGFja3MgYW4gaWQuXG4gICAgICAgIGlzTmV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaGFzKHRoaXMuaWRBdHRyaWJ1dGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbW9kZWwgaXMgY3VycmVudGx5IGluIGEgdmFsaWQgc3RhdGUuXG4gICAgICAgIGlzVmFsaWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGUoe30sIF8uZXh0ZW5kKG9wdGlvbnMgfHwge30sIHt2YWxpZGF0ZTogdHJ1ZX0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUnVuIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgbmV4dCBjb21wbGV0ZSBzZXQgb2YgbW9kZWwgYXR0cmlidXRlcyxcbiAgICAgICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXG4gICAgICAgIF92YWxpZGF0ZTogZnVuY3Rpb24gKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudmFsaWRhdGUgfHwgIXRoaXMudmFsaWRhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBhdHRycyA9IF8uZXh0ZW5kKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZShhdHRycywgb3B0aW9ucykgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmICghZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBlcnJvciwgXy5leHRlbmQob3B0aW9ucywge3ZhbGlkYXRpb25FcnJvcjogZXJyb3J9KSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIE1vZGVsLlxuICAgIHZhciBtb2RlbE1ldGhvZHMgPSBbJ2tleXMnLCAndmFsdWVzJywgJ3BhaXJzJywgJ2ludmVydCcsICdwaWNrJywgJ29taXQnXTtcblxuICAgIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICAgIF8uZWFjaChtb2RlbE1ldGhvZHMsIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgTW9kZWwucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEJhY2tib25lLkNvbGxlY3Rpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBJZiBtb2RlbHMgdGVuZCB0byByZXByZXNlbnQgYSBzaW5nbGUgcm93IG9mIGRhdGEsIGEgQmFja2JvbmUgQ29sbGVjdGlvbiBpc1xuICAgIC8vIG1vcmUgYW5hbGFnb3VzIHRvIGEgdGFibGUgZnVsbCBvZiBkYXRhIC4uLiBvciBhIHNtYWxsIHNsaWNlIG9yIHBhZ2Ugb2YgdGhhdFxuICAgIC8vIHRhYmxlLCBvciBhIGNvbGxlY3Rpb24gb2Ygcm93cyB0aGF0IGJlbG9uZyB0b2dldGhlciBmb3IgYSBwYXJ0aWN1bGFyIHJlYXNvblxuICAgIC8vIC0tIGFsbCBvZiB0aGUgbWVzc2FnZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIGZvbGRlciwgYWxsIG9mIHRoZSBkb2N1bWVudHNcbiAgICAvLyBiZWxvbmdpbmcgdG8gdGhpcyBwYXJ0aWN1bGFyIGF1dGhvciwgYW5kIHNvIG9uLiBDb2xsZWN0aW9ucyBtYWludGFpblxuICAgIC8vIGluZGV4ZXMgb2YgdGhlaXIgbW9kZWxzLCBib3RoIGluIG9yZGVyLCBhbmQgZm9yIGxvb2t1cCBieSBgaWRgLlxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3ICoqQ29sbGVjdGlvbioqLCBwZXJoYXBzIHRvIGNvbnRhaW4gYSBzcGVjaWZpYyB0eXBlIG9mIGBtb2RlbGAuXG4gICAgLy8gSWYgYSBgY29tcGFyYXRvcmAgaXMgc3BlY2lmaWVkLCB0aGUgQ29sbGVjdGlvbiB3aWxsIG1haW50YWluXG4gICAgLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxuICAgIHZhciBDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kZWwpXG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcGFyYXRvciAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gb3B0aW9ucy5jb21wYXJhdG9yO1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG1vZGVscylcbiAgICAgICAgICAgIHRoaXMucmVzZXQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICAgIH07XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb2xsZWN0aW9uI3NldGAuXG4gICAgdmFyIHNldE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IHRydWUsIG1lcmdlOiB0cnVlfTtcbiAgICB2YXIgYWRkT3B0aW9ucyA9IHthZGQ6IHRydWUsIHJlbW92ZTogZmFsc2V9O1xuXG4gICAgLy8gRGVmaW5lIHRoZSBDb2xsZWN0aW9uJ3MgaW5oZXJpdGFibGUgbWV0aG9kcy5cbiAgICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IG1vZGVsIGZvciBhIGNvbGxlY3Rpb24gaXMganVzdCBhICoqQmFja2JvbmUuTW9kZWwqKi5cbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgICAgICBtb2RlbDogTW9kZWwsXG4gICAgICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgICAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB9LFxuICAgICAgICAvLyBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIENvbGxlY3Rpb24gaXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgICAgIC8vIG1vZGVscycgYXR0cmlidXRlcy5cbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbC50b0pTT04ob3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQuXG4gICAgICAgIHN5bmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBCYWNrYm9uZS5zeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFkZCBhIG1vZGVsLCBvciBsaXN0IG9mIG1vZGVscyB0byB0aGUgc2V0LlxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChtb2RlbHMsIF8uZXh0ZW5kKHttZXJnZTogZmFsc2V9LCBvcHRpb25zLCBhZGRPcHRpb25zKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlbW92ZSBhIG1vZGVsLCBvciBhIGxpc3Qgb2YgbW9kZWxzIGZyb20gdGhlIHNldC5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAobW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICAgICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogXy5jbG9uZShtb2RlbHMpO1xuICAgICAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgICAgIHZhciBpLCBsLCBpbmRleCwgbW9kZWw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5nZXQobW9kZWxzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZGVsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5pZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2luZ3VsYXIgPyBtb2RlbHNbMF0gOiBtb2RlbHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFVwZGF0ZSBhIGNvbGxlY3Rpb24gYnkgYHNldGAtaW5nIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCBhZGRpbmcgbmV3IG9uZXMsXG4gICAgICAgIC8vIHJlbW92aW5nIG1vZGVscyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCwgYW5kIG1lcmdpbmcgbW9kZWxzIHRoYXRcbiAgICAgICAgLy8gYWxyZWFkeSBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgYXMgbmVjZXNzYXJ5LiBTaW1pbGFyIHRvICoqTW9kZWwjc2V0KiosXG4gICAgICAgIC8vIHRoZSBjb3JlIG9wZXJhdGlvbiBmb3IgdXBkYXRpbmcgdGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXRPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKVxuICAgICAgICAgICAgICAgIG1vZGVscyA9IHRoaXMucGFyc2UobW9kZWxzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgICAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gKG1vZGVscyA/IFttb2RlbHNdIDogW10pIDogXy5jbG9uZShtb2RlbHMpO1xuICAgICAgICAgICAgdmFyIGksIGwsIGlkLCBtb2RlbCwgYXR0cnMsIGV4aXN0aW5nLCBzb3J0O1xuICAgICAgICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICB2YXIgc29ydGFibGUgPSB0aGlzLmNvbXBhcmF0b3IgJiYgKGF0ID09IG51bGwpICYmIG9wdGlvbnMuc29ydCAhPT0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc29ydEF0dHIgPSBfLmlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgPyB0aGlzLmNvbXBhcmF0b3IgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHRvQWRkID0gW10sIHRvUmVtb3ZlID0gW10sIG1vZGVsTWFwID0ge307XG4gICAgICAgICAgICB2YXIgYWRkID0gb3B0aW9ucy5hZGQsIG1lcmdlID0gb3B0aW9ucy5tZXJnZSwgcmVtb3ZlID0gb3B0aW9ucy5yZW1vdmU7XG4gICAgICAgICAgICB2YXIgb3JkZXIgPSAhc29ydGFibGUgJiYgYWRkICYmIHJlbW92ZSA/IFtdIDogZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIFR1cm4gYmFyZSBvYmplY3RzIGludG8gbW9kZWwgcmVmZXJlbmNlcywgYW5kIHByZXZlbnQgaW52YWxpZCBtb2RlbHNcbiAgICAgICAgICAgIC8vIGZyb20gYmVpbmcgYWRkZWQuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dHJzID0gbW9kZWxzW2ldIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gbW9kZWwgPSBhdHRycztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IGF0dHJzW3RhcmdldE1vZGVsLnByb3RvdHlwZS5pZEF0dHJpYnV0ZSB8fCAnaWQnXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIGR1cGxpY2F0ZSBpcyBmb3VuZCwgcHJldmVudCBpdCBmcm9tIGJlaW5nIGFkZGVkIGFuZFxuICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsbHkgbWVyZ2UgaXQgaW50byB0aGUgZXhpc3RpbmcgbW9kZWwuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nID0gdGhpcy5nZXQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbE1hcFtleGlzdGluZy5jaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycyA9IGF0dHJzID09PSBtb2RlbCA/IG1vZGVsLmF0dHJpYnV0ZXMgOiBhdHRycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzID0gZXhpc3RpbmcucGFyc2UoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcuc2V0KGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0YWJsZSAmJiAhc29ydCAmJiBleGlzdGluZy5oYXNDaGFuZ2VkKHNvcnRBdHRyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3LCB2YWxpZCBtb2RlbCwgcHVzaCBpdCB0byB0aGUgYHRvQWRkYCBsaXN0LlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RlbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIG11bHRpcGxlIG1vZGVscyB3aXRoIHRoZSBzYW1lIGBpZGAuXG4gICAgICAgICAgICAgICAgbW9kZWwgPSBleGlzdGluZyB8fCBtb2RlbDtcbiAgICAgICAgICAgICAgICBpZiAob3JkZXIgJiYgKG1vZGVsLmlzTmV3KCkgfHwgIW1vZGVsTWFwW21vZGVsLmlkXSkpXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgICAgIG1vZGVsTWFwW21vZGVsLmlkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBub25leGlzdGVudCBtb2RlbHMgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbW9kZWxNYXBbKG1vZGVsID0gdGhpcy5tb2RlbHNbaV0pLmNpZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvUmVtb3ZlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodG9SZW1vdmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZWUgaWYgc29ydGluZyBpcyBuZWVkZWQsIHVwZGF0ZSBgbGVuZ3RoYCBhbmQgc3BsaWNlIGluIG5ldyBtb2RlbHMuXG4gICAgICAgICAgICBpZiAodG9BZGQubGVuZ3RoIHx8IChvcmRlciAmJiBvcmRlci5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRhYmxlKVxuICAgICAgICAgICAgICAgICAgICBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCArPSB0b0FkZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRvQWRkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlKGF0ICsgaSwgMCwgdG9BZGRbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yZGVyZWRNb2RlbHMgPSBvcmRlciB8fCB0b0FkZDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9yZGVyZWRNb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVscy5wdXNoKG9yZGVyZWRNb2RlbHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaWxlbnRseSBzb3J0IHRoZSBjb2xsZWN0aW9uIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKHNvcnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0KHtzaWxlbnQ6IHRydWV9KTtcblxuICAgICAgICAgICAgLy8gVW5sZXNzIHNpbGVuY2VkLCBpdCdzIHRpbWUgdG8gZmlyZSBhbGwgYXBwcm9wcmlhdGUgYWRkL3NvcnQgZXZlbnRzLlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b0FkZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgKG1vZGVsID0gdG9BZGRbaV0pLnRyaWdnZXIoJ2FkZCcsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvcnQgfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgICAgICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAgICAgLy8geW91IGNhbiByZXNldCB0aGUgZW50aXJlIHNldCB3aXRoIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCB3aXRob3V0IGZpcmluZ1xuICAgICAgICAvLyBhbnkgZ3JhbnVsYXIgYGFkZGAgb3IgYHJlbW92ZWAgZXZlbnRzLiBGaXJlcyBgcmVzZXRgIHdoZW4gZmluaXNoZWQuXG4gICAgICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgICAgICByZXNldDogZnVuY3Rpb24gKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5tb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKHRoaXMubW9kZWxzW2ldLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMucHJldmlvdXNNb2RlbHMgPSB0aGlzLm1vZGVscztcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICBtb2RlbHMgPSB0aGlzLmFkZChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uIChtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG1vZGVsLCBfLmV4dGVuZCh7YXQ6IHRoaXMubGVuZ3RofSwgb3B0aW9ucykpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgIHBvcDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogMH0sIG9wdGlvbnMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICBzaGlmdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNsaWNlIG91dCBhIHN1Yi1hcnJheSBvZiBtb2RlbHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgc2xpY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGljZS5hcHBseSh0aGlzLm1vZGVscywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IGEgbW9kZWwgZnJvbSB0aGUgc2V0IGJ5IGlkLlxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J5SWRbb2JqXSB8fCB0aGlzLl9ieUlkW29iai5pZF0gfHwgdGhpcy5fYnlJZFtvYmouY2lkXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IHRoZSBtb2RlbCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICAgIGF0OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsc1tpbmRleF07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJldHVybiBtb2RlbHMgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIHNpbXBsZSBjYXNlcyBvZlxuICAgICAgICAvLyBgZmlsdGVyYC5cbiAgICAgICAgd2hlcmU6IGZ1bmN0aW9uIChhdHRycywgZmlyc3QpIHtcbiAgICAgICAgICAgIGlmIChfLmlzRW1wdHkoYXR0cnMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdCA/IHZvaWQgMCA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmlyc3QgPyAnZmluZCcgOiAnZmlsdGVyJ10oZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyc1trZXldICE9PSBtb2RlbC5nZXQoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RlbCB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzXG4gICAgICAgIC8vIG9mIGBmaW5kYC5cbiAgICAgICAgZmluZFdoZXJlOiBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKGF0dHJzLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRm9yY2UgdGhlIGNvbGxlY3Rpb24gdG8gcmUtc29ydCBpdHNlbGYuIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyB1bmRlclxuICAgICAgICAvLyBub3JtYWwgY2lyY3Vtc3RhbmNlcywgYXMgdGhlIHNldCB3aWxsIG1haW50YWluIHNvcnQgb3JkZXIgYXMgZWFjaCBpdGVtXG4gICAgICAgIC8vIGlzIGFkZGVkLlxuICAgICAgICBzb3J0OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc29ydCBhIHNldCB3aXRob3V0IGEgY29tcGFyYXRvcicpO1xuICAgICAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgICAgICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgICAgICAgICBpZiAoXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpIHx8IHRoaXMuY29tcGFyYXRvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMuc29ydEJ5KHRoaXMuY29tcGFyYXRvciwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWxzLnNvcnQoXy5iaW5kKHRoaXMuY29tcGFyYXRvciwgdGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBsdWNrIGFuIGF0dHJpYnV0ZSBmcm9tIGVhY2ggbW9kZWwgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgIHBsdWNrOiBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIF8uaW52b2tlKHRoaXMubW9kZWxzLCAnZ2V0JywgYXR0cik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEZldGNoIHRoZSBkZWZhdWx0IHNldCBvZiBtb2RlbHMgZm9yIHRoaXMgY29sbGVjdGlvbiwgcmVzZXR0aW5nIHRoZVxuICAgICAgICAvLyBjb2xsZWN0aW9uIHdoZW4gdGhleSBhcnJpdmUuIElmIGByZXNldDogdHJ1ZWAgaXMgcGFzc2VkLCB0aGUgcmVzcG9uc2VcbiAgICAgICAgLy8gZGF0YSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRoZSBgcmVzZXRgIG1ldGhvZCBpbnN0ZWFkIG9mIGBzZXRgLlxuICAgICAgICBmZXRjaDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5yZXNldCA/ICdyZXNldCcgOiAnc2V0JztcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW21ldGhvZF0ocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi50cmlnZ2VyKCdzeW5jJywgY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBtb2RlbCBpbiB0aGlzIGNvbGxlY3Rpb24uIEFkZCB0aGUgbW9kZWwgdG8gdGhlXG4gICAgICAgIC8vIGNvbGxlY3Rpb24gaW1tZWRpYXRlbHksIHVubGVzcyBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gYWdyZWUuXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgICAgICAgIGlmICghKG1vZGVsID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLndhaXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAobW9kZWwsIHJlc3ApIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53YWl0KVxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmFkZChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAgICAgLy8gY29sbGVjdGlvbi4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIGl0IHRocm91Z2guXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAocmVzcCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubW9kZWxzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlLiBDYWxsZWQgd2hlbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICAgICAgX3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fYnlJZCA9IHt9O1xuICAgICAgICB9LFxuICAgICAgICAvLyBQcmVwYXJlIGEgaGFzaCBvZiBhdHRyaWJ1dGVzIChvciBvdGhlciBtb2RlbCkgdG8gYmUgYWRkZWQgdG8gdGhpc1xuICAgICAgICAvLyBjb2xsZWN0aW9uLlxuICAgICAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbiAoYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIE1vZGVsKVxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIG1vZGVsLnZhbGlkYXRpb25FcnJvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgICAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbiAobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2J5SWRbbW9kZWwuY2lkXSA9IG1vZGVsO1xuICAgICAgICAgICAgaWYgKG1vZGVsLmlkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5fYnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcbiAgICAgICAgICAgIGlmICghbW9kZWwuY29sbGVjdGlvbilcbiAgICAgICAgICAgICAgICBtb2RlbC5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgICAgICAgIG1vZGVsLm9uKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2V2ZXIgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgICAgICBfcmVtb3ZlUmVmZXJlbmNlOiBmdW5jdGlvbiAobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBtb2RlbC5jb2xsZWN0aW9uKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgICAgICAgICAgbW9kZWwub2ZmKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2RlbCBpbiB0aGUgc2V0IGZpcmVzIGFuIGV2ZW50LlxuICAgICAgICAvLyBTZXRzIG5lZWQgdG8gdXBkYXRlIHRoZWlyIGluZGV4ZXMgd2hlbiBtb2RlbHMgY2hhbmdlIGlkcy4gQWxsIG90aGVyXG4gICAgICAgIC8vIGV2ZW50cyBzaW1wbHkgcHJveHkgdGhyb3VnaC4gXCJhZGRcIiBhbmQgXCJyZW1vdmVcIiBldmVudHMgdGhhdCBvcmlnaW5hdGVcbiAgICAgICAgLy8gaW4gb3RoZXIgY29sbGVjdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgICAgIF9vbk1vZGVsRXZlbnQ6IGZ1bmN0aW9uIChldmVudCwgbW9kZWwsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09ICdkZXN0cm95JylcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobW9kZWwgJiYgZXZlbnQgPT09ICdjaGFuZ2U6JyArIG1vZGVsLmlkQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwucHJldmlvdXMobW9kZWwuaWRBdHRyaWJ1dGUpXTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuaWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBDb2xsZWN0aW9uLlxuICAgIC8vIDkwJSBvZiB0aGUgY29yZSB1c2VmdWxuZXNzIG9mIEJhY2tib25lIENvbGxlY3Rpb25zIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkXG4gICAgLy8gcmlnaHQgaGVyZTpcbiAgICB2YXIgbWV0aG9kcyA9IFsnZm9yRWFjaCcsICdlYWNoJywgJ21hcCcsICdjb2xsZWN0JywgJ3JlZHVjZScsICdmb2xkbCcsXG4gICAgICAgICdpbmplY3QnLCAncmVkdWNlUmlnaHQnLCAnZm9sZHInLCAnZmluZCcsICdkZXRlY3QnLCAnZmlsdGVyJywgJ3NlbGVjdCcsXG4gICAgICAgICdyZWplY3QnLCAnZXZlcnknLCAnYWxsJywgJ3NvbWUnLCAnYW55JywgJ2luY2x1ZGUnLCAnY29udGFpbnMnLCAnaW52b2tlJyxcbiAgICAgICAgJ21heCcsICdtaW4nLCAndG9BcnJheScsICdzaXplJywgJ2ZpcnN0JywgJ2hlYWQnLCAndGFrZScsICdpbml0aWFsJywgJ3Jlc3QnLFxuICAgICAgICAndGFpbCcsICdkcm9wJywgJ2xhc3QnLCAnd2l0aG91dCcsICdkaWZmZXJlbmNlJywgJ2luZGV4T2YnLCAnc2h1ZmZsZScsXG4gICAgICAgICdsYXN0SW5kZXhPZicsICdpc0VtcHR5JywgJ2NoYWluJywgJ3NhbXBsZSddO1xuXG4gICAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgQ29sbGVjdGlvbiNtb2RlbHNgLlxuICAgIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLm1vZGVscyk7XG4gICAgICAgICAgICByZXR1cm4gX1ttZXRob2RdLmFwcGx5KF8sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgdGFrZSBhIHByb3BlcnR5IG5hbWUgYXMgYW4gYXJndW1lbnQuXG4gICAgdmFyIGF0dHJpYnV0ZU1ldGhvZHMgPSBbJ2dyb3VwQnknLCAnY291bnRCeScsICdzb3J0QnknLCAnaW5kZXhCeSddO1xuXG4gICAgLy8gVXNlIGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzLlxuICAgIF8uZWFjaChhdHRyaWJ1dGVNZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbC5nZXQodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfW21ldGhvZF0odGhpcy5tb2RlbHMsIGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEJhY2tib25lLlZpZXdcbiAgICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgICAvLyBpcyBzaW1wbHkgYSBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBsb2dpY2FsIGNodW5rIG9mIFVJIGluIHRoZVxuICAgIC8vIERPTS4gVGhpcyBtaWdodCBiZSBhIHNpbmdsZSBpdGVtLCBhbiBlbnRpcmUgbGlzdCwgYSBzaWRlYmFyIG9yIHBhbmVsLCBvclxuICAgIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gICAgLy8gVUkgYXMgYSAqKlZpZXcqKiBhbGxvd3MgeW91IHRvIGRlZmluZSB5b3VyIERPTSBldmVudHMgZGVjbGFyYXRpdmVseSwgd2l0aG91dFxuICAgIC8vIGhhdmluZyB0byB3b3JyeSBhYm91dCByZW5kZXIgb3JkZXIgLi4uIGFuZCBtYWtlcyBpdCBlYXN5IGZvciB0aGUgdmlldyB0b1xuICAgIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gICAgLy8gQ3JlYXRpbmcgYSBCYWNrYm9uZS5WaWV3IGNyZWF0ZXMgaXRzIGluaXRpYWwgZWxlbWVudCBvdXRzaWRlIG9mIHRoZSBET00sXG4gICAgLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbiAgICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQoJ3ZpZXcnKTtcbiAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICB9O1xuXG4gICAgLy8gQ2FjaGVkIHJlZ2V4IHRvIHNwbGl0IGtleXMgZm9yIGBkZWxlZ2F0ZWAuXG4gICAgdmFyIGRlbGVnYXRlRXZlbnRTcGxpdHRlciA9IC9eKFxcUyspXFxzKiguKikkLztcblxuICAgIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIG1lcmdlZCBhcyBwcm9wZXJ0aWVzLlxuICAgIHZhciB2aWV3T3B0aW9ucyA9IFsnbW9kZWwnLCAnY29sbGVjdGlvbicsICdlbCcsICdpZCcsICdhdHRyaWJ1dGVzJywgJ2NsYXNzTmFtZScsICd0YWdOYW1lJywgJ2V2ZW50cyddO1xuXG4gICAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlZpZXcqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICAgIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgYHRhZ05hbWVgIG9mIGEgVmlldydzIGVsZW1lbnQgaXMgYFwiZGl2XCJgLlxuICAgICAgICB0YWdOYW1lOiAnZGl2JyxcbiAgICAgICAgLy8galF1ZXJ5IGRlbGVnYXRlIGZvciBlbGVtZW50IGxvb2t1cCwgc2NvcGVkIHRvIERPTSBlbGVtZW50cyB3aXRoaW4gdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICAgICAkOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKHNlbGVjdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH0sXG4gICAgICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgICAgICAvLyB0byBwb3B1bGF0ZSBpdHMgZWxlbWVudCAoYHRoaXMuZWxgKSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSFRNTC4gVGhlXG4gICAgICAgIC8vIGNvbnZlbnRpb24gaXMgZm9yICoqcmVuZGVyKiogdG8gYWx3YXlzIHJldHVybiBgdGhpc2AuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcgYnkgdGFraW5nIHRoZSBlbGVtZW50IG91dCBvZiB0aGUgRE9NLCBhbmQgcmVtb3ZpbmcgYW55XG4gICAgICAgIC8vIGFwcGxpY2FibGUgQmFja2JvbmUuRXZlbnRzIGxpc3RlbmVycy5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENoYW5nZSB0aGUgdmlldydzIGVsZW1lbnQgKGB0aGlzLmVsYCBwcm9wZXJ0eSksIGluY2x1ZGluZyBldmVudFxuICAgICAgICAvLyByZS1kZWxlZ2F0aW9uLlxuICAgICAgICBzZXRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRlbClcbiAgICAgICAgICAgICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuJGVsID0gZWxlbWVudCBpbnN0YW5jZW9mIEJhY2tib25lLiQgPyBlbGVtZW50IDogQmFja2JvbmUuJChlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNldCBjYWxsYmFja3MsIHdoZXJlIGB0aGlzLmV2ZW50c2AgaXMgYSBoYXNoIG9mXG4gICAgICAgIC8vXG4gICAgICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgICAgIC8vICAgICAgICdjbGljayAuYnV0dG9uJzogICAgICdzYXZlJyxcbiAgICAgICAgLy8gICAgICAgJ2NsaWNrIC5vcGVuJzogICAgICAgZnVuY3Rpb24oZSkgeyAuLi4gfVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBwYWlycy4gQ2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhlIHZpZXcsIHdpdGggYHRoaXNgIHNldCBwcm9wZXJseS5cbiAgICAgICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgICAgICAvLyBPbWl0dGluZyB0aGUgc2VsZWN0b3IgYmluZHMgdGhlIGV2ZW50IHRvIGB0aGlzLmVsYC5cbiAgICAgICAgLy8gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsIGBibHVyYCwgYW5kXG4gICAgICAgIC8vIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICAgICAgICBkZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgICAgICAgICAgaWYgKCEoZXZlbnRzIHx8IChldmVudHMgPSBfLnJlc3VsdCh0aGlzLCAnZXZlbnRzJykpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBldmVudHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihtZXRob2QpKVxuICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSB0aGlzW2V2ZW50c1trZXldXTtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gbWF0Y2hbMV0sIHNlbGVjdG9yID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXy5iaW5kKG1ldGhvZCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lICs9ICcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwub24oZXZlbnROYW1lLCBzZWxlY3RvciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2xlYXJzIGFsbCBjYWxsYmFja3MgcHJldmlvdXNseSBib3VuZCB0byB0aGUgdmlldyB3aXRoIGBkZWxlZ2F0ZUV2ZW50c2AuXG4gICAgICAgIC8vIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBtYXkgd2lzaCB0byBpZiB5b3UgaGF2ZSBtdWx0aXBsZVxuICAgICAgICAvLyBCYWNrYm9uZSB2aWV3cyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICAgICAgdW5kZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgICAgICAvLyBJZiBgdGhpcy5lbGAgaXMgYSBzdHJpbmcsIHBhc3MgaXQgdGhyb3VnaCBgJCgpYCwgdGFrZSB0aGUgZmlyc3RcbiAgICAgICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgICAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgICAgICAgX2Vuc3VyZUVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF8uZXh0ZW5kKHt9LCBfLnJlc3VsdCh0aGlzLCAnYXR0cmlidXRlcycpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZClcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuaWQgPSBfLnJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICAgICAgICAgIHZhciAkZWwgPSBCYWNrYm9uZS4kKCc8JyArIF8ucmVzdWx0KHRoaXMsICd0YWdOYW1lJykgKyAnPicpLmF0dHIoYXR0cnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCgkZWwsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gQmFja2JvbmUuc3luY1xuICAgIC8vIC0tLS0tLS0tLS0tLS1cblxuICAgIC8vIE92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gY2hhbmdlIHRoZSBtYW5uZXIgaW4gd2hpY2ggQmFja2JvbmUgcGVyc2lzdHNcbiAgICAvLyBtb2RlbHMgdG8gdGhlIHNlcnZlci4gWW91IHdpbGwgYmUgcGFzc2VkIHRoZSB0eXBlIG9mIHJlcXVlc3QsIGFuZCB0aGVcbiAgICAvLyBtb2RlbCBpbiBxdWVzdGlvbi4gQnkgZGVmYXVsdCwgbWFrZXMgYSBSRVNUZnVsIEFqYXggcmVxdWVzdFxuICAgIC8vIHRvIHRoZSBtb2RlbCdzIGB1cmwoKWAuIFNvbWUgcG9zc2libGUgY3VzdG9taXphdGlvbnMgY291bGQgYmU6XG4gICAgLy9cbiAgICAvLyAqIFVzZSBgc2V0VGltZW91dGAgdG8gYmF0Y2ggcmFwaWQtZmlyZSB1cGRhdGVzIGludG8gYSBzaW5nbGUgcmVxdWVzdC5cbiAgICAvLyAqIFNlbmQgdXAgdGhlIG1vZGVscyBhcyBYTUwgaW5zdGVhZCBvZiBKU09OLlxuICAgIC8vICogUGVyc2lzdCBtb2RlbHMgdmlhIFdlYlNvY2tldHMgaW5zdGVhZCBvZiBBamF4LlxuICAgIC8vXG4gICAgLy8gVHVybiBvbiBgQmFja2JvbmUuZW11bGF0ZUhUVFBgIGluIG9yZGVyIHRvIHNlbmQgYFBVVGAgYW5kIGBERUxFVEVgIHJlcXVlc3RzXG4gICAgLy8gYXMgYFBPU1RgLCB3aXRoIGEgYF9tZXRob2RgIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSB0cnVlIEhUVFAgbWV0aG9kLFxuICAgIC8vIGFzIHdlbGwgYXMgYWxsIHJlcXVlc3RzIHdpdGggdGhlIGJvZHkgYXMgYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGBcbiAgICAvLyBpbnN0ZWFkIG9mIGBhcHBsaWNhdGlvbi9qc29uYCB3aXRoIHRoZSBtb2RlbCBpbiBhIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gICAgLy8gVXNlZnVsIHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBzZXJ2ZXItc2lkZSBsYW5ndWFnZXMgbGlrZSAqKlBIUCoqIHRoYXQgbWFrZVxuICAgIC8vIGl0IGRpZmZpY3VsdCB0byByZWFkIHRoZSBib2R5IG9mIGBQVVRgIHJlcXVlc3RzLlxuICAgIEJhY2tib25lLnN5bmMgPSBmdW5jdGlvbiAobWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdHlwZSA9IG1ldGhvZE1hcFttZXRob2RdO1xuXG4gICAgICAgIC8vIERlZmF1bHQgb3B0aW9ucywgdW5sZXNzIHNwZWNpZmllZC5cbiAgICAgICAgXy5kZWZhdWx0cyhvcHRpb25zIHx8IChvcHRpb25zID0ge30pLCB7XG4gICAgICAgICAgICBlbXVsYXRlSFRUUDogQmFja2JvbmUuZW11bGF0ZUhUVFAsXG4gICAgICAgICAgICBlbXVsYXRlSlNPTjogQmFja2JvbmUuZW11bGF0ZUpTT05cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBKU09OLXJlcXVlc3Qgb3B0aW9ucy5cbiAgICAgICAgdmFyIHBhcmFtcyA9IHt0eXBlOiB0eXBlLCBkYXRhVHlwZTogJ2pzb24nfTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGEgVVJMLlxuICAgICAgICBpZiAoIW9wdGlvbnMudXJsKSB7XG4gICAgICAgICAgICBwYXJhbXMudXJsID0gXy5yZXN1bHQobW9kZWwsICd1cmwnKSB8fCB1cmxFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgcmVxdWVzdCBkYXRhLlxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhID09IG51bGwgJiYgbW9kZWwgJiYgKG1ldGhvZCA9PT0gJ2NyZWF0ZScgfHwgbWV0aG9kID09PSAndXBkYXRlJyB8fCBtZXRob2QgPT09ICdwYXRjaCcpKSB7XG4gICAgICAgICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBwYXJhbXMuZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYXR0cnMgfHwgbW9kZWwudG9KU09OKG9wdGlvbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEpTT04gYnkgZW5jb2RpbmcgdGhlIHJlcXVlc3QgaW50byBhbiBIVE1MLWZvcm0uXG4gICAgICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICAgICAgICBwYXJhbXMuY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgICAgIHBhcmFtcy5kYXRhID0gcGFyYW1zLmRhdGEgPyB7bW9kZWw6IHBhcmFtcy5kYXRhfSA6IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSFRUUCBieSBtaW1pY2tpbmcgdGhlIEhUVFAgbWV0aG9kIHdpdGggYF9tZXRob2RgXG4gICAgICAgIC8vIEFuZCBhbiBgWC1IVFRQLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxuICAgICAgICBpZiAob3B0aW9ucy5lbXVsYXRlSFRUUCAmJiAodHlwZSA9PT0gJ1BVVCcgfHwgdHlwZSA9PT0gJ0RFTEVURScgfHwgdHlwZSA9PT0gJ1BBVENIJykpIHtcbiAgICAgICAgICAgIHBhcmFtcy50eXBlID0gJ1BPU1QnO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pXG4gICAgICAgICAgICAgICAgcGFyYW1zLmRhdGEuX21ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICB2YXIgYmVmb3JlU2VuZCA9IG9wdGlvbnMuYmVmb3JlU2VuZDtcbiAgICAgICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1IVFRQLU1ldGhvZC1PdmVycmlkZScsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmVTZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvbid0IHByb2Nlc3MgZGF0YSBvbiBhIG5vbi1HRVQgcmVxdWVzdC5cbiAgICAgICAgaWYgKHBhcmFtcy50eXBlICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgICAgICAgcGFyYW1zLnByb2Nlc3NEYXRhID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSdyZSBzZW5kaW5nIGEgYFBBVENIYCByZXF1ZXN0LCBhbmQgd2UncmUgaW4gYW4gb2xkIEludGVybmV0IEV4cGxvcmVyXG4gICAgICAgIC8vIHRoYXQgc3RpbGwgaGFzIEFjdGl2ZVggZW5hYmxlZCBieSBkZWZhdWx0LCBvdmVycmlkZSBqUXVlcnkgdG8gdXNlIHRoYXRcbiAgICAgICAgLy8gZm9yIFhIUiBpbnN0ZWFkLiBSZW1vdmUgdGhpcyBsaW5lIHdoZW4galF1ZXJ5IHN1cHBvcnRzIGBQQVRDSGAgb24gSUU4LlxuICAgICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdQQVRDSCcgJiYgbm9YaHJQYXRjaCkge1xuICAgICAgICAgICAgcGFyYW1zLnhociA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgICAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgPSBCYWNrYm9uZS5hamF4KF8uZXh0ZW5kKHBhcmFtcywgb3B0aW9ucykpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZXF1ZXN0JywgbW9kZWwsIHhociwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcblxuICAgIHZhciBub1hoclBhdGNoID1cbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cuQWN0aXZlWE9iamVjdCAmJlxuICAgICAgICAhKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAobmV3IFhNTEh0dHBSZXF1ZXN0KS5kaXNwYXRjaEV2ZW50KTtcblxuICAgIC8vIE1hcCBmcm9tIENSVUQgdG8gSFRUUCBmb3Igb3VyIGRlZmF1bHQgYEJhY2tib25lLnN5bmNgIGltcGxlbWVudGF0aW9uLlxuICAgIHZhciBtZXRob2RNYXAgPSB7XG4gICAgICAgICdjcmVhdGUnOiAnUE9TVCcsXG4gICAgICAgICd1cGRhdGUnOiAnUFVUJyxcbiAgICAgICAgJ3BhdGNoJzogJ1BBVENIJyxcbiAgICAgICAgJ2RlbGV0ZSc6ICdERUxFVEUnLFxuICAgICAgICAncmVhZCc6ICdHRVQnXG4gICAgfTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgQmFja2JvbmUuYWpheGAgdG8gcHJveHkgdGhyb3VnaCB0byBgJGAuXG4gICAgLy8gT3ZlcnJpZGUgdGhpcyBpZiB5b3UnZCBsaWtlIHRvIHVzZSBhIGRpZmZlcmVudCBsaWJyYXJ5LlxuICAgIEJhY2tib25lLmFqYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCYWNrYm9uZS4kLmFqYXguYXBwbHkoQmFja2JvbmUuJCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgLy8gQmFja2JvbmUuUm91dGVyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBSb3V0ZXJzIG1hcCBmYXV4LVVSTHMgdG8gYWN0aW9ucywgYW5kIGZpcmUgZXZlbnRzIHdoZW4gcm91dGVzIGFyZVxuICAgIC8vIG1hdGNoZWQuIENyZWF0aW5nIGEgbmV3IG9uZSBzZXRzIGl0cyBgcm91dGVzYCBoYXNoLCBpZiBub3Qgc2V0IHN0YXRpY2FsbHkuXG4gICAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgIGlmIChvcHRpb25zLnJvdXRlcylcbiAgICAgICAgICAgIHRoaXMucm91dGVzID0gb3B0aW9ucy5yb3V0ZXM7XG4gICAgICAgIHRoaXMuX2JpbmRSb3V0ZXMoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIC8vIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBtYXRjaGluZyBuYW1lZCBwYXJhbSBwYXJ0cyBhbmQgc3BsYXR0ZWRcbiAgICAvLyBwYXJ0cyBvZiByb3V0ZSBzdHJpbmdzLlxuICAgIHZhciBvcHRpb25hbFBhcmFtID0gL1xcKCguKj8pXFwpL2c7XG4gICAgdmFyIG5hbWVkUGFyYW0gPSAvKFxcKFxcPyk/OlxcdysvZztcbiAgICB2YXIgc3BsYXRQYXJhbSA9IC9cXCpcXHcrL2c7XG4gICAgdmFyIGVzY2FwZVJlZ0V4cCA9IC9bXFwte31cXFtcXF0rPy4sXFxcXFxcXiR8I1xcc10vZztcblxuICAgIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5Sb3V0ZXIqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICAgIF8uZXh0ZW5kKFJvdXRlci5wcm90b3R5cGUsIEV2ZW50cywge1xuICAgICAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCBhIHNpbmdsZSBuYW1lZCByb3V0ZSB0byBhIGNhbGxiYWNrLiBGb3IgZXhhbXBsZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIHRoaXMucm91dGUoJ3NlYXJjaC86cXVlcnkvcDpudW0nLCAnc2VhcmNoJywgZnVuY3Rpb24ocXVlcnksIG51bSkge1xuICAgICAgICAvLyAgICAgICAuLi5cbiAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAvL1xuICAgICAgICByb3V0ZTogZnVuY3Rpb24gKHJvdXRlLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCFfLmlzUmVnRXhwKHJvdXRlKSlcbiAgICAgICAgICAgICAgICByb3V0ZSA9IHRoaXMuX3JvdXRlVG9SZWdFeHAocm91dGUpO1xuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgICAgICAgICAgICBuYW1lID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIHZhciByb3V0ZXIgPSB0aGlzO1xuICAgICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5yb3V0ZShyb3V0ZSwgZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSByb3V0ZXIuX2V4dHJhY3RQYXJhbWV0ZXJzKHJvdXRlLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgcm91dGVyLmV4ZWN1dGUoY2FsbGJhY2ssIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJvdXRlci50cmlnZ2VyLmFwcGx5KHJvdXRlciwgWydyb3V0ZTonICsgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnRyaWdnZXIoJ3JvdXRlJywgcm91dGVyLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEV4ZWN1dGUgYSByb3V0ZSBoYW5kbGVyIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuICBUaGlzIGlzIGFuXG4gICAgICAgIC8vIGV4Y2VsbGVudCBwbGFjZSB0byBkbyBwcmUtcm91dGUgc2V0dXAgb3IgcG9zdC1yb3V0ZSBjbGVhbnVwLlxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2ltcGxlIHByb3h5IHRvIGBCYWNrYm9uZS5oaXN0b3J5YCB0byBzYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGlzdG9yeS5cbiAgICAgICAgbmF2aWdhdGU6IGZ1bmN0aW9uIChmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShmcmFnbWVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQmluZCBhbGwgZGVmaW5lZCByb3V0ZXMgdG8gYEJhY2tib25lLmhpc3RvcnlgLiBXZSBoYXZlIHRvIHJldmVyc2UgdGhlXG4gICAgICAgIC8vIG9yZGVyIG9mIHRoZSByb3V0ZXMgaGVyZSB0byBzdXBwb3J0IGJlaGF2aW9yIHdoZXJlIHRoZSBtb3N0IGdlbmVyYWxcbiAgICAgICAgLy8gcm91dGVzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBib3R0b20gb2YgdGhlIHJvdXRlIG1hcC5cbiAgICAgICAgX2JpbmRSb3V0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb3V0ZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXMgPSBfLnJlc3VsdCh0aGlzLCAncm91dGVzJyk7XG4gICAgICAgICAgICB2YXIgcm91dGUsIHJvdXRlcyA9IF8ua2V5cyh0aGlzLnJvdXRlcyk7XG4gICAgICAgICAgICB3aGlsZSAoKHJvdXRlID0gcm91dGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXNbcm91dGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ29udmVydCBhIHJvdXRlIHN0cmluZyBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLCBzdWl0YWJsZSBmb3IgbWF0Y2hpbmdcbiAgICAgICAgLy8gYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbiBoYXNoLlxuICAgICAgICBfcm91dGVUb1JlZ0V4cDogZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCAnXFxcXCQmJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShvcHRpb25hbFBhcmFtLCAnKD86JDEpPycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UobmFtZWRQYXJhbSwgZnVuY3Rpb24gKG1hdGNoLCBvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBtYXRjaCA6ICcoW14vP10rKSc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShzcGxhdFBhcmFtLCAnKFteP10qPyknKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHJvdXRlICsgJyg/OlxcXFw/KFtcXFxcc1xcXFxTXSopKT8kJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdpdmVuIGEgcm91dGUsIGFuZCBhIFVSTCBmcmFnbWVudCB0aGF0IGl0IG1hdGNoZXMsIHJldHVybiB0aGUgYXJyYXkgb2ZcbiAgICAgICAgLy8gZXh0cmFjdGVkIGRlY29kZWQgcGFyYW1ldGVycy4gRW1wdHkgb3IgdW5tYXRjaGVkIHBhcmFtZXRlcnMgd2lsbCBiZVxuICAgICAgICAvLyB0cmVhdGVkIGFzIGBudWxsYCB0byBub3JtYWxpemUgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgICAgICAgX2V4dHJhY3RQYXJhbWV0ZXJzOiBmdW5jdGlvbiAocm91dGUsIGZyYWdtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gcm91dGUuZXhlYyhmcmFnbWVudCkuc2xpY2UoMSk7XG4gICAgICAgICAgICByZXR1cm4gXy5tYXAocGFyYW1zLCBmdW5jdGlvbiAocGFyYW0sIGkpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBkZWNvZGUgdGhlIHNlYXJjaCBwYXJhbXMuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHBhcmFtcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIEJhY2tib25lLkhpc3RvcnlcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgICAvLyBbcHVzaFN0YXRlXShodHRwOi8vZGl2ZWludG9odG1sNS5pbmZvL2hpc3RvcnkuaHRtbCkgYW5kIHJlYWwgVVJMcywgb3JcbiAgICAvLyBbb25oYXNoY2hhbmdlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS93aW5kb3cub25oYXNoY2hhbmdlKVxuICAgIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgICAvLyBmYWxscyBiYWNrIHRvIHBvbGxpbmcuXG4gICAgdmFyIEhpc3RvcnkgPSBCYWNrYm9uZS5IaXN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIF8uYmluZEFsbCh0aGlzLCAnY2hlY2tVcmwnKTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBgSGlzdG9yeWAgY2FuIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgYSBsZWFkaW5nIGhhc2gvc2xhc2ggYW5kIHRyYWlsaW5nIHNwYWNlLlxuICAgIHZhciByb3V0ZVN0cmlwcGVyID0gL15bI1xcL118XFxzKyQvZztcblxuICAgIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMuXG4gICAgdmFyIHJvb3RTdHJpcHBlciA9IC9eXFwvK3xcXC8rJC9nO1xuXG4gICAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBkZXRlY3RpbmcgTVNJRS5cbiAgICB2YXIgaXNFeHBsb3JlciA9IC9tc2llIFtcXHcuXSsvO1xuXG4gICAgLy8gQ2FjaGVkIHJlZ2V4IGZvciByZW1vdmluZyBhIHRyYWlsaW5nIHNsYXNoLlxuICAgIHZhciB0cmFpbGluZ1NsYXNoID0gL1xcLyQvO1xuXG4gICAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgdXJscyBvZiBoYXNoLlxuICAgIHZhciBwYXRoU3RyaXBwZXIgPSAvIy4qJC87XG5cbiAgICAvLyBIYXMgdGhlIGhpc3RvcnkgaGFuZGxpbmcgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQ/XG4gICAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gICAgXy5leHRlbmQoSGlzdG9yeS5wcm90b3R5cGUsIEV2ZW50cywge1xuICAgICAgICAvLyBUaGUgZGVmYXVsdCBpbnRlcnZhbCB0byBwb2xsIGZvciBoYXNoIGNoYW5nZXMsIGlmIG5lY2Vzc2FyeSwgaXNcbiAgICAgICAgLy8gdHdlbnR5IHRpbWVzIGEgc2Vjb25kLlxuICAgICAgICBpbnRlcnZhbDogNTAsXG4gICAgICAgIC8vIEFyZSB3ZSBhdCB0aGUgYXBwIHJvb3Q/XG4gICAgICAgIGF0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvW15cXC9dJC8sICckJi8nKSA9PT0gdGhpcy5yb290O1xuICAgICAgICB9LFxuICAgICAgICAvLyBHZXRzIHRoZSB0cnVlIGhhc2ggdmFsdWUuIENhbm5vdCB1c2UgbG9jYXRpb24uaGFzaCBkaXJlY3RseSBkdWUgdG8gYnVnXG4gICAgICAgIC8vIGluIEZpcmVmb3ggd2hlcmUgbG9jYXRpb24uaGFzaCB3aWxsIGFsd2F5cyBiZSBkZWNvZGVkLlxuICAgICAgICBnZXRIYXNoOiBmdW5jdGlvbiAod2luZG93KSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSAod2luZG93IHx8IHRoaXMpLmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IHRoZSBjcm9zcy1icm93c2VyIG5vcm1hbGl6ZWQgVVJMIGZyYWdtZW50LCBlaXRoZXIgZnJvbSB0aGUgVVJMLFxuICAgICAgICAvLyB0aGUgaGFzaCwgb3IgdGhlIG92ZXJyaWRlLlxuICAgICAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24gKGZyYWdtZW50LCBmb3JjZVB1c2hTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlIHx8ICF0aGlzLl93YW50c0hhc2hDaGFuZ2UgfHwgZm9yY2VQdXNoU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBkZWNvZGVVUkkodGhpcy5sb2NhdGlvbi5wYXRobmFtZSArIHRoaXMubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QucmVwbGFjZSh0cmFpbGluZ1NsYXNoLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnJhZ21lbnQuaW5kZXhPZihyb290KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuc2xpY2Uocm9vdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRIYXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAgICAgLy8gYW4gZXhpc3Rpbmcgcm91dGUsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tib25lLmhpc3RvcnkgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkXCIpO1xuICAgICAgICAgICAgSGlzdG9yeS5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uLiBEbyB3ZSBuZWVkIGFuIGlmcmFtZT9cbiAgICAgICAgICAgIC8vIElzIHB1c2hTdGF0ZSBkZXNpcmVkIC4uLiBpcyBpdCBhdmFpbGFibGU/XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh7cm9vdDogJy8nfSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHRoaXMub3B0aW9ucy5yb290O1xuICAgICAgICAgICAgdGhpcy5fd2FudHNIYXNoQ2hhbmdlID0gdGhpcy5vcHRpb25zLmhhc2hDaGFuZ2UgIT09IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fd2FudHNQdXNoU3RhdGUgPSAhIXRoaXMub3B0aW9ucy5wdXNoU3RhdGU7XG4gICAgICAgICAgICB0aGlzLl9oYXNQdXNoU3RhdGUgPSAhISh0aGlzLm9wdGlvbnMucHVzaFN0YXRlICYmIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkucHVzaFN0YXRlKTtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHZhciBkb2NNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgICAgICAgICAgdmFyIG9sZElFID0gKGlzRXhwbG9yZXIuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpICYmICghZG9jTW9kZSB8fCBkb2NNb2RlIDw9IDcpKTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHJvb3QgdG8gYWx3YXlzIGluY2x1ZGUgYSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xuXG4gICAgICAgICAgICBpZiAob2xkSUUgJiYgdGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gQmFja2JvbmUuJCgnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiB0YWJpbmRleD1cIi0xXCI+Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZnJhbWUgPSBmcmFtZS5oaWRlKCkuYXBwZW5kVG8oJ2JvZHknKVswXS5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGUoZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgQmFja2JvbmUuJCh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgKCdvbmhhc2hjaGFuZ2UnIGluIHdpbmRvdykgJiYgIW9sZElFKSB7XG4gICAgICAgICAgICAgICAgQmFja2JvbmUuJCh3aW5kb3cpLm9uKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBiYXNlIHVybCwgZm9yIGEgcHVzaFN0YXRlIGxpbmtcbiAgICAgICAgICAgIC8vIG9wZW5lZCBieSBhIG5vbi1wdXNoU3RhdGUgYnJvd3Nlci5cbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIHZhciBsb2MgPSB0aGlzLmxvY2F0aW9uO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIGZyb20gaGFzaENoYW5nZSB0byBwdXNoU3RhdGUgb3IgdmljZSB2ZXJzYSBpZiBib3RoIGFyZVxuICAgICAgICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgc3RhcnRlZCBvZmYgd2l0aCBhIHJvdXRlIGZyb20gYSBgcHVzaFN0YXRlYC1lbmFibGVkXG4gICAgICAgICAgICAgICAgLy8gYnJvd3NlciwgYnV0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIGJyb3dzZXIgdGhhdCBkb2Vzbid0IHN1cHBvcnQgaXQuLi5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMucm9vdCArICcjJyArIHRoaXMuZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgYXMgYnJvd3NlciB3aWxsIGRvIHJlZGlyZWN0IHRvIG5ldyB1cmxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3IgaWYgd2UndmUgc3RhcnRlZCBvdXQgd2l0aCBhIGhhc2gtYmFzZWQgcm91dGUsIGJ1dCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYSBicm93c2VyIHdoZXJlIGl0IGNvdWxkIGJlIGBwdXNoU3RhdGVgLWJhc2VkIGluc3RlYWQuLi5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiB0aGlzLmF0Um9vdCgpICYmIGxvYy5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKS5yZXBsYWNlKHJvdXRlU3RyaXBwZXIsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgZG9jdW1lbnQudGl0bGUsIHRoaXMucm9vdCArIHRoaXMuZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWxlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFVybCgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBEaXNhYmxlIEJhY2tib25lLmhpc3RvcnksIHBlcmhhcHMgdGVtcG9yYXJpbHkuIE5vdCB1c2VmdWwgaW4gYSByZWFsIGFwcCxcbiAgICAgICAgLy8gYnV0IHBvc3NpYmx5IHVzZWZ1bCBmb3IgdW5pdCB0ZXN0aW5nIFJvdXRlcnMuXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEJhY2tib25lLiQod2luZG93KS5vZmYoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCkub2ZmKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hlY2tVcmxJbnRlcnZhbClcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFkZCBhIHJvdXRlIHRvIGJlIHRlc3RlZCB3aGVuIHRoZSBmcmFnbWVudCBjaGFuZ2VzLiBSb3V0ZXMgYWRkZWQgbGF0ZXJcbiAgICAgICAgLy8gbWF5IG92ZXJyaWRlIHByZXZpb3VzIHJvdXRlcy5cbiAgICAgICAgcm91dGU6IGZ1bmN0aW9uIChyb3V0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMudW5zaGlmdCh7cm91dGU6IHJvdXRlLCBjYWxsYmFjazogY2FsbGJhY2t9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2hlY2tzIHRoZSBjdXJyZW50IFVSTCB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsXG4gICAgICAgIC8vIGNhbGxzIGBsb2FkVXJsYCwgbm9ybWFsaXppbmcgYWNyb3NzIHRoZSBoaWRkZW4gaWZyYW1lLlxuICAgICAgICBjaGVja1VybDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5nZXRGcmFnbWVudCh0aGlzLmdldEhhc2godGhpcy5pZnJhbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlmcmFtZSlcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlKGN1cnJlbnQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkVXJsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gbG9hZCB0aGUgY3VycmVudCBVUkwgZnJhZ21lbnQuIElmIGEgcm91dGUgc3VjY2VlZHMgd2l0aCBhXG4gICAgICAgIC8vIG1hdGNoLCByZXR1cm5zIGB0cnVlYC4gSWYgbm8gZGVmaW5lZCByb3V0ZXMgbWF0Y2hlcyB0aGUgZnJhZ21lbnQsXG4gICAgICAgIC8vIHJldHVybnMgYGZhbHNlYC5cbiAgICAgICAgbG9hZFVybDogZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBfLmFueSh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJvdXRlLnRlc3QoZnJhZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2soZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhhc2ggaGlzdG9yeSwgb3IgcmVwbGFjZSB0aGUgVVJMIHN0YXRlIGlmIHRoZVxuICAgICAgICAvLyAncmVwbGFjZScgb3B0aW9uIGlzIHBhc3NlZC4gWW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvcGVybHkgVVJMLWVuY29kaW5nXG4gICAgICAgIC8vIHRoZSBmcmFnbWVudCBpbiBhZHZhbmNlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gYHRyaWdnZXI6IHRydWVgIGlmIHlvdSB3aXNoIHRvIGhhdmUgdGhlXG4gICAgICAgIC8vIHJvdXRlIGNhbGxiYWNrIGJlIGZpcmVkIChub3QgdXN1YWxseSBkZXNpcmFibGUpLCBvciBgcmVwbGFjZTogdHJ1ZWAsIGlmXG4gICAgICAgIC8vIHlvdSB3aXNoIHRvIG1vZGlmeSB0aGUgY3VycmVudCBVUkwgd2l0aG91dCBhZGRpbmcgYW4gZW50cnkgdG8gdGhlIGhpc3RvcnkuXG4gICAgICAgIG5hdmlnYXRlOiBmdW5jdGlvbiAoZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghSGlzdG9yeS5zdGFydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7dHJpZ2dlcjogISFvcHRpb25zfTtcblxuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMucm9vdCArIChmcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQgfHwgJycpKTtcblxuICAgICAgICAgICAgLy8gU3RyaXAgdGhlIGhhc2ggZm9yIG1hdGNoaW5nLlxuICAgICAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKHBhdGhTdHJpcHBlciwgJycpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZ21lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuXG4gICAgICAgICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQgPT09ICcnICYmIHVybCAhPT0gJy8nKVxuICAgICAgICAgICAgICAgIHVybCA9IHVybC5zbGljZSgwLCAtMSk7XG5cbiAgICAgICAgICAgIC8vIElmIHB1c2hTdGF0ZSBpcyBhdmFpbGFibGUsIHdlIHVzZSBpdCB0byBzZXQgdGhlIGZyYWdtZW50IGFzIGEgcmVhbCBVUkwuXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGhhc2ggY2hhbmdlcyBoYXZlbid0IGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZCwgdXBkYXRlIHRoZSBoYXNoXG4gICAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgdG8gc3RvcmUgaGlzdG9yeS5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmxvY2F0aW9uLCBmcmFnbWVudCwgb3B0aW9ucy5yZXBsYWNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgKGZyYWdtZW50ICE9PSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcGVuaW5nIGFuZCBjbG9zaW5nIHRoZSBpZnJhbWUgdHJpY2tzIElFNyBhbmQgZWFybGllciB0byBwdXNoIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FudCB0aGlzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVwbGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWZyYW1lLmRvY3VtZW50Lm9wZW4oKS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMuaWZyYW1lLmxvY2F0aW9uLCBmcmFnbWVudCwgb3B0aW9ucy5yZXBsYWNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB5b3UndmUgdG9sZCB1cyB0aGF0IHlvdSBleHBsaWNpdGx5IGRvbid0IHdhbnQgZmFsbGJhY2sgaGFzaGNoYW5nZS1cbiAgICAgICAgICAgICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50cmlnZ2VyKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRVcmwoZnJhZ21lbnQpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2ggbG9jYXRpb24sIGVpdGhlciByZXBsYWNpbmcgdGhlIGN1cnJlbnQgZW50cnksIG9yIGFkZGluZ1xuICAgICAgICAvLyBhIG5ldyBvbmUgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICAgICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uIChsb2NhdGlvbiwgZnJhZ21lbnQsIHJlcGxhY2UpIHtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKGhyZWYgKyAnIycgKyBmcmFnbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgcmVxdWlyZSB0aGF0IGBoYXNoYCBjb250YWlucyBhIGxlYWRpbmcgIy5cbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IEJhY2tib25lLmhpc3RvcnkuXG4gICAgQmFja2JvbmUuaGlzdG9yeSA9IG5ldyBIaXN0b3J5O1xuXG4gICAgLy8gSGVscGVyc1xuICAgIC8vIC0tLS0tLS1cblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb3JyZWN0bHkgc2V0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sIGZvciBzdWJjbGFzc2VzLlxuICAgIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gICAgLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cbiAgICB2YXIgZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGQ7XG5cbiAgICAgICAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAgICAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAgICAgLy8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxuICAgICAgICBpZiAocHJvdG9Qcm9wcyAmJiBfLmhhcyhwcm90b1Byb3BzLCAnY29uc3RydWN0b3InKSkge1xuICAgICAgICAgICAgY2hpbGQgPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGlmIHN1cHBsaWVkLlxuICAgICAgICBfLmV4dGVuZChjaGlsZCwgcGFyZW50LCBzdGF0aWNQcm9wcyk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAgICAgLy8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgICAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICAgICAgfTtcbiAgICAgICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGU7XG5cbiAgICAgICAgLy8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG4gICAgICAgIC8vIGlmIHN1cHBsaWVkLlxuICAgICAgICBpZiAocHJvdG9Qcm9wcylcbiAgICAgICAgICAgIF8uZXh0ZW5kKGNoaWxkLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG5cbiAgICAgICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxuICAgICAgICAvLyBsYXRlci5cbiAgICAgICAgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIC8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLCBjb2xsZWN0aW9uLCByb3V0ZXIsIHZpZXcgYW5kIGhpc3RvcnkuXG4gICAgTW9kZWwuZXh0ZW5kID0gQ29sbGVjdGlvbi5leHRlbmQgPSBSb3V0ZXIuZXh0ZW5kID0gVmlldy5leHRlbmQgPSBIaXN0b3J5LmV4dGVuZCA9IGV4dGVuZDtcblxuICAgIC8vIFRocm93IGFuIGVycm9yIHdoZW4gYSBVUkwgaXMgbmVlZGVkLCBhbmQgbm9uZSBpcyBzdXBwbGllZC5cbiAgICB2YXIgdXJsRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQSBcInVybFwiIHByb3BlcnR5IG9yIGZ1bmN0aW9uIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gICAgfTtcblxuICAgIC8vIFdyYXAgYW4gb3B0aW9uYWwgZXJyb3IgY2FsbGJhY2sgd2l0aCBhIGZhbGxiYWNrIGVycm9yIGV2ZW50LlxuICAgIHZhciB3cmFwRXJyb3IgPSBmdW5jdGlvbiAobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICAgICAgb3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgZXJyb3IobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbW9kZWwudHJpZ2dlcignZXJyb3InLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBCYWNrYm9uZTtcblxufSkpO1xuXG5cblxuLyoqKiBFWFBPUlRTIEZST00gZXhwb3J0cy1sb2FkZXIgKioqL1xubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXNzZXRzL2pzL3ZlbmRvci9iYWNrYm9uZS5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license\n //@ sourceMappingURL=jquery.min.map\n */\n(function (e, t) {\n    var n, r, i = typeof t, o = e.location, a = e.document, s = a.documentElement, l = e.jQuery, u = e.$, c = {}, p = [], f = \"1.10.2\", d = p.concat, h = p.push, g = p.slice, m = p.indexOf, y = c.toString, v = c.hasOwnProperty, b = f.trim, x = function (e, t) {\n        return new x.fn.init(e, t, r)\n    }, w = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source, T = /\\S+/g, C = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, N = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/, k = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/, E = /^[\\],:{}\\s]*$/, S = /(?:^|:|,)(?:\\s*\\[)+/g, A = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g, j = /\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g, D = /^-ms-/, L = /-([\\da-z])/gi, H = function (e, t) {\n        return t.toUpperCase()\n    }, q = function (e) {\n        (a.addEventListener || \"load\" === e.type || \"complete\" === a.readyState) && (_(), x.ready())\n    }, _ = function () {\n        a.addEventListener ? (a.removeEventListener(\"DOMContentLoaded\", q, !1), e.removeEventListener(\"load\", q, !1)) : (a.detachEvent(\"onreadystatechange\", q), e.detachEvent(\"onload\", q))\n    };\n    x.fn = x.prototype = {jquery: f, constructor: x, init: function (e, n, r) {\n            var i, o;\n            if (!e)\n                return this;\n            if (\"string\" == typeof e) {\n                if (i = \"<\" === e.charAt(0) && \">\" === e.charAt(e.length - 1) && e.length >= 3 ? [null, e, null] : N.exec(e), !i || !i[1] && n)\n                    return!n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e);\n                if (i[1]) {\n                    if (n = n instanceof x ? n[0] : n, x.merge(this, x.parseHTML(i[1], n && n.nodeType ? n.ownerDocument || n : a, !0)), k.test(i[1]) && x.isPlainObject(n))\n                        for (i in n)\n                            x.isFunction(this[i]) ? this[i](n[i]) : this.attr(i, n[i]);\n                    return this\n                }\n                if (o = a.getElementById(i[2]), o && o.parentNode) {\n                    if (o.id !== i[2])\n                        return r.find(e);\n                    this.length = 1, this[0] = o\n                }\n                return this.context = a, this.selector = e, this\n            }\n            return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : x.isFunction(e) ? r.ready(e) : (e.selector !== t && (this.selector = e.selector, this.context = e.context), x.makeArray(e, this))\n        }, selector: \"\", length: 0, toArray: function () {\n            return g.call(this)\n        }, get: function (e) {\n            return null == e ? this.toArray() : 0 > e ? this[this.length + e] : this[e]\n        }, pushStack: function (e) {\n            var t = x.merge(this.constructor(), e);\n            return t.prevObject = this, t.context = this.context, t\n        }, each: function (e, t) {\n            return x.each(this, e, t)\n        }, ready: function (e) {\n            return x.ready.promise().done(e), this\n        }, slice: function () {\n            return this.pushStack(g.apply(this, arguments))\n        }, first: function () {\n            return this.eq(0)\n        }, last: function () {\n            return this.eq(-1)\n        }, eq: function (e) {\n            var t = this.length, n = +e + (0 > e ? t : 0);\n            return this.pushStack(n >= 0 && t > n ? [this[n]] : [])\n        }, map: function (e) {\n            return this.pushStack(x.map(this, function (t, n) {\n                return e.call(t, n, t)\n            }))\n        }, end: function () {\n            return this.prevObject || this.constructor(null)\n        }, push: h, sort: [].sort, splice: [].splice}, x.fn.init.prototype = x.fn, x.extend = x.fn.extend = function () {\n        var e, n, r, i, o, a, s = arguments[0] || {}, l = 1, u = arguments.length, c = !1;\n        for (\"boolean\" == typeof s && (c = s, s = arguments[1] || {}, l = 2), \"object\" == typeof s || x.isFunction(s) || (s = {}), u === l && (s = this, --l); u > l; l++)\n            if (null != (o = arguments[l]))\n                for (i in o)\n                    e = s[i], r = o[i], s !== r && (c && r && (x.isPlainObject(r) || (n = x.isArray(r))) ? (n ? (n = !1, a = e && x.isArray(e) ? e : []) : a = e && x.isPlainObject(e) ? e : {}, s[i] = x.extend(c, a, r)) : r !== t && (s[i] = r));\n        return s\n    }, x.extend({expando: \"jQuery\" + (f + Math.random()).replace(/\\D/g, \"\"), noConflict: function (t) {\n            return e.$ === x && (e.$ = u), t && e.jQuery === x && (e.jQuery = l), x\n        }, isReady: !1, readyWait: 1, holdReady: function (e) {\n            e ? x.readyWait++ : x.ready(!0)\n        }, ready: function (e) {\n            if (e === !0 ? !--x.readyWait : !x.isReady) {\n                if (!a.body)\n                    return setTimeout(x.ready);\n                x.isReady = !0, e !== !0 && --x.readyWait > 0 || (n.resolveWith(a, [x]), x.fn.trigger && x(a).trigger(\"ready\").off(\"ready\"))\n            }\n        }, isFunction: function (e) {\n            return\"function\" === x.type(e)\n        }, isArray: Array.isArray || function (e) {\n            return\"array\" === x.type(e)\n        }, isWindow: function (e) {\n            return null != e && e == e.window\n        }, isNumeric: function (e) {\n            return!isNaN(parseFloat(e)) && isFinite(e)\n        }, type: function (e) {\n            return null == e ? e + \"\" : \"object\" == typeof e || \"function\" == typeof e ? c[y.call(e)] || \"object\" : typeof e\n        }, isPlainObject: function (e) {\n            var n;\n            if (!e || \"object\" !== x.type(e) || e.nodeType || x.isWindow(e))\n                return!1;\n            try {\n                if (e.constructor && !v.call(e, \"constructor\") && !v.call(e.constructor.prototype, \"isPrototypeOf\"))\n                    return!1\n            } catch (r) {\n                return!1\n            }\n            if (x.support.ownLast)\n                for (n in e)\n                    return v.call(e, n);\n            for (n in e)\n                ;\n            return n === t || v.call(e, n)\n        }, isEmptyObject: function (e) {\n            var t;\n            for (t in e)\n                return!1;\n            return!0\n        }, error: function (e) {\n            throw Error(e)\n        }, parseHTML: function (e, t, n) {\n            if (!e || \"string\" != typeof e)\n                return null;\n            \"boolean\" == typeof t && (n = t, t = !1), t = t || a;\n            var r = k.exec(e), i = !n && [];\n            return r ? [t.createElement(r[1])] : (r = x.buildFragment([e], t, i), i && x(i).remove(), x.merge([], r.childNodes))\n        }, parseJSON: function (n) {\n            return e.JSON && e.JSON.parse ? e.JSON.parse(n) : null === n ? n : \"string\" == typeof n && (n = x.trim(n), n && E.test(n.replace(A, \"@\").replace(j, \"]\").replace(S, \"\"))) ? Function(\"return \" + n)() : (x.error(\"Invalid JSON: \" + n), t)\n        }, parseXML: function (n) {\n            var r, i;\n            if (!n || \"string\" != typeof n)\n                return null;\n            try {\n                e.DOMParser ? (i = new DOMParser, r = i.parseFromString(n, \"text/xml\")) : (r = new ActiveXObject(\"Microsoft.XMLDOM\"), r.async = \"false\", r.loadXML(n))\n            } catch (o) {\n                r = t\n            }\n            return r && r.documentElement && !r.getElementsByTagName(\"parsererror\").length || x.error(\"Invalid XML: \" + n), r\n        }, noop: function () {\n        }, globalEval: function (t) {\n            t && x.trim(t) && (e.execScript || function (t) {\n                e.eval.call(e, t)\n            })(t)\n        }, camelCase: function (e) {\n            return e.replace(D, \"ms-\").replace(L, H)\n        }, nodeName: function (e, t) {\n            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()\n        }, each: function (e, t, n) {\n            var r, i = 0, o = e.length, a = M(e);\n            if (n) {\n                if (a) {\n                    for (; o > i; i++)\n                        if (r = t.apply(e[i], n), r === !1)\n                            break\n                } else\n                    for (i in e)\n                        if (r = t.apply(e[i], n), r === !1)\n                            break\n            } else if (a) {\n                for (; o > i; i++)\n                    if (r = t.call(e[i], i, e[i]), r === !1)\n                        break\n            } else\n                for (i in e)\n                    if (r = t.call(e[i], i, e[i]), r === !1)\n                        break;\n            return e\n        }, trim: b && !b.call(\"\\ufeff\\u00a0\") ? function (e) {\n            return null == e ? \"\" : b.call(e)\n        } : function (e) {\n            return null == e ? \"\" : (e + \"\").replace(C, \"\")\n        }, makeArray: function (e, t) {\n            var n = t || [];\n            return null != e && (M(Object(e)) ? x.merge(n, \"string\" == typeof e ? [e] : e) : h.call(n, e)), n\n        }, inArray: function (e, t, n) {\n            var r;\n            if (t) {\n                if (m)\n                    return m.call(t, e, n);\n                for (r = t.length, n = n?0 > n?Math.max(0, r + n):n:0; r > n; n++)\n                    if (n in t && t[n] === e)\n                        return n\n            }\n            return-1\n        }, merge: function (e, n) {\n            var r = n.length, i = e.length, o = 0;\n            if (\"number\" == typeof r)\n                for (; r > o; o++)\n                    e[i++] = n[o];\n            else\n                while (n[o] !== t)\n                    e[i++] = n[o++];\n            return e.length = i, e\n        }, grep: function (e, t, n) {\n            var r, i = [], o = 0, a = e.length;\n            for (n = !!n; a > o; o++)\n                r = !!t(e[o], o), n !== r && i.push(e[o]);\n            return i\n        }, map: function (e, t, n) {\n            var r, i = 0, o = e.length, a = M(e), s = [];\n            if (a)\n                for (; o > i; i++)\n                    r = t(e[i], i, n), null != r && (s[s.length] = r);\n            else\n                for (i in e)\n                    r = t(e[i], i, n), null != r && (s[s.length] = r);\n            return d.apply([], s)\n        }, guid: 1, proxy: function (e, n) {\n            var r, i, o;\n            return\"string\" == typeof n && (o = e[n], n = e, e = o), x.isFunction(e) ? (r = g.call(arguments, 2), i = function () {\n                return e.apply(n || this, r.concat(g.call(arguments)))\n            }, i.guid = e.guid = e.guid || x.guid++, i) : t\n        }, access: function (e, n, r, i, o, a, s) {\n            var l = 0, u = e.length, c = null == r;\n            if (\"object\" === x.type(r)) {\n                o = !0;\n                for (l in r)\n                    x.access(e, n, l, r[l], !0, a, s)\n            } else if (i !== t && (o = !0, x.isFunction(i) || (s = !0), c && (s ? (n.call(e, i), n = null) : (c = n, n = function (e, t, n) {\n                return c.call(x(e), n)\n            })), n))\n                for (; u > l; l++)\n                    n(e[l], r, s ? i : i.call(e[l], l, n(e[l], r)));\n            return o ? e : c ? n.call(e) : u ? n(e[0], r) : a\n        }, now: function () {\n            return(new Date).getTime()\n        }, swap: function (e, t, n, r) {\n            var i, o, a = {};\n            for (o in t)\n                a[o] = e.style[o], e.style[o] = t[o];\n            i = n.apply(e, r || []);\n            for (o in t)\n                e.style[o] = a[o];\n            return i\n        }}), x.ready.promise = function (t) {\n        if (!n)\n            if (n = x.Deferred(), \"complete\" === a.readyState)\n                setTimeout(x.ready);\n            else if (a.addEventListener)\n                a.addEventListener(\"DOMContentLoaded\", q, !1), e.addEventListener(\"load\", q, !1);\n            else {\n                a.attachEvent(\"onreadystatechange\", q), e.attachEvent(\"onload\", q);\n                var r = !1;\n                try {\n                    r = null == e.frameElement && a.documentElement\n                } catch (i) {\n                }\n                r && r.doScroll && function o() {\n                    if (!x.isReady) {\n                        try {\n                            r.doScroll(\"left\")\n                        } catch (e) {\n                            return setTimeout(o, 50)\n                        }\n                        _(), x.ready()\n                    }\n                }()\n            }\n        return n.promise(t)\n    }, x.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (e, t) {\n        c[\"[object \" + t + \"]\"] = t.toLowerCase()\n    });\n    function M(e) {\n        var t = e.length, n = x.type(e);\n        return x.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : \"array\" === n || \"function\" !== n && (0 === t || \"number\" == typeof t && t > 0 && t - 1 in e)\n    }\n    r = x(a), function (e, t) {\n        var n, r, i, o, a, s, l, u, c, p, f, d, h, g, m, y, v, b = \"sizzle\" + -new Date, w = e.document, T = 0, C = 0, N = st(), k = st(), E = st(), S = !1, A = function (e, t) {\n            return e === t ? (S = !0, 0) : 0\n        }, j = typeof t, D = 1 << 31, L = {}.hasOwnProperty, H = [], q = H.pop, _ = H.push, M = H.push, O = H.slice, F = H.indexOf || function (e) {\n            var t = 0, n = this.length;\n            for (; n > t; t++)\n                if (this[t] === e)\n                    return t;\n            return-1\n        }, B = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\", P = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\", R = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\", W = R.replace(\"w\", \"w#\"), $ = \"\\\\[\" + P + \"*(\" + R + \")\" + P + \"*(?:([*^$|!~]?=)\" + P + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + W + \")|)|)\" + P + \"*\\\\]\", I = \":(\" + R + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + $.replace(3, 8) + \")*)|.*)\\\\)|)\", z = RegExp(\"^\" + P + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + P + \"+$\", \"g\"), X = RegExp(\"^\" + P + \"*,\" + P + \"*\"), U = RegExp(\"^\" + P + \"*([>+~]|\" + P + \")\" + P + \"*\"), V = RegExp(P + \"*[+~]\"), Y = RegExp(\"=\" + P + \"*([^\\\\]'\\\"]*)\" + P + \"*\\\\]\", \"g\"), J = RegExp(I), G = RegExp(\"^\" + W + \"$\"), Q = {ID: RegExp(\"^#(\" + R + \")\"), CLASS: RegExp(\"^\\\\.(\" + R + \")\"), TAG: RegExp(\"^(\" + R.replace(\"w\", \"w*\") + \")\"), ATTR: RegExp(\"^\" + $), PSEUDO: RegExp(\"^\" + I), CHILD: RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + P + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + P + \"*(?:([+-]|)\" + P + \"*(\\\\d+)|))\" + P + \"*\\\\)|)\", \"i\"), bool: RegExp(\"^(?:\" + B + \")$\", \"i\"), needsContext: RegExp(\"^\" + P + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + P + \"*((?:-\\\\d)?\\\\d*)\" + P + \"*\\\\)|)(?=[^-]|$)\", \"i\")}, K = /^[^{]+\\{\\s*\\[native \\w/, Z = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/, et = /^(?:input|select|textarea|button)$/i, tt = /^h\\d$/i, nt = /'|\\\\/g, rt = RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + P + \"?|(\" + P + \")|.)\", \"ig\"), it = function (e, t, n) {\n            var r = \"0x\" + t - 65536;\n            return r !== r || n ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)\n        };\n        try {\n            M.apply(H = O.call(w.childNodes), w.childNodes), H[w.childNodes.length].nodeType\n        } catch (ot) {\n            M = {apply: H.length ? function (e, t) {\n                    _.apply(e, O.call(t))\n                } : function (e, t) {\n                    var n = e.length, r = 0;\n                    while (e[n++] = t[r++])\n                        ;\n                    e.length = n - 1\n                }}\n        }\n        function at(e, t, n, i) {\n            var o, a, s, l, u, c, d, m, y, x;\n            if ((t ? t.ownerDocument || t : w) !== f && p(t), t = t || f, n = n || [], !e || \"string\" != typeof e)\n                return n;\n            if (1 !== (l = t.nodeType) && 9 !== l)\n                return[];\n            if (h && !i) {\n                if (o = Z.exec(e))\n                    if (s = o[1]) {\n                        if (9 === l) {\n                            if (a = t.getElementById(s), !a || !a.parentNode)\n                                return n;\n                            if (a.id === s)\n                                return n.push(a), n\n                        } else if (t.ownerDocument && (a = t.ownerDocument.getElementById(s)) && v(t, a) && a.id === s)\n                            return n.push(a), n\n                    } else {\n                        if (o[2])\n                            return M.apply(n, t.getElementsByTagName(e)), n;\n                        if ((s = o[3]) && r.getElementsByClassName && t.getElementsByClassName)\n                            return M.apply(n, t.getElementsByClassName(s)), n\n                    }\n                if (r.qsa && (!g || !g.test(e))) {\n                    if (m = d = b, y = t, x = 9 === l && e, 1 === l && \"object\" !== t.nodeName.toLowerCase()) {\n                        c = mt(e), (d = t.getAttribute(\"id\")) ? m = d.replace(nt, \"\\\\$&\") : t.setAttribute(\"id\", m), m = \"[id='\" + m + \"'] \", u = c.length;\n                        while (u--)\n                            c[u] = m + yt(c[u]);\n                        y = V.test(e) && t.parentNode || t, x = c.join(\",\")\n                    }\n                    if (x)\n                        try {\n                            return M.apply(n, y.querySelectorAll(x)), n\n                        } catch (T) {\n                        } finally {\n                            d || t.removeAttribute(\"id\")\n                        }\n                }\n            }\n            return kt(e.replace(z, \"$1\"), t, n, i)\n        }\n        function st() {\n            var e = [];\n            function t(n, r) {\n                return e.push(n += \" \") > o.cacheLength && delete t[e.shift()], t[n] = r\n            }\n            return t\n        }\n        function lt(e) {\n            return e[b] = !0, e\n        }\n        function ut(e) {\n            var t = f.createElement(\"div\");\n            try {\n                return!!e(t)\n            } catch (n) {\n                return!1\n            } finally {\n                t.parentNode && t.parentNode.removeChild(t), t = null\n            }\n        }\n        function ct(e, t) {\n            var n = e.split(\"|\"), r = e.length;\n            while (r--)\n                o.attrHandle[n[r]] = t\n        }\n        function pt(e, t) {\n            var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || D) - (~e.sourceIndex || D);\n            if (r)\n                return r;\n            if (n)\n                while (n = n.nextSibling)\n                    if (n === t)\n                        return-1;\n            return e ? 1 : -1\n        }\n        function ft(e) {\n            return function (t) {\n                var n = t.nodeName.toLowerCase();\n                return\"input\" === n && t.type === e\n            }\n        }\n        function dt(e) {\n            return function (t) {\n                var n = t.nodeName.toLowerCase();\n                return(\"input\" === n || \"button\" === n) && t.type === e\n            }\n        }\n        function ht(e) {\n            return lt(function (t) {\n                return t = +t, lt(function (n, r) {\n                    var i, o = e([], n.length, t), a = o.length;\n                    while (a--)\n                        n[i = o[a]] && (n[i] = !(r[i] = n[i]))\n                })\n            })\n        }\n        s = at.isXML = function (e) {\n            var t = e && (e.ownerDocument || e).documentElement;\n            return t ? \"HTML\" !== t.nodeName : !1\n        }, r = at.support = {}, p = at.setDocument = function (e) {\n            var n = e ? e.ownerDocument || e : w, i = n.defaultView;\n            return n !== f && 9 === n.nodeType && n.documentElement ? (f = n, d = n.documentElement, h = !s(n), i && i.attachEvent && i !== i.top && i.attachEvent(\"onbeforeunload\", function () {\n                p()\n            }), r.attributes = ut(function (e) {\n                return e.className = \"i\", !e.getAttribute(\"className\")\n            }), r.getElementsByTagName = ut(function (e) {\n                return e.appendChild(n.createComment(\"\")), !e.getElementsByTagName(\"*\").length\n            }), r.getElementsByClassName = ut(function (e) {\n                return e.innerHTML = \"<div class='a'></div><div class='a i'></div>\", e.firstChild.className = \"i\", 2 === e.getElementsByClassName(\"i\").length\n            }), r.getById = ut(function (e) {\n                return d.appendChild(e).id = b, !n.getElementsByName || !n.getElementsByName(b).length\n            }), r.getById ? (o.find.ID = function (e, t) {\n                if (typeof t.getElementById !== j && h) {\n                    var n = t.getElementById(e);\n                    return n && n.parentNode ? [n] : []\n                }\n            }, o.filter.ID = function (e) {\n                var t = e.replace(rt, it);\n                return function (e) {\n                    return e.getAttribute(\"id\") === t\n                }\n            }) : (delete o.find.ID, o.filter.ID = function (e) {\n                var t = e.replace(rt, it);\n                return function (e) {\n                    var n = typeof e.getAttributeNode !== j && e.getAttributeNode(\"id\");\n                    return n && n.value === t\n                }\n            }), o.find.TAG = r.getElementsByTagName ? function (e, n) {\n                return typeof n.getElementsByTagName !== j ? n.getElementsByTagName(e) : t\n            } : function (e, t) {\n                var n, r = [], i = 0, o = t.getElementsByTagName(e);\n                if (\"*\" === e) {\n                    while (n = o[i++])\n                        1 === n.nodeType && r.push(n);\n                    return r\n                }\n                return o\n            }, o.find.CLASS = r.getElementsByClassName && function (e, n) {\n                return typeof n.getElementsByClassName !== j && h ? n.getElementsByClassName(e) : t\n            }, m = [], g = [], (r.qsa = K.test(n.querySelectorAll)) && (ut(function (e) {\n                e.innerHTML = \"<select><option selected=''></option></select>\", e.querySelectorAll(\"[selected]\").length || g.push(\"\\\\[\" + P + \"*(?:value|\" + B + \")\"), e.querySelectorAll(\":checked\").length || g.push(\":checked\")\n            }), ut(function (e) {\n                var t = n.createElement(\"input\");\n                t.setAttribute(\"type\", \"hidden\"), e.appendChild(t).setAttribute(\"t\", \"\"), e.querySelectorAll(\"[t^='']\").length && g.push(\"[*^$]=\" + P + \"*(?:''|\\\"\\\")\"), e.querySelectorAll(\":enabled\").length || g.push(\":enabled\", \":disabled\"), e.querySelectorAll(\"*,:x\"), g.push(\",.*:\")\n            })), (r.matchesSelector = K.test(y = d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.msMatchesSelector)) && ut(function (e) {\n                r.disconnectedMatch = y.call(e, \"div\"), y.call(e, \"[s!='']:x\"), m.push(\"!=\", I)\n            }), g = g.length && RegExp(g.join(\"|\")), m = m.length && RegExp(m.join(\"|\")), v = K.test(d.contains) || d.compareDocumentPosition ? function (e, t) {\n                var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode;\n                return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))\n            } : function (e, t) {\n                if (t)\n                    while (t = t.parentNode)\n                        if (t === e)\n                            return!0;\n                return!1\n            }, A = d.compareDocumentPosition ? function (e, t) {\n                if (e === t)\n                    return S = !0, 0;\n                var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition(t);\n                return i ? 1 & i || !r.sortDetached && t.compareDocumentPosition(e) === i ? e === n || v(w, e) ? -1 : t === n || v(w, t) ? 1 : c ? F.call(c, e) - F.call(c, t) : 0 : 4 & i ? -1 : 1 : e.compareDocumentPosition ? -1 : 1\n            } : function (e, t) {\n                var r, i = 0, o = e.parentNode, a = t.parentNode, s = [e], l = [t];\n                if (e === t)\n                    return S = !0, 0;\n                if (!o || !a)\n                    return e === n ? -1 : t === n ? 1 : o ? -1 : a ? 1 : c ? F.call(c, e) - F.call(c, t) : 0;\n                if (o === a)\n                    return pt(e, t);\n                r = e;\n                while (r = r.parentNode)\n                    s.unshift(r);\n                r = t;\n                while (r = r.parentNode)\n                    l.unshift(r);\n                while (s[i] === l[i])\n                    i++;\n                return i ? pt(s[i], l[i]) : s[i] === w ? -1 : l[i] === w ? 1 : 0\n            }, n) : f\n        }, at.matches = function (e, t) {\n            return at(e, null, null, t)\n        }, at.matchesSelector = function (e, t) {\n            if ((e.ownerDocument || e) !== f && p(e), t = t.replace(Y, \"='$1']\"), !(!r.matchesSelector || !h || m && m.test(t) || g && g.test(t)))\n                try {\n                    var n = y.call(e, t);\n                    if (n || r.disconnectedMatch || e.document && 11 !== e.document.nodeType)\n                        return n\n                } catch (i) {\n                }\n            return at(t, f, null, [e]).length > 0\n        }, at.contains = function (e, t) {\n            return(e.ownerDocument || e) !== f && p(e), v(e, t)\n        }, at.attr = function (e, n) {\n            (e.ownerDocument || e) !== f && p(e);\n            var i = o.attrHandle[n.toLowerCase()], a = i && L.call(o.attrHandle, n.toLowerCase()) ? i(e, n, !h) : t;\n            return a === t ? r.attributes || !h ? e.getAttribute(n) : (a = e.getAttributeNode(n)) && a.specified ? a.value : null : a\n        }, at.error = function (e) {\n            throw Error(\"Syntax error, unrecognized expression: \" + e)\n        }, at.uniqueSort = function (e) {\n            var t, n = [], i = 0, o = 0;\n            if (S = !r.detectDuplicates, c = !r.sortStable && e.slice(0), e.sort(A), S) {\n                while (t = e[o++])\n                    t === e[o] && (i = n.push(o));\n                while (i--)\n                    e.splice(n[i], 1)\n            }\n            return e\n        }, a = at.getText = function (e) {\n            var t, n = \"\", r = 0, i = e.nodeType;\n            if (i) {\n                if (1 === i || 9 === i || 11 === i) {\n                    if (\"string\" == typeof e.textContent)\n                        return e.textContent;\n                    for (e = e.firstChild; e; e = e.nextSibling)\n                        n += a(e)\n                } else if (3 === i || 4 === i)\n                    return e.nodeValue\n            } else\n                for (; t = e[r]; r++)\n                    n += a(t);\n            return n\n        }, o = at.selectors = {cacheLength: 50, createPseudo: lt, match: Q, attrHandle: {}, find: {}, relative: {\">\": {dir: \"parentNode\", first: !0}, \" \": {dir: \"parentNode\"}, \"+\": {dir: \"previousSibling\", first: !0}, \"~\": {dir: \"previousSibling\"}}, preFilter: {ATTR: function (e) {\n                    return e[1] = e[1].replace(rt, it), e[3] = (e[4] || e[5] || \"\").replace(rt, it), \"~=\" === e[2] && (e[3] = \" \" + e[3] + \" \"), e.slice(0, 4)\n                }, CHILD: function (e) {\n                    return e[1] = e[1].toLowerCase(), \"nth\" === e[1].slice(0, 3) ? (e[3] || at.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * (\"even\" === e[3] || \"odd\" === e[3])), e[5] = +(e[7] + e[8] || \"odd\" === e[3])) : e[3] && at.error(e[0]), e\n                }, PSEUDO: function (e) {\n                    var n, r = !e[5] && e[2];\n                    return Q.CHILD.test(e[0]) ? null : (e[3] && e[4] !== t ? e[2] = e[4] : r && J.test(r) && (n = mt(r, !0)) && (n = r.indexOf(\")\", r.length - n) - r.length) && (e[0] = e[0].slice(0, n), e[2] = r.slice(0, n)), e.slice(0, 3))\n                }}, filter: {TAG: function (e) {\n                    var t = e.replace(rt, it).toLowerCase();\n                    return\"*\" === e ? function () {\n                        return!0\n                    } : function (e) {\n                        return e.nodeName && e.nodeName.toLowerCase() === t\n                    }\n                }, CLASS: function (e) {\n                    var t = N[e + \" \"];\n                    return t || (t = RegExp(\"(^|\" + P + \")\" + e + \"(\" + P + \"|$)\")) && N(e, function (e) {\n                        return t.test(\"string\" == typeof e.className && e.className || typeof e.getAttribute !== j && e.getAttribute(\"class\") || \"\")\n                    })\n                }, ATTR: function (e, t, n) {\n                    return function (r) {\n                        var i = at.attr(r, e);\n                        return null == i ? \"!=\" === t : t ? (i += \"\", \"=\" === t ? i === n : \"!=\" === t ? i !== n : \"^=\" === t ? n && 0 === i.indexOf(n) : \"*=\" === t ? n && i.indexOf(n) > -1 : \"$=\" === t ? n && i.slice(-n.length) === n : \"~=\" === t ? (\" \" + i + \" \").indexOf(n) > -1 : \"|=\" === t ? i === n || i.slice(0, n.length + 1) === n + \"-\" : !1) : !0\n                    }\n                }, CHILD: function (e, t, n, r, i) {\n                    var o = \"nth\" !== e.slice(0, 3), a = \"last\" !== e.slice(-4), s = \"of-type\" === t;\n                    return 1 === r && 0 === i ? function (e) {\n                        return!!e.parentNode\n                    } : function (t, n, l) {\n                        var u, c, p, f, d, h, g = o !== a ? \"nextSibling\" : \"previousSibling\", m = t.parentNode, y = s && t.nodeName.toLowerCase(), v = !l && !s;\n                        if (m) {\n                            if (o) {\n                                while (g) {\n                                    p = t;\n                                    while (p = p[g])\n                                        if (s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType)\n                                            return!1;\n                                    h = g = \"only\" === e && !h && \"nextSibling\"\n                                }\n                                return!0\n                            }\n                            if (h = [a ? m.firstChild : m.lastChild], a && v) {\n                                c = m[b] || (m[b] = {}), u = c[e] || [], d = u[0] === T && u[1], f = u[0] === T && u[2], p = d && m.childNodes[d];\n                                while (p = ++d && p && p[g] || (f = d = 0) || h.pop())\n                                    if (1 === p.nodeType && ++f && p === t) {\n                                        c[e] = [T, d, f];\n                                        break\n                                    }\n                            } else if (v && (u = (t[b] || (t[b] = {}))[e]) && u[0] === T)\n                                f = u[1];\n                            else\n                                while (p = ++d && p && p[g] || (f = d = 0) || h.pop())\n                                    if ((s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) && ++f && (v && ((p[b] || (p[b] = {}))[e] = [T, f]), p === t))\n                                        break;\n                            return f -= i, f === r || 0 === f % r && f / r >= 0\n                        }\n                    }\n                }, PSEUDO: function (e, t) {\n                    var n, r = o.pseudos[e] || o.setFilters[e.toLowerCase()] || at.error(\"unsupported pseudo: \" + e);\n                    return r[b] ? r(t) : r.length > 1 ? (n = [e, e, \"\", t], o.setFilters.hasOwnProperty(e.toLowerCase()) ? lt(function (e, n) {\n                        var i, o = r(e, t), a = o.length;\n                        while (a--)\n                            i = F.call(e, o[a]), e[i] = !(n[i] = o[a])\n                    }) : function (e) {\n                        return r(e, 0, n)\n                    }) : r\n                }}, pseudos: {not: lt(function (e) {\n                    var t = [], n = [], r = l(e.replace(z, \"$1\"));\n                    return r[b] ? lt(function (e, t, n, i) {\n                        var o, a = r(e, null, i, []), s = e.length;\n                        while (s--)\n                            (o = a[s]) && (e[s] = !(t[s] = o))\n                    }) : function (e, i, o) {\n                        return t[0] = e, r(t, null, o, n), !n.pop()\n                    }\n                }), has: lt(function (e) {\n                    return function (t) {\n                        return at(e, t).length > 0\n                    }\n                }), contains: lt(function (e) {\n                    return function (t) {\n                        return(t.textContent || t.innerText || a(t)).indexOf(e) > -1\n                    }\n                }), lang: lt(function (e) {\n                    return G.test(e || \"\") || at.error(\"unsupported lang: \" + e), e = e.replace(rt, it).toLowerCase(), function (t) {\n                        var n;\n                        do\n                            if (n = h ? t.lang : t.getAttribute(\"xml:lang\") || t.getAttribute(\"lang\"))\n                                return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + \"-\");\n                        while ((t = t.parentNode) && 1 === t.nodeType);\n                        return!1\n                    }\n                }), target: function (t) {\n                    var n = e.location && e.location.hash;\n                    return n && n.slice(1) === t.id\n                }, root: function (e) {\n                    return e === d\n                }, focus: function (e) {\n                    return e === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)\n                }, enabled: function (e) {\n                    return e.disabled === !1\n                }, disabled: function (e) {\n                    return e.disabled === !0\n                }, checked: function (e) {\n                    var t = e.nodeName.toLowerCase();\n                    return\"input\" === t && !!e.checked || \"option\" === t && !!e.selected\n                }, selected: function (e) {\n                    return e.parentNode && e.parentNode.selectedIndex, e.selected === !0\n                }, empty: function (e) {\n                    for (e = e.firstChild; e; e = e.nextSibling)\n                        if (e.nodeName > \"@\" || 3 === e.nodeType || 4 === e.nodeType)\n                            return!1;\n                    return!0\n                }, parent: function (e) {\n                    return!o.pseudos.empty(e)\n                }, header: function (e) {\n                    return tt.test(e.nodeName)\n                }, input: function (e) {\n                    return et.test(e.nodeName)\n                }, button: function (e) {\n                    var t = e.nodeName.toLowerCase();\n                    return\"input\" === t && \"button\" === e.type || \"button\" === t\n                }, text: function (e) {\n                    var t;\n                    return\"input\" === e.nodeName.toLowerCase() && \"text\" === e.type && (null == (t = e.getAttribute(\"type\")) || t.toLowerCase() === e.type)\n                }, first: ht(function () {\n                    return[0]\n                }), last: ht(function (e, t) {\n                    return[t - 1]\n                }), eq: ht(function (e, t, n) {\n                    return[0 > n ? n + t : n]\n                }), even: ht(function (e, t) {\n                    var n = 0;\n                    for (; t > n; n += 2)\n                        e.push(n);\n                    return e\n                }), odd: ht(function (e, t) {\n                    var n = 1;\n                    for (; t > n; n += 2)\n                        e.push(n);\n                    return e\n                }), lt: ht(function (e, t, n) {\n                    var r = 0 > n ? n + t : n;\n                    for (; --r >= 0; )\n                        e.push(r);\n                    return e\n                }), gt: ht(function (e, t, n) {\n                    var r = 0 > n ? n + t : n;\n                    for (; t > ++r; )\n                        e.push(r);\n                    return e\n                })}}, o.pseudos.nth = o.pseudos.eq;\n        for (n in{radio:!0, checkbox:!0, file:!0, password:!0, image:!0})\n            o.pseudos[n] = ft(n);\n        for (n in{submit:!0, reset:!0})\n            o.pseudos[n] = dt(n);\n        function gt() {\n        }\n        gt.prototype = o.filters = o.pseudos, o.setFilters = new gt;\n        function mt(e, t) {\n            var n, r, i, a, s, l, u, c = k[e + \" \"];\n            if (c)\n                return t ? 0 : c.slice(0);\n            s = e, l = [], u = o.preFilter;\n            while (s) {\n                (!n || (r = X.exec(s))) && (r && (s = s.slice(r[0].length) || s), l.push(i = [])), n = !1, (r = U.exec(s)) && (n = r.shift(), i.push({value: n, type: r[0].replace(z, \" \")}), s = s.slice(n.length));\n                for (a in o.filter)\n                    !(r = Q[a].exec(s)) || u[a] && !(r = u[a](r)) || (n = r.shift(), i.push({value: n, type: a, matches: r}), s = s.slice(n.length));\n                if (!n)\n                    break\n            }\n            return t ? s.length : s ? at.error(e) : k(e, l).slice(0)\n        }\n        function yt(e) {\n            var t = 0, n = e.length, r = \"\";\n            for (; n > t; t++)\n                r += e[t].value;\n            return r\n        }\n        function vt(e, t, n) {\n            var r = t.dir, o = n && \"parentNode\" === r, a = C++;\n            return t.first ? function (t, n, i) {\n                while (t = t[r])\n                    if (1 === t.nodeType || o)\n                        return e(t, n, i)\n            } : function (t, n, s) {\n                var l, u, c, p = T + \" \" + a;\n                if (s) {\n                    while (t = t[r])\n                        if ((1 === t.nodeType || o) && e(t, n, s))\n                            return!0\n                } else\n                    while (t = t[r])\n                        if (1 === t.nodeType || o)\n                            if (c = t[b] || (t[b] = {}), (u = c[r]) && u[0] === p) {\n                                if ((l = u[1]) === !0 || l === i)\n                                    return l === !0\n                            } else if (u = c[r] = [p], u[1] = e(t, n, s) || i, u[1] === !0)\n                                return!0\n            }\n        }\n        function bt(e) {\n            return e.length > 1 ? function (t, n, r) {\n                var i = e.length;\n                while (i--)\n                    if (!e[i](t, n, r))\n                        return!1;\n                return!0\n            } : e[0]\n        }\n        function xt(e, t, n, r, i) {\n            var o, a = [], s = 0, l = e.length, u = null != t;\n            for (; l > s; s++)\n                (o = e[s]) && (!n || n(o, r, i)) && (a.push(o), u && t.push(s));\n            return a\n        }\n        function wt(e, t, n, r, i, o) {\n            return r && !r[b] && (r = wt(r)), i && !i[b] && (i = wt(i, o)), lt(function (o, a, s, l) {\n                var u, c, p, f = [], d = [], h = a.length, g = o || Nt(t || \"*\", s.nodeType ? [s] : s, []), m = !e || !o && t ? g : xt(g, f, e, s, l), y = n ? i || (o ? e : h || r) ? [] : a : m;\n                if (n && n(m, y, s, l), r) {\n                    u = xt(y, d), r(u, [], s, l), c = u.length;\n                    while (c--)\n                        (p = u[c]) && (y[d[c]] = !(m[d[c]] = p))\n                }\n                if (o) {\n                    if (i || e) {\n                        if (i) {\n                            u = [], c = y.length;\n                            while (c--)\n                                (p = y[c]) && u.push(m[c] = p);\n                            i(null, y = [], u, l)\n                        }\n                        c = y.length;\n                        while (c--)\n                            (p = y[c]) && (u = i ? F.call(o, p) : f[c]) > -1 && (o[u] = !(a[u] = p))\n                    }\n                } else\n                    y = xt(y === a ? y.splice(h, y.length) : y), i ? i(null, a, y, l) : M.apply(a, y)\n            })\n        }\n        function Tt(e) {\n            var t, n, r, i = e.length, a = o.relative[e[0].type], s = a || o.relative[\" \"], l = a ? 1 : 0, c = vt(function (e) {\n                return e === t\n            }, s, !0), p = vt(function (e) {\n                return F.call(t, e) > -1\n            }, s, !0), f = [function (e, n, r) {\n                    return!a && (r || n !== u) || ((t = n).nodeType ? c(e, n, r) : p(e, n, r))\n                }];\n            for (; i > l; l++)\n                if (n = o.relative[e[l].type])\n                    f = [vt(bt(f), n)];\n                else {\n                    if (n = o.filter[e[l].type].apply(null, e[l].matches), n[b]) {\n                        for (r = ++l; i > r; r++)\n                            if (o.relative[e[r].type])\n                                break;\n                        return wt(l > 1 && bt(f), l > 1 && yt(e.slice(0, l - 1).concat({value: \" \" === e[l - 2].type ? \"*\" : \"\"})).replace(z, \"$1\"), n, r > l && Tt(e.slice(l, r)), i > r && Tt(e = e.slice(r)), i > r && yt(e))\n                    }\n                    f.push(n)\n                }\n            return bt(f)\n        }\n        function Ct(e, t) {\n            var n = 0, r = t.length > 0, a = e.length > 0, s = function (s, l, c, p, d) {\n                var h, g, m, y = [], v = 0, b = \"0\", x = s && [], w = null != d, C = u, N = s || a && o.find.TAG(\"*\", d && l.parentNode || l), k = T += null == C ? 1 : Math.random() || .1;\n                for (w && (u = l !== f && l, i = n); null != (h = N[b]); b++) {\n                    if (a && h) {\n                        g = 0;\n                        while (m = e[g++])\n                            if (m(h, l, c)) {\n                                p.push(h);\n                                break\n                            }\n                        w && (T = k, i = ++n)\n                    }\n                    r && ((h = !m && h) && v--, s && x.push(h))\n                }\n                if (v += b, r && b !== v) {\n                    g = 0;\n                    while (m = t[g++])\n                        m(x, y, l, c);\n                    if (s) {\n                        if (v > 0)\n                            while (b--)\n                                x[b] || y[b] || (y[b] = q.call(p));\n                        y = xt(y)\n                    }\n                    M.apply(p, y), w && !s && y.length > 0 && v + t.length > 1 && at.uniqueSort(p)\n                }\n                return w && (T = k, u = C), x\n            };\n            return r ? lt(s) : s\n        }\n        l = at.compile = function (e, t) {\n            var n, r = [], i = [], o = E[e + \" \"];\n            if (!o) {\n                t || (t = mt(e)), n = t.length;\n                while (n--)\n                    o = Tt(t[n]), o[b] ? r.push(o) : i.push(o);\n                o = E(e, Ct(i, r))\n            }\n            return o\n        };\n        function Nt(e, t, n) {\n            var r = 0, i = t.length;\n            for (; i > r; r++)\n                at(e, t[r], n);\n            return n\n        }\n        function kt(e, t, n, i) {\n            var a, s, u, c, p, f = mt(e);\n            if (!i && 1 === f.length) {\n                if (s = f[0] = f[0].slice(0), s.length > 2 && \"ID\" === (u = s[0]).type && r.getById && 9 === t.nodeType && h && o.relative[s[1].type]) {\n                    if (t = (o.find.ID(u.matches[0].replace(rt, it), t) || [])[0], !t)\n                        return n;\n                    e = e.slice(s.shift().value.length)\n                }\n                a = Q.needsContext.test(e) ? 0 : s.length;\n                while (a--) {\n                    if (u = s[a], o.relative[c = u.type])\n                        break;\n                    if ((p = o.find[c]) && (i = p(u.matches[0].replace(rt, it), V.test(s[0].type) && t.parentNode || t))) {\n                        if (s.splice(a, 1), e = i.length && yt(s), !e)\n                            return M.apply(n, i), n;\n                        break\n                    }\n                }\n            }\n            return l(e, f)(i, t, !h, n, V.test(e)), n\n        }\n        r.sortStable = b.split(\"\").sort(A).join(\"\") === b, r.detectDuplicates = S, p(), r.sortDetached = ut(function (e) {\n            return 1 & e.compareDocumentPosition(f.createElement(\"div\"))\n        }), ut(function (e) {\n            return e.innerHTML = \"<a href='#'></a>\", \"#\" === e.firstChild.getAttribute(\"href\")\n        }) || ct(\"type|href|height|width\", function (e, n, r) {\n            return r ? t : e.getAttribute(n, \"type\" === n.toLowerCase() ? 1 : 2)\n        }), r.attributes && ut(function (e) {\n            return e.innerHTML = \"<input/>\", e.firstChild.setAttribute(\"value\", \"\"), \"\" === e.firstChild.getAttribute(\"value\")\n        }) || ct(\"value\", function (e, n, r) {\n            return r || \"input\" !== e.nodeName.toLowerCase() ? t : e.defaultValue\n        }), ut(function (e) {\n            return null == e.getAttribute(\"disabled\")\n        }) || ct(B, function (e, n, r) {\n            var i;\n            return r ? t : (i = e.getAttributeNode(n)) && i.specified ? i.value : e[n] === !0 ? n.toLowerCase() : null\n        }), x.find = at, x.expr = at.selectors, x.expr[\":\"] = x.expr.pseudos, x.unique = at.uniqueSort, x.text = at.getText, x.isXMLDoc = at.isXML, x.contains = at.contains\n    }(e);\n    var O = {};\n    function F(e) {\n        var t = O[e] = {};\n        return x.each(e.match(T) || [], function (e, n) {\n            t[n] = !0\n        }), t\n    }\n    x.Callbacks = function (e) {\n        e = \"string\" == typeof e ? O[e] || F(e) : x.extend({}, e);\n        var n, r, i, o, a, s, l = [], u = !e.once && [], c = function (t) {\n            for (r = e.memory && t, i = !0, a = s || 0, s = 0, o = l.length, n = !0; l && o > a; a++)\n                if (l[a].apply(t[0], t[1]) === !1 && e.stopOnFalse) {\n                    r = !1;\n                    break\n                }\n            n = !1, l && (u ? u.length && c(u.shift()) : r ? l = [] : p.disable())\n        }, p = {add: function () {\n                if (l) {\n                    var t = l.length;\n                    (function i(t) {\n                        x.each(t, function (t, n) {\n                            var r = x.type(n);\n                            \"function\" === r ? e.unique && p.has(n) || l.push(n) : n && n.length && \"string\" !== r && i(n)\n                        })\n                    })(arguments), n ? o = l.length : r && (s = t, c(r))\n                }\n                return this\n            }, remove: function () {\n                return l && x.each(arguments, function (e, t) {\n                    var r;\n                    while ((r = x.inArray(t, l, r)) > - 1)\n                        l.splice(r, 1), n && (o >= r && o--, a >= r && a--)\n                }), this\n            }, has: function (e) {\n                return e ? x.inArray(e, l) > -1 : !(!l || !l.length)\n            }, empty: function () {\n                return l = [], o = 0, this\n            }, disable: function () {\n                return l = u = r = t, this\n            }, disabled: function () {\n                return!l\n            }, lock: function () {\n                return u = t, r || p.disable(), this\n            }, locked: function () {\n                return!u\n            }, fireWith: function (e, t) {\n                return!l || i && !u || (t = t || [], t = [e, t.slice ? t.slice() : t], n ? u.push(t) : c(t)), this\n            }, fire: function () {\n                return p.fireWith(this, arguments), this\n            }, fired: function () {\n                return!!i\n            }};\n        return p\n    }, x.extend({Deferred: function (e) {\n            var t = [[\"resolve\", \"done\", x.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", x.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", x.Callbacks(\"memory\")]], n = \"pending\", r = {state: function () {\n                    return n\n                }, always: function () {\n                    return i.done(arguments).fail(arguments), this\n                }, then: function () {\n                    var e = arguments;\n                    return x.Deferred(function (n) {\n                        x.each(t, function (t, o) {\n                            var a = o[0], s = x.isFunction(e[t]) && e[t];\n                            i[o[1]](function () {\n                                var e = s && s.apply(this, arguments);\n                                e && x.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[a + \"With\"](this === r ? n.promise() : this, s ? [e] : arguments)\n                            })\n                        }), e = null\n                    }).promise()\n                }, promise: function (e) {\n                    return null != e ? x.extend(e, r) : r\n                }}, i = {};\n            return r.pipe = r.then, x.each(t, function (e, o) {\n                var a = o[2], s = o[3];\n                r[o[1]] = a.add, s && a.add(function () {\n                    n = s\n                }, t[1 ^ e][2].disable, t[2][2].lock), i[o[0]] = function () {\n                    return i[o[0] + \"With\"](this === i ? r : this, arguments), this\n                }, i[o[0] + \"With\"] = a.fireWith\n            }), r.promise(i), e && e.call(i, i), i\n        }, when: function (e) {\n            var t = 0, n = g.call(arguments), r = n.length, i = 1 !== r || e && x.isFunction(e.promise) ? r : 0, o = 1 === i ? e : x.Deferred(), a = function (e, t, n) {\n                return function (r) {\n                    t[e] = this, n[e] = arguments.length > 1 ? g.call(arguments) : r, n === s ? o.notifyWith(t, n) : --i || o.resolveWith(t, n)\n                }\n            }, s, l, u;\n            if (r > 1)\n                for (s = Array(r), l = Array(r), u = Array(r); r > t; t++)\n                    n[t] && x.isFunction(n[t].promise) ? n[t].promise().done(a(t, u, n)).fail(o.reject).progress(a(t, l, s)) : --i;\n            return i || o.resolveWith(u, n), o.promise()\n        }}), x.support = function (t) {\n        var n, r, o, s, l, u, c, p, f, d = a.createElement(\"div\");\n        if (d.setAttribute(\"className\", \"t\"), d.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\", n = d.getElementsByTagName(\"*\") || [], r = d.getElementsByTagName(\"a\")[0], !r || !r.style || !n.length)\n            return t;\n        s = a.createElement(\"select\"), u = s.appendChild(a.createElement(\"option\")), o = d.getElementsByTagName(\"input\")[0], r.style.cssText = \"top:1px;float:left;opacity:.5\", t.getSetAttribute = \"t\" !== d.className, t.leadingWhitespace = 3 === d.firstChild.nodeType, t.tbody = !d.getElementsByTagName(\"tbody\").length, t.htmlSerialize = !!d.getElementsByTagName(\"link\").length, t.style = /top/.test(r.getAttribute(\"style\")), t.hrefNormalized = \"/a\" === r.getAttribute(\"href\"), t.opacity = /^0.5/.test(r.style.opacity), t.cssFloat = !!r.style.cssFloat, t.checkOn = !!o.value, t.optSelected = u.selected, t.enctype = !!a.createElement(\"form\").enctype, t.html5Clone = \"<:nav></:nav>\" !== a.createElement(\"nav\").cloneNode(!0).outerHTML, t.inlineBlockNeedsLayout = !1, t.shrinkWrapBlocks = !1, t.pixelPosition = !1, t.deleteExpando = !0, t.noCloneEvent = !0, t.reliableMarginRight = !0, t.boxSizingReliable = !0, o.checked = !0, t.noCloneChecked = o.cloneNode(!0).checked, s.disabled = !0, t.optDisabled = !u.disabled;\n        try {\n            delete d.test\n        } catch (h) {\n            t.deleteExpando = !1\n        }\n        o = a.createElement(\"input\"), o.setAttribute(\"value\", \"\"), t.input = \"\" === o.getAttribute(\"value\"), o.value = \"t\", o.setAttribute(\"type\", \"radio\"), t.radioValue = \"t\" === o.value, o.setAttribute(\"checked\", \"t\"), o.setAttribute(\"name\", \"t\"), l = a.createDocumentFragment(), l.appendChild(o), t.appendChecked = o.checked, t.checkClone = l.cloneNode(!0).cloneNode(!0).lastChild.checked, d.attachEvent && (d.attachEvent(\"onclick\", function () {\n            t.noCloneEvent = !1\n        }), d.cloneNode(!0).click());\n        for (f in{submit:!0, change:!0, focusin:!0})\n            d.setAttribute(c = \"on\" + f, \"t\"), t[f + \"Bubbles\"] = c in e || d.attributes[c].expando === !1;\n        d.style.backgroundClip = \"content-box\", d.cloneNode(!0).style.backgroundClip = \"\", t.clearCloneStyle = \"content-box\" === d.style.backgroundClip;\n        for (f in x(t))\n            break;\n        return t.ownLast = \"0\" !== f, x(function () {\n            var n, r, o, s = \"padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;\", l = a.getElementsByTagName(\"body\")[0];\n            l && (n = a.createElement(\"div\"), n.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\", l.appendChild(n).appendChild(d), d.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\", o = d.getElementsByTagName(\"td\"), o[0].style.cssText = \"padding:0;margin:0;border:0;display:none\", p = 0 === o[0].offsetHeight, o[0].style.display = \"\", o[1].style.display = \"none\", t.reliableHiddenOffsets = p && 0 === o[0].offsetHeight, d.innerHTML = \"\", d.style.cssText = \"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\", x.swap(l, null != l.style.zoom ? {zoom: 1} : {}, function () {\n                t.boxSizing = 4 === d.offsetWidth\n            }), e.getComputedStyle && (t.pixelPosition = \"1%\" !== (e.getComputedStyle(d, null) || {}).top, t.boxSizingReliable = \"4px\" === (e.getComputedStyle(d, null) || {width: \"4px\"}).width, r = d.appendChild(a.createElement(\"div\")), r.style.cssText = d.style.cssText = s, r.style.marginRight = r.style.width = \"0\", d.style.width = \"1px\", t.reliableMarginRight = !parseFloat((e.getComputedStyle(r, null) || {}).marginRight)), typeof d.style.zoom !== i && (d.innerHTML = \"\", d.style.cssText = s + \"width:1px;padding:1px;display:inline;zoom:1\", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display = \"block\", d.innerHTML = \"<div></div>\", d.firstChild.style.width = \"5px\", t.shrinkWrapBlocks = 3 !== d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild(n), n = d = o = r = null)\n        }), n = s = l = u = r = o = null, t\n    }({});\n    var B = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/, P = /([A-Z])/g;\n    function R(e, n, r, i) {\n        if (x.acceptData(e)) {\n            var o, a, s = x.expando, l = e.nodeType, u = l ? x.cache : e, c = l ? e[s] : e[s] && s;\n            if (c && u[c] && (i || u[c].data) || r !== t || \"string\" != typeof n)\n                return c || (c = l ? e[s] = p.pop() || x.guid++ : s), u[c] || (u[c] = l ? {} : {toJSON: x.noop}), (\"object\" == typeof n || \"function\" == typeof n) && (i ? u[c] = x.extend(u[c], n) : u[c].data = x.extend(u[c].data, n)), a = u[c], i || (a.data || (a.data = {}), a = a.data), r !== t && (a[x.camelCase(n)] = r), \"string\" == typeof n ? (o = a[n], null == o && (o = a[x.camelCase(n)])) : o = a, o\n        }\n    }\n    function W(e, t, n) {\n        if (x.acceptData(e)) {\n            var r, i, o = e.nodeType, a = o ? x.cache : e, s = o ? e[x.expando] : x.expando;\n            if (a[s]) {\n                if (t && (r = n ? a[s] : a[s].data)) {\n                    x.isArray(t) ? t = t.concat(x.map(t, x.camelCase)) : t in r ? t = [t] : (t = x.camelCase(t), t = t in r ? [t] : t.split(\" \")), i = t.length;\n                    while (i--)\n                        delete r[t[i]];\n                    if (n ? !I(r) : !x.isEmptyObject(r))\n                        return\n                }\n                (n || (delete a[s].data, I(a[s]))) && (o ? x.cleanData([e], !0) : x.support.deleteExpando || a != a.window ? delete a[s] : a[s] = null)\n            }\n        }\n    }\n    x.extend({cache: {}, noData: {applet: !0, embed: !0, object: \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"}, hasData: function (e) {\n            return e = e.nodeType ? x.cache[e[x.expando]] : e[x.expando], !!e && !I(e)\n        }, data: function (e, t, n) {\n            return R(e, t, n)\n        }, removeData: function (e, t) {\n            return W(e, t)\n        }, _data: function (e, t, n) {\n            return R(e, t, n, !0)\n        }, _removeData: function (e, t) {\n            return W(e, t, !0)\n        }, acceptData: function (e) {\n            if (e.nodeType && 1 !== e.nodeType && 9 !== e.nodeType)\n                return!1;\n            var t = e.nodeName && x.noData[e.nodeName.toLowerCase()];\n            return!t || t !== !0 && e.getAttribute(\"classid\") === t\n        }}), x.fn.extend({data: function (e, n) {\n            var r, i, o = null, a = 0, s = this[0];\n            if (e === t) {\n                if (this.length && (o = x.data(s), 1 === s.nodeType && !x._data(s, \"parsedAttrs\"))) {\n                    for (r = s.attributes; r.length > a; a++)\n                        i = r[a].name, 0 === i.indexOf(\"data-\") && (i = x.camelCase(i.slice(5)), $(s, i, o[i]));\n                    x._data(s, \"parsedAttrs\", !0)\n                }\n                return o\n            }\n            return\"object\" == typeof e ? this.each(function () {\n                x.data(this, e)\n            }) : arguments.length > 1 ? this.each(function () {\n                x.data(this, e, n)\n            }) : s ? $(s, e, x.data(s, e)) : null\n        }, removeData: function (e) {\n            return this.each(function () {\n                x.removeData(this, e)\n            })\n        }});\n    function $(e, n, r) {\n        if (r === t && 1 === e.nodeType) {\n            var i = \"data-\" + n.replace(P, \"-$1\").toLowerCase();\n            if (r = e.getAttribute(i), \"string\" == typeof r) {\n                try {\n                    r = \"true\" === r ? !0 : \"false\" === r ? !1 : \"null\" === r ? null : +r + \"\" === r ? +r : B.test(r) ? x.parseJSON(r) : r\n                } catch (o) {\n                }\n                x.data(e, n, r)\n            } else\n                r = t\n        }\n        return r\n    }\n    function I(e) {\n        var t;\n        for (t in e)\n            if ((\"data\" !== t || !x.isEmptyObject(e[t])) && \"toJSON\" !== t)\n                return!1;\n        return!0\n    }\n    x.extend({queue: function (e, n, r) {\n            var i;\n            return e ? (n = (n || \"fx\") + \"queue\", i = x._data(e, n), r && (!i || x.isArray(r) ? i = x._data(e, n, x.makeArray(r)) : i.push(r)), i || []) : t\n        }, dequeue: function (e, t) {\n            t = t || \"fx\";\n            var n = x.queue(e, t), r = n.length, i = n.shift(), o = x._queueHooks(e, t), a = function () {\n                x.dequeue(e, t)\n            };\n            \"inprogress\" === i && (i = n.shift(), r--), i && (\"fx\" === t && n.unshift(\"inprogress\"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire()\n        }, _queueHooks: function (e, t) {\n            var n = t + \"queueHooks\";\n            return x._data(e, n) || x._data(e, n, {empty: x.Callbacks(\"once memory\").add(function () {\n                    x._removeData(e, t + \"queue\"), x._removeData(e, n)\n                })})\n        }}), x.fn.extend({queue: function (e, n) {\n            var r = 2;\n            return\"string\" != typeof e && (n = e, e = \"fx\", r--), r > arguments.length ? x.queue(this[0], e) : n === t ? this : this.each(function () {\n                var t = x.queue(this, e, n);\n                x._queueHooks(this, e), \"fx\" === e && \"inprogress\" !== t[0] && x.dequeue(this, e)\n            })\n        }, dequeue: function (e) {\n            return this.each(function () {\n                x.dequeue(this, e)\n            })\n        }, delay: function (e, t) {\n            return e = x.fx ? x.fx.speeds[e] || e : e, t = t || \"fx\", this.queue(t, function (t, n) {\n                var r = setTimeout(t, e);\n                n.stop = function () {\n                    clearTimeout(r)\n                }\n            })\n        }, clearQueue: function (e) {\n            return this.queue(e || \"fx\", [])\n        }, promise: function (e, n) {\n            var r, i = 1, o = x.Deferred(), a = this, s = this.length, l = function () {\n                --i || o.resolveWith(a, [a])\n            };\n            \"string\" != typeof e && (n = e, e = t), e = e || \"fx\";\n            while (s--)\n                r = x._data(a[s], e + \"queueHooks\"), r && r.empty && (i++, r.empty.add(l));\n            return l(), o.promise(n)\n        }});\n    var z, X, U = /[\\t\\r\\n\\f]/g, V = /\\r/g, Y = /^(?:input|select|textarea|button|object)$/i, J = /^(?:a|area)$/i, G = /^(?:checked|selected)$/i, Q = x.support.getSetAttribute, K = x.support.input;\n    x.fn.extend({attr: function (e, t) {\n            return x.access(this, x.attr, e, t, arguments.length > 1)\n        }, removeAttr: function (e) {\n            return this.each(function () {\n                x.removeAttr(this, e)\n            })\n        }, prop: function (e, t) {\n            return x.access(this, x.prop, e, t, arguments.length > 1)\n        }, removeProp: function (e) {\n            return e = x.propFix[e] || e, this.each(function () {\n                try {\n                    this[e] = t, delete this[e]\n                } catch (n) {\n                }\n            })\n        }, addClass: function (e) {\n            var t, n, r, i, o, a = 0, s = this.length, l = \"string\" == typeof e && e;\n            if (x.isFunction(e))\n                return this.each(function (t) {\n                    x(this).addClass(e.call(this, t, this.className))\n                });\n            if (l)\n                for (t = (e || \"\").match(T) || []; s > a; a++)\n                    if (n = this[a], r = 1 === n.nodeType && (n.className ? (\" \" + n.className + \" \").replace(U, \" \") : \" \")) {\n                        o = 0;\n                        while (i = t[o++])\n                            0 > r.indexOf(\" \" + i + \" \") && (r += i + \" \");\n                        n.className = x.trim(r)\n                    }\n            return this\n        }, removeClass: function (e) {\n            var t, n, r, i, o, a = 0, s = this.length, l = 0 === arguments.length || \"string\" == typeof e && e;\n            if (x.isFunction(e))\n                return this.each(function (t) {\n                    x(this).removeClass(e.call(this, t, this.className))\n                });\n            if (l)\n                for (t = (e || \"\").match(T) || []; s > a; a++)\n                    if (n = this[a], r = 1 === n.nodeType && (n.className ? (\" \" + n.className + \" \").replace(U, \" \") : \"\")) {\n                        o = 0;\n                        while (i = t[o++])\n                            while (r.indexOf(\" \" + i + \" \") >= 0)\n                                r = r.replace(\" \" + i + \" \", \" \");\n                        n.className = e ? x.trim(r) : \"\"\n                    }\n            return this\n        }, toggleClass: function (e, t) {\n            var n = typeof e;\n            return\"boolean\" == typeof t && \"string\" === n ? t ? this.addClass(e) : this.removeClass(e) : x.isFunction(e) ? this.each(function (n) {\n                x(this).toggleClass(e.call(this, n, this.className, t), t)\n            }) : this.each(function () {\n                if (\"string\" === n) {\n                    var t, r = 0, o = x(this), a = e.match(T) || [];\n                    while (t = a[r++])\n                        o.hasClass(t) ? o.removeClass(t) : o.addClass(t)\n                } else\n                    (n === i || \"boolean\" === n) && (this.className && x._data(this, \"__className__\", this.className), this.className = this.className || e === !1 ? \"\" : x._data(this, \"__className__\") || \"\")\n            })\n        }, hasClass: function (e) {\n            var t = \" \" + e + \" \", n = 0, r = this.length;\n            for (; r > n; n++)\n                if (1 === this[n].nodeType && (\" \" + this[n].className + \" \").replace(U, \" \").indexOf(t) >= 0)\n                    return!0;\n            return!1\n        }, val: function (e) {\n            var n, r, i, o = this[0];\n            {\n                if (arguments.length)\n                    return i = x.isFunction(e), this.each(function (n) {\n                        var o;\n                        1 === this.nodeType && (o = i ? e.call(this, n, x(this).val()) : e, null == o ? o = \"\" : \"number\" == typeof o ? o += \"\" : x.isArray(o) && (o = x.map(o, function (e) {\n                            return null == e ? \"\" : e + \"\"\n                        })), r = x.valHooks[this.type] || x.valHooks[this.nodeName.toLowerCase()], r && \"set\"in r && r.set(this, o, \"value\") !== t || (this.value = o))\n                    });\n                if (o)\n                    return r = x.valHooks[o.type] || x.valHooks[o.nodeName.toLowerCase()], r && \"get\"in r && (n = r.get(o, \"value\")) !== t ? n : (n = o.value, \"string\" == typeof n ? n.replace(V, \"\") : null == n ? \"\" : n)\n            }\n        }}), x.extend({valHooks: {option: {get: function (e) {\n                    var t = x.find.attr(e, \"value\");\n                    return null != t ? t : e.text\n                }}, select: {get: function (e) {\n                    var t, n, r = e.options, i = e.selectedIndex, o = \"select-one\" === e.type || 0 > i, a = o ? null : [], s = o ? i + 1 : r.length, l = 0 > i ? s : o ? i : 0;\n                    for (; s > l; l++)\n                        if (n = r[l], !(!n.selected && l !== i || (x.support.optDisabled ? n.disabled : null !== n.getAttribute(\"disabled\")) || n.parentNode.disabled && x.nodeName(n.parentNode, \"optgroup\"))) {\n                            if (t = x(n).val(), o)\n                                return t;\n                            a.push(t)\n                        }\n                    return a\n                }, set: function (e, t) {\n                    var n, r, i = e.options, o = x.makeArray(t), a = i.length;\n                    while (a--)\n                        r = i[a], (r.selected = x.inArray(x(r).val(), o) >= 0) && (n = !0);\n                    return n || (e.selectedIndex = -1), o\n                }}}, attr: function (e, n, r) {\n            var o, a, s = e.nodeType;\n            if (e && 3 !== s && 8 !== s && 2 !== s)\n                return typeof e.getAttribute === i ? x.prop(e, n, r) : (1 === s && x.isXMLDoc(e) || (n = n.toLowerCase(), o = x.attrHooks[n] || (x.expr.match.bool.test(n) ? X : z)), r === t ? o && \"get\"in o && null !== (a = o.get(e, n)) ? a : (a = x.find.attr(e, n), null == a ? t : a) : null !== r ? o && \"set\"in o && (a = o.set(e, r, n)) !== t ? a : (e.setAttribute(n, r + \"\"), r) : (x.removeAttr(e, n), t))\n        }, removeAttr: function (e, t) {\n            var n, r, i = 0, o = t && t.match(T);\n            if (o && 1 === e.nodeType)\n                while (n = o[i++])\n                    r = x.propFix[n] || n, x.expr.match.bool.test(n) ? K && Q || !G.test(n) ? e[r] = !1 : e[x.camelCase(\"default-\" + n)] = e[r] = !1 : x.attr(e, n, \"\"), e.removeAttribute(Q ? n : r)\n        }, attrHooks: {type: {set: function (e, t) {\n                    if (!x.support.radioValue && \"radio\" === t && x.nodeName(e, \"input\")) {\n                        var n = e.value;\n                        return e.setAttribute(\"type\", t), n && (e.value = n), t\n                    }\n                }}}, propFix: {\"for\": \"htmlFor\", \"class\": \"className\"}, prop: function (e, n, r) {\n            var i, o, a, s = e.nodeType;\n            if (e && 3 !== s && 8 !== s && 2 !== s)\n                return a = 1 !== s || !x.isXMLDoc(e), a && (n = x.propFix[n] || n, o = x.propHooks[n]), r !== t ? o && \"set\"in o && (i = o.set(e, r, n)) !== t ? i : e[n] = r : o && \"get\"in o && null !== (i = o.get(e, n)) ? i : e[n]\n        }, propHooks: {tabIndex: {get: function (e) {\n                    var t = x.find.attr(e, \"tabindex\");\n                    return t ? parseInt(t, 10) : Y.test(e.nodeName) || J.test(e.nodeName) && e.href ? 0 : -1\n                }}}}), X = {set: function (e, t, n) {\n            return t === !1 ? x.removeAttr(e, n) : K && Q || !G.test(n) ? e.setAttribute(!Q && x.propFix[n] || n, n) : e[x.camelCase(\"default-\" + n)] = e[n] = !0, n\n        }}, x.each(x.expr.match.bool.source.match(/\\w+/g), function (e, n) {\n        var r = x.expr.attrHandle[n] || x.find.attr;\n        x.expr.attrHandle[n] = K && Q || !G.test(n) ? function (e, n, i) {\n            var o = x.expr.attrHandle[n], a = i ? t : (x.expr.attrHandle[n] = t) != r(e, n, i) ? n.toLowerCase() : null;\n            return x.expr.attrHandle[n] = o, a\n        } : function (e, n, r) {\n            return r ? t : e[x.camelCase(\"default-\" + n)] ? n.toLowerCase() : null\n        }\n    }), K && Q || (x.attrHooks.value = {set: function (e, n, r) {\n            return x.nodeName(e, \"input\") ? (e.defaultValue = n, t) : z && z.set(e, n, r)\n        }}), Q || (z = {set: function (e, n, r) {\n            var i = e.getAttributeNode(r);\n            return i || e.setAttributeNode(i = e.ownerDocument.createAttribute(r)), i.value = n += \"\", \"value\" === r || n === e.getAttribute(r) ? n : t\n        }}, x.expr.attrHandle.id = x.expr.attrHandle.name = x.expr.attrHandle.coords = function (e, n, r) {\n        var i;\n        return r ? t : (i = e.getAttributeNode(n)) && \"\" !== i.value ? i.value : null\n    }, x.valHooks.button = {get: function (e, n) {\n            var r = e.getAttributeNode(n);\n            return r && r.specified ? r.value : t\n        }, set: z.set}, x.attrHooks.contenteditable = {set: function (e, t, n) {\n            z.set(e, \"\" === t ? !1 : t, n)\n        }}, x.each([\"width\", \"height\"], function (e, n) {\n        x.attrHooks[n] = {set: function (e, r) {\n                return\"\" === r ? (e.setAttribute(n, \"auto\"), r) : t\n            }}\n    })), x.support.hrefNormalized || x.each([\"href\", \"src\"], function (e, t) {\n        x.propHooks[t] = {get: function (e) {\n                return e.getAttribute(t, 4)\n            }}\n    }), x.support.style || (x.attrHooks.style = {get: function (e) {\n            return e.style.cssText || t\n        }, set: function (e, t) {\n            return e.style.cssText = t + \"\"\n        }}), x.support.optSelected || (x.propHooks.selected = {get: function (e) {\n            var t = e.parentNode;\n            return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null\n        }}), x.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n        x.propFix[this.toLowerCase()] = this\n    }), x.support.enctype || (x.propFix.enctype = \"encoding\"), x.each([\"radio\", \"checkbox\"], function () {\n        x.valHooks[this] = {set: function (e, n) {\n                return x.isArray(n) ? e.checked = x.inArray(x(e).val(), n) >= 0 : t\n            }}, x.support.checkOn || (x.valHooks[this].get = function (e) {\n            return null === e.getAttribute(\"value\") ? \"on\" : e.value\n        })\n    });\n    var Z = /^(?:input|select|textarea)$/i, et = /^key/, tt = /^(?:mouse|contextmenu)|click/, nt = /^(?:focusinfocus|focusoutblur)$/, rt = /^([^.]*)(?:\\.(.+)|)$/;\n    function it() {\n        return!0\n    }\n    function ot() {\n        return!1\n    }\n    function at() {\n        try {\n            return a.activeElement\n        } catch (e) {\n        }\n    }\n    x.event = {global: {}, add: function (e, n, r, o, a) {\n            var s, l, u, c, p, f, d, h, g, m, y, v = x._data(e);\n            if (v) {\n                r.handler && (c = r, r = c.handler, a = c.selector), r.guid || (r.guid = x.guid++), (l = v.events) || (l = v.events = {}), (f = v.handle) || (f = v.handle = function (e) {\n                    return typeof x === i || e && x.event.triggered === e.type ? t : x.event.dispatch.apply(f.elem, arguments)\n                }, f.elem = e), n = (n || \"\").match(T) || [\"\"], u = n.length;\n                while (u--)\n                    s = rt.exec(n[u]) || [], g = y = s[1], m = (s[2] || \"\").split(\".\").sort(), g && (p = x.event.special[g] || {}, g = (a ? p.delegateType : p.bindType) || g, p = x.event.special[g] || {}, d = x.extend({type: g, origType: y, data: o, handler: r, guid: r.guid, selector: a, needsContext: a && x.expr.match.needsContext.test(a), namespace: m.join(\".\")}, c), (h = l[g]) || (h = l[g] = [], h.delegateCount = 0, p.setup && p.setup.call(e, o, m, f) !== !1 || (e.addEventListener ? e.addEventListener(g, f, !1) : e.attachEvent && e.attachEvent(\"on\" + g, f))), p.add && (p.add.call(e, d), d.handler.guid || (d.handler.guid = r.guid)), a ? h.splice(h.delegateCount++, 0, d) : h.push(d), x.event.global[g] = !0);\n                e = null\n            }\n        }, remove: function (e, t, n, r, i) {\n            var o, a, s, l, u, c, p, f, d, h, g, m = x.hasData(e) && x._data(e);\n            if (m && (c = m.events)) {\n                t = (t || \"\").match(T) || [\"\"], u = t.length;\n                while (u--)\n                    if (s = rt.exec(t[u]) || [], d = g = s[1], h = (s[2] || \"\").split(\".\").sort(), d) {\n                        p = x.event.special[d] || {}, d = (r ? p.delegateType : p.bindType) || d, f = c[d] || [], s = s[2] && RegExp(\"(^|\\\\.)\" + h.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), l = o = f.length;\n                        while (o--)\n                            a = f[o], !i && g !== a.origType || n && n.guid !== a.guid || s && !s.test(a.namespace) || r && r !== a.selector && (\"**\" !== r || !a.selector) || (f.splice(o, 1), a.selector && f.delegateCount--, p.remove && p.remove.call(e, a));\n                        l && !f.length && (p.teardown && p.teardown.call(e, h, m.handle) !== !1 || x.removeEvent(e, d, m.handle), delete c[d])\n                    } else\n                        for (d in c)\n                            x.event.remove(e, d + t[u], n, r, !0);\n                x.isEmptyObject(c) && (delete m.handle, x._removeData(e, \"events\"))\n            }\n        }, trigger: function (n, r, i, o) {\n            var s, l, u, c, p, f, d, h = [i || a], g = v.call(n, \"type\") ? n.type : n, m = v.call(n, \"namespace\") ? n.namespace.split(\".\") : [];\n            if (u = f = i = i || a, 3 !== i.nodeType && 8 !== i.nodeType && !nt.test(g + x.event.triggered) && (g.indexOf(\".\") >= 0 && (m = g.split(\".\"), g = m.shift(), m.sort()), l = 0 > g.indexOf(\":\") && \"on\" + g, n = n[x.expando] ? n : new x.Event(g, \"object\" == typeof n && n), n.isTrigger = o ? 2 : 3, n.namespace = m.join(\".\"), n.namespace_re = n.namespace ? RegExp(\"(^|\\\\.)\" + m.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, n.result = t, n.target || (n.target = i), r = null == r ? [n] : x.makeArray(r, [n]), p = x.event.special[g] || {}, o || !p.trigger || p.trigger.apply(i, r) !== !1)) {\n                if (!o && !p.noBubble && !x.isWindow(i)) {\n                    for (c = p.delegateType || g, nt.test(c + g) || (u = u.parentNode); u; u = u.parentNode)\n                        h.push(u), f = u;\n                    f === (i.ownerDocument || a) && h.push(f.defaultView || f.parentWindow || e)\n                }\n                d = 0;\n                while ((u = h[d++]) && !n.isPropagationStopped())\n                    n.type = d > 1 ? c : p.bindType || g, s = (x._data(u, \"events\") || {})[n.type] && x._data(u, \"handle\"), s && s.apply(u, r), s = l && u[l], s && x.acceptData(u) && s.apply && s.apply(u, r) === !1 && n.preventDefault();\n                if (n.type = g, !o && !n.isDefaultPrevented() && (!p._default || p._default.apply(h.pop(), r) === !1) && x.acceptData(i) && l && i[g] && !x.isWindow(i)) {\n                    f = i[l], f && (i[l] = null), x.event.triggered = g;\n                    try {\n                        i[g]()\n                    } catch (y) {\n                    }\n                    x.event.triggered = t, f && (i[l] = f)\n                }\n                return n.result\n            }\n        }, dispatch: function (e) {\n            e = x.event.fix(e);\n            var n, r, i, o, a, s = [], l = g.call(arguments), u = (x._data(this, \"events\") || {})[e.type] || [], c = x.event.special[e.type] || {};\n            if (l[0] = e, e.delegateTarget = this, !c.preDispatch || c.preDispatch.call(this, e) !== !1) {\n                s = x.event.handlers.call(this, e, u), n = 0;\n                while ((o = s[n++]) && !e.isPropagationStopped()) {\n                    e.currentTarget = o.elem, a = 0;\n                    while ((i = o.handlers[a++]) && !e.isImmediatePropagationStopped())\n                        (!e.namespace_re || e.namespace_re.test(i.namespace)) && (e.handleObj = i, e.data = i.data, r = ((x.event.special[i.origType] || {}).handle || i.handler).apply(o.elem, l), r !== t && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()))\n                }\n                return c.postDispatch && c.postDispatch.call(this, e), e.result\n            }\n        }, handlers: function (e, n) {\n            var r, i, o, a, s = [], l = n.delegateCount, u = e.target;\n            if (l && u.nodeType && (!e.button || \"click\" !== e.type))\n                for (; u != this; u = u.parentNode || this)\n                    if (1 === u.nodeType && (u.disabled !== !0 || \"click\" !== e.type)) {\n                        for (o = [], a = 0; l > a; a++)\n                            i = n[a], r = i.selector + \" \", o[r] === t && (o[r] = i.needsContext ? x(r, this).index(u) >= 0 : x.find(r, this, null, [u]).length), o[r] && o.push(i);\n                        o.length && s.push({elem: u, handlers: o})\n                    }\n            return n.length > l && s.push({elem: this, handlers: n.slice(l)}), s\n        }, fix: function (e) {\n            if (e[x.expando])\n                return e;\n            var t, n, r, i = e.type, o = e, s = this.fixHooks[i];\n            s || (this.fixHooks[i] = s = tt.test(i) ? this.mouseHooks : et.test(i) ? this.keyHooks : {}), r = s.props ? this.props.concat(s.props) : this.props, e = new x.Event(o), t = r.length;\n            while (t--)\n                n = r[t], e[n] = o[n];\n            return e.target || (e.target = o.srcElement || a), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !!e.metaKey, s.filter ? s.filter(e, o) : e\n        }, props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"), fixHooks: {}, keyHooks: {props: \"char charCode key keyCode\".split(\" \"), filter: function (e, t) {\n                return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e\n            }}, mouseHooks: {props: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"), filter: function (e, n) {\n                var r, i, o, s = n.button, l = n.fromElement;\n                return null == e.pageX && null != n.clientX && (i = e.target.ownerDocument || a, o = i.documentElement, r = i.body, e.pageX = n.clientX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0), e.pageY = n.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0)), !e.relatedTarget && l && (e.relatedTarget = l === e.target ? n.toElement : l), e.which || s === t || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0), e\n            }}, special: {load: {noBubble: !0}, focus: {trigger: function () {\n                    if (this !== at() && this.focus)\n                        try {\n                            return this.focus(), !1\n                        } catch (e) {\n                        }\n                }, delegateType: \"focusin\"}, blur: {trigger: function () {\n                    return this === at() && this.blur ? (this.blur(), !1) : t\n                }, delegateType: \"focusout\"}, click: {trigger: function () {\n                    return x.nodeName(this, \"input\") && \"checkbox\" === this.type && this.click ? (this.click(), !1) : t\n                }, _default: function (e) {\n                    return x.nodeName(e.target, \"a\")\n                }}, beforeunload: {postDispatch: function (e) {\n                    e.result !== t && (e.originalEvent.returnValue = e.result)\n                }}}, simulate: function (e, t, n, r) {\n            var i = x.extend(new x.Event, n, {type: e, isSimulated: !0, originalEvent: {}});\n            r ? x.event.trigger(i, null, t) : x.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault()\n        }}, x.removeEvent = a.removeEventListener ? function (e, t, n) {\n        e.removeEventListener && e.removeEventListener(t, n, !1)\n    } : function (e, t, n) {\n        var r = \"on\" + t;\n        e.detachEvent && (typeof e[r] === i && (e[r] = null), e.detachEvent(r, n))\n    }, x.Event = function (e, n) {\n        return this instanceof x.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e.getPreventDefault && e.getPreventDefault() ? it : ot) : this.type = e, n && x.extend(this, n), this.timeStamp = e && e.timeStamp || x.now(), this[x.expando] = !0, t) : new x.Event(e, n)\n    }, x.Event.prototype = {isDefaultPrevented: ot, isPropagationStopped: ot, isImmediatePropagationStopped: ot, preventDefault: function () {\n            var e = this.originalEvent;\n            this.isDefaultPrevented = it, e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1)\n        }, stopPropagation: function () {\n            var e = this.originalEvent;\n            this.isPropagationStopped = it, e && (e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0)\n        }, stopImmediatePropagation: function () {\n            this.isImmediatePropagationStopped = it, this.stopPropagation()\n        }}, x.each({mouseenter: \"mouseover\", mouseleave: \"mouseout\"}, function (e, t) {\n        x.event.special[e] = {delegateType: t, bindType: t, handle: function (e) {\n                var n, r = this, i = e.relatedTarget, o = e.handleObj;\n                return(!i || i !== r && !x.contains(r, i)) && (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n\n            }}\n    }), x.support.submitBubbles || (x.event.special.submit = {setup: function () {\n            return x.nodeName(this, \"form\") ? !1 : (x.event.add(this, \"click._submit keypress._submit\", function (e) {\n                var n = e.target, r = x.nodeName(n, \"input\") || x.nodeName(n, \"button\") ? n.form : t;\n                r && !x._data(r, \"submitBubbles\") && (x.event.add(r, \"submit._submit\", function (e) {\n                    e._submit_bubble = !0\n                }), x._data(r, \"submitBubbles\", !0))\n            }), t)\n        }, postDispatch: function (e) {\n            e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger && x.event.simulate(\"submit\", this.parentNode, e, !0))\n        }, teardown: function () {\n            return x.nodeName(this, \"form\") ? !1 : (x.event.remove(this, \"._submit\"), t)\n        }}), x.support.changeBubbles || (x.event.special.change = {setup: function () {\n            return Z.test(this.nodeName) ? ((\"checkbox\" === this.type || \"radio\" === this.type) && (x.event.add(this, \"propertychange._change\", function (e) {\n                \"checked\" === e.originalEvent.propertyName && (this._just_changed = !0)\n            }), x.event.add(this, \"click._change\", function (e) {\n                this._just_changed && !e.isTrigger && (this._just_changed = !1), x.event.simulate(\"change\", this, e, !0)\n            })), !1) : (x.event.add(this, \"beforeactivate._change\", function (e) {\n                var t = e.target;\n                Z.test(t.nodeName) && !x._data(t, \"changeBubbles\") && (x.event.add(t, \"change._change\", function (e) {\n                    !this.parentNode || e.isSimulated || e.isTrigger || x.event.simulate(\"change\", this.parentNode, e, !0)\n                }), x._data(t, \"changeBubbles\", !0))\n            }), t)\n        }, handle: function (e) {\n            var n = e.target;\n            return this !== n || e.isSimulated || e.isTrigger || \"radio\" !== n.type && \"checkbox\" !== n.type ? e.handleObj.handler.apply(this, arguments) : t\n        }, teardown: function () {\n            return x.event.remove(this, \"._change\"), !Z.test(this.nodeName)\n        }}), x.support.focusinBubbles || x.each({focus: \"focusin\", blur: \"focusout\"}, function (e, t) {\n        var n = 0, r = function (e) {\n            x.event.simulate(t, e.target, x.event.fix(e), !0)\n        };\n        x.event.special[t] = {setup: function () {\n                0 === n++ && a.addEventListener(e, r, !0)\n            }, teardown: function () {\n                0 === --n && a.removeEventListener(e, r, !0)\n            }}\n    }), x.fn.extend({on: function (e, n, r, i, o) {\n            var a, s;\n            if (\"object\" == typeof e) {\n                \"string\" != typeof n && (r = r || n, n = t);\n                for (a in e)\n                    this.on(a, n, r, e[a], o);\n                return this\n            }\n            if (null == r && null == i ? (i = n, r = n = t) : null == i && (\"string\" == typeof n ? (i = r, r = t) : (i = r, r = n, n = t)), i === !1)\n                i = ot;\n            else if (!i)\n                return this;\n            return 1 === o && (s = i, i = function (e) {\n                return x().off(e), s.apply(this, arguments)\n            }, i.guid = s.guid || (s.guid = x.guid++)), this.each(function () {\n                x.event.add(this, e, i, r, n)\n            })\n        }, one: function (e, t, n, r) {\n            return this.on(e, t, n, r, 1)\n        }, off: function (e, n, r) {\n            var i, o;\n            if (e && e.preventDefault && e.handleObj)\n                return i = e.handleObj, x(e.delegateTarget).off(i.namespace ? i.origType + \".\" + i.namespace : i.origType, i.selector, i.handler), this;\n            if (\"object\" == typeof e) {\n                for (o in e)\n                    this.off(o, n, e[o]);\n                return this\n            }\n            return(n === !1 || \"function\" == typeof n) && (r = n, n = t), r === !1 && (r = ot), this.each(function () {\n                x.event.remove(this, e, r, n)\n            })\n        }, trigger: function (e, t) {\n            return this.each(function () {\n                x.event.trigger(e, t, this)\n            })\n        }, triggerHandler: function (e, n) {\n            var r = this[0];\n            return r ? x.event.trigger(e, n, r, !0) : t\n        }});\n    var st = /^.[^:#\\[\\.,]*$/, lt = /^(?:parents|prev(?:Until|All))/, ut = x.expr.match.needsContext, ct = {children: !0, contents: !0, next: !0, prev: !0};\n    x.fn.extend({find: function (e) {\n            var t, n = [], r = this, i = r.length;\n            if (\"string\" != typeof e)\n                return this.pushStack(x(e).filter(function () {\n                    for (t = 0; i > t; t++)\n                        if (x.contains(r[t], this))\n                            return!0\n                }));\n            for (t = 0; i > t; t++)\n                x.find(e, r[t], n);\n            return n = this.pushStack(i > 1 ? x.unique(n) : n), n.selector = this.selector ? this.selector + \" \" + e : e, n\n        }, has: function (e) {\n            var t, n = x(e, this), r = n.length;\n            return this.filter(function () {\n                for (t = 0; r > t; t++)\n                    if (x.contains(this, n[t]))\n                        return!0\n            })\n        }, not: function (e) {\n            return this.pushStack(ft(this, e || [], !0))\n        }, filter: function (e) {\n            return this.pushStack(ft(this, e || [], !1))\n        }, is: function (e) {\n            return!!ft(this, \"string\" == typeof e && ut.test(e) ? x(e) : e || [], !1).length\n        }, closest: function (e, t) {\n            var n, r = 0, i = this.length, o = [], a = ut.test(e) || \"string\" != typeof e ? x(e, t || this.context) : 0;\n            for (; i > r; r++)\n                for (n = this[r]; n && n !== t; n = n.parentNode)\n                    if (11 > n.nodeType && (a ? a.index(n) > -1 : 1 === n.nodeType && x.find.matchesSelector(n, e))) {\n                        n = o.push(n);\n                        break\n                    }\n            return this.pushStack(o.length > 1 ? x.unique(o) : o)\n        }, index: function (e) {\n            return e ? \"string\" == typeof e ? x.inArray(this[0], x(e)) : x.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1\n        }, add: function (e, t) {\n            var n = \"string\" == typeof e ? x(e, t) : x.makeArray(e && e.nodeType ? [e] : e), r = x.merge(this.get(), n);\n            return this.pushStack(x.unique(r))\n        }, addBack: function (e) {\n            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))\n        }});\n    function pt(e, t) {\n        do\n            e = e[t];\n        while (e && 1 !== e.nodeType);\n        return e\n    }\n    x.each({parent: function (e) {\n            var t = e.parentNode;\n            return t && 11 !== t.nodeType ? t : null\n        }, parents: function (e) {\n            return x.dir(e, \"parentNode\")\n        }, parentsUntil: function (e, t, n) {\n            return x.dir(e, \"parentNode\", n)\n        }, next: function (e) {\n            return pt(e, \"nextSibling\")\n        }, prev: function (e) {\n            return pt(e, \"previousSibling\")\n        }, nextAll: function (e) {\n            return x.dir(e, \"nextSibling\")\n        }, prevAll: function (e) {\n            return x.dir(e, \"previousSibling\")\n        }, nextUntil: function (e, t, n) {\n            return x.dir(e, \"nextSibling\", n)\n        }, prevUntil: function (e, t, n) {\n            return x.dir(e, \"previousSibling\", n)\n        }, siblings: function (e) {\n            return x.sibling((e.parentNode || {}).firstChild, e)\n        }, children: function (e) {\n            return x.sibling(e.firstChild)\n        }, contents: function (e) {\n            return x.nodeName(e, \"iframe\") ? e.contentDocument || e.contentWindow.document : x.merge([], e.childNodes)\n        }}, function (e, t) {\n        x.fn[e] = function (n, r) {\n            var i = x.map(this, t, n);\n            return\"Until\" !== e.slice(-5) && (r = n), r && \"string\" == typeof r && (i = x.filter(r, i)), this.length > 1 && (ct[e] || (i = x.unique(i)), lt.test(e) && (i = i.reverse())), this.pushStack(i)\n        }\n    }), x.extend({filter: function (e, t, n) {\n            var r = t[0];\n            return n && (e = \":not(\" + e + \")\"), 1 === t.length && 1 === r.nodeType ? x.find.matchesSelector(r, e) ? [r] : [] : x.find.matches(e, x.grep(t, function (e) {\n                return 1 === e.nodeType\n            }))\n        }, dir: function (e, n, r) {\n            var i = [], o = e[n];\n            while (o && 9 !== o.nodeType && (r === t || 1 !== o.nodeType || !x(o).is(r)))\n                1 === o.nodeType && i.push(o), o = o[n];\n            return i\n        }, sibling: function (e, t) {\n            var n = [];\n            for (; e; e = e.nextSibling)\n                1 === e.nodeType && e !== t && n.push(e);\n            return n\n        }});\n    function ft(e, t, n) {\n        if (x.isFunction(t))\n            return x.grep(e, function (e, r) {\n                return!!t.call(e, r, e) !== n\n            });\n        if (t.nodeType)\n            return x.grep(e, function (e) {\n                return e === t !== n\n            });\n        if (\"string\" == typeof t) {\n            if (st.test(t))\n                return x.filter(t, e, n);\n            t = x.filter(t, e)\n        }\n        return x.grep(e, function (e) {\n            return x.inArray(e, t) >= 0 !== n\n        })\n    }\n    function dt(e) {\n        var t = ht.split(\"|\"), n = e.createDocumentFragment();\n        if (n.createElement)\n            while (t.length)\n                n.createElement(t.pop());\n        return n\n    }\n    var ht = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\", gt = / jQuery\\d+=\"(?:null|\\d+)\"/g, mt = RegExp(\"<(?:\" + ht + \")[\\\\s/>]\", \"i\"), yt = /^\\s+/, vt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi, bt = /<([\\w:]+)/, xt = /<tbody/i, wt = /<|&#?\\w+;/, Tt = /<(?:script|style|link)/i, Ct = /^(?:checkbox|radio)$/i, Nt = /checked\\s*(?:[^=]|=\\s*.checked.)/i, kt = /^$|\\/(?:java|ecma)script/i, Et = /^true\\/(.*)/, St = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g, At = {option: [1, \"<select multiple='multiple'>\", \"</select>\"], legend: [1, \"<fieldset>\", \"</fieldset>\"], area: [1, \"<map>\", \"</map>\"], param: [1, \"<object>\", \"</object>\"], thead: [1, \"<table>\", \"</table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], col: [2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: x.support.htmlSerialize ? [0, \"\", \"\"] : [1, \"X<div>\", \"</div>\"]}, jt = dt(a), Dt = jt.appendChild(a.createElement(\"div\"));\n    At.optgroup = At.option, At.tbody = At.tfoot = At.colgroup = At.caption = At.thead, At.th = At.td, x.fn.extend({text: function (e) {\n            return x.access(this, function (e) {\n                return e === t ? x.text(this) : this.empty().append((this[0] && this[0].ownerDocument || a).createTextNode(e))\n            }, null, e, arguments.length)\n        }, append: function () {\n            return this.domManip(arguments, function (e) {\n                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n                    var t = Lt(this, e);\n                    t.appendChild(e)\n                }\n            })\n        }, prepend: function () {\n            return this.domManip(arguments, function (e) {\n                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n                    var t = Lt(this, e);\n                    t.insertBefore(e, t.firstChild)\n                }\n            })\n        }, before: function () {\n            return this.domManip(arguments, function (e) {\n                this.parentNode && this.parentNode.insertBefore(e, this)\n            })\n        }, after: function () {\n            return this.domManip(arguments, function (e) {\n                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)\n            })\n        }, remove: function (e, t) {\n            var n, r = e ? x.filter(e, this) : this, i = 0;\n            for (; null != (n = r[i]); i++)\n                t || 1 !== n.nodeType || x.cleanData(Ft(n)), n.parentNode && (t && x.contains(n.ownerDocument, n) && _t(Ft(n, \"script\")), n.parentNode.removeChild(n));\n            return this\n        }, empty: function () {\n            var e, t = 0;\n            for (; null != (e = this[t]); t++) {\n                1 === e.nodeType && x.cleanData(Ft(e, !1));\n                while (e.firstChild)\n                    e.removeChild(e.firstChild);\n                e.options && x.nodeName(e, \"select\") && (e.options.length = 0)\n            }\n            return this\n        }, clone: function (e, t) {\n            return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function () {\n                return x.clone(this, e, t)\n            })\n        }, html: function (e) {\n            return x.access(this, function (e) {\n                var n = this[0] || {}, r = 0, i = this.length;\n                if (e === t)\n                    return 1 === n.nodeType ? n.innerHTML.replace(gt, \"\") : t;\n                if (!(\"string\" != typeof e || Tt.test(e) || !x.support.htmlSerialize && mt.test(e) || !x.support.leadingWhitespace && yt.test(e) || At[(bt.exec(e) || [\"\", \"\"])[1].toLowerCase()])) {\n                    e = e.replace(vt, \"<$1></$2>\");\n                    try {\n                        for (; i > r; r++)\n                            n = this[r] || {}, 1 === n.nodeType && (x.cleanData(Ft(n, !1)), n.innerHTML = e);\n                        n = 0\n                    } catch (o) {\n                    }\n                }\n                n && this.empty().append(e)\n            }, null, e, arguments.length)\n        }, replaceWith: function () {\n            var e = x.map(this, function (e) {\n                return[e.nextSibling, e.parentNode]\n            }), t = 0;\n            return this.domManip(arguments, function (n) {\n                var r = e[t++], i = e[t++];\n                i && (r && r.parentNode !== i && (r = this.nextSibling), x(this).remove(), i.insertBefore(n, r))\n            }, !0), t ? this : this.remove()\n        }, detach: function (e) {\n            return this.remove(e, !0)\n        }, domManip: function (e, t, n) {\n            e = d.apply([], e);\n            var r, i, o, a, s, l, u = 0, c = this.length, p = this, f = c - 1, h = e[0], g = x.isFunction(h);\n            if (g || !(1 >= c || \"string\" != typeof h || x.support.checkClone) && Nt.test(h))\n                return this.each(function (r) {\n                    var i = p.eq(r);\n                    g && (e[0] = h.call(this, r, i.html())), i.domManip(e, t, n)\n                });\n            if (c && (l = x.buildFragment(e, this[0].ownerDocument, !1, !n && this), r = l.firstChild, 1 === l.childNodes.length && (l = r), r)) {\n                for (a = x.map(Ft(l, \"script\"), Ht), o = a.length; c > u; u++)\n                    i = l, u !== f && (i = x.clone(i, !0, !0), o && x.merge(a, Ft(i, \"script\"))), t.call(this[u], i, u);\n                if (o)\n                    for (s = a[a.length - 1].ownerDocument, x.map(a, qt), u = 0; o > u; u++)\n                        i = a[u], kt.test(i.type || \"\") && !x._data(i, \"globalEval\") && x.contains(s, i) && (i.src ? x._evalUrl(i.src) : x.globalEval((i.text || i.textContent || i.innerHTML || \"\").replace(St, \"\")));\n                l = r = null\n            }\n            return this\n        }});\n    function Lt(e, t) {\n        return x.nodeName(e, \"table\") && x.nodeName(1 === t.nodeType ? t : t.firstChild, \"tr\") ? e.getElementsByTagName(\"tbody\")[0] || e.appendChild(e.ownerDocument.createElement(\"tbody\")) : e\n    }\n    function Ht(e) {\n        return e.type = (null !== x.find.attr(e, \"type\")) + \"/\" + e.type, e\n    }\n    function qt(e) {\n        var t = Et.exec(e.type);\n        return t ? e.type = t[1] : e.removeAttribute(\"type\"), e\n    }\n    function _t(e, t) {\n        var n, r = 0;\n        for (; null != (n = e[r]); r++)\n            x._data(n, \"globalEval\", !t || x._data(t[r], \"globalEval\"))\n    }\n    function Mt(e, t) {\n        if (1 === t.nodeType && x.hasData(e)) {\n            var n, r, i, o = x._data(e), a = x._data(t, o), s = o.events;\n            if (s) {\n                delete a.handle, a.events = {};\n                for (n in s)\n                    for (r = 0, i = s[n].length; i > r; r++)\n                        x.event.add(t, n, s[n][r])\n            }\n            a.data && (a.data = x.extend({}, a.data))\n        }\n    }\n    function Ot(e, t) {\n        var n, r, i;\n        if (1 === t.nodeType) {\n            if (n = t.nodeName.toLowerCase(), !x.support.noCloneEvent && t[x.expando]) {\n                i = x._data(t);\n                for (r in i.events)\n                    x.removeEvent(t, r, i.handle);\n                t.removeAttribute(x.expando)\n            }\n            \"script\" === n && t.text !== e.text ? (Ht(t).text = e.text, qt(t)) : \"object\" === n ? (t.parentNode && (t.outerHTML = e.outerHTML), x.support.html5Clone && e.innerHTML && !x.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : \"input\" === n && Ct.test(e.type) ? (t.defaultChecked = t.checked = e.checked, t.value !== e.value && (t.value = e.value)) : \"option\" === n ? t.defaultSelected = t.selected = e.defaultSelected : (\"input\" === n || \"textarea\" === n) && (t.defaultValue = e.defaultValue)\n        }\n    }\n    x.each({appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\"}, function (e, t) {\n        x.fn[e] = function (e) {\n            var n, r = 0, i = [], o = x(e), a = o.length - 1;\n            for (; a >= r; r++)\n                n = r === a ? this : this.clone(!0), x(o[r])[t](n), h.apply(i, n.get());\n            return this.pushStack(i)\n        }\n    });\n    function Ft(e, n) {\n        var r, o, a = 0, s = typeof e.getElementsByTagName !== i ? e.getElementsByTagName(n || \"*\") : typeof e.querySelectorAll !== i ? e.querySelectorAll(n || \"*\") : t;\n        if (!s)\n            for (s = [], r = e.childNodes || e; null != (o = r[a]); a++)\n                !n || x.nodeName(o, n) ? s.push(o) : x.merge(s, Ft(o, n));\n        return n === t || n && x.nodeName(e, n) ? x.merge([e], s) : s\n    }\n    function Bt(e) {\n        Ct.test(e.type) && (e.defaultChecked = e.checked)\n    }\n    x.extend({clone: function (e, t, n) {\n            var r, i, o, a, s, l = x.contains(e.ownerDocument, e);\n            if (x.support.html5Clone || x.isXMLDoc(e) || !mt.test(\"<\" + e.nodeName + \">\") ? o = e.cloneNode(!0) : (Dt.innerHTML = e.outerHTML, Dt.removeChild(o = Dt.firstChild)), !(x.support.noCloneEvent && x.support.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || x.isXMLDoc(e)))\n                for (r = Ft(o), s = Ft(e), a = 0; null != (i = s[a]); ++a)\n                    r[a] && Ot(i, r[a]);\n            if (t)\n                if (n)\n                    for (s = s || Ft(e), r = r || Ft(o), a = 0; null != (i = s[a]); a++)\n                        Mt(i, r[a]);\n                else\n                    Mt(e, o);\n            return r = Ft(o, \"script\"), r.length > 0 && _t(r, !l && Ft(e, \"script\")), r = s = i = null, o\n        }, buildFragment: function (e, t, n, r) {\n            var i, o, a, s, l, u, c, p = e.length, f = dt(t), d = [], h = 0;\n            for (; p > h; h++)\n                if (o = e[h], o || 0 === o)\n                    if (\"object\" === x.type(o))\n                        x.merge(d, o.nodeType ? [o] : o);\n                    else if (wt.test(o)) {\n                        s = s || f.appendChild(t.createElement(\"div\")), l = (bt.exec(o) || [\"\", \"\"])[1].toLowerCase(), c = At[l] || At._default, s.innerHTML = c[1] + o.replace(vt, \"<$1></$2>\") + c[2], i = c[0];\n                        while (i--)\n                            s = s.lastChild;\n                        if (!x.support.leadingWhitespace && yt.test(o) && d.push(t.createTextNode(yt.exec(o)[0])), !x.support.tbody) {\n                            o = \"table\" !== l || xt.test(o) ? \"<table>\" !== c[1] || xt.test(o) ? 0 : s : s.firstChild, i = o && o.childNodes.length;\n                            while (i--)\n                                x.nodeName(u = o.childNodes[i], \"tbody\") && !u.childNodes.length && o.removeChild(u)\n                        }\n                        x.merge(d, s.childNodes), s.textContent = \"\";\n                        while (s.firstChild)\n                            s.removeChild(s.firstChild);\n                        s = f.lastChild\n                    } else\n                        d.push(t.createTextNode(o));\n            s && f.removeChild(s), x.support.appendChecked || x.grep(Ft(d, \"input\"), Bt), h = 0;\n            while (o = d[h++])\n                if ((!r || -1 === x.inArray(o, r)) && (a = x.contains(o.ownerDocument, o), s = Ft(f.appendChild(o), \"script\"), a && _t(s), n)) {\n                    i = 0;\n                    while (o = s[i++])\n                        kt.test(o.type || \"\") && n.push(o)\n                }\n            return s = null, f\n        }, cleanData: function (e, t) {\n            var n, r, o, a, s = 0, l = x.expando, u = x.cache, c = x.support.deleteExpando, f = x.event.special;\n            for (; null != (n = e[s]); s++)\n                if ((t || x.acceptData(n)) && (o = n[l], a = o && u[o])) {\n                    if (a.events)\n                        for (r in a.events)\n                            f[r] ? x.event.remove(n, r) : x.removeEvent(n, r, a.handle);\n                    u[o] && (delete u[o], c ? delete n[l] : typeof n.removeAttribute !== i ? n.removeAttribute(l) : n[l] = null, p.push(o))\n                }\n        }, _evalUrl: function (e) {\n            return x.ajax({url: e, type: \"GET\", dataType: \"script\", async: !1, global: !1, \"throws\": !0})\n        }}), x.fn.extend({wrapAll: function (e) {\n            if (x.isFunction(e))\n                return this.each(function (t) {\n                    x(this).wrapAll(e.call(this, t))\n                });\n            if (this[0]) {\n                var t = x(e, this[0].ownerDocument).eq(0).clone(!0);\n                this[0].parentNode && t.insertBefore(this[0]), t.map(function () {\n                    var e = this;\n                    while (e.firstChild && 1 === e.firstChild.nodeType)\n                        e = e.firstChild;\n                    return e\n                }).append(this)\n            }\n            return this\n        }, wrapInner: function (e) {\n            return x.isFunction(e) ? this.each(function (t) {\n                x(this).wrapInner(e.call(this, t))\n            }) : this.each(function () {\n                var t = x(this), n = t.contents();\n                n.length ? n.wrapAll(e) : t.append(e)\n            })\n        }, wrap: function (e) {\n            var t = x.isFunction(e);\n            return this.each(function (n) {\n                x(this).wrapAll(t ? e.call(this, n) : e)\n            })\n        }, unwrap: function () {\n            return this.parent().each(function () {\n                x.nodeName(this, \"body\") || x(this).replaceWith(this.childNodes)\n            }).end()\n        }});\n    var Pt, Rt, Wt, $t = /alpha\\([^)]*\\)/i, It = /opacity\\s*=\\s*([^)]*)/, zt = /^(top|right|bottom|left)$/, Xt = /^(none|table(?!-c[ea]).+)/, Ut = /^margin/, Vt = RegExp(\"^(\" + w + \")(.*)$\", \"i\"), Yt = RegExp(\"^(\" + w + \")(?!px)[a-z%]+$\", \"i\"), Jt = RegExp(\"^([+-])=(\" + w + \")\", \"i\"), Gt = {BODY: \"block\"}, Qt = {position: \"absolute\", visibility: \"hidden\", display: \"block\"}, Kt = {letterSpacing: 0, fontWeight: 400}, Zt = [\"Top\", \"Right\", \"Bottom\", \"Left\"], en = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\n    function tn(e, t) {\n        if (t in e)\n            return t;\n        var n = t.charAt(0).toUpperCase() + t.slice(1), r = t, i = en.length;\n        while (i--)\n            if (t = en[i] + n, t in e)\n                return t;\n        return r\n    }\n    function nn(e, t) {\n        return e = t || e, \"none\" === x.css(e, \"display\") || !x.contains(e.ownerDocument, e)\n    }\n    function rn(e, t) {\n        var n, r, i, o = [], a = 0, s = e.length;\n        for (; s > a; a++)\n            r = e[a], r.style && (o[a] = x._data(r, \"olddisplay\"), n = r.style.display, t ? (o[a] || \"none\" !== n || (r.style.display = \"\"), \"\" === r.style.display && nn(r) && (o[a] = x._data(r, \"olddisplay\", ln(r.nodeName)))) : o[a] || (i = nn(r), (n && \"none\" !== n || !i) && x._data(r, \"olddisplay\", i ? n : x.css(r, \"display\"))));\n        for (a = 0; s > a; a++)\n            r = e[a], r.style && (t && \"none\" !== r.style.display && \"\" !== r.style.display || (r.style.display = t ? o[a] || \"\" : \"none\"));\n        return e\n    }\n    x.fn.extend({css: function (e, n) {\n            return x.access(this, function (e, n, r) {\n                var i, o, a = {}, s = 0;\n                if (x.isArray(n)) {\n                    for (o = Rt(e), i = n.length; i > s; s++)\n                        a[n[s]] = x.css(e, n[s], !1, o);\n                    return a\n                }\n                return r !== t ? x.style(e, n, r) : x.css(e, n)\n            }, e, n, arguments.length > 1)\n        }, show: function () {\n            return rn(this, !0)\n        }, hide: function () {\n            return rn(this)\n        }, toggle: function (e) {\n            return\"boolean\" == typeof e ? e ? this.show() : this.hide() : this.each(function () {\n                nn(this) ? x(this).show() : x(this).hide()\n            })\n        }}), x.extend({cssHooks: {opacity: {get: function (e, t) {\n                    if (t) {\n                        var n = Wt(e, \"opacity\");\n                        return\"\" === n ? \"1\" : n\n                    }\n                }}}, cssNumber: {columnCount: !0, fillOpacity: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0}, cssProps: {\"float\": x.support.cssFloat ? \"cssFloat\" : \"styleFloat\"}, style: function (e, n, r, i) {\n            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {\n                var o, a, s, l = x.camelCase(n), u = e.style;\n                if (n = x.cssProps[l] || (x.cssProps[l] = tn(u, l)), s = x.cssHooks[n] || x.cssHooks[l], r === t)\n                    return s && \"get\"in s && (o = s.get(e, !1, i)) !== t ? o : u[n];\n                if (a = typeof r, \"string\" === a && (o = Jt.exec(r)) && (r = (o[1] + 1) * o[2] + parseFloat(x.css(e, n)), a = \"number\"), !(null == r || \"number\" === a && isNaN(r) || (\"number\" !== a || x.cssNumber[l] || (r += \"px\"), x.support.clearCloneStyle || \"\" !== r || 0 !== n.indexOf(\"background\") || (u[n] = \"inherit\"), s && \"set\"in s && (r = s.set(e, r, i)) === t)))\n                    try {\n                        u[n] = r\n                    } catch (c) {\n                    }\n            }\n        }, css: function (e, n, r, i) {\n            var o, a, s, l = x.camelCase(n);\n            return n = x.cssProps[l] || (x.cssProps[l] = tn(e.style, l)), s = x.cssHooks[n] || x.cssHooks[l], s && \"get\"in s && (a = s.get(e, !0, r)), a === t && (a = Wt(e, n, i)), \"normal\" === a && n in Kt && (a = Kt[n]), \"\" === r || r ? (o = parseFloat(a), r === !0 || x.isNumeric(o) ? o || 0 : a) : a\n        }}), e.getComputedStyle ? (Rt = function (t) {\n        return e.getComputedStyle(t, null)\n    }, Wt = function (e, n, r) {\n        var i, o, a, s = r || Rt(e), l = s ? s.getPropertyValue(n) || s[n] : t, u = e.style;\n        return s && (\"\" !== l || x.contains(e.ownerDocument, e) || (l = x.style(e, n)), Yt.test(l) && Ut.test(n) && (i = u.width, o = u.minWidth, a = u.maxWidth, u.minWidth = u.maxWidth = u.width = l, l = s.width, u.width = i, u.minWidth = o, u.maxWidth = a)), l\n    }) : a.documentElement.currentStyle && (Rt = function (e) {\n        return e.currentStyle\n    }, Wt = function (e, n, r) {\n        var i, o, a, s = r || Rt(e), l = s ? s[n] : t, u = e.style;\n        return null == l && u && u[n] && (l = u[n]), Yt.test(l) && !zt.test(n) && (i = u.left, o = e.runtimeStyle, a = o && o.left, a && (o.left = e.currentStyle.left), u.left = \"fontSize\" === n ? \"1em\" : l, l = u.pixelLeft + \"px\", u.left = i, a && (o.left = a)), \"\" === l ? \"auto\" : l\n    });\n    function on(e, t, n) {\n        var r = Vt.exec(t);\n        return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || \"px\") : t\n    }\n    function an(e, t, n, r, i) {\n        var o = n === (r ? \"border\" : \"content\") ? 4 : \"width\" === t ? 1 : 0, a = 0;\n        for (; 4 > o; o += 2)\n            \"margin\" === n && (a += x.css(e, n + Zt[o], !0, i)), r ? (\"content\" === n && (a -= x.css(e, \"padding\" + Zt[o], !0, i)), \"margin\" !== n && (a -= x.css(e, \"border\" + Zt[o] + \"Width\", !0, i))) : (a += x.css(e, \"padding\" + Zt[o], !0, i), \"padding\" !== n && (a += x.css(e, \"border\" + Zt[o] + \"Width\", !0, i)));\n        return a\n    }\n    function sn(e, t, n) {\n        var r = !0, i = \"width\" === t ? e.offsetWidth : e.offsetHeight, o = Rt(e), a = x.support.boxSizing && \"border-box\" === x.css(e, \"boxSizing\", !1, o);\n        if (0 >= i || null == i) {\n            if (i = Wt(e, t, o), (0 > i || null == i) && (i = e.style[t]), Yt.test(i))\n                return i;\n            r = a && (x.support.boxSizingReliable || i === e.style[t]), i = parseFloat(i) || 0\n        }\n        return i + an(e, t, n || (a ? \"border\" : \"content\"), r, o) + \"px\"\n    }\n    function ln(e) {\n        var t = a, n = Gt[e];\n        return n || (n = un(e, t), \"none\" !== n && n || (Pt = (Pt || x(\"<iframe frameborder='0' width='0' height='0'/>\").css(\"cssText\", \"display:block !important\")).appendTo(t.documentElement), t = (Pt[0].contentWindow || Pt[0].contentDocument).document, t.write(\"<!doctype html><html><body>\"), t.close(), n = un(e, t), Pt.detach()), Gt[e] = n), n\n    }\n    function un(e, t) {\n        var n = x(t.createElement(e)).appendTo(t.body), r = x.css(n[0], \"display\");\n        return n.remove(), r\n    }\n    x.each([\"height\", \"width\"], function (e, n) {\n        x.cssHooks[n] = {get: function (e, r, i) {\n                return r ? 0 === e.offsetWidth && Xt.test(x.css(e, \"display\")) ? x.swap(e, Qt, function () {\n                    return sn(e, n, i)\n                }) : sn(e, n, i) : t\n            }, set: function (e, t, r) {\n                var i = r && Rt(e);\n                return on(e, t, r ? an(e, n, r, x.support.boxSizing && \"border-box\" === x.css(e, \"boxSizing\", !1, i), i) : 0)\n            }}\n    }), x.support.opacity || (x.cssHooks.opacity = {get: function (e, t) {\n            return It.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || \"\") ? .01 * parseFloat(RegExp.$1) + \"\" : t ? \"1\" : \"\"\n        }, set: function (e, t) {\n            var n = e.style, r = e.currentStyle, i = x.isNumeric(t) ? \"alpha(opacity=\" + 100 * t + \")\" : \"\", o = r && r.filter || n.filter || \"\";\n            n.zoom = 1, (t >= 1 || \"\" === t) && \"\" === x.trim(o.replace($t, \"\")) && n.removeAttribute && (n.removeAttribute(\"filter\"), \"\" === t || r && !r.filter) || (n.filter = $t.test(o) ? o.replace($t, i) : o + \" \" + i)\n        }}), x(function () {\n        x.support.reliableMarginRight || (x.cssHooks.marginRight = {get: function (e, n) {\n                return n ? x.swap(e, {display: \"inline-block\"}, Wt, [e, \"marginRight\"]) : t\n            }}), !x.support.pixelPosition && x.fn.position && x.each([\"top\", \"left\"], function (e, n) {\n            x.cssHooks[n] = {get: function (e, r) {\n                    return r ? (r = Wt(e, n), Yt.test(r) ? x(e).position()[n] + \"px\" : r) : t\n                }}\n        })\n    }), x.expr && x.expr.filters && (x.expr.filters.hidden = function (e) {\n        return 0 >= e.offsetWidth && 0 >= e.offsetHeight || !x.support.reliableHiddenOffsets && \"none\" === (e.style && e.style.display || x.css(e, \"display\"))\n    }, x.expr.filters.visible = function (e) {\n        return!x.expr.filters.hidden(e)\n    }), x.each({margin: \"\", padding: \"\", border: \"Width\"}, function (e, t) {\n        x.cssHooks[e + t] = {expand: function (n) {\n                var r = 0, i = {}, o = \"string\" == typeof n ? n.split(\" \") : [n];\n                for (; 4 > r; r++)\n                    i[e + Zt[r] + t] = o[r] || o[r - 2] || o[0];\n                return i\n            }}, Ut.test(e) || (x.cssHooks[e + t].set = on)\n    });\n    var cn = /%20/g, pn = /\\[\\]$/, fn = /\\r?\\n/g, dn = /^(?:submit|button|image|reset|file)$/i, hn = /^(?:input|select|textarea|keygen)/i;\n    x.fn.extend({serialize: function () {\n            return x.param(this.serializeArray())\n        }, serializeArray: function () {\n            return this.map(function () {\n                var e = x.prop(this, \"elements\");\n                return e ? x.makeArray(e) : this\n            }).filter(function () {\n                var e = this.type;\n                return this.name && !x(this).is(\":disabled\") && hn.test(this.nodeName) && !dn.test(e) && (this.checked || !Ct.test(e))\n            }).map(function (e, t) {\n                var n = x(this).val();\n                return null == n ? null : x.isArray(n) ? x.map(n, function (e) {\n                    return{name: t.name, value: e.replace(fn, \"\\r\\n\")}\n                }) : {name: t.name, value: n.replace(fn, \"\\r\\n\")}\n            }).get()\n        }}), x.param = function (e, n) {\n        var r, i = [], o = function (e, t) {\n            t = x.isFunction(t) ? t() : null == t ? \"\" : t, i[i.length] = encodeURIComponent(e) + \"=\" + encodeURIComponent(t)\n        };\n        if (n === t && (n = x.ajaxSettings && x.ajaxSettings.traditional), x.isArray(e) || e.jquery && !x.isPlainObject(e))\n            x.each(e, function () {\n                o(this.name, this.value)\n            });\n        else\n            for (r in e)\n                gn(r, e[r], n, o);\n        return i.join(\"&\").replace(cn, \"+\")\n    };\n    function gn(e, t, n, r) {\n        var i;\n        if (x.isArray(t))\n            x.each(t, function (t, i) {\n                n || pn.test(e) ? r(e, i) : gn(e + \"[\" + (\"object\" == typeof i ? t : \"\") + \"]\", i, n, r)\n            });\n        else if (n || \"object\" !== x.type(t))\n            r(e, t);\n        else\n            for (i in t)\n                gn(e + \"[\" + i + \"]\", t[i], n, r)\n    }\n    x.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (e, t) {\n        x.fn[t] = function (e, n) {\n            return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)\n        }\n    }), x.fn.extend({hover: function (e, t) {\n            return this.mouseenter(e).mouseleave(t || e)\n        }, bind: function (e, t, n) {\n            return this.on(e, null, t, n)\n        }, unbind: function (e, t) {\n            return this.off(e, null, t)\n        }, delegate: function (e, t, n, r) {\n            return this.on(t, e, n, r)\n        }, undelegate: function (e, t, n) {\n            return 1 === arguments.length ? this.off(e, \"**\") : this.off(t, e || \"**\", n)\n        }});\n    var mn, yn, vn = x.now(), bn = /\\?/, xn = /#.*$/, wn = /([?&])_=[^&]*/, Tn = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/gm, Cn = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Nn = /^(?:GET|HEAD)$/, kn = /^\\/\\//, En = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/, Sn = x.fn.load, An = {}, jn = {}, Dn = \"*/\".concat(\"*\");\n    try {\n        yn = o.href\n    } catch (Ln) {\n        yn = a.createElement(\"a\"), yn.href = \"\", yn = yn.href\n    }\n    mn = En.exec(yn.toLowerCase()) || [];\n    function Hn(e) {\n        return function (t, n) {\n            \"string\" != typeof t && (n = t, t = \"*\");\n            var r, i = 0, o = t.toLowerCase().match(T) || [];\n            if (x.isFunction(n))\n                while (r = o[i++])\n                    \"+\" === r[0] ? (r = r.slice(1) || \"*\", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n)\n        }\n    }\n    function qn(e, n, r, i) {\n        var o = {}, a = e === jn;\n        function s(l) {\n            var u;\n            return o[l] = !0, x.each(e[l] || [], function (e, l) {\n                var c = l(n, r, i);\n                return\"string\" != typeof c || a || o[c] ? a ? !(u = c) : t : (n.dataTypes.unshift(c), s(c), !1)\n            }), u\n        }\n        return s(n.dataTypes[0]) || !o[\"*\"] && s(\"*\")\n    }\n    function _n(e, n) {\n        var r, i, o = x.ajaxSettings.flatOptions || {};\n        for (i in n)\n            n[i] !== t && ((o[i] ? e : r || (r = {}))[i] = n[i]);\n        return r && x.extend(!0, e, r), e\n    }\n    x.fn.load = function (e, n, r) {\n        if (\"string\" != typeof e && Sn)\n            return Sn.apply(this, arguments);\n        var i, o, a, s = this, l = e.indexOf(\" \");\n        return l >= 0 && (i = e.slice(l, e.length), e = e.slice(0, l)), x.isFunction(n) ? (r = n, n = t) : n && \"object\" == typeof n && (a = \"POST\"), s.length > 0 && x.ajax({url: e, type: a, dataType: \"html\", data: n}).done(function (e) {\n            o = arguments, s.html(i ? x(\"<div>\").append(x.parseHTML(e)).find(i) : e)\n        }).complete(r && function (e, t) {\n            s.each(r, o || [e.responseText, t, e])\n        }), this\n    }, x.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (e, t) {\n        x.fn[t] = function (e) {\n            return this.on(t, e)\n        }\n    }), x.extend({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: yn, type: \"GET\", isLocal: Cn.test(mn[1]), global: !0, processData: !0, async: !0, contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", accepts: {\"*\": Dn, text: \"text/plain\", html: \"text/html\", xml: \"application/xml, text/xml\", json: \"application/json, text/javascript\"}, contents: {xml: /xml/, html: /html/, json: /json/}, responseFields: {xml: \"responseXML\", text: \"responseText\", json: \"responseJSON\"}, converters: {\"* text\": String, \"text html\": !0, \"text json\": x.parseJSON, \"text xml\": x.parseXML}, flatOptions: {url: !0, context: !0}}, ajaxSetup: function (e, t) {\n            return t ? _n(_n(e, x.ajaxSettings), t) : _n(x.ajaxSettings, e)\n        }, ajaxPrefilter: Hn(An), ajaxTransport: Hn(jn), ajax: function (e, n) {\n            \"object\" == typeof e && (n = e, e = t), n = n || {};\n            var r, i, o, a, s, l, u, c, p = x.ajaxSetup({}, n), f = p.context || p, d = p.context && (f.nodeType || f.jquery) ? x(f) : x.event, h = x.Deferred(), g = x.Callbacks(\"once memory\"), m = p.statusCode || {}, y = {}, v = {}, b = 0, w = \"canceled\", C = {readyState: 0, getResponseHeader: function (e) {\n                    var t;\n                    if (2 === b) {\n                        if (!c) {\n                            c = {};\n                            while (t = Tn.exec(a))\n                                c[t[1].toLowerCase()] = t[2]\n                        }\n                        t = c[e.toLowerCase()]\n                    }\n                    return null == t ? null : t\n                }, getAllResponseHeaders: function () {\n                    return 2 === b ? a : null\n                }, setRequestHeader: function (e, t) {\n                    var n = e.toLowerCase();\n                    return b || (e = v[n] = v[n] || e, y[e] = t), this\n                }, overrideMimeType: function (e) {\n                    return b || (p.mimeType = e), this\n                }, statusCode: function (e) {\n                    var t;\n                    if (e)\n                        if (2 > b)\n                            for (t in e)\n                                m[t] = [m[t], e[t]];\n                        else\n                            C.always(e[C.status]);\n                    return this\n                }, abort: function (e) {\n                    var t = e || w;\n                    return u && u.abort(t), k(0, t), this\n                }};\n            if (h.promise(C).complete = g.add, C.success = C.done, C.error = C.fail, p.url = ((e || p.url || yn) + \"\").replace(xn, \"\").replace(kn, mn[1] + \"//\"), p.type = n.method || n.type || p.method || p.type, p.dataTypes = x.trim(p.dataType || \"*\").toLowerCase().match(T) || [\"\"], null == p.crossDomain && (r = En.exec(p.url.toLowerCase()), p.crossDomain = !(!r || r[1] === mn[1] && r[2] === mn[2] && (r[3] || (\"http:\" === r[1] ? \"80\" : \"443\")) === (mn[3] || (\"http:\" === mn[1] ? \"80\" : \"443\")))), p.data && p.processData && \"string\" != typeof p.data && (p.data = x.param(p.data, p.traditional)), qn(An, p, n, C), 2 === b)\n                return C;\n            l = p.global, l && 0 === x.active++ && x.event.trigger(\"ajaxStart\"), p.type = p.type.toUpperCase(), p.hasContent = !Nn.test(p.type), o = p.url, p.hasContent || (p.data && (o = p.url += (bn.test(o) ? \"&\" : \"?\") + p.data, delete p.data), p.cache === !1 && (p.url = wn.test(o) ? o.replace(wn, \"$1_=\" + vn++) : o + (bn.test(o) ? \"&\" : \"?\") + \"_=\" + vn++)), p.ifModified && (x.lastModified[o] && C.setRequestHeader(\"If-Modified-Since\", x.lastModified[o]), x.etag[o] && C.setRequestHeader(\"If-None-Match\", x.etag[o])), (p.data && p.hasContent && p.contentType !== !1 || n.contentType) && C.setRequestHeader(\"Content-Type\", p.contentType), C.setRequestHeader(\"Accept\", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + (\"*\" !== p.dataTypes[0] ? \", \" + Dn + \"; q=0.01\" : \"\") : p.accepts[\"*\"]);\n            for (i in p.headers)\n                C.setRequestHeader(i, p.headers[i]);\n            if (p.beforeSend && (p.beforeSend.call(f, C, p) === !1 || 2 === b))\n                return C.abort();\n            w = \"abort\";\n            for (i in{success:1, error:1, complete:1})\n                C[i](p[i]);\n            if (u = qn(jn, p, n, C)) {\n                C.readyState = 1, l && d.trigger(\"ajaxSend\", [C, p]), p.async && p.timeout > 0 && (s = setTimeout(function () {\n                    C.abort(\"timeout\")\n                }, p.timeout));\n                try {\n                    b = 1, u.send(y, k)\n                } catch (N) {\n                    if (!(2 > b))\n                        throw N;\n                    k(-1, N)\n                }\n            } else\n                k(-1, \"No Transport\");\n            function k(e, n, r, i) {\n                var c, y, v, w, T, N = n;\n                2 !== b && (b = 2, s && clearTimeout(s), u = t, a = i || \"\", C.readyState = e > 0 ? 4 : 0, c = e >= 200 && 300 > e || 304 === e, r && (w = Mn(p, C, r)), w = On(p, w, C, c), c ? (p.ifModified && (T = C.getResponseHeader(\"Last-Modified\"), T && (x.lastModified[o] = T), T = C.getResponseHeader(\"etag\"), T && (x.etag[o] = T)), 204 === e || \"HEAD\" === p.type ? N = \"nocontent\" : 304 === e ? N = \"notmodified\" : (N = w.state, y = w.data, v = w.error, c = !v)) : (v = N, (e || !N) && (N = \"error\", 0 > e && (e = 0))), C.status = e, C.statusText = (n || N) + \"\", c ? h.resolveWith(f, [y, N, C]) : h.rejectWith(f, [C, N, v]), C.statusCode(m), m = t, l && d.trigger(c ? \"ajaxSuccess\" : \"ajaxError\", [C, p, c ? y : v]), g.fireWith(f, [C, N]), l && (d.trigger(\"ajaxComplete\", [C, p]), --x.active || x.event.trigger(\"ajaxStop\")))\n            }\n            return C\n        }, getJSON: function (e, t, n) {\n            return x.get(e, t, n, \"json\")\n        }, getScript: function (e, n) {\n            return x.get(e, t, n, \"script\")\n        }}), x.each([\"get\", \"post\"], function (e, n) {\n        x[n] = function (e, r, i, o) {\n            return x.isFunction(r) && (o = o || i, i = r, r = t), x.ajax({url: e, type: n, dataType: o, data: r, success: i})\n        }\n    });\n    function Mn(e, n, r) {\n        var i, o, a, s, l = e.contents, u = e.dataTypes;\n        while (\"*\" === u[0])\n            u.shift(), o === t && (o = e.mimeType || n.getResponseHeader(\"Content-Type\"));\n        if (o)\n            for (s in l)\n                if (l[s] && l[s].test(o)) {\n                    u.unshift(s);\n                    break\n                }\n        if (u[0]in r)\n            a = u[0];\n        else {\n            for (s in r) {\n                if (!u[0] || e.converters[s + \" \" + u[0]]) {\n                    a = s;\n                    break\n                }\n                i || (i = s)\n            }\n            a = a || i\n        }\n        return a ? (a !== u[0] && u.unshift(a), r[a]) : t\n    }\n    function On(e, t, n, r) {\n        var i, o, a, s, l, u = {}, c = e.dataTypes.slice();\n        if (c[1])\n            for (a in e.converters)\n                u[a.toLowerCase()] = e.converters[a];\n        o = c.shift();\n        while (o)\n            if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = c.shift())\n                if (\"*\" === o)\n                    o = l;\n                else if (\"*\" !== l && l !== o) {\n                    if (a = u[l + \" \" + o] || u[\"* \" + o], !a)\n                        for (i in u)\n                            if (s = i.split(\" \"), s[1] === o && (a = u[l + \" \" + s[0]] || u[\"* \" + s[0]])) {\n                                a === !0 ? a = u[i] : u[i] !== !0 && (o = s[0], c.unshift(s[1]));\n                                break\n                            }\n                    if (a !== !0)\n                        if (a && e[\"throws\"])\n                            t = a(t);\n                        else\n                            try {\n                                t = a(t)\n                            } catch (p) {\n                                return{state: \"parsererror\", error: a ? p : \"No conversion from \" + l + \" to \" + o}\n                            }\n                }\n        return{state: \"success\", data: t}\n    }\n    x.ajaxSetup({accepts: {script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"}, contents: {script: /(?:java|ecma)script/}, converters: {\"text script\": function (e) {\n                return x.globalEval(e), e\n            }}}), x.ajaxPrefilter(\"script\", function (e) {\n        e.cache === t && (e.cache = !1), e.crossDomain && (e.type = \"GET\", e.global = !1)\n    }), x.ajaxTransport(\"script\", function (e) {\n        if (e.crossDomain) {\n            var n, r = a.head || x(\"head\")[0] || a.documentElement;\n            return{send: function (t, i) {\n                    n = a.createElement(\"script\"), n.async = !0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function (e, t) {\n                        (t || !n.readyState || /loaded|complete/.test(n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), n = null, t || i(200, \"success\"))\n                    }, r.insertBefore(n, r.firstChild)\n                }, abort: function () {\n                    n && n.onload(t, !0)\n                }}\n        }\n    });\n    var Fn = [], Bn = /(=)\\?(?=&|$)|\\?\\?/;\n    x.ajaxSetup({jsonp: \"callback\", jsonpCallback: function () {\n            var e = Fn.pop() || x.expando + \"_\" + vn++;\n            return this[e] = !0, e\n        }}), x.ajaxPrefilter(\"json jsonp\", function (n, r, i) {\n        var o, a, s, l = n.jsonp !== !1 && (Bn.test(n.url) ? \"url\" : \"string\" == typeof n.data && !(n.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Bn.test(n.data) && \"data\");\n        return l || \"jsonp\" === n.dataTypes[0] ? (o = n.jsonpCallback = x.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback, l ? n[l] = n[l].replace(Bn, \"$1\" + o) : n.jsonp !== !1 && (n.url += (bn.test(n.url) ? \"&\" : \"?\") + n.jsonp + \"=\" + o), n.converters[\"script json\"] = function () {\n            return s || x.error(o + \" was not called\"), s[0]\n        }, n.dataTypes[0] = \"json\", a = e[o], e[o] = function () {\n            s = arguments\n        }, i.always(function () {\n            e[o] = a, n[o] && (n.jsonpCallback = r.jsonpCallback, Fn.push(o)), s && x.isFunction(a) && a(s[0]), s = a = t\n        }), \"script\") : t\n    });\n    var Pn, Rn, Wn = 0, $n = e.ActiveXObject && function () {\n        var e;\n        for (e in Pn)\n            Pn[e](t, !0)\n    };\n    function In() {\n        try {\n            return new e.XMLHttpRequest\n        } catch (t) {\n        }\n    }\n    function zn() {\n        try {\n            return new e.ActiveXObject(\"Microsoft.XMLHTTP\")\n        } catch (t) {\n        }\n    }\n    x.ajaxSettings.xhr = e.ActiveXObject ? function () {\n        return!this.isLocal && In() || zn()\n    } : In, Rn = x.ajaxSettings.xhr(), x.support.cors = !!Rn && \"withCredentials\"in Rn, Rn = x.support.ajax = !!Rn, Rn && x.ajaxTransport(function (n) {\n        if (!n.crossDomain || x.support.cors) {\n            var r;\n            return{send: function (i, o) {\n                    var a, s, l = n.xhr();\n                    if (n.username ? l.open(n.type, n.url, n.async, n.username, n.password) : l.open(n.type, n.url, n.async), n.xhrFields)\n                        for (s in n.xhrFields)\n                            l[s] = n.xhrFields[s];\n                    n.mimeType && l.overrideMimeType && l.overrideMimeType(n.mimeType), n.crossDomain || i[\"X-Requested-With\"] || (i[\"X-Requested-With\"] = \"XMLHttpRequest\");\n                    try {\n                        for (s in i)\n                            l.setRequestHeader(s, i[s])\n                    } catch (u) {\n                    }\n                    l.send(n.hasContent && n.data || null), r = function (e, i) {\n                        var s, u, c, p;\n                        try {\n                            if (r && (i || 4 === l.readyState))\n                                if (r = t, a && (l.onreadystatechange = x.noop, $n && delete Pn[a]), i)\n                                    4 !== l.readyState && l.abort();\n                                else {\n                                    p = {}, s = l.status, u = l.getAllResponseHeaders(), \"string\" == typeof l.responseText && (p.text = l.responseText);\n                                    try {\n                                        c = l.statusText\n                                    } catch (f) {\n                                        c = \"\"\n                                    }\n                                    s || !n.isLocal || n.crossDomain ? 1223 === s && (s = 204) : s = p.text ? 200 : 404\n                                }\n                        } catch (d) {\n                            i || o(-1, d)\n                        }\n                        p && o(s, c, p, u)\n                    }, n.async ? 4 === l.readyState ? setTimeout(r) : (a = ++Wn, $n && (Pn || (Pn = {}, x(e).unload($n)), Pn[a] = r), l.onreadystatechange = r) : r()\n                }, abort: function () {\n                    r && r(t, !0)\n                }}\n        }\n    });\n    var Xn, Un, Vn = /^(?:toggle|show|hide)$/, Yn = RegExp(\"^(?:([+-])=|)(\" + w + \")([a-z%]*)$\", \"i\"), Jn = /queueHooks$/, Gn = [nr], Qn = {\"*\": [function (e, t) {\n                var n = this.createTween(e, t), r = n.cur(), i = Yn.exec(t), o = i && i[3] || (x.cssNumber[e] ? \"\" : \"px\"), a = (x.cssNumber[e] || \"px\" !== o && +r) && Yn.exec(x.css(n.elem, e)), s = 1, l = 20;\n                if (a && a[3] !== o) {\n                    o = o || a[3], i = i || [], a = +r || 1;\n                    do\n                        s = s || \".5\", a /= s, x.style(n.elem, e, a + o);\n                    while (s !== (s = n.cur() / r) && 1 !== s && --l)\n                }\n                return i && (a = n.start = +a || +r || 0, n.unit = o, n.end = i[1] ? a + (i[1] + 1) * i[2] : +i[2]), n\n            }]};\n    function Kn() {\n        return setTimeout(function () {\n            Xn = t\n        }), Xn = x.now()\n    }\n    function Zn(e, t, n) {\n        var r, i = (Qn[t] || []).concat(Qn[\"*\"]), o = 0, a = i.length;\n        for (; a > o; o++)\n            if (r = i[o].call(n, t, e))\n                return r\n    }\n    function er(e, t, n) {\n        var r, i, o = 0, a = Gn.length, s = x.Deferred().always(function () {\n            delete l.elem\n        }), l = function () {\n            if (i)\n                return!1;\n            var t = Xn || Kn(), n = Math.max(0, u.startTime + u.duration - t), r = n / u.duration || 0, o = 1 - r, a = 0, l = u.tweens.length;\n            for (; l > a; a++)\n                u.tweens[a].run(o);\n            return s.notifyWith(e, [u, o, n]), 1 > o && l ? n : (s.resolveWith(e, [u]), !1)\n        }, u = s.promise({elem: e, props: x.extend({}, t), opts: x.extend(!0, {specialEasing: {}}, n), originalProperties: t, originalOptions: n, startTime: Xn || Kn(), duration: n.duration, tweens: [], createTween: function (t, n) {\n                var r = x.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);\n                return u.tweens.push(r), r\n            }, stop: function (t) {\n                var n = 0, r = t ? u.tweens.length : 0;\n                if (i)\n                    return this;\n                for (i = !0; r > n; n++)\n                    u.tweens[n].run(1);\n                return t ? s.resolveWith(e, [u, t]) : s.rejectWith(e, [u, t]), this\n            }}), c = u.props;\n        for (tr(c, u.opts.specialEasing); a > o; o++)\n            if (r = Gn[o].call(u, e, c, u.opts))\n                return r;\n        return x.map(c, Zn, u), x.isFunction(u.opts.start) && u.opts.start.call(e, u), x.fx.timer(x.extend(l, {elem: e, anim: u, queue: u.opts.queue})), u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always)\n    }\n    function tr(e, t) {\n        var n, r, i, o, a;\n        for (n in e)\n            if (r = x.camelCase(n), i = t[r], o = e[n], x.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), a = x.cssHooks[r], a && \"expand\"in a) {\n                o = a.expand(o), delete e[r];\n                for (n in o)\n                    n in e || (e[n] = o[n], t[n] = i)\n            } else\n                t[r] = i\n    }\n    x.Animation = x.extend(er, {tweener: function (e, t) {\n            x.isFunction(e) ? (t = e, e = [\"*\"]) : e = e.split(\" \");\n            var n, r = 0, i = e.length;\n            for (; i > r; r++)\n                n = e[r], Qn[n] = Qn[n] || [], Qn[n].unshift(t)\n        }, prefilter: function (e, t) {\n            t ? Gn.unshift(e) : Gn.push(e)\n        }});\n    function nr(e, t, n) {\n        var r, i, o, a, s, l, u = this, c = {}, p = e.style, f = e.nodeType && nn(e), d = x._data(e, \"fxshow\");\n        n.queue || (s = x._queueHooks(e, \"fx\"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function () {\n            s.unqueued || l()\n        }), s.unqueued++, u.always(function () {\n            u.always(function () {\n                s.unqueued--, x.queue(e, \"fx\").length || s.empty.fire()\n            })\n        })), 1 === e.nodeType && (\"height\"in t || \"width\"in t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], \"inline\" === x.css(e, \"display\") && \"none\" === x.css(e, \"float\") && (x.support.inlineBlockNeedsLayout && \"inline\" !== ln(e.nodeName) ? p.zoom = 1 : p.display = \"inline-block\")), n.overflow && (p.overflow = \"hidden\", x.support.shrinkWrapBlocks || u.always(function () {\n            p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2]\n        }));\n        for (r in t)\n            if (i = t[r], Vn.exec(i)) {\n                if (delete t[r], o = o || \"toggle\" === i, i === (f ? \"hide\" : \"show\"))\n                    continue;\n                c[r] = d && d[r] || x.style(e, r)\n            }\n        if (!x.isEmptyObject(c)) {\n            d ? \"hidden\"in d && (f = d.hidden) : d = x._data(e, \"fxshow\", {}), o && (d.hidden = !f), f ? x(e).show() : u.done(function () {\n                x(e).hide()\n            }), u.done(function () {\n                var t;\n                x._removeData(e, \"fxshow\");\n                for (t in c)\n                    x.style(e, t, c[t])\n            });\n            for (r in c)\n                a = Zn(f ? d[r] : 0, r, u), r in d || (d[r] = a.start, f && (a.end = a.start, a.start = \"width\" === r || \"height\" === r ? 1 : 0))\n        }\n    }\n    function rr(e, t, n, r, i) {\n        return new rr.prototype.init(e, t, n, r, i)\n    }\n    x.Tween = rr, rr.prototype = {constructor: rr, init: function (e, t, n, r, i, o) {\n            this.elem = e, this.prop = n, this.easing = i || \"swing\", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (x.cssNumber[n] ? \"\" : \"px\")\n        }, cur: function () {\n            var e = rr.propHooks[this.prop];\n            return e && e.get ? e.get(this) : rr.propHooks._default.get(this)\n        }, run: function (e) {\n            var t, n = rr.propHooks[this.prop];\n            return this.pos = t = this.options.duration ? x.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : rr.propHooks._default.set(this), this\n        }}, rr.prototype.init.prototype = rr.prototype, rr.propHooks = {_default: {get: function (e) {\n                var t;\n                return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = x.css(e.elem, e.prop, \"\"), t && \"auto\" !== t ? t : 0) : e.elem[e.prop]\n            }, set: function (e) {\n                x.fx.step[e.prop] ? x.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[x.cssProps[e.prop]] || x.cssHooks[e.prop]) ? x.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now\n            }}}, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = {set: function (e) {\n            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)\n        }}, x.each([\"toggle\", \"show\", \"hide\"], function (e, t) {\n        var n = x.fn[t];\n        x.fn[t] = function (e, r, i) {\n            return null == e || \"boolean\" == typeof e ? n.apply(this, arguments) : this.animate(ir(t, !0), e, r, i)\n        }\n    }), x.fn.extend({fadeTo: function (e, t, n, r) {\n            return this.filter(nn).css(\"opacity\", 0).show().end().animate({opacity: t}, e, n, r)\n        }, animate: function (e, t, n, r) {\n            var i = x.isEmptyObject(e), o = x.speed(t, n, r), a = function () {\n                var t = er(this, x.extend({}, e), o);\n                (i || x._data(this, \"finish\")) && t.stop(!0)\n            };\n            return a.finish = a, i || o.queue === !1 ? this.each(a) : this.queue(o.queue, a)\n        }, stop: function (e, n, r) {\n            var i = function (e) {\n                var t = e.stop;\n                delete e.stop, t(r)\n            };\n            return\"string\" != typeof e && (r = n, n = e, e = t), n && e !== !1 && this.queue(e || \"fx\", []), this.each(function () {\n                var t = !0, n = null != e && e + \"queueHooks\", o = x.timers, a = x._data(this);\n                if (n)\n                    a[n] && a[n].stop && i(a[n]);\n                else\n                    for (n in a)\n                        a[n] && a[n].stop && Jn.test(n) && i(a[n]);\n                for (n = o.length; n--; )\n                    o[n].elem !== this || null != e && o[n].queue !== e || (o[n].anim.stop(r), t = !1, o.splice(n, 1));\n                (t || !r) && x.dequeue(this, e)\n            })\n        }, finish: function (e) {\n            return e !== !1 && (e = e || \"fx\"), this.each(function () {\n                var t, n = x._data(this), r = n[e + \"queue\"], i = n[e + \"queueHooks\"], o = x.timers, a = r ? r.length : 0;\n                for (n.finish = !0, x.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--; )\n                    o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));\n                for (t = 0; a > t; t++)\n                    r[t] && r[t].finish && r[t].finish.call(this);\n                delete n.finish\n            })\n        }});\n    function ir(e, t) {\n        var n, r = {height: e}, i = 0;\n        for (t = t?1:0; 4 > i; i += 2 - t)\n            n = Zt[i], r[\"margin\" + n] = r[\"padding\" + n] = e;\n        return t && (r.opacity = r.width = e), r\n    }\n    x.each({slideDown: ir(\"show\"), slideUp: ir(\"hide\"), slideToggle: ir(\"toggle\"), fadeIn: {opacity: \"show\"}, fadeOut: {opacity: \"hide\"}, fadeToggle: {opacity: \"toggle\"}}, function (e, t) {\n        x.fn[e] = function (e, n, r) {\n            return this.animate(t, e, n, r)\n        }\n    }), x.speed = function (e, t, n) {\n        var r = e && \"object\" == typeof e ? x.extend({}, e) : {complete: n || !n && t || x.isFunction(e) && e, duration: e, easing: n && t || t && !x.isFunction(t) && t};\n        return r.duration = x.fx.off ? 0 : \"number\" == typeof r.duration ? r.duration : r.duration in x.fx.speeds ? x.fx.speeds[r.duration] : x.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = \"fx\"), r.old = r.complete, r.complete = function () {\n            x.isFunction(r.old) && r.old.call(this), r.queue && x.dequeue(this, r.queue)\n        }, r\n    }, x.easing = {linear: function (e) {\n            return e\n        }, swing: function (e) {\n            return.5 - Math.cos(e * Math.PI) / 2\n        }}, x.timers = [], x.fx = rr.prototype.init, x.fx.tick = function () {\n        var e, n = x.timers, r = 0;\n        for (Xn = x.now(); n.length > r; r++)\n            e = n[r], e() || n[r] !== e || n.splice(r--, 1);\n        n.length || x.fx.stop(), Xn = t\n    }, x.fx.timer = function (e) {\n        e() && x.timers.push(e) && x.fx.start()\n    }, x.fx.interval = 13, x.fx.start = function () {\n        Un || (Un = setInterval(x.fx.tick, x.fx.interval))\n    }, x.fx.stop = function () {\n        clearInterval(Un), Un = null\n    }, x.fx.speeds = {slow: 600, fast: 200, _default: 400}, x.fx.step = {}, x.expr && x.expr.filters && (x.expr.filters.animated = function (e) {\n        return x.grep(x.timers, function (t) {\n            return e === t.elem\n        }).length\n    }), x.fn.offset = function (e) {\n        if (arguments.length)\n            return e === t ? this : this.each(function (t) {\n                x.offset.setOffset(this, e, t)\n            });\n        var n, r, o = {top: 0, left: 0}, a = this[0], s = a && a.ownerDocument;\n        if (s)\n            return n = s.documentElement, x.contains(n, a) ? (typeof a.getBoundingClientRect !== i && (o = a.getBoundingClientRect()), r = or(s), {top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0), left: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0)}) : o\n    }, x.offset = {setOffset: function (e, t, n) {\n            var r = x.css(e, \"position\");\n            \"static\" === r && (e.style.position = \"relative\");\n            var i = x(e), o = i.offset(), a = x.css(e, \"top\"), s = x.css(e, \"left\"), l = (\"absolute\" === r || \"fixed\" === r) && x.inArray(\"auto\", [a, s]) > -1, u = {}, c = {}, p, f;\n            l ? (c = i.position(), p = c.top, f = c.left) : (p = parseFloat(a) || 0, f = parseFloat(s) || 0), x.isFunction(t) && (t = t.call(e, n, o)), null != t.top && (u.top = t.top - o.top + p), null != t.left && (u.left = t.left - o.left + f), \"using\"in t ? t.using.call(e, u) : i.css(u)\n        }}, x.fn.extend({position: function () {\n            if (this[0]) {\n                var e, t, n = {top: 0, left: 0}, r = this[0];\n                return\"fixed\" === x.css(r, \"position\") ? t = r.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), x.nodeName(e[0], \"html\") || (n = e.offset()), n.top += x.css(e[0], \"borderTopWidth\", !0), n.left += x.css(e[0], \"borderLeftWidth\", !0)), {top: t.top - n.top - x.css(r, \"marginTop\", !0), left: t.left - n.left - x.css(r, \"marginLeft\", !0)}\n            }\n        }, offsetParent: function () {\n            return this.map(function () {\n                var e = this.offsetParent || s;\n                while (e && !x.nodeName(e, \"html\") && \"static\" === x.css(e, \"position\"))\n                    e = e.offsetParent;\n                return e || s\n            })\n        }}), x.each({scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function (e, n) {\n        var r = /Y/.test(n);\n        x.fn[e] = function (i) {\n            return x.access(this, function (e, i, o) {\n                var a = or(e);\n                return o === t ? a ? n in a ? a[n] : a.document.documentElement[i] : e[i] : (a ? a.scrollTo(r ? x(a).scrollLeft() : o, r ? o : x(a).scrollTop()) : e[i] = o, t)\n            }, e, i, arguments.length, null)\n        }\n    });\n    function or(e) {\n        return x.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1\n    }\n    x.each({Height: \"height\", Width: \"width\"}, function (e, n) {\n        x.each({padding: \"inner\" + e, content: n, \"\": \"outer\" + e}, function (r, i) {\n            x.fn[i] = function (i, o) {\n                var a = arguments.length && (r || \"boolean\" != typeof i), s = r || (i === !0 || o === !0 ? \"margin\" : \"border\");\n                return x.access(this, function (n, r, i) {\n                    var o;\n                    return x.isWindow(n) ? n.document.documentElement[\"client\" + e] : 9 === n.nodeType ? (o = n.documentElement, Math.max(n.body[\"scroll\" + e], o[\"scroll\" + e], n.body[\"offset\" + e], o[\"offset\" + e], o[\"client\" + e])) : i === t ? x.css(n, r, s) : x.style(n, r, i, s)\n                }, n, a ? i : t, a, null)\n            }\n        })\n    }), x.fn.size = function () {\n        return this.length\n    }, x.fn.andSelf = x.fn.addBack, \"object\" == typeof module && module && \"object\" == typeof module.exports ? module.exports = x : (e.jQuery = e.$ = x, \"function\" == \"function\" && __webpack_require__(4) && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n        return x\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))\n})(window);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdmVuZG9yL2pxdWVyeS5taW4uanM/MDhmMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0VBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0g7QUFDaEg7QUFDQSxLQUFLLG9NQUFvTSx1RUFBdUUsRUFBRTtBQUNsUjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQsb0RBQW9EO0FBQ3BELG9FQUFvRSw0REFBNEQsOEJBQThCLE9BQU87QUFDcks7QUFDQTtBQUNBLCtMQUErTDtBQUMvTDtBQUNBLEtBQUssWUFBWTtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FB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QUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBLG1KQUFtSix1SUFBdUk7QUFDMVIsS0FBSyxjQUFjO0FBQ25CO0FBQ0E7QUFDQSxzS0FBc0ssUUFBUTtBQUM5SztBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0MsZ1JBQWdSO0FBQ2hSO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVSxXQUFXLG9EQUFvRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsQ0FBQyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIGpRdWVyeSB2MS4xMC4yIHwgKGMpIDIwMDUsIDIwMTMgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gfCBqcXVlcnkub3JnL2xpY2Vuc2VcbiAvL0Agc291cmNlTWFwcGluZ1VSTD1qcXVlcnkubWluLm1hcFxuICovXG4oZnVuY3Rpb24gKGUsIHQpIHtcbiAgICB2YXIgbiwgciwgaSA9IHR5cGVvZiB0LCBvID0gZS5sb2NhdGlvbiwgYSA9IGUuZG9jdW1lbnQsIHMgPSBhLmRvY3VtZW50RWxlbWVudCwgbCA9IGUualF1ZXJ5LCB1ID0gZS4kLCBjID0ge30sIHAgPSBbXSwgZiA9IFwiMS4xMC4yXCIsIGQgPSBwLmNvbmNhdCwgaCA9IHAucHVzaCwgZyA9IHAuc2xpY2UsIG0gPSBwLmluZGV4T2YsIHkgPSBjLnRvU3RyaW5nLCB2ID0gYy5oYXNPd25Qcm9wZXJ0eSwgYiA9IGYudHJpbSwgeCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHJldHVybiBuZXcgeC5mbi5pbml0KGUsIHQsIHIpXG4gICAgfSwgdyA9IC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZSwgVCA9IC9cXFMrL2csIEMgPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csIE4gPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLywgayA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLywgRSA9IC9eW1xcXSw6e31cXHNdKiQvLCBTID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLCBBID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbXFxkYS1mQS1GXXs0fSkvZywgaiA9IC9cIlteXCJcXFxcXFxyXFxuXSpcInx0cnVlfGZhbHNlfG51bGx8LT8oPzpcXGQrXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpL2csIEQgPSAvXi1tcy0vLCBMID0gLy0oW1xcZGEtel0pL2dpLCBIID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgcmV0dXJuIHQudG9VcHBlckNhc2UoKVxuICAgIH0sIHEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAoYS5hZGRFdmVudExpc3RlbmVyIHx8IFwibG9hZFwiID09PSBlLnR5cGUgfHwgXCJjb21wbGV0ZVwiID09PSBhLnJlYWR5U3RhdGUpICYmIChfKCksIHgucmVhZHkoKSlcbiAgICB9LCBfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhLmFkZEV2ZW50TGlzdGVuZXIgPyAoYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBxLCAhMSksIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcSwgITEpKSA6IChhLmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIHEpLCBlLmRldGFjaEV2ZW50KFwib25sb2FkXCIsIHEpKVxuICAgIH07XG4gICAgeC5mbiA9IHgucHJvdG90eXBlID0ge2pxdWVyeTogZiwgY29uc3RydWN0b3I6IHgsIGluaXQ6IGZ1bmN0aW9uIChlLCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgaSwgbztcbiAgICAgICAgICAgIGlmICghZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPSBcIjxcIiA9PT0gZS5jaGFyQXQoMCkgJiYgXCI+XCIgPT09IGUuY2hhckF0KGUubGVuZ3RoIC0gMSkgJiYgZS5sZW5ndGggPj0gMyA/IFtudWxsLCBlLCBudWxsXSA6IE4uZXhlYyhlKSwgIWkgfHwgIWlbMV0gJiYgbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIW4gfHwgbi5qcXVlcnkgPyAobiB8fCByKS5maW5kKGUpIDogdGhpcy5jb25zdHJ1Y3RvcihuKS5maW5kKGUpO1xuICAgICAgICAgICAgICAgIGlmIChpWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuID0gbiBpbnN0YW5jZW9mIHggPyBuWzBdIDogbiwgeC5tZXJnZSh0aGlzLCB4LnBhcnNlSFRNTChpWzFdLCBuICYmIG4ubm9kZVR5cGUgPyBuLm93bmVyRG9jdW1lbnQgfHwgbiA6IGEsICEwKSksIGsudGVzdChpWzFdKSAmJiB4LmlzUGxhaW5PYmplY3QobikpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmlzRnVuY3Rpb24odGhpc1tpXSkgPyB0aGlzW2ldKG5baV0pIDogdGhpcy5hdHRyKGksIG5baV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobyA9IGEuZ2V0RWxlbWVudEJ5SWQoaVsyXSksIG8gJiYgby5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLmlkICE9PSBpWzJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIuZmluZChlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxLCB0aGlzWzBdID0gb1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0ID0gYSwgdGhpcy5zZWxlY3RvciA9IGUsIHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlLm5vZGVUeXBlID8gKHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBlLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXMpIDogeC5pc0Z1bmN0aW9uKGUpID8gci5yZWFkeShlKSA6IChlLnNlbGVjdG9yICE9PSB0ICYmICh0aGlzLnNlbGVjdG9yID0gZS5zZWxlY3RvciwgdGhpcy5jb250ZXh0ID0gZS5jb250ZXh0KSwgeC5tYWtlQXJyYXkoZSwgdGhpcykpXG4gICAgICAgIH0sIHNlbGVjdG9yOiBcIlwiLCBsZW5ndGg6IDAsIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnLmNhbGwodGhpcylcbiAgICAgICAgfSwgZ2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSA/IHRoaXMudG9BcnJheSgpIDogMCA+IGUgPyB0aGlzW3RoaXMubGVuZ3RoICsgZV0gOiB0aGlzW2VdXG4gICAgICAgIH0sIHB1c2hTdGFjazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0geC5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGUpO1xuICAgICAgICAgICAgcmV0dXJuIHQucHJldk9iamVjdCA9IHRoaXMsIHQuY29udGV4dCA9IHRoaXMuY29udGV4dCwgdFxuICAgICAgICB9LCBlYWNoOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIHguZWFjaCh0aGlzLCBlLCB0KVxuICAgICAgICB9LCByZWFkeTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB4LnJlYWR5LnByb21pc2UoKS5kb25lKGUpLCB0aGlzXG4gICAgICAgIH0sIHNsaWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICAgICAgICB9LCBmaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoMClcbiAgICAgICAgfSwgbGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoLTEpXG4gICAgICAgIH0sIGVxOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmxlbmd0aCwgbiA9ICtlICsgKDAgPiBlID8gdCA6IDApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4gPj0gMCAmJiB0ID4gbiA/IFt0aGlzW25dXSA6IFtdKVxuICAgICAgICB9LCBtYXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soeC5tYXAodGhpcywgZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5jYWxsKHQsIG4sIHQpXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfSwgZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IobnVsbClcbiAgICAgICAgfSwgcHVzaDogaCwgc29ydDogW10uc29ydCwgc3BsaWNlOiBbXS5zcGxpY2V9LCB4LmZuLmluaXQucHJvdG90eXBlID0geC5mbiwgeC5leHRlbmQgPSB4LmZuLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsIG4sIHIsIGksIG8sIGEsIHMgPSBhcmd1bWVudHNbMF0gfHwge30sIGwgPSAxLCB1ID0gYXJndW1lbnRzLmxlbmd0aCwgYyA9ICExO1xuICAgICAgICBmb3IgKFwiYm9vbGVhblwiID09IHR5cGVvZiBzICYmIChjID0gcywgcyA9IGFyZ3VtZW50c1sxXSB8fCB7fSwgbCA9IDIpLCBcIm9iamVjdFwiID09IHR5cGVvZiBzIHx8IHguaXNGdW5jdGlvbihzKSB8fCAocyA9IHt9KSwgdSA9PT0gbCAmJiAocyA9IHRoaXMsIC0tbCk7IHUgPiBsOyBsKyspXG4gICAgICAgICAgICBpZiAobnVsbCAhPSAobyA9IGFyZ3VtZW50c1tsXSkpXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIG8pXG4gICAgICAgICAgICAgICAgICAgIGUgPSBzW2ldLCByID0gb1tpXSwgcyAhPT0gciAmJiAoYyAmJiByICYmICh4LmlzUGxhaW5PYmplY3QocikgfHwgKG4gPSB4LmlzQXJyYXkocikpKSA/IChuID8gKG4gPSAhMSwgYSA9IGUgJiYgeC5pc0FycmF5KGUpID8gZSA6IFtdKSA6IGEgPSBlICYmIHguaXNQbGFpbk9iamVjdChlKSA/IGUgOiB7fSwgc1tpXSA9IHguZXh0ZW5kKGMsIGEsIHIpKSA6IHIgIT09IHQgJiYgKHNbaV0gPSByKSk7XG4gICAgICAgIHJldHVybiBzXG4gICAgfSwgeC5leHRlbmQoe2V4cGFuZG86IFwialF1ZXJ5XCIgKyAoZiArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSwgbm9Db25mbGljdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlLiQgPT09IHggJiYgKGUuJCA9IHUpLCB0ICYmIGUualF1ZXJ5ID09PSB4ICYmIChlLmpRdWVyeSA9IGwpLCB4XG4gICAgICAgIH0sIGlzUmVhZHk6ICExLCByZWFkeVdhaXQ6IDEsIGhvbGRSZWFkeTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUgPyB4LnJlYWR5V2FpdCsrIDogeC5yZWFkeSghMClcbiAgICAgICAgfSwgcmVhZHk6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZSA9PT0gITAgPyAhLS14LnJlYWR5V2FpdCA6ICF4LmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWEuYm9keSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoeC5yZWFkeSk7XG4gICAgICAgICAgICAgICAgeC5pc1JlYWR5ID0gITAsIGUgIT09ICEwICYmIC0teC5yZWFkeVdhaXQgPiAwIHx8IChuLnJlc29sdmVXaXRoKGEsIFt4XSksIHguZm4udHJpZ2dlciAmJiB4KGEpLnRyaWdnZXIoXCJyZWFkeVwiKS5vZmYoXCJyZWFkeVwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaXNGdW5jdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVyblwiZnVuY3Rpb25cIiA9PT0geC50eXBlKGUpXG4gICAgICAgIH0sIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVyblwiYXJyYXlcIiA9PT0geC50eXBlKGUpXG4gICAgICAgIH0sIGlzV2luZG93OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gZSAmJiBlID09IGUud2luZG93XG4gICAgICAgIH0sIGlzTnVtZXJpYzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiFpc05hTihwYXJzZUZsb2F0KGUpKSAmJiBpc0Zpbml0ZShlKVxuICAgICAgICB9LCB0eXBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSA/IGUgKyBcIlwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBjW3kuY2FsbChlKV0gfHwgXCJvYmplY3RcIiA6IHR5cGVvZiBlXG4gICAgICAgIH0sIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgIGlmICghZSB8fCBcIm9iamVjdFwiICE9PSB4LnR5cGUoZSkgfHwgZS5ub2RlVHlwZSB8fCB4LmlzV2luZG93KGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiExO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jb25zdHJ1Y3RvciAmJiAhdi5jYWxsKGUsIFwiY29uc3RydWN0b3JcIikgJiYgIXYuY2FsbChlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4hMVxuICAgICAgICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiExXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeC5zdXBwb3J0Lm93bkxhc3QpXG4gICAgICAgICAgICAgICAgZm9yIChuIGluIGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2LmNhbGwoZSwgbik7XG4gICAgICAgICAgICBmb3IgKG4gaW4gZSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4gbiA9PT0gdCB8fCB2LmNhbGwoZSwgbilcbiAgICAgICAgfSwgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgZm9yICh0IGluIGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuITE7XG4gICAgICAgICAgICByZXR1cm4hMFxuICAgICAgICB9LCBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGUpXG4gICAgICAgIH0sIHBhcnNlSFRNTDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIGlmICghZSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgXCJib29sZWFuXCIgPT0gdHlwZW9mIHQgJiYgKG4gPSB0LCB0ID0gITEpLCB0ID0gdCB8fCBhO1xuICAgICAgICAgICAgdmFyIHIgPSBrLmV4ZWMoZSksIGkgPSAhbiAmJiBbXTtcbiAgICAgICAgICAgIHJldHVybiByID8gW3QuY3JlYXRlRWxlbWVudChyWzFdKV0gOiAociA9IHguYnVpbGRGcmFnbWVudChbZV0sIHQsIGkpLCBpICYmIHgoaSkucmVtb3ZlKCksIHgubWVyZ2UoW10sIHIuY2hpbGROb2RlcykpXG4gICAgICAgIH0sIHBhcnNlSlNPTjogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBlLkpTT04gJiYgZS5KU09OLnBhcnNlID8gZS5KU09OLnBhcnNlKG4pIDogbnVsbCA9PT0gbiA/IG4gOiBcInN0cmluZ1wiID09IHR5cGVvZiBuICYmIChuID0geC50cmltKG4pLCBuICYmIEUudGVzdChuLnJlcGxhY2UoQSwgXCJAXCIpLnJlcGxhY2UoaiwgXCJdXCIpLnJlcGxhY2UoUywgXCJcIikpKSA/IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsgbikoKSA6ICh4LmVycm9yKFwiSW52YWxpZCBKU09OOiBcIiArIG4pLCB0KVxuICAgICAgICB9LCBwYXJzZVhNTDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciByLCBpO1xuICAgICAgICAgICAgaWYgKCFuIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGUuRE9NUGFyc2VyID8gKGkgPSBuZXcgRE9NUGFyc2VyLCByID0gaS5wYXJzZUZyb21TdHJpbmcobiwgXCJ0ZXh0L3htbFwiKSkgOiAociA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKSwgci5hc3luYyA9IFwiZmFsc2VcIiwgci5sb2FkWE1MKG4pKVxuICAgICAgICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICAgICAgICAgIHIgPSB0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gciAmJiByLmRvY3VtZW50RWxlbWVudCAmJiAhci5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpLmxlbmd0aCB8fCB4LmVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgbiksIHJcbiAgICAgICAgfSwgbm9vcDogZnVuY3Rpb24gKCkge1xuICAgICAgICB9LCBnbG9iYWxFdmFsOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdCAmJiB4LnRyaW0odCkgJiYgKGUuZXhlY1NjcmlwdCB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIGUuZXZhbC5jYWxsKGUsIHQpXG4gICAgICAgICAgICB9KSh0KVxuICAgICAgICB9LCBjYW1lbENhc2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5yZXBsYWNlKEQsIFwibXMtXCIpLnJlcGxhY2UoTCwgSClcbiAgICAgICAgfSwgbm9kZU5hbWU6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gZS5ub2RlTmFtZSAmJiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHQudG9Mb3dlckNhc2UoKVxuICAgICAgICB9LCBlYWNoOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIsIGkgPSAwLCBvID0gZS5sZW5ndGgsIGEgPSBNKGUpO1xuICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbyA+IGk7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID0gdC5hcHBseShlW2ldLCBuKSwgciA9PT0gITEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9IHQuYXBwbHkoZVtpXSwgbiksIHIgPT09ICExKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbyA+IGk7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSB0LmNhbGwoZVtpXSwgaSwgZVtpXSksIHIgPT09ICExKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBlKVxuICAgICAgICAgICAgICAgICAgICBpZiAociA9IHQuY2FsbChlW2ldLCBpLCBlW2ldKSwgciA9PT0gITEpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgIH0sIHRyaW06IGIgJiYgIWIuY2FsbChcIlxcdWZlZmZcXHUwMGEwXCIpID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGUgPyBcIlwiIDogYi5jYWxsKGUpXG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSA/IFwiXCIgOiAoZSArIFwiXCIpLnJlcGxhY2UoQywgXCJcIilcbiAgICAgICAgfSwgbWFrZUFycmF5OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0IHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gZSAmJiAoTShPYmplY3QoZSkpID8geC5tZXJnZShuLCBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gW2VdIDogZSkgOiBoLmNhbGwobiwgZSkpLCBuXG4gICAgICAgIH0sIGluQXJyYXk6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtLmNhbGwodCwgZSwgbik7XG4gICAgICAgICAgICAgICAgZm9yIChyID0gdC5sZW5ndGgsIG4gPSBuPzAgPiBuP01hdGgubWF4KDAsIHIgKyBuKTpuOjA7IHIgPiBuOyBuKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChuIGluIHQgJiYgdFtuXSA9PT0gZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4tMVxuICAgICAgICB9LCBtZXJnZTogZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgIHZhciByID0gbi5sZW5ndGgsIGkgPSBlLmxlbmd0aCwgbyA9IDA7XG4gICAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgcilcbiAgICAgICAgICAgICAgICBmb3IgKDsgciA+IG87IG8rKylcbiAgICAgICAgICAgICAgICAgICAgZVtpKytdID0gbltvXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3aGlsZSAobltvXSAhPT0gdClcbiAgICAgICAgICAgICAgICAgICAgZVtpKytdID0gbltvKytdO1xuICAgICAgICAgICAgcmV0dXJuIGUubGVuZ3RoID0gaSwgZVxuICAgICAgICB9LCBncmVwOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIsIGkgPSBbXSwgbyA9IDAsIGEgPSBlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobiA9ICEhbjsgYSA+IG87IG8rKylcbiAgICAgICAgICAgICAgICByID0gISF0KGVbb10sIG8pLCBuICE9PSByICYmIGkucHVzaChlW29dKTtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgIH0sIG1hcDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHZhciByLCBpID0gMCwgbyA9IGUubGVuZ3RoLCBhID0gTShlKSwgcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGEpXG4gICAgICAgICAgICAgICAgZm9yICg7IG8gPiBpOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0KGVbaV0sIGksIG4pLCBudWxsICE9IHIgJiYgKHNbcy5sZW5ndGhdID0gcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIGUpXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0KGVbaV0sIGksIG4pLCBudWxsICE9IHIgJiYgKHNbcy5sZW5ndGhdID0gcik7XG4gICAgICAgICAgICByZXR1cm4gZC5hcHBseShbXSwgcylcbiAgICAgICAgfSwgZ3VpZDogMSwgcHJveHk6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICB2YXIgciwgaSwgbztcbiAgICAgICAgICAgIHJldHVyblwic3RyaW5nXCIgPT0gdHlwZW9mIG4gJiYgKG8gPSBlW25dLCBuID0gZSwgZSA9IG8pLCB4LmlzRnVuY3Rpb24oZSkgPyAociA9IGcuY2FsbChhcmd1bWVudHMsIDIpLCBpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmFwcGx5KG4gfHwgdGhpcywgci5jb25jYXQoZy5jYWxsKGFyZ3VtZW50cykpKVxuICAgICAgICAgICAgfSwgaS5ndWlkID0gZS5ndWlkID0gZS5ndWlkIHx8IHguZ3VpZCsrLCBpKSA6IHRcbiAgICAgICAgfSwgYWNjZXNzOiBmdW5jdGlvbiAoZSwgbiwgciwgaSwgbywgYSwgcykge1xuICAgICAgICAgICAgdmFyIGwgPSAwLCB1ID0gZS5sZW5ndGgsIGMgPSBudWxsID09IHI7XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0geC50eXBlKHIpKSB7XG4gICAgICAgICAgICAgICAgbyA9ICEwO1xuICAgICAgICAgICAgICAgIGZvciAobCBpbiByKVxuICAgICAgICAgICAgICAgICAgICB4LmFjY2VzcyhlLCBuLCBsLCByW2xdLCAhMCwgYSwgcylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSAhPT0gdCAmJiAobyA9ICEwLCB4LmlzRnVuY3Rpb24oaSkgfHwgKHMgPSAhMCksIGMgJiYgKHMgPyAobi5jYWxsKGUsIGkpLCBuID0gbnVsbCkgOiAoYyA9IG4sIG4gPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLmNhbGwoeChlKSwgbilcbiAgICAgICAgICAgIH0pKSwgbikpXG4gICAgICAgICAgICAgICAgZm9yICg7IHUgPiBsOyBsKyspXG4gICAgICAgICAgICAgICAgICAgIG4oZVtsXSwgciwgcyA/IGkgOiBpLmNhbGwoZVtsXSwgbCwgbihlW2xdLCByKSkpO1xuICAgICAgICAgICAgcmV0dXJuIG8gPyBlIDogYyA/IG4uY2FsbChlKSA6IHUgPyBuKGVbMF0sIHIpIDogYVxuICAgICAgICB9LCBub3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpXG4gICAgICAgIH0sIHN3YXA6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgaSwgbywgYSA9IHt9O1xuICAgICAgICAgICAgZm9yIChvIGluIHQpXG4gICAgICAgICAgICAgICAgYVtvXSA9IGUuc3R5bGVbb10sIGUuc3R5bGVbb10gPSB0W29dO1xuICAgICAgICAgICAgaSA9IG4uYXBwbHkoZSwgciB8fCBbXSk7XG4gICAgICAgICAgICBmb3IgKG8gaW4gdClcbiAgICAgICAgICAgICAgICBlLnN0eWxlW29dID0gYVtvXTtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgIH19KSwgeC5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgaWYgKG4gPSB4LkRlZmVycmVkKCksIFwiY29tcGxldGVcIiA9PT0gYS5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoeC5yZWFkeSk7XG4gICAgICAgICAgICBlbHNlIGlmIChhLmFkZEV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgYS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBxLCAhMSksIGUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcSwgITEpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYS5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBxKSwgZS5hdHRhY2hFdmVudChcIm9ubG9hZFwiLCBxKTtcbiAgICAgICAgICAgICAgICB2YXIgciA9ICExO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBudWxsID09IGUuZnJhbWVFbGVtZW50ICYmIGEuZG9jdW1lbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByICYmIHIuZG9TY3JvbGwgJiYgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF4LmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5kb1Njcm9sbChcImxlZnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChvLCA1MClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF8oKSwgeC5yZWFkeSgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4ucHJvbWlzZSh0KVxuICAgIH0sIHguZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGNbXCJbb2JqZWN0IFwiICsgdCArIFwiXVwiXSA9IHQudG9Mb3dlckNhc2UoKVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIE0oZSkge1xuICAgICAgICB2YXIgdCA9IGUubGVuZ3RoLCBuID0geC50eXBlKGUpO1xuICAgICAgICByZXR1cm4geC5pc1dpbmRvdyhlKSA/ICExIDogMSA9PT0gZS5ub2RlVHlwZSAmJiB0ID8gITAgOiBcImFycmF5XCIgPT09IG4gfHwgXCJmdW5jdGlvblwiICE9PSBuICYmICgwID09PSB0IHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgJiYgdCA+IDAgJiYgdCAtIDEgaW4gZSlcbiAgICB9XG4gICAgciA9IHgoYSksIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciBuLCByLCBpLCBvLCBhLCBzLCBsLCB1LCBjLCBwLCBmLCBkLCBoLCBnLCBtLCB5LCB2LCBiID0gXCJzaXp6bGVcIiArIC1uZXcgRGF0ZSwgdyA9IGUuZG9jdW1lbnQsIFQgPSAwLCBDID0gMCwgTiA9IHN0KCksIGsgPSBzdCgpLCBFID0gc3QoKSwgUyA9ICExLCBBID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlID09PSB0ID8gKFMgPSAhMCwgMCkgOiAwXG4gICAgICAgIH0sIGogPSB0eXBlb2YgdCwgRCA9IDEgPDwgMzEsIEwgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgSCA9IFtdLCBxID0gSC5wb3AsIF8gPSBILnB1c2gsIE0gPSBILnB1c2gsIE8gPSBILnNsaWNlLCBGID0gSC5pbmRleE9mIHx8IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IDAsIG4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBuID4gdDsgdCsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzW3RdID09PSBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIHJldHVybi0xXG4gICAgICAgIH0sIEIgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsIFAgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsIFIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLCBXID0gUi5yZXBsYWNlKFwid1wiLCBcIncjXCIpLCAkID0gXCJcXFxcW1wiICsgUCArIFwiKihcIiArIFIgKyBcIilcIiArIFAgKyBcIiooPzooWypeJHwhfl0/PSlcIiArIFAgKyBcIiooPzooWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfChcIiArIFcgKyBcIil8KXwpXCIgKyBQICsgXCIqXFxcXF1cIiwgSSA9IFwiOihcIiArIFIgKyBcIikoPzpcXFxcKCgoWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArICQucmVwbGFjZSgzLCA4KSArIFwiKSopfC4qKVxcXFwpfClcIiwgeiA9IFJlZ0V4cChcIl5cIiArIFAgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyBQICsgXCIrJFwiLCBcImdcIiksIFggPSBSZWdFeHAoXCJeXCIgKyBQICsgXCIqLFwiICsgUCArIFwiKlwiKSwgVSA9IFJlZ0V4cChcIl5cIiArIFAgKyBcIiooWz4rfl18XCIgKyBQICsgXCIpXCIgKyBQICsgXCIqXCIpLCBWID0gUmVnRXhwKFAgKyBcIipbK35dXCIpLCBZID0gUmVnRXhwKFwiPVwiICsgUCArIFwiKihbXlxcXFxdJ1xcXCJdKilcIiArIFAgKyBcIipcXFxcXVwiLCBcImdcIiksIEogPSBSZWdFeHAoSSksIEcgPSBSZWdFeHAoXCJeXCIgKyBXICsgXCIkXCIpLCBRID0ge0lEOiBSZWdFeHAoXCJeIyhcIiArIFIgKyBcIilcIiksIENMQVNTOiBSZWdFeHAoXCJeXFxcXC4oXCIgKyBSICsgXCIpXCIpLCBUQUc6IFJlZ0V4cChcIl4oXCIgKyBSLnJlcGxhY2UoXCJ3XCIsIFwidypcIikgKyBcIilcIiksIEFUVFI6IFJlZ0V4cChcIl5cIiArICQpLCBQU0VVRE86IFJlZ0V4cChcIl5cIiArIEkpLCBDSElMRDogUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIFAgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgUCArIFwiKig/OihbKy1dfClcIiArIFAgKyBcIiooXFxcXGQrKXwpKVwiICsgUCArIFwiKlxcXFwpfClcIiwgXCJpXCIpLCBib29sOiBSZWdFeHAoXCJeKD86XCIgKyBCICsgXCIpJFwiLCBcImlcIiksIG5lZWRzQ29udGV4dDogUmVnRXhwKFwiXlwiICsgUCArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIFAgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyBQICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIpfSwgSyA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sIFogPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLywgZXQgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLCB0dCA9IC9eaFxcZCQvaSwgbnQgPSAvJ3xcXFxcL2csIHJ0ID0gUmVnRXhwKFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyBQICsgXCI/fChcIiArIFAgKyBcIil8LilcIiwgXCJpZ1wiKSwgaXQgPSBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIgPSBcIjB4XCIgKyB0IC0gNjU1MzY7XG4gICAgICAgICAgICByZXR1cm4gciAhPT0gciB8fCBuID8gdCA6IDAgPiByID8gU3RyaW5nLmZyb21DaGFyQ29kZShyICsgNjU1MzYpIDogU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IHIgPj4gMTAsIDU2MzIwIHwgMTAyMyAmIHIpXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBNLmFwcGx5KEggPSBPLmNhbGwody5jaGlsZE5vZGVzKSwgdy5jaGlsZE5vZGVzKSwgSFt3LmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZVxuICAgICAgICB9IGNhdGNoIChvdCkge1xuICAgICAgICAgICAgTSA9IHthcHBseTogSC5sZW5ndGggPyBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBfLmFwcGx5KGUsIE8uY2FsbCh0KSlcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLmxlbmd0aCwgciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlW24rK10gPSB0W3IrK10pXG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGUubGVuZ3RoID0gbiAtIDFcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGF0KGUsIHQsIG4sIGkpIHtcbiAgICAgICAgICAgIHZhciBvLCBhLCBzLCBsLCB1LCBjLCBkLCBtLCB5LCB4O1xuICAgICAgICAgICAgaWYgKCh0ID8gdC5vd25lckRvY3VtZW50IHx8IHQgOiB3KSAhPT0gZiAmJiBwKHQpLCB0ID0gdCB8fCBmLCBuID0gbiB8fCBbXSwgIWUgfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIGlmICgxICE9PSAobCA9IHQubm9kZVR5cGUpICYmIDkgIT09IGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuW107XG4gICAgICAgICAgICBpZiAoaCAmJiAhaSkge1xuICAgICAgICAgICAgICAgIGlmIChvID0gWi5leGVjKGUpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocyA9IG9bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICg5ID09PSBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPSB0LmdldEVsZW1lbnRCeUlkKHMpLCAhYSB8fCAhYS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5pZCA9PT0gcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4ucHVzaChhKSwgblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0Lm93bmVyRG9jdW1lbnQgJiYgKGEgPSB0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocykpICYmIHYodCwgYSkgJiYgYS5pZCA9PT0gcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5wdXNoKGEpLCBuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob1syXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTS5hcHBseShuLCB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpKSwgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocyA9IG9bM10pICYmIHIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE0uYXBwbHkobiwgdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHMpKSwgblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIucXNhICYmICghZyB8fCAhZy50ZXN0KGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobSA9IGQgPSBiLCB5ID0gdCwgeCA9IDkgPT09IGwgJiYgZSwgMSA9PT0gbCAmJiBcIm9iamVjdFwiICE9PSB0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBtdChlKSwgKGQgPSB0LmdldEF0dHJpYnV0ZShcImlkXCIpKSA/IG0gPSBkLnJlcGxhY2UobnQsIFwiXFxcXCQmXCIpIDogdC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBtKSwgbSA9IFwiW2lkPSdcIiArIG0gKyBcIiddIFwiLCB1ID0gYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbdV0gPSBtICsgeXQoY1t1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gVi50ZXN0KGUpICYmIHQucGFyZW50Tm9kZSB8fCB0LCB4ID0gYy5qb2luKFwiLFwiKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh4KVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTS5hcHBseShuLCB5LnF1ZXJ5U2VsZWN0b3JBbGwoeCkpLCBuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgfHwgdC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrdChlLnJlcGxhY2UoeiwgXCIkMVwiKSwgdCwgbiwgaSlcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdCgpIHtcbiAgICAgICAgICAgIHZhciBlID0gW107XG4gICAgICAgICAgICBmdW5jdGlvbiB0KG4sIHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5wdXNoKG4gKz0gXCIgXCIpID4gby5jYWNoZUxlbmd0aCAmJiBkZWxldGUgdFtlLnNoaWZ0KCldLCB0W25dID0gclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsdChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZVtiXSA9ICEwLCBlXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXQoZSkge1xuICAgICAgICAgICAgdmFyIHQgPSBmLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiEhZSh0KVxuICAgICAgICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICAgICAgICAgIHJldHVybiExXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCksIHQgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3QoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4gPSBlLnNwbGl0KFwifFwiKSwgciA9IGUubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHItLSlcbiAgICAgICAgICAgICAgICBvLmF0dHJIYW5kbGVbbltyXV0gPSB0XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHQoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0ICYmIGUsIHIgPSBuICYmIDEgPT09IGUubm9kZVR5cGUgJiYgMSA9PT0gdC5ub2RlVHlwZSAmJiAofnQuc291cmNlSW5kZXggfHwgRCkgLSAofmUuc291cmNlSW5kZXggfHwgRCk7XG4gICAgICAgICAgICBpZiAocilcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuID0gbi5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4tMTtcbiAgICAgICAgICAgIHJldHVybiBlID8gMSA6IC0xXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuXCJpbnB1dFwiID09PSBuICYmIHQudHlwZSA9PT0gZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGR0KGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybihcImlucHV0XCIgPT09IG4gfHwgXCJidXR0b25cIiA9PT0gbikgJiYgdC50eXBlID09PSBlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaHQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGx0KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQgPSArdCwgbHQoZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSBlKFtdLCBuLmxlbmd0aCwgdCksIGEgPSBvLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGEtLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5baSA9IG9bYV1dICYmIChuW2ldID0gIShyW2ldID0gbltpXSkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcyA9IGF0LmlzWE1MID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZSAmJiAoZS5vd25lckRvY3VtZW50IHx8IGUpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHJldHVybiB0ID8gXCJIVE1MXCIgIT09IHQubm9kZU5hbWUgOiAhMVxuICAgICAgICB9LCByID0gYXQuc3VwcG9ydCA9IHt9LCBwID0gYXQuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIG4gPSBlID8gZS5vd25lckRvY3VtZW50IHx8IGUgOiB3LCBpID0gbi5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIHJldHVybiBuICE9PSBmICYmIDkgPT09IG4ubm9kZVR5cGUgJiYgbi5kb2N1bWVudEVsZW1lbnQgPyAoZiA9IG4sIGQgPSBuLmRvY3VtZW50RWxlbWVudCwgaCA9ICFzKG4pLCBpICYmIGkuYXR0YWNoRXZlbnQgJiYgaSAhPT0gaS50b3AgJiYgaS5hdHRhY2hFdmVudChcIm9uYmVmb3JldW5sb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwKClcbiAgICAgICAgICAgIH0pLCByLmF0dHJpYnV0ZXMgPSB1dChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmNsYXNzTmFtZSA9IFwiaVwiLCAhZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIilcbiAgICAgICAgICAgIH0pLCByLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5hcHBlbmRDaGlsZChuLmNyZWF0ZUNvbW1lbnQoXCJcIikpLCAhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoXG4gICAgICAgICAgICB9KSwgci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2EnPjwvZGl2PjxkaXYgY2xhc3M9J2EgaSc+PC9kaXY+XCIsIGUuZmlyc3RDaGlsZC5jbGFzc05hbWUgPSBcImlcIiwgMiA9PT0gZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaVwiKS5sZW5ndGhcbiAgICAgICAgICAgIH0pLCByLmdldEJ5SWQgPSB1dChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmFwcGVuZENoaWxkKGUpLmlkID0gYiwgIW4uZ2V0RWxlbWVudHNCeU5hbWUgfHwgIW4uZ2V0RWxlbWVudHNCeU5hbWUoYikubGVuZ3RoXG4gICAgICAgICAgICB9KSwgci5nZXRCeUlkID8gKG8uZmluZC5JRCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0LmdldEVsZW1lbnRCeUlkICE9PSBqICYmIGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0LmdldEVsZW1lbnRCeUlkKGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAmJiBuLnBhcmVudE5vZGUgPyBbbl0gOiBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG8uZmlsdGVyLklEID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUucmVwbGFjZShydCwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pIDogKGRlbGV0ZSBvLmZpbmQuSUQsIG8uZmlsdGVyLklEID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUucmVwbGFjZShydCwgaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHR5cGVvZiBlLmdldEF0dHJpYnV0ZU5vZGUgIT09IGogJiYgZS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuICYmIG4udmFsdWUgPT09IHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgby5maW5kLlRBRyA9IHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygbi5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gaiA/IG4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSkgOiB0XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiwgciA9IFtdLCBpID0gMCwgbyA9IHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk7XG4gICAgICAgICAgICAgICAgaWYgKFwiKlwiID09PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuID0gb1tpKytdKVxuICAgICAgICAgICAgICAgICAgICAgICAgMSA9PT0gbi5ub2RlVHlwZSAmJiByLnB1c2gobik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvXG4gICAgICAgICAgICB9LCBvLmZpbmQuQ0xBU1MgPSByLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG4uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gaiAmJiBoID8gbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGUpIDogdFxuICAgICAgICAgICAgfSwgbSA9IFtdLCBnID0gW10sIChyLnFzYSA9IEsudGVzdChuLnF1ZXJ5U2VsZWN0b3JBbGwpKSAmJiAodXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLmlubmVySFRNTCA9IFwiPHNlbGVjdD48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCB8fCBnLnB1c2goXCJcXFxcW1wiICsgUCArIFwiKig/OnZhbHVlfFwiICsgQiArIFwiKVwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoIHx8IGcucHVzaChcIjpjaGVja2VkXCIpXG4gICAgICAgICAgICB9KSwgdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IG4uY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgIHQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKSwgZS5hcHBlbmRDaGlsZCh0KS5zZXRBdHRyaWJ1dGUoXCJ0XCIsIFwiXCIpLCBlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbdF49JyddXCIpLmxlbmd0aCAmJiBnLnB1c2goXCJbKl4kXT1cIiArIFAgKyBcIiooPzonJ3xcXFwiXFxcIilcIiksIGUucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCB8fCBnLnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKSwgZS5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKSwgZy5wdXNoKFwiLC4qOlwiKVxuICAgICAgICAgICAgfSkpLCAoci5tYXRjaGVzU2VsZWN0b3IgPSBLLnRlc3QoeSA9IGQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGQubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGQub01hdGNoZXNTZWxlY3RvciB8fCBkLm1zTWF0Y2hlc1NlbGVjdG9yKSkgJiYgdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByLmRpc2Nvbm5lY3RlZE1hdGNoID0geS5jYWxsKGUsIFwiZGl2XCIpLCB5LmNhbGwoZSwgXCJbcyE9JyddOnhcIiksIG0ucHVzaChcIiE9XCIsIEkpXG4gICAgICAgICAgICB9KSwgZyA9IGcubGVuZ3RoICYmIFJlZ0V4cChnLmpvaW4oXCJ8XCIpKSwgbSA9IG0ubGVuZ3RoICYmIFJlZ0V4cChtLmpvaW4oXCJ8XCIpKSwgdiA9IEsudGVzdChkLmNvbnRhaW5zKSB8fCBkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID8gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IDkgPT09IGUubm9kZVR5cGUgPyBlLmRvY3VtZW50RWxlbWVudCA6IGUsIHIgPSB0ICYmIHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA9PT0gciB8fCAhKCFyIHx8IDEgIT09IHIubm9kZVR5cGUgfHwgIShuLmNvbnRhaW5zID8gbi5jb250YWlucyhyKSA6IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgMTYgJiBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHIpKSlcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgIGlmICh0KVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IHQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID09PSBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiEwO1xuICAgICAgICAgICAgICAgIHJldHVybiExXG4gICAgICAgICAgICB9LCBBID0gZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTID0gITAsIDA7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA/IDEgJiBpIHx8ICFyLnNvcnREZXRhY2hlZCAmJiB0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUpID09PSBpID8gZSA9PT0gbiB8fCB2KHcsIGUpID8gLTEgOiB0ID09PSBuIHx8IHYodywgdCkgPyAxIDogYyA/IEYuY2FsbChjLCBlKSAtIEYuY2FsbChjLCB0KSA6IDAgOiA0ICYgaSA/IC0xIDogMSA6IGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gPyAtMSA6IDFcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgIHZhciByLCBpID0gMCwgbyA9IGUucGFyZW50Tm9kZSwgYSA9IHQucGFyZW50Tm9kZSwgcyA9IFtlXSwgbCA9IFt0XTtcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFMgPSAhMCwgMDtcbiAgICAgICAgICAgICAgICBpZiAoIW8gfHwgIWEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlID09PSBuID8gLTEgOiB0ID09PSBuID8gMSA6IG8gPyAtMSA6IGEgPyAxIDogYyA/IEYuY2FsbChjLCBlKSAtIEYuY2FsbChjLCB0KSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKG8gPT09IGEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwdChlLCB0KTtcbiAgICAgICAgICAgICAgICByID0gZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAociA9IHIucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgcy51bnNoaWZ0KHIpO1xuICAgICAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChyID0gci5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBsLnVuc2hpZnQocik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNbaV0gPT09IGxbaV0pXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA/IHB0KHNbaV0sIGxbaV0pIDogc1tpXSA9PT0gdyA/IC0xIDogbFtpXSA9PT0gdyA/IDEgOiAwXG4gICAgICAgICAgICB9LCBuKSA6IGZcbiAgICAgICAgfSwgYXQubWF0Y2hlcyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXQoZSwgbnVsbCwgbnVsbCwgdClcbiAgICAgICAgfSwgYXQubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIGlmICgoZS5vd25lckRvY3VtZW50IHx8IGUpICE9PSBmICYmIHAoZSksIHQgPSB0LnJlcGxhY2UoWSwgXCI9JyQxJ11cIiksICEoIXIubWF0Y2hlc1NlbGVjdG9yIHx8ICFoIHx8IG0gJiYgbS50ZXN0KHQpIHx8IGcgJiYgZy50ZXN0KHQpKSlcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHkuY2FsbChlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gfHwgci5kaXNjb25uZWN0ZWRNYXRjaCB8fCBlLmRvY3VtZW50ICYmIDExICE9PSBlLmRvY3VtZW50Lm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0KHQsIGYsIG51bGwsIFtlXSkubGVuZ3RoID4gMFxuICAgICAgICB9LCBhdC5jb250YWlucyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4oZS5vd25lckRvY3VtZW50IHx8IGUpICE9PSBmICYmIHAoZSksIHYoZSwgdClcbiAgICAgICAgfSwgYXQuYXR0ciA9IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICAoZS5vd25lckRvY3VtZW50IHx8IGUpICE9PSBmICYmIHAoZSk7XG4gICAgICAgICAgICB2YXIgaSA9IG8uYXR0ckhhbmRsZVtuLnRvTG93ZXJDYXNlKCldLCBhID0gaSAmJiBMLmNhbGwoby5hdHRySGFuZGxlLCBuLnRvTG93ZXJDYXNlKCkpID8gaShlLCBuLCAhaCkgOiB0O1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IHQgPyByLmF0dHJpYnV0ZXMgfHwgIWggPyBlLmdldEF0dHJpYnV0ZShuKSA6IChhID0gZS5nZXRBdHRyaWJ1dGVOb2RlKG4pKSAmJiBhLnNwZWNpZmllZCA/IGEudmFsdWUgOiBudWxsIDogYVxuICAgICAgICB9LCBhdC5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgZSlcbiAgICAgICAgfSwgYXQudW5pcXVlU29ydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCwgbiA9IFtdLCBpID0gMCwgbyA9IDA7XG4gICAgICAgICAgICBpZiAoUyA9ICFyLmRldGVjdER1cGxpY2F0ZXMsIGMgPSAhci5zb3J0U3RhYmxlICYmIGUuc2xpY2UoMCksIGUuc29ydChBKSwgUykge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0ID0gZVtvKytdKVxuICAgICAgICAgICAgICAgICAgICB0ID09PSBlW29dICYmIChpID0gbi5wdXNoKG8pKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICBlLnNwbGljZShuW2ldLCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgfSwgYSA9IGF0LmdldFRleHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQsIG4gPSBcIlwiLCByID0gMCwgaSA9IGUubm9kZVR5cGU7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIGlmICgxID09PSBpIHx8IDkgPT09IGkgfHwgMTEgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUudGV4dENvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlID0gZS5maXJzdENoaWxkOyBlOyBlID0gZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gYShlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoMyA9PT0gaSB8fCA0ID09PSBpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5ub2RlVmFsdWVcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGZvciAoOyB0ID0gZVtyXTsgcisrKVxuICAgICAgICAgICAgICAgICAgICBuICs9IGEodCk7XG4gICAgICAgICAgICByZXR1cm4gblxuICAgICAgICB9LCBvID0gYXQuc2VsZWN0b3JzID0ge2NhY2hlTGVuZ3RoOiA1MCwgY3JlYXRlUHNldWRvOiBsdCwgbWF0Y2g6IFEsIGF0dHJIYW5kbGU6IHt9LCBmaW5kOiB7fSwgcmVsYXRpdmU6IHtcIj5cIjoge2RpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiAhMH0sIFwiIFwiOiB7ZGlyOiBcInBhcmVudE5vZGVcIn0sIFwiK1wiOiB7ZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogITB9LCBcIn5cIjoge2RpcjogXCJwcmV2aW91c1NpYmxpbmdcIn19LCBwcmVGaWx0ZXI6IHtBVFRSOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVsxXSA9IGVbMV0ucmVwbGFjZShydCwgaXQpLCBlWzNdID0gKGVbNF0gfHwgZVs1XSB8fCBcIlwiKS5yZXBsYWNlKHJ0LCBpdCksIFwifj1cIiA9PT0gZVsyXSAmJiAoZVszXSA9IFwiIFwiICsgZVszXSArIFwiIFwiKSwgZS5zbGljZSgwLCA0KVxuICAgICAgICAgICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVsxXSA9IGVbMV0udG9Mb3dlckNhc2UoKSwgXCJudGhcIiA9PT0gZVsxXS5zbGljZSgwLCAzKSA/IChlWzNdIHx8IGF0LmVycm9yKGVbMF0pLCBlWzRdID0gKyhlWzRdID8gZVs1XSArIChlWzZdIHx8IDEpIDogMiAqIChcImV2ZW5cIiA9PT0gZVszXSB8fCBcIm9kZFwiID09PSBlWzNdKSksIGVbNV0gPSArKGVbN10gKyBlWzhdIHx8IFwib2RkXCIgPT09IGVbM10pKSA6IGVbM10gJiYgYXQuZXJyb3IoZVswXSksIGVcbiAgICAgICAgICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuLCByID0gIWVbNV0gJiYgZVsyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEuQ0hJTEQudGVzdChlWzBdKSA/IG51bGwgOiAoZVszXSAmJiBlWzRdICE9PSB0ID8gZVsyXSA9IGVbNF0gOiByICYmIEoudGVzdChyKSAmJiAobiA9IG10KHIsICEwKSkgJiYgKG4gPSByLmluZGV4T2YoXCIpXCIsIHIubGVuZ3RoIC0gbikgLSByLmxlbmd0aCkgJiYgKGVbMF0gPSBlWzBdLnNsaWNlKDAsIG4pLCBlWzJdID0gci5zbGljZSgwLCBuKSksIGUuc2xpY2UoMCwgMykpXG4gICAgICAgICAgICAgICAgfX0sIGZpbHRlcjoge1RBRzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnJlcGxhY2UocnQsIGl0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cIipcIiA9PT0gZSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiEwXG4gICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubm9kZU5hbWUgJiYgZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBDTEFTUzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBOW2UgKyBcIiBcIl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0IHx8ICh0ID0gUmVnRXhwKFwiKF58XCIgKyBQICsgXCIpXCIgKyBlICsgXCIoXCIgKyBQICsgXCJ8JClcIikpICYmIE4oZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0LnRlc3QoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5jbGFzc05hbWUgJiYgZS5jbGFzc05hbWUgfHwgdHlwZW9mIGUuZ2V0QXR0cmlidXRlICE9PSBqICYmIGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LCBBVFRSOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gYXQuYXR0cihyLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09IGkgPyBcIiE9XCIgPT09IHQgOiB0ID8gKGkgKz0gXCJcIiwgXCI9XCIgPT09IHQgPyBpID09PSBuIDogXCIhPVwiID09PSB0ID8gaSAhPT0gbiA6IFwiXj1cIiA9PT0gdCA/IG4gJiYgMCA9PT0gaS5pbmRleE9mKG4pIDogXCIqPVwiID09PSB0ID8gbiAmJiBpLmluZGV4T2YobikgPiAtMSA6IFwiJD1cIiA9PT0gdCA/IG4gJiYgaS5zbGljZSgtbi5sZW5ndGgpID09PSBuIDogXCJ+PVwiID09PSB0ID8gKFwiIFwiICsgaSArIFwiIFwiKS5pbmRleE9mKG4pID4gLTEgOiBcInw9XCIgPT09IHQgPyBpID09PSBuIHx8IGkuc2xpY2UoMCwgbi5sZW5ndGggKyAxKSA9PT0gbiArIFwiLVwiIDogITEpIDogITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiAoZSwgdCwgbiwgciwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IFwibnRoXCIgIT09IGUuc2xpY2UoMCwgMyksIGEgPSBcImxhc3RcIiAhPT0gZS5zbGljZSgtNCksIHMgPSBcIm9mLXR5cGVcIiA9PT0gdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgPT09IHIgJiYgMCA9PT0gaSA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hIWUucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHQsIG4sIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1LCBjLCBwLCBmLCBkLCBoLCBnID0gbyAhPT0gYSA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsIG0gPSB0LnBhcmVudE5vZGUsIHkgPSBzICYmIHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgdiA9ICFsICYmICFzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCA9IHBbZ10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPyBwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHkgOiAxID09PSBwLm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBnID0gXCJvbmx5XCIgPT09IGUgJiYgIWggJiYgXCJuZXh0U2libGluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggPSBbYSA/IG0uZmlyc3RDaGlsZCA6IG0ubGFzdENoaWxkXSwgYSAmJiB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBtW2JdIHx8IChtW2JdID0ge30pLCB1ID0gY1tlXSB8fCBbXSwgZCA9IHVbMF0gPT09IFQgJiYgdVsxXSwgZiA9IHVbMF0gPT09IFQgJiYgdVsyXSwgcCA9IGQgJiYgbS5jaGlsZE5vZGVzW2RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCA9ICsrZCAmJiBwICYmIHBbZ10gfHwgKGYgPSBkID0gMCkgfHwgaC5wb3AoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgxID09PSBwLm5vZGVUeXBlICYmICsrZiAmJiBwID09PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tlXSA9IFtULCBkLCBmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiAmJiAodSA9ICh0W2JdIHx8ICh0W2JdID0ge30pKVtlXSkgJiYgdVswXSA9PT0gVClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocCA9ICsrZCAmJiBwICYmIHBbZ10gfHwgKGYgPSBkID0gMCkgfHwgaC5wb3AoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocyA/IHAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0geSA6IDEgPT09IHAubm9kZVR5cGUpICYmICsrZiAmJiAodiAmJiAoKHBbYl0gfHwgKHBbYl0gPSB7fSkpW2VdID0gW1QsIGZdKSwgcCA9PT0gdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYgLT0gaSwgZiA9PT0gciB8fCAwID09PSBmICUgciAmJiBmIC8gciA+PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuLCByID0gby5wc2V1ZG9zW2VdIHx8IG8uc2V0RmlsdGVyc1tlLnRvTG93ZXJDYXNlKCldIHx8IGF0LmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcltiXSA/IHIodCkgOiByLmxlbmd0aCA+IDEgPyAobiA9IFtlLCBlLCBcIlwiLCB0XSwgby5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KGUudG9Mb3dlckNhc2UoKSkgPyBsdChmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIG8gPSByKGUsIHQpLCBhID0gby5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBGLmNhbGwoZSwgb1thXSksIGVbaV0gPSAhKG5baV0gPSBvW2FdKVxuICAgICAgICAgICAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcihlLCAwLCBuKVxuICAgICAgICAgICAgICAgICAgICB9KSA6IHJcbiAgICAgICAgICAgICAgICB9fSwgcHNldWRvczoge25vdDogbHQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBbXSwgbiA9IFtdLCByID0gbChlLnJlcGxhY2UoeiwgXCIkMVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByW2JdID8gbHQoZnVuY3Rpb24gKGUsIHQsIG4sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvLCBhID0gcihlLCBudWxsLCBpLCBbXSksIHMgPSBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG8gPSBhW3NdKSAmJiAoZVtzXSA9ICEodFtzXSA9IG8pKVxuICAgICAgICAgICAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFswXSA9IGUsIHIodCwgbnVsbCwgbywgbiksICFuLnBvcCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgaGFzOiBsdChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdChlLCB0KS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgY29udGFpbnM6IGx0KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuKHQudGV4dENvbnRlbnQgfHwgdC5pbm5lclRleHQgfHwgYSh0KSkuaW5kZXhPZihlKSA+IC0xXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgbGFuZzogbHQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEcudGVzdChlIHx8IFwiXCIpIHx8IGF0LmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBlKSwgZSA9IGUucmVwbGFjZShydCwgaXQpLnRvTG93ZXJDYXNlKCksIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPSBoID8gdC5sYW5nIDogdC5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCB0LmdldEF0dHJpYnV0ZShcImxhbmdcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuID0gbi50b0xvd2VyQ2FzZSgpLCBuID09PSBlIHx8IDAgPT09IG4uaW5kZXhPZihlICsgXCItXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh0ID0gdC5wYXJlbnROb2RlKSAmJiAxID09PSB0Lm5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiExXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgdGFyZ2V0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUubG9jYXRpb24gJiYgZS5sb2NhdGlvbi5oYXNoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiAmJiBuLnNsaWNlKDEpID09PSB0LmlkXG4gICAgICAgICAgICAgICAgfSwgcm9vdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IGRcbiAgICAgICAgICAgICAgICB9LCBmb2N1czogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IGYuYWN0aXZlRWxlbWVudCAmJiAoIWYuaGFzRm9jdXMgfHwgZi5oYXNGb2N1cygpKSAmJiAhIShlLnR5cGUgfHwgZS5ocmVmIHx8IH5lLnRhYkluZGV4KVxuICAgICAgICAgICAgICAgIH0sIGVuYWJsZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmRpc2FibGVkID09PSAhMVxuICAgICAgICAgICAgICAgIH0sIGRpc2FibGVkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5kaXNhYmxlZCA9PT0gITBcbiAgICAgICAgICAgICAgICB9LCBjaGVja2VkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXCJpbnB1dFwiID09PSB0ICYmICEhZS5jaGVja2VkIHx8IFwib3B0aW9uXCIgPT09IHQgJiYgISFlLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgfSwgc2VsZWN0ZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnBhcmVudE5vZGUgJiYgZS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsIGUuc2VsZWN0ZWQgPT09ICEwXG4gICAgICAgICAgICAgICAgfSwgZW1wdHk6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoZSA9IGUuZmlyc3RDaGlsZDsgZTsgZSA9IGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5ub2RlTmFtZSA+IFwiQFwiIHx8IDMgPT09IGUubm9kZVR5cGUgfHwgNCA9PT0gZS5ub2RlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuITBcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiFvLnBzZXVkb3MuZW1wdHkoZSlcbiAgICAgICAgICAgICAgICB9LCBoZWFkZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0dC50ZXN0KGUubm9kZU5hbWUpXG4gICAgICAgICAgICAgICAgfSwgaW5wdXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldC50ZXN0KGUubm9kZU5hbWUpXG4gICAgICAgICAgICAgICAgfSwgYnV0dG9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXCJpbnB1dFwiID09PSB0ICYmIFwiYnV0dG9uXCIgPT09IGUudHlwZSB8fCBcImJ1dHRvblwiID09PSB0XG4gICAgICAgICAgICAgICAgfSwgdGV4dDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblwiaW5wdXRcIiA9PT0gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIFwidGV4dFwiID09PSBlLnR5cGUgJiYgKG51bGwgPT0gKHQgPSBlLmdldEF0dHJpYnV0ZShcInR5cGVcIikpIHx8IHQudG9Mb3dlckNhc2UoKSA9PT0gZS50eXBlKVxuICAgICAgICAgICAgICAgIH0sIGZpcnN0OiBodChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblswXVxuICAgICAgICAgICAgICAgIH0pLCBsYXN0OiBodChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5bdCAtIDFdXG4gICAgICAgICAgICAgICAgfSksIGVxOiBodChmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5bMCA+IG4gPyBuICsgdCA6IG5dXG4gICAgICAgICAgICAgICAgfSksIGV2ZW46IGh0KGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHQgPiBuOyBuICs9IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnB1c2gobik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgICAgICAgICAgfSksIG9kZDogaHQoZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAxO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgdCA+IG47IG4gKz0gMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICB9KSwgbHQ6IGh0KGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gMCA+IG4gPyBuICsgdCA6IG47XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyAtLXIgPj0gMDsgKVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgIH0pLCBndDogaHQoZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAwID4gbiA/IG4gKyB0IDogbjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHQgPiArK3I7IClcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgICAgICAgICB9KX19LCBvLnBzZXVkb3MubnRoID0gby5wc2V1ZG9zLmVxO1xuICAgICAgICBmb3IgKG4gaW57cmFkaW86ITAsIGNoZWNrYm94OiEwLCBmaWxlOiEwLCBwYXNzd29yZDohMCwgaW1hZ2U6ITB9KVxuICAgICAgICAgICAgby5wc2V1ZG9zW25dID0gZnQobik7XG4gICAgICAgIGZvciAobiBpbntzdWJtaXQ6ITAsIHJlc2V0OiEwfSlcbiAgICAgICAgICAgIG8ucHNldWRvc1tuXSA9IGR0KG4pO1xuICAgICAgICBmdW5jdGlvbiBndCgpIHtcbiAgICAgICAgfVxuICAgICAgICBndC5wcm90b3R5cGUgPSBvLmZpbHRlcnMgPSBvLnBzZXVkb3MsIG8uc2V0RmlsdGVycyA9IG5ldyBndDtcbiAgICAgICAgZnVuY3Rpb24gbXQoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4sIHIsIGksIGEsIHMsIGwsIHUsIGMgPSBrW2UgKyBcIiBcIl07XG4gICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICByZXR1cm4gdCA/IDAgOiBjLnNsaWNlKDApO1xuICAgICAgICAgICAgcyA9IGUsIGwgPSBbXSwgdSA9IG8ucHJlRmlsdGVyO1xuICAgICAgICAgICAgd2hpbGUgKHMpIHtcbiAgICAgICAgICAgICAgICAoIW4gfHwgKHIgPSBYLmV4ZWMocykpKSAmJiAociAmJiAocyA9IHMuc2xpY2UoclswXS5sZW5ndGgpIHx8IHMpLCBsLnB1c2goaSA9IFtdKSksIG4gPSAhMSwgKHIgPSBVLmV4ZWMocykpICYmIChuID0gci5zaGlmdCgpLCBpLnB1c2goe3ZhbHVlOiBuLCB0eXBlOiByWzBdLnJlcGxhY2UoeiwgXCIgXCIpfSksIHMgPSBzLnNsaWNlKG4ubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChhIGluIG8uZmlsdGVyKVxuICAgICAgICAgICAgICAgICAgICAhKHIgPSBRW2FdLmV4ZWMocykpIHx8IHVbYV0gJiYgIShyID0gdVthXShyKSkgfHwgKG4gPSByLnNoaWZ0KCksIGkucHVzaCh7dmFsdWU6IG4sIHR5cGU6IGEsIG1hdGNoZXM6IHJ9KSwgcyA9IHMuc2xpY2Uobi5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdCA/IHMubGVuZ3RoIDogcyA/IGF0LmVycm9yKGUpIDogayhlLCBsKS5zbGljZSgwKVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHl0KGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gMCwgbiA9IGUubGVuZ3RoLCByID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAoOyBuID4gdDsgdCsrKVxuICAgICAgICAgICAgICAgIHIgKz0gZVt0XS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdnQoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIgPSB0LmRpciwgbyA9IG4gJiYgXCJwYXJlbnROb2RlXCIgPT09IHIsIGEgPSBDKys7XG4gICAgICAgICAgICByZXR1cm4gdC5maXJzdCA/IGZ1bmN0aW9uICh0LCBuLCBpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHQgPSB0W3JdKVxuICAgICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gdC5ub2RlVHlwZSB8fCBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUodCwgbiwgaSlcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAodCwgbiwgcykge1xuICAgICAgICAgICAgICAgIHZhciBsLCB1LCBjLCBwID0gVCArIFwiIFwiICsgYTtcbiAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IHRbcl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDEgPT09IHQubm9kZVR5cGUgfHwgbykgJiYgZSh0LCBuLCBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMFxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IHRbcl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gdC5ub2RlVHlwZSB8fCBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID0gdFtiXSB8fCAodFtiXSA9IHt9KSwgKHUgPSBjW3JdKSAmJiB1WzBdID09PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobCA9IHVbMV0pID09PSAhMCB8fCBsID09PSBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwgPT09ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1ID0gY1tyXSA9IFtwXSwgdVsxXSA9IGUodCwgbiwgcykgfHwgaSwgdVsxXSA9PT0gITApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiEwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUubGVuZ3RoID4gMSA/IGZ1bmN0aW9uICh0LCBuLCByKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVbaV0odCwgbiwgcikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgICAgICAgICByZXR1cm4hMFxuICAgICAgICAgICAgfSA6IGVbMF1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB4dChlLCB0LCBuLCByLCBpKSB7XG4gICAgICAgICAgICB2YXIgbywgYSA9IFtdLCBzID0gMCwgbCA9IGUubGVuZ3RoLCB1ID0gbnVsbCAhPSB0O1xuICAgICAgICAgICAgZm9yICg7IGwgPiBzOyBzKyspXG4gICAgICAgICAgICAgICAgKG8gPSBlW3NdKSAmJiAoIW4gfHwgbihvLCByLCBpKSkgJiYgKGEucHVzaChvKSwgdSAmJiB0LnB1c2gocykpO1xuICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3dChlLCB0LCBuLCByLCBpLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gciAmJiAhcltiXSAmJiAociA9IHd0KHIpKSwgaSAmJiAhaVtiXSAmJiAoaSA9IHd0KGksIG8pKSwgbHQoZnVuY3Rpb24gKG8sIGEsIHMsIGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdSwgYywgcCwgZiA9IFtdLCBkID0gW10sIGggPSBhLmxlbmd0aCwgZyA9IG8gfHwgTnQodCB8fCBcIipcIiwgcy5ub2RlVHlwZSA/IFtzXSA6IHMsIFtdKSwgbSA9ICFlIHx8ICFvICYmIHQgPyBnIDogeHQoZywgZiwgZSwgcywgbCksIHkgPSBuID8gaSB8fCAobyA/IGUgOiBoIHx8IHIpID8gW10gOiBhIDogbTtcbiAgICAgICAgICAgICAgICBpZiAobiAmJiBuKG0sIHksIHMsIGwpLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHUgPSB4dCh5LCBkKSwgcih1LCBbXSwgcywgbCksIGMgPSB1Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGMtLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChwID0gdVtjXSkgJiYgKHlbZFtjXV0gPSAhKG1bZFtjXV0gPSBwKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgfHwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gW10sIGMgPSB5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYy0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocCA9IHlbY10pICYmIHUucHVzaChtW2NdID0gcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaShudWxsLCB5ID0gW10sIHUsIGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0geS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYy0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwID0geVtjXSkgJiYgKHUgPSBpID8gRi5jYWxsKG8sIHApIDogZltjXSkgPiAtMSAmJiAob1t1XSA9ICEoYVt1XSA9IHApKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHkgPSB4dCh5ID09PSBhID8geS5zcGxpY2UoaCwgeS5sZW5ndGgpIDogeSksIGkgPyBpKG51bGwsIGEsIHksIGwpIDogTS5hcHBseShhLCB5KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBUdChlKSB7XG4gICAgICAgICAgICB2YXIgdCwgbiwgciwgaSA9IGUubGVuZ3RoLCBhID0gby5yZWxhdGl2ZVtlWzBdLnR5cGVdLCBzID0gYSB8fCBvLnJlbGF0aXZlW1wiIFwiXSwgbCA9IGEgPyAxIDogMCwgYyA9IHZ0KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IHRcbiAgICAgICAgICAgIH0sIHMsICEwKSwgcCA9IHZ0KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEYuY2FsbCh0LCBlKSA+IC0xXG4gICAgICAgICAgICB9LCBzLCAhMCksIGYgPSBbZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIWEgJiYgKHIgfHwgbiAhPT0gdSkgfHwgKCh0ID0gbikubm9kZVR5cGUgPyBjKGUsIG4sIHIpIDogcChlLCBuLCByKSlcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIGZvciAoOyBpID4gbDsgbCsrKVxuICAgICAgICAgICAgICAgIGlmIChuID0gby5yZWxhdGl2ZVtlW2xdLnR5cGVdKVxuICAgICAgICAgICAgICAgICAgICBmID0gW3Z0KGJ0KGYpLCBuKV07XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuID0gby5maWx0ZXJbZVtsXS50eXBlXS5hcHBseShudWxsLCBlW2xdLm1hdGNoZXMpLCBuW2JdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHIgPSArK2w7IGkgPiByOyByKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ucmVsYXRpdmVbZVtyXS50eXBlXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3QobCA+IDEgJiYgYnQoZiksIGwgPiAxICYmIHl0KGUuc2xpY2UoMCwgbCAtIDEpLmNvbmNhdCh7dmFsdWU6IFwiIFwiID09PSBlW2wgLSAyXS50eXBlID8gXCIqXCIgOiBcIlwifSkpLnJlcGxhY2UoeiwgXCIkMVwiKSwgbiwgciA+IGwgJiYgVHQoZS5zbGljZShsLCByKSksIGkgPiByICYmIFR0KGUgPSBlLnNsaWNlKHIpKSwgaSA+IHIgJiYgeXQoZSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZi5wdXNoKG4pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ0KGYpXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQ3QoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4gPSAwLCByID0gdC5sZW5ndGggPiAwLCBhID0gZS5sZW5ndGggPiAwLCBzID0gZnVuY3Rpb24gKHMsIGwsIGMsIHAsIGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaCwgZywgbSwgeSA9IFtdLCB2ID0gMCwgYiA9IFwiMFwiLCB4ID0gcyAmJiBbXSwgdyA9IG51bGwgIT0gZCwgQyA9IHUsIE4gPSBzIHx8IGEgJiYgby5maW5kLlRBRyhcIipcIiwgZCAmJiBsLnBhcmVudE5vZGUgfHwgbCksIGsgPSBUICs9IG51bGwgPT0gQyA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IC4xO1xuICAgICAgICAgICAgICAgIGZvciAodyAmJiAodSA9IGwgIT09IGYgJiYgbCwgaSA9IG4pOyBudWxsICE9IChoID0gTltiXSk7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSAmJiBoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChtID0gZVtnKytdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtKGgsIGwsIGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAucHVzaChoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICYmIChUID0gaywgaSA9ICsrbilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByICYmICgoaCA9ICFtICYmIGgpICYmIHYtLSwgcyAmJiB4LnB1c2goaCkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2ICs9IGIsIHIgJiYgYiAhPT0gdikge1xuICAgICAgICAgICAgICAgICAgICBnID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG0gPSB0W2crK10pXG4gICAgICAgICAgICAgICAgICAgICAgICBtKHgsIHksIGwsIGMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhbYl0gfHwgeVtiXSB8fCAoeVtiXSA9IHEuY2FsbChwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0geHQoeSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBNLmFwcGx5KHAsIHkpLCB3ICYmICFzICYmIHkubGVuZ3RoID4gMCAmJiB2ICsgdC5sZW5ndGggPiAxICYmIGF0LnVuaXF1ZVNvcnQocClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHcgJiYgKFQgPSBrLCB1ID0gQyksIHhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gciA/IGx0KHMpIDogc1xuICAgICAgICB9XG4gICAgICAgIGwgPSBhdC5jb21waWxlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuLCByID0gW10sIGkgPSBbXSwgbyA9IEVbZSArIFwiIFwiXTtcbiAgICAgICAgICAgIGlmICghbykge1xuICAgICAgICAgICAgICAgIHQgfHwgKHQgPSBtdChlKSksIG4gPSB0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobi0tKVxuICAgICAgICAgICAgICAgICAgICBvID0gVHQodFtuXSksIG9bYl0gPyByLnB1c2gobykgOiBpLnB1c2gobyk7XG4gICAgICAgICAgICAgICAgbyA9IEUoZSwgQ3QoaSwgcikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBOdChlLCB0LCBuKSB7XG4gICAgICAgICAgICB2YXIgciA9IDAsIGkgPSB0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpID4gcjsgcisrKVxuICAgICAgICAgICAgICAgIGF0KGUsIHRbcl0sIG4pO1xuICAgICAgICAgICAgcmV0dXJuIG5cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBrdChlLCB0LCBuLCBpKSB7XG4gICAgICAgICAgICB2YXIgYSwgcywgdSwgYywgcCwgZiA9IG10KGUpO1xuICAgICAgICAgICAgaWYgKCFpICYmIDEgPT09IGYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMgPSBmWzBdID0gZlswXS5zbGljZSgwKSwgcy5sZW5ndGggPiAyICYmIFwiSURcIiA9PT0gKHUgPSBzWzBdKS50eXBlICYmIHIuZ2V0QnlJZCAmJiA5ID09PSB0Lm5vZGVUeXBlICYmIGggJiYgby5yZWxhdGl2ZVtzWzFdLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID0gKG8uZmluZC5JRCh1Lm1hdGNoZXNbMF0ucmVwbGFjZShydCwgaXQpLCB0KSB8fCBbXSlbMF0sICF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgICAgIGUgPSBlLnNsaWNlKHMuc2hpZnQoKS52YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEgPSBRLm5lZWRzQ29udGV4dC50ZXN0KGUpID8gMCA6IHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChhLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPSBzW2FdLCBvLnJlbGF0aXZlW2MgPSB1LnR5cGVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocCA9IG8uZmluZFtjXSkgJiYgKGkgPSBwKHUubWF0Y2hlc1swXS5yZXBsYWNlKHJ0LCBpdCksIFYudGVzdChzWzBdLnR5cGUpICYmIHQucGFyZW50Tm9kZSB8fCB0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNwbGljZShhLCAxKSwgZSA9IGkubGVuZ3RoICYmIHl0KHMpLCAhZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTS5hcHBseShuLCBpKSwgbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbChlLCBmKShpLCB0LCAhaCwgbiwgVi50ZXN0KGUpKSwgblxuICAgICAgICB9XG4gICAgICAgIHIuc29ydFN0YWJsZSA9IGIuc3BsaXQoXCJcIikuc29ydChBKS5qb2luKFwiXCIpID09PSBiLCByLmRldGVjdER1cGxpY2F0ZXMgPSBTLCBwKCksIHIuc29ydERldGFjaGVkID0gdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAxICYgZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihmLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpXG4gICAgICAgIH0pLCB1dChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCIsIFwiI1wiID09PSBlLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuICAgICAgICB9KSB8fCBjdChcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiByID8gdCA6IGUuZ2V0QXR0cmlidXRlKG4sIFwidHlwZVwiID09PSBuLnRvTG93ZXJDYXNlKCkgPyAxIDogMilcbiAgICAgICAgfSksIHIuYXR0cmlidXRlcyAmJiB1dChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiLCBlLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgXCJcIiksIFwiXCIgPT09IGUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuICAgICAgICB9KSB8fCBjdChcInZhbHVlXCIsIGZ1bmN0aW9uIChlLCBuLCByKSB7XG4gICAgICAgICAgICByZXR1cm4gciB8fCBcImlucHV0XCIgIT09IGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA/IHQgOiBlLmRlZmF1bHRWYWx1ZVxuICAgICAgICB9KSwgdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGUuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIilcbiAgICAgICAgfSkgfHwgY3QoQiwgZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgcmV0dXJuIHIgPyB0IDogKGkgPSBlLmdldEF0dHJpYnV0ZU5vZGUobikpICYmIGkuc3BlY2lmaWVkID8gaS52YWx1ZSA6IGVbbl0gPT09ICEwID8gbi50b0xvd2VyQ2FzZSgpIDogbnVsbFxuICAgICAgICB9KSwgeC5maW5kID0gYXQsIHguZXhwciA9IGF0LnNlbGVjdG9ycywgeC5leHByW1wiOlwiXSA9IHguZXhwci5wc2V1ZG9zLCB4LnVuaXF1ZSA9IGF0LnVuaXF1ZVNvcnQsIHgudGV4dCA9IGF0LmdldFRleHQsIHguaXNYTUxEb2MgPSBhdC5pc1hNTCwgeC5jb250YWlucyA9IGF0LmNvbnRhaW5zXG4gICAgfShlKTtcbiAgICB2YXIgTyA9IHt9O1xuICAgIGZ1bmN0aW9uIEYoZSkge1xuICAgICAgICB2YXIgdCA9IE9bZV0gPSB7fTtcbiAgICAgICAgcmV0dXJuIHguZWFjaChlLm1hdGNoKFQpIHx8IFtdLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgdFtuXSA9ICEwXG4gICAgICAgIH0pLCB0XG4gICAgfVxuICAgIHguQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBPW2VdIHx8IEYoZSkgOiB4LmV4dGVuZCh7fSwgZSk7XG4gICAgICAgIHZhciBuLCByLCBpLCBvLCBhLCBzLCBsID0gW10sIHUgPSAhZS5vbmNlICYmIFtdLCBjID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGZvciAociA9IGUubWVtb3J5ICYmIHQsIGkgPSAhMCwgYSA9IHMgfHwgMCwgcyA9IDAsIG8gPSBsLmxlbmd0aCwgbiA9ICEwOyBsICYmIG8gPiBhOyBhKyspXG4gICAgICAgICAgICAgICAgaWYgKGxbYV0uYXBwbHkodFswXSwgdFsxXSkgPT09ICExICYmIGUuc3RvcE9uRmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9ICExO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSAhMSwgbCAmJiAodSA/IHUubGVuZ3RoICYmIGModS5zaGlmdCgpKSA6IHIgPyBsID0gW10gOiBwLmRpc2FibGUoKSlcbiAgICAgICAgfSwgcCA9IHthZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGwubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gaSh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LmVhY2godCwgZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHgudHlwZShuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHIgPyBlLnVuaXF1ZSAmJiBwLmhhcyhuKSB8fCBsLnB1c2gobikgOiBuICYmIG4ubGVuZ3RoICYmIFwic3RyaW5nXCIgIT09IHIgJiYgaShuKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSkoYXJndW1lbnRzKSwgbiA/IG8gPSBsLmxlbmd0aCA6IHIgJiYgKHMgPSB0LCBjKHIpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGwgJiYgeC5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgociA9IHguaW5BcnJheSh0LCBsLCByKSkgPiAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBsLnNwbGljZShyLCAxKSwgbiAmJiAobyA+PSByICYmIG8tLSwgYSA+PSByICYmIGEtLSlcbiAgICAgICAgICAgICAgICB9KSwgdGhpc1xuICAgICAgICAgICAgfSwgaGFzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlID8geC5pbkFycmF5KGUsIGwpID4gLTEgOiAhKCFsIHx8ICFsLmxlbmd0aClcbiAgICAgICAgICAgIH0sIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGwgPSBbXSwgbyA9IDAsIHRoaXNcbiAgICAgICAgICAgIH0sIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbCA9IHUgPSByID0gdCwgdGhpc1xuICAgICAgICAgICAgfSwgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4hbFxuICAgICAgICAgICAgfSwgbG9jazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1ID0gdCwgciB8fCBwLmRpc2FibGUoKSwgdGhpc1xuICAgICAgICAgICAgfSwgbG9ja2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIXVcbiAgICAgICAgICAgIH0sIGZpcmVXaXRoOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiFsIHx8IGkgJiYgIXUgfHwgKHQgPSB0IHx8IFtdLCB0ID0gW2UsIHQuc2xpY2UgPyB0LnNsaWNlKCkgOiB0XSwgbiA/IHUucHVzaCh0KSA6IGModCkpLCB0aGlzXG4gICAgICAgICAgICB9LCBmaXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuZmlyZVdpdGgodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgICAgICAgICAgfSwgZmlyZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4hIWlcbiAgICAgICAgICAgIH19O1xuICAgICAgICByZXR1cm4gcFxuICAgIH0sIHguZXh0ZW5kKHtEZWZlcnJlZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gW1tcInJlc29sdmVcIiwgXCJkb25lXCIsIHguQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIl0sIFtcInJlamVjdFwiLCBcImZhaWxcIiwgeC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiXSwgW1wibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgeC5DYWxsYmFja3MoXCJtZW1vcnlcIildXSwgbiA9IFwicGVuZGluZ1wiLCByID0ge3N0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgICAgICAgfSwgYWx3YXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyksIHRoaXNcbiAgICAgICAgICAgICAgICB9LCB0aGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5EZWZlcnJlZChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeC5lYWNoKHQsIGZ1bmN0aW9uICh0LCBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBvWzBdLCBzID0geC5pc0Z1bmN0aW9uKGVbdF0pICYmIGVbdF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVtvWzFdXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gcyAmJiBzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgJiYgeC5pc0Z1bmN0aW9uKGUucHJvbWlzZSkgPyBlLnByb21pc2UoKS5kb25lKG4ucmVzb2x2ZSkuZmFpbChuLnJlamVjdCkucHJvZ3Jlc3Mobi5ub3RpZnkpIDogblthICsgXCJXaXRoXCJdKHRoaXMgPT09IHIgPyBuLnByb21pc2UoKSA6IHRoaXMsIHMgPyBbZV0gOiBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBlID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KS5wcm9taXNlKClcbiAgICAgICAgICAgICAgICB9LCBwcm9taXNlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAhPSBlID8geC5leHRlbmQoZSwgcikgOiByXG4gICAgICAgICAgICAgICAgfX0sIGkgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiByLnBpcGUgPSByLnRoZW4sIHguZWFjaCh0LCBmdW5jdGlvbiAoZSwgbykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gb1syXSwgcyA9IG9bM107XG4gICAgICAgICAgICAgICAgcltvWzFdXSA9IGEuYWRkLCBzICYmIGEuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHNcbiAgICAgICAgICAgICAgICB9LCB0WzEgXiBlXVsyXS5kaXNhYmxlLCB0WzJdWzJdLmxvY2spLCBpW29bMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVtvWzBdICsgXCJXaXRoXCJdKHRoaXMgPT09IGkgPyByIDogdGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgICAgICAgICAgICAgIH0sIGlbb1swXSArIFwiV2l0aFwiXSA9IGEuZmlyZVdpdGhcbiAgICAgICAgICAgIH0pLCByLnByb21pc2UoaSksIGUgJiYgZS5jYWxsKGksIGkpLCBpXG4gICAgICAgIH0sIHdoZW46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IDAsIG4gPSBnLmNhbGwoYXJndW1lbnRzKSwgciA9IG4ubGVuZ3RoLCBpID0gMSAhPT0gciB8fCBlICYmIHguaXNGdW5jdGlvbihlLnByb21pc2UpID8gciA6IDAsIG8gPSAxID09PSBpID8gZSA6IHguRGVmZXJyZWQoKSwgYSA9IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRbZV0gPSB0aGlzLCBuW2VdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBnLmNhbGwoYXJndW1lbnRzKSA6IHIsIG4gPT09IHMgPyBvLm5vdGlmeVdpdGgodCwgbikgOiAtLWkgfHwgby5yZXNvbHZlV2l0aCh0LCBuKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHMsIGwsIHU7XG4gICAgICAgICAgICBpZiAociA+IDEpXG4gICAgICAgICAgICAgICAgZm9yIChzID0gQXJyYXkociksIGwgPSBBcnJheShyKSwgdSA9IEFycmF5KHIpOyByID4gdDsgdCsrKVxuICAgICAgICAgICAgICAgICAgICBuW3RdICYmIHguaXNGdW5jdGlvbihuW3RdLnByb21pc2UpID8gblt0XS5wcm9taXNlKCkuZG9uZShhKHQsIHUsIG4pKS5mYWlsKG8ucmVqZWN0KS5wcm9ncmVzcyhhKHQsIGwsIHMpKSA6IC0taTtcbiAgICAgICAgICAgIHJldHVybiBpIHx8IG8ucmVzb2x2ZVdpdGgodSwgbiksIG8ucHJvbWlzZSgpXG4gICAgICAgIH19KSwgeC5zdXBwb3J0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIG4sIHIsIG8sIHMsIGwsIHUsIGMsIHAsIGYsIGQgPSBhLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmIChkLnNldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiLCBcInRcIiksIGQuaW5uZXJIVE1MID0gXCIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz5cIiwgbiA9IGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHx8IFtdLCByID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIilbMF0sICFyIHx8ICFyLnN0eWxlIHx8ICFuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICBzID0gYS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLCB1ID0gcy5hcHBlbmRDaGlsZChhLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpLCBvID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdLCByLnN0eWxlLmNzc1RleHQgPSBcInRvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCIsIHQuZ2V0U2V0QXR0cmlidXRlID0gXCJ0XCIgIT09IGQuY2xhc3NOYW1lLCB0LmxlYWRpbmdXaGl0ZXNwYWNlID0gMyA9PT0gZC5maXJzdENoaWxkLm5vZGVUeXBlLCB0LnRib2R5ID0gIWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKS5sZW5ndGgsIHQuaHRtbFNlcmlhbGl6ZSA9ICEhZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIikubGVuZ3RoLCB0LnN0eWxlID0gL3RvcC8udGVzdChyLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSwgdC5ocmVmTm9ybWFsaXplZCA9IFwiL2FcIiA9PT0gci5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLCB0Lm9wYWNpdHkgPSAvXjAuNS8udGVzdChyLnN0eWxlLm9wYWNpdHkpLCB0LmNzc0Zsb2F0ID0gISFyLnN0eWxlLmNzc0Zsb2F0LCB0LmNoZWNrT24gPSAhIW8udmFsdWUsIHQub3B0U2VsZWN0ZWQgPSB1LnNlbGVjdGVkLCB0LmVuY3R5cGUgPSAhIWEuY3JlYXRlRWxlbWVudChcImZvcm1cIikuZW5jdHlwZSwgdC5odG1sNUNsb25lID0gXCI8Om5hdj48LzpuYXY+XCIgIT09IGEuY3JlYXRlRWxlbWVudChcIm5hdlwiKS5jbG9uZU5vZGUoITApLm91dGVySFRNTCwgdC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gITEsIHQuc2hyaW5rV3JhcEJsb2NrcyA9ICExLCB0LnBpeGVsUG9zaXRpb24gPSAhMSwgdC5kZWxldGVFeHBhbmRvID0gITAsIHQubm9DbG9uZUV2ZW50ID0gITAsIHQucmVsaWFibGVNYXJnaW5SaWdodCA9ICEwLCB0LmJveFNpemluZ1JlbGlhYmxlID0gITAsIG8uY2hlY2tlZCA9ICEwLCB0Lm5vQ2xvbmVDaGVja2VkID0gby5jbG9uZU5vZGUoITApLmNoZWNrZWQsIHMuZGlzYWJsZWQgPSAhMCwgdC5vcHREaXNhYmxlZCA9ICF1LmRpc2FibGVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIGQudGVzdFxuICAgICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgICAgICB0LmRlbGV0ZUV4cGFuZG8gPSAhMVxuICAgICAgICB9XG4gICAgICAgIG8gPSBhLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSwgby5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBcIlwiKSwgdC5pbnB1dCA9IFwiXCIgPT09IG8uZ2V0QXR0cmlidXRlKFwidmFsdWVcIiksIG8udmFsdWUgPSBcInRcIiwgby5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwicmFkaW9cIiksIHQucmFkaW9WYWx1ZSA9IFwidFwiID09PSBvLnZhbHVlLCBvLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJ0XCIpLCBvLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJ0XCIpLCBsID0gYS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGwuYXBwZW5kQ2hpbGQobyksIHQuYXBwZW5kQ2hlY2tlZCA9IG8uY2hlY2tlZCwgdC5jaGVja0Nsb25lID0gbC5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQsIGQuYXR0YWNoRXZlbnQgJiYgKGQuYXR0YWNoRXZlbnQoXCJvbmNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHQubm9DbG9uZUV2ZW50ID0gITFcbiAgICAgICAgfSksIGQuY2xvbmVOb2RlKCEwKS5jbGljaygpKTtcbiAgICAgICAgZm9yIChmIGlue3N1Ym1pdDohMCwgY2hhbmdlOiEwLCBmb2N1c2luOiEwfSlcbiAgICAgICAgICAgIGQuc2V0QXR0cmlidXRlKGMgPSBcIm9uXCIgKyBmLCBcInRcIiksIHRbZiArIFwiQnViYmxlc1wiXSA9IGMgaW4gZSB8fCBkLmF0dHJpYnV0ZXNbY10uZXhwYW5kbyA9PT0gITE7XG4gICAgICAgIGQuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCIsIGQuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCIsIHQuY2xlYXJDbG9uZVN0eWxlID0gXCJjb250ZW50LWJveFwiID09PSBkLnN0eWxlLmJhY2tncm91bmRDbGlwO1xuICAgICAgICBmb3IgKGYgaW4geCh0KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXR1cm4gdC5vd25MYXN0ID0gXCIwXCIgIT09IGYsIHgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG4sIHIsIG8sIHMgPSBcInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtcIiwgbCA9IGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuICAgICAgICAgICAgbCAmJiAobiA9IGEuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbi5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweFwiLCBsLmFwcGVuZENoaWxkKG4pLmFwcGVuZENoaWxkKGQpLCBkLmlubmVySFRNTCA9IFwiPHRhYmxlPjx0cj48dGQ+PC90ZD48dGQ+dDwvdGQ+PC90cj48L3RhYmxlPlwiLCBvID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRkXCIpLCBvWzBdLnN0eWxlLmNzc1RleHQgPSBcInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5Om5vbmVcIiwgcCA9IDAgPT09IG9bMF0ub2Zmc2V0SGVpZ2h0LCBvWzBdLnN0eWxlLmRpc3BsYXkgPSBcIlwiLCBvWzFdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgdC5yZWxpYWJsZUhpZGRlbk9mZnNldHMgPSBwICYmIDAgPT09IG9bMF0ub2Zmc2V0SGVpZ2h0LCBkLmlubmVySFRNTCA9IFwiXCIsIGQuc3R5bGUuY3NzVGV4dCA9IFwiYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MXB4O2JvcmRlcjoxcHg7ZGlzcGxheTpibG9jazt3aWR0aDo0cHg7bWFyZ2luLXRvcDoxJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MSU7XCIsIHguc3dhcChsLCBudWxsICE9IGwuc3R5bGUuem9vbSA/IHt6b29tOiAxfSA6IHt9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdC5ib3hTaXppbmcgPSA0ID09PSBkLm9mZnNldFdpZHRoXG4gICAgICAgICAgICB9KSwgZS5nZXRDb21wdXRlZFN0eWxlICYmICh0LnBpeGVsUG9zaXRpb24gPSBcIjElXCIgIT09IChlLmdldENvbXB1dGVkU3R5bGUoZCwgbnVsbCkgfHwge30pLnRvcCwgdC5ib3hTaXppbmdSZWxpYWJsZSA9IFwiNHB4XCIgPT09IChlLmdldENvbXB1dGVkU3R5bGUoZCwgbnVsbCkgfHwge3dpZHRoOiBcIjRweFwifSkud2lkdGgsIHIgPSBkLmFwcGVuZENoaWxkKGEuY3JlYXRlRWxlbWVudChcImRpdlwiKSksIHIuc3R5bGUuY3NzVGV4dCA9IGQuc3R5bGUuY3NzVGV4dCA9IHMsIHIuc3R5bGUubWFyZ2luUmlnaHQgPSByLnN0eWxlLndpZHRoID0gXCIwXCIsIGQuc3R5bGUud2lkdGggPSBcIjFweFwiLCB0LnJlbGlhYmxlTWFyZ2luUmlnaHQgPSAhcGFyc2VGbG9hdCgoZS5nZXRDb21wdXRlZFN0eWxlKHIsIG51bGwpIHx8IHt9KS5tYXJnaW5SaWdodCkpLCB0eXBlb2YgZC5zdHlsZS56b29tICE9PSBpICYmIChkLmlubmVySFRNTCA9IFwiXCIsIGQuc3R5bGUuY3NzVGV4dCA9IHMgKyBcIndpZHRoOjFweDtwYWRkaW5nOjFweDtkaXNwbGF5OmlubGluZTt6b29tOjFcIiwgdC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gMyA9PT0gZC5vZmZzZXRXaWR0aCwgZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCBkLmlubmVySFRNTCA9IFwiPGRpdj48L2Rpdj5cIiwgZC5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gXCI1cHhcIiwgdC5zaHJpbmtXcmFwQmxvY2tzID0gMyAhPT0gZC5vZmZzZXRXaWR0aCwgdC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ICYmIChsLnN0eWxlLnpvb20gPSAxKSksIGwucmVtb3ZlQ2hpbGQobiksIG4gPSBkID0gbyA9IHIgPSBudWxsKVxuICAgICAgICB9KSwgbiA9IHMgPSBsID0gdSA9IHIgPSBvID0gbnVsbCwgdFxuICAgIH0oe30pO1xuICAgIHZhciBCID0gLyg/Olxce1tcXHNcXFNdKlxcfXxcXFtbXFxzXFxTXSpcXF0pJC8sIFAgPSAvKFtBLVpdKS9nO1xuICAgIGZ1bmN0aW9uIFIoZSwgbiwgciwgaSkge1xuICAgICAgICBpZiAoeC5hY2NlcHREYXRhKGUpKSB7XG4gICAgICAgICAgICB2YXIgbywgYSwgcyA9IHguZXhwYW5kbywgbCA9IGUubm9kZVR5cGUsIHUgPSBsID8geC5jYWNoZSA6IGUsIGMgPSBsID8gZVtzXSA6IGVbc10gJiYgcztcbiAgICAgICAgICAgIGlmIChjICYmIHVbY10gJiYgKGkgfHwgdVtjXS5kYXRhKSB8fCByICE9PSB0IHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgfHwgKGMgPSBsID8gZVtzXSA9IHAucG9wKCkgfHwgeC5ndWlkKysgOiBzKSwgdVtjXSB8fCAodVtjXSA9IGwgPyB7fSA6IHt0b0pTT046IHgubm9vcH0pLCAoXCJvYmplY3RcIiA9PSB0eXBlb2YgbiB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4pICYmIChpID8gdVtjXSA9IHguZXh0ZW5kKHVbY10sIG4pIDogdVtjXS5kYXRhID0geC5leHRlbmQodVtjXS5kYXRhLCBuKSksIGEgPSB1W2NdLCBpIHx8IChhLmRhdGEgfHwgKGEuZGF0YSA9IHt9KSwgYSA9IGEuZGF0YSksIHIgIT09IHQgJiYgKGFbeC5jYW1lbENhc2UobildID0gciksIFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gPyAobyA9IGFbbl0sIG51bGwgPT0gbyAmJiAobyA9IGFbeC5jYW1lbENhc2UobildKSkgOiBvID0gYSwgb1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFcoZSwgdCwgbikge1xuICAgICAgICBpZiAoeC5hY2NlcHREYXRhKGUpKSB7XG4gICAgICAgICAgICB2YXIgciwgaSwgbyA9IGUubm9kZVR5cGUsIGEgPSBvID8geC5jYWNoZSA6IGUsIHMgPSBvID8gZVt4LmV4cGFuZG9dIDogeC5leHBhbmRvO1xuICAgICAgICAgICAgaWYgKGFbc10pIHtcbiAgICAgICAgICAgICAgICBpZiAodCAmJiAociA9IG4gPyBhW3NdIDogYVtzXS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICB4LmlzQXJyYXkodCkgPyB0ID0gdC5jb25jYXQoeC5tYXAodCwgeC5jYW1lbENhc2UpKSA6IHQgaW4gciA/IHQgPSBbdF0gOiAodCA9IHguY2FtZWxDYXNlKHQpLCB0ID0gdCBpbiByID8gW3RdIDogdC5zcGxpdChcIiBcIikpLCBpID0gdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgclt0W2ldXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPyAhSShyKSA6ICF4LmlzRW1wdHlPYmplY3QocikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKG4gfHwgKGRlbGV0ZSBhW3NdLmRhdGEsIEkoYVtzXSkpKSAmJiAobyA/IHguY2xlYW5EYXRhKFtlXSwgITApIDogeC5zdXBwb3J0LmRlbGV0ZUV4cGFuZG8gfHwgYSAhPSBhLndpbmRvdyA/IGRlbGV0ZSBhW3NdIDogYVtzXSA9IG51bGwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgeC5leHRlbmQoe2NhY2hlOiB7fSwgbm9EYXRhOiB7YXBwbGV0OiAhMCwgZW1iZWQ6ICEwLCBvYmplY3Q6IFwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCJ9LCBoYXNEYXRhOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgPSBlLm5vZGVUeXBlID8geC5jYWNoZVtlW3guZXhwYW5kb11dIDogZVt4LmV4cGFuZG9dLCAhIWUgJiYgIUkoZSlcbiAgICAgICAgfSwgZGF0YTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHJldHVybiBSKGUsIHQsIG4pXG4gICAgICAgIH0sIHJlbW92ZURhdGE6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gVyhlLCB0KVxuICAgICAgICB9LCBfZGF0YTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHJldHVybiBSKGUsIHQsIG4sICEwKVxuICAgICAgICB9LCBfcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiBXKGUsIHQsICEwKVxuICAgICAgICB9LCBhY2NlcHREYXRhOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUubm9kZVR5cGUgJiYgMSAhPT0gZS5ub2RlVHlwZSAmJiA5ICE9PSBlLm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiExO1xuICAgICAgICAgICAgdmFyIHQgPSBlLm5vZGVOYW1lICYmIHgubm9EYXRhW2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICByZXR1cm4hdCB8fCB0ICE9PSAhMCAmJiBlLmdldEF0dHJpYnV0ZShcImNsYXNzaWRcIikgPT09IHRcbiAgICAgICAgfX0pLCB4LmZuLmV4dGVuZCh7ZGF0YTogZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgIHZhciByLCBpLCBvID0gbnVsbCwgYSA9IDAsIHMgPSB0aGlzWzBdO1xuICAgICAgICAgICAgaWYgKGUgPT09IHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggJiYgKG8gPSB4LmRhdGEocyksIDEgPT09IHMubm9kZVR5cGUgJiYgIXguX2RhdGEocywgXCJwYXJzZWRBdHRyc1wiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyID0gcy5hdHRyaWJ1dGVzOyByLmxlbmd0aCA+IGE7IGErKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSByW2FdLm5hbWUsIDAgPT09IGkuaW5kZXhPZihcImRhdGEtXCIpICYmIChpID0geC5jYW1lbENhc2UoaS5zbGljZSg1KSksICQocywgaSwgb1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB4Ll9kYXRhKHMsIFwicGFyc2VkQXR0cnNcIiwgITApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5cIm9iamVjdFwiID09IHR5cGVvZiBlID8gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB4LmRhdGEodGhpcywgZSlcbiAgICAgICAgICAgIH0pIDogYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHguZGF0YSh0aGlzLCBlLCBuKVxuICAgICAgICAgICAgfSkgOiBzID8gJChzLCBlLCB4LmRhdGEocywgZSkpIDogbnVsbFxuICAgICAgICB9LCByZW1vdmVEYXRhOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeC5yZW1vdmVEYXRhKHRoaXMsIGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9fSk7XG4gICAgZnVuY3Rpb24gJChlLCBuLCByKSB7XG4gICAgICAgIGlmIChyID09PSB0ICYmIDEgPT09IGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBpID0gXCJkYXRhLVwiICsgbi5yZXBsYWNlKFAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAociA9IGUuZ2V0QXR0cmlidXRlKGkpLCBcInN0cmluZ1wiID09IHR5cGVvZiByKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgciA9IFwidHJ1ZVwiID09PSByID8gITAgOiBcImZhbHNlXCIgPT09IHIgPyAhMSA6IFwibnVsbFwiID09PSByID8gbnVsbCA6ICtyICsgXCJcIiA9PT0gciA/ICtyIDogQi50ZXN0KHIpID8geC5wYXJzZUpTT04ocikgOiByXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4LmRhdGEoZSwgbiwgcilcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHIgPSB0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJcbiAgICB9XG4gICAgZnVuY3Rpb24gSShlKSB7XG4gICAgICAgIHZhciB0O1xuICAgICAgICBmb3IgKHQgaW4gZSlcbiAgICAgICAgICAgIGlmICgoXCJkYXRhXCIgIT09IHQgfHwgIXguaXNFbXB0eU9iamVjdChlW3RdKSkgJiYgXCJ0b0pTT05cIiAhPT0gdClcbiAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgcmV0dXJuITBcbiAgICB9XG4gICAgeC5leHRlbmQoe3F1ZXVlOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICByZXR1cm4gZSA/IChuID0gKG4gfHwgXCJmeFwiKSArIFwicXVldWVcIiwgaSA9IHguX2RhdGEoZSwgbiksIHIgJiYgKCFpIHx8IHguaXNBcnJheShyKSA/IGkgPSB4Ll9kYXRhKGUsIG4sIHgubWFrZUFycmF5KHIpKSA6IGkucHVzaChyKSksIGkgfHwgW10pIDogdFxuICAgICAgICB9LCBkZXF1ZXVlOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgdCA9IHQgfHwgXCJmeFwiO1xuICAgICAgICAgICAgdmFyIG4gPSB4LnF1ZXVlKGUsIHQpLCByID0gbi5sZW5ndGgsIGkgPSBuLnNoaWZ0KCksIG8gPSB4Ll9xdWV1ZUhvb2tzKGUsIHQpLCBhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHguZGVxdWV1ZShlLCB0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFwiaW5wcm9ncmVzc1wiID09PSBpICYmIChpID0gbi5zaGlmdCgpLCByLS0pLCBpICYmIChcImZ4XCIgPT09IHQgJiYgbi51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKSwgZGVsZXRlIG8uc3RvcCwgaS5jYWxsKGUsIGEsIG8pKSwgIXIgJiYgbyAmJiBvLmVtcHR5LmZpcmUoKVxuICAgICAgICB9LCBfcXVldWVIb29rczogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gdCArIFwicXVldWVIb29rc1wiO1xuICAgICAgICAgICAgcmV0dXJuIHguX2RhdGEoZSwgbikgfHwgeC5fZGF0YShlLCBuLCB7ZW1wdHk6IHguQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgeC5fcmVtb3ZlRGF0YShlLCB0ICsgXCJxdWV1ZVwiKSwgeC5fcmVtb3ZlRGF0YShlLCBuKVxuICAgICAgICAgICAgICAgIH0pfSlcbiAgICAgICAgfX0pLCB4LmZuLmV4dGVuZCh7cXVldWU6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICB2YXIgciA9IDI7XG4gICAgICAgICAgICByZXR1cm5cInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIChuID0gZSwgZSA9IFwiZnhcIiwgci0tKSwgciA+IGFyZ3VtZW50cy5sZW5ndGggPyB4LnF1ZXVlKHRoaXNbMF0sIGUpIDogbiA9PT0gdCA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0geC5xdWV1ZSh0aGlzLCBlLCBuKTtcbiAgICAgICAgICAgICAgICB4Ll9xdWV1ZUhvb2tzKHRoaXMsIGUpLCBcImZ4XCIgPT09IGUgJiYgXCJpbnByb2dyZXNzXCIgIT09IHRbMF0gJiYgeC5kZXF1ZXVlKHRoaXMsIGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBkZXF1ZXVlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeC5kZXF1ZXVlKHRoaXMsIGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBkZWxheTogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlID0geC5meCA/IHguZnguc3BlZWRzW2VdIHx8IGUgOiBlLCB0ID0gdCB8fCBcImZ4XCIsIHRoaXMucXVldWUodCwgZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHNldFRpbWVvdXQodCwgZSk7XG4gICAgICAgICAgICAgICAgbi5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBjbGVhclF1ZXVlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUoZSB8fCBcImZ4XCIsIFtdKVxuICAgICAgICB9LCBwcm9taXNlOiBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgdmFyIHIsIGkgPSAxLCBvID0geC5EZWZlcnJlZCgpLCBhID0gdGhpcywgcyA9IHRoaXMubGVuZ3RoLCBsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC0taSB8fCBvLnJlc29sdmVXaXRoKGEsIFthXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIChuID0gZSwgZSA9IHQpLCBlID0gZSB8fCBcImZ4XCI7XG4gICAgICAgICAgICB3aGlsZSAocy0tKVxuICAgICAgICAgICAgICAgIHIgPSB4Ll9kYXRhKGFbc10sIGUgKyBcInF1ZXVlSG9va3NcIiksIHIgJiYgci5lbXB0eSAmJiAoaSsrLCByLmVtcHR5LmFkZChsKSk7XG4gICAgICAgICAgICByZXR1cm4gbCgpLCBvLnByb21pc2UobilcbiAgICAgICAgfX0pO1xuICAgIHZhciB6LCBYLCBVID0gL1tcXHRcXHJcXG5cXGZdL2csIFYgPSAvXFxyL2csIFkgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaSwgSiA9IC9eKD86YXxhcmVhKSQvaSwgRyA9IC9eKD86Y2hlY2tlZHxzZWxlY3RlZCkkL2ksIFEgPSB4LnN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlLCBLID0geC5zdXBwb3J0LmlucHV0O1xuICAgIHguZm4uZXh0ZW5kKHthdHRyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWNjZXNzKHRoaXMsIHguYXR0ciwgZSwgdCwgYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICAgIH0sIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB4LnJlbW92ZUF0dHIodGhpcywgZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHByb3A6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgeC5wcm9wLCBlLCB0LCBhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgICAgfSwgcmVtb3ZlUHJvcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlID0geC5wcm9wRml4W2VdIHx8IGUsIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tlXSA9IHQsIGRlbGV0ZSB0aGlzW2VdXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGFkZENsYXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQsIG4sIHIsIGksIG8sIGEgPSAwLCBzID0gdGhpcy5sZW5ndGgsIGwgPSBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIGU7XG4gICAgICAgICAgICBpZiAoeC5pc0Z1bmN0aW9uKGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgeCh0aGlzKS5hZGRDbGFzcyhlLmNhbGwodGhpcywgdCwgdGhpcy5jbGFzc05hbWUpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGwpXG4gICAgICAgICAgICAgICAgZm9yICh0ID0gKGUgfHwgXCJcIikubWF0Y2goVCkgfHwgW107IHMgPiBhOyBhKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChuID0gdGhpc1thXSwgciA9IDEgPT09IG4ubm9kZVR5cGUgJiYgKG4uY2xhc3NOYW1lID8gKFwiIFwiICsgbi5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZShVLCBcIiBcIikgOiBcIiBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPSB0W28rK10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA+IHIuaW5kZXhPZihcIiBcIiArIGkgKyBcIiBcIikgJiYgKHIgKz0gaSArIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uY2xhc3NOYW1lID0geC50cmltKHIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0sIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQsIG4sIHIsIGksIG8sIGEgPSAwLCBzID0gdGhpcy5sZW5ndGgsIGwgPSAwID09PSBhcmd1bWVudHMubGVuZ3RoIHx8IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgZTtcbiAgICAgICAgICAgIGlmICh4LmlzRnVuY3Rpb24oZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB4KHRoaXMpLnJlbW92ZUNsYXNzKGUuY2FsbCh0aGlzLCB0LCB0aGlzLmNsYXNzTmFtZSkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobClcbiAgICAgICAgICAgICAgICBmb3IgKHQgPSAoZSB8fCBcIlwiKS5tYXRjaChUKSB8fCBbXTsgcyA+IGE7IGErKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPSB0aGlzW2FdLCByID0gMSA9PT0gbi5ub2RlVHlwZSAmJiAobi5jbGFzc05hbWUgPyAoXCIgXCIgKyBuLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKFUsIFwiIFwiKSA6IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpID0gdFtvKytdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyLmluZGV4T2YoXCIgXCIgKyBpICsgXCIgXCIpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByLnJlcGxhY2UoXCIgXCIgKyBpICsgXCIgXCIsIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uY2xhc3NOYW1lID0gZSA/IHgudHJpbShyKSA6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSwgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IHR5cGVvZiBlO1xuICAgICAgICAgICAgcmV0dXJuXCJib29sZWFuXCIgPT0gdHlwZW9mIHQgJiYgXCJzdHJpbmdcIiA9PT0gbiA/IHQgPyB0aGlzLmFkZENsYXNzKGUpIDogdGhpcy5yZW1vdmVDbGFzcyhlKSA6IHguaXNGdW5jdGlvbihlKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHgodGhpcykudG9nZ2xlQ2xhc3MoZS5jYWxsKHRoaXMsIG4sIHRoaXMuY2xhc3NOYW1lLCB0KSwgdClcbiAgICAgICAgICAgIH0pIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCwgciA9IDAsIG8gPSB4KHRoaXMpLCBhID0gZS5tYXRjaChUKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPSBhW3IrK10pXG4gICAgICAgICAgICAgICAgICAgICAgICBvLmhhc0NsYXNzKHQpID8gby5yZW1vdmVDbGFzcyh0KSA6IG8uYWRkQ2xhc3ModClcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKG4gPT09IGkgfHwgXCJib29sZWFuXCIgPT09IG4pICYmICh0aGlzLmNsYXNzTmFtZSAmJiB4Ll9kYXRhKHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCB0aGlzLmNsYXNzTmFtZSksIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgZSA9PT0gITEgPyBcIlwiIDogeC5fZGF0YSh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIikgfHwgXCJcIilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGhhc0NsYXNzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQgPSBcIiBcIiArIGUgKyBcIiBcIiwgbiA9IDAsIHIgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyByID4gbjsgbisrKVxuICAgICAgICAgICAgICAgIGlmICgxID09PSB0aGlzW25dLm5vZGVUeXBlICYmIChcIiBcIiArIHRoaXNbbl0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoVSwgXCIgXCIpLmluZGV4T2YodCkgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuITA7XG4gICAgICAgICAgICByZXR1cm4hMVxuICAgICAgICB9LCB2YWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgbiwgciwgaSwgbyA9IHRoaXNbMF07XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpID0geC5pc0Z1bmN0aW9uKGUpLCB0aGlzLmVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgICAgICAgICAgICAgMSA9PT0gdGhpcy5ub2RlVHlwZSAmJiAobyA9IGkgPyBlLmNhbGwodGhpcywgbiwgeCh0aGlzKS52YWwoKSkgOiBlLCBudWxsID09IG8gPyBvID0gXCJcIiA6IFwibnVtYmVyXCIgPT0gdHlwZW9mIG8gPyBvICs9IFwiXCIgOiB4LmlzQXJyYXkobykgJiYgKG8gPSB4Lm1hcChvLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsID09IGUgPyBcIlwiIDogZSArIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgciA9IHgudmFsSG9va3NbdGhpcy50eXBlXSB8fCB4LnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sIHIgJiYgXCJzZXRcImluIHIgJiYgci5zZXQodGhpcywgbywgXCJ2YWx1ZVwiKSAhPT0gdCB8fCAodGhpcy52YWx1ZSA9IG8pKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPSB4LnZhbEhvb2tzW28udHlwZV0gfHwgeC52YWxIb29rc1tvLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLCByICYmIFwiZ2V0XCJpbiByICYmIChuID0gci5nZXQobywgXCJ2YWx1ZVwiKSkgIT09IHQgPyBuIDogKG4gPSBvLnZhbHVlLCBcInN0cmluZ1wiID09IHR5cGVvZiBuID8gbi5yZXBsYWNlKFYsIFwiXCIpIDogbnVsbCA9PSBuID8gXCJcIiA6IG4pXG4gICAgICAgICAgICB9XG4gICAgICAgIH19KSwgeC5leHRlbmQoe3ZhbEhvb2tzOiB7b3B0aW9uOiB7Z2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHguZmluZC5hdHRyKGUsIFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsICE9IHQgPyB0IDogZS50ZXh0XG4gICAgICAgICAgICAgICAgfX0sIHNlbGVjdDoge2dldDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQsIG4sIHIgPSBlLm9wdGlvbnMsIGkgPSBlLnNlbGVjdGVkSW5kZXgsIG8gPSBcInNlbGVjdC1vbmVcIiA9PT0gZS50eXBlIHx8IDAgPiBpLCBhID0gbyA/IG51bGwgOiBbXSwgcyA9IG8gPyBpICsgMSA6IHIubGVuZ3RoLCBsID0gMCA+IGkgPyBzIDogbyA/IGkgOiAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcyA+IGw7IGwrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID0gcltsXSwgISghbi5zZWxlY3RlZCAmJiBsICE9PSBpIHx8ICh4LnN1cHBvcnQub3B0RGlzYWJsZWQgPyBuLmRpc2FibGVkIDogbnVsbCAhPT0gbi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkgfHwgbi5wYXJlbnROb2RlLmRpc2FibGVkICYmIHgubm9kZU5hbWUobi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID0geChuKS52YWwoKSwgbylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhXG4gICAgICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiwgciwgaSA9IGUub3B0aW9ucywgbyA9IHgubWFrZUFycmF5KHQpLCBhID0gaS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gaVthXSwgKHIuc2VsZWN0ZWQgPSB4LmluQXJyYXkoeChyKS52YWwoKSwgbykgPj0gMCkgJiYgKG4gPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuIHx8IChlLnNlbGVjdGVkSW5kZXggPSAtMSksIG9cbiAgICAgICAgICAgICAgICB9fX0sIGF0dHI6IGZ1bmN0aW9uIChlLCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgbywgYSwgcyA9IGUubm9kZVR5cGU7XG4gICAgICAgICAgICBpZiAoZSAmJiAzICE9PSBzICYmIDggIT09IHMgJiYgMiAhPT0gcylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGUuZ2V0QXR0cmlidXRlID09PSBpID8geC5wcm9wKGUsIG4sIHIpIDogKDEgPT09IHMgJiYgeC5pc1hNTERvYyhlKSB8fCAobiA9IG4udG9Mb3dlckNhc2UoKSwgbyA9IHguYXR0ckhvb2tzW25dIHx8ICh4LmV4cHIubWF0Y2guYm9vbC50ZXN0KG4pID8gWCA6IHopKSwgciA9PT0gdCA/IG8gJiYgXCJnZXRcImluIG8gJiYgbnVsbCAhPT0gKGEgPSBvLmdldChlLCBuKSkgPyBhIDogKGEgPSB4LmZpbmQuYXR0cihlLCBuKSwgbnVsbCA9PSBhID8gdCA6IGEpIDogbnVsbCAhPT0gciA/IG8gJiYgXCJzZXRcImluIG8gJiYgKGEgPSBvLnNldChlLCByLCBuKSkgIT09IHQgPyBhIDogKGUuc2V0QXR0cmlidXRlKG4sIHIgKyBcIlwiKSwgcikgOiAoeC5yZW1vdmVBdHRyKGUsIG4pLCB0KSlcbiAgICAgICAgfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuLCByLCBpID0gMCwgbyA9IHQgJiYgdC5tYXRjaChUKTtcbiAgICAgICAgICAgIGlmIChvICYmIDEgPT09IGUubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPSBvW2krK10pXG4gICAgICAgICAgICAgICAgICAgIHIgPSB4LnByb3BGaXhbbl0gfHwgbiwgeC5leHByLm1hdGNoLmJvb2wudGVzdChuKSA/IEsgJiYgUSB8fCAhRy50ZXN0KG4pID8gZVtyXSA9ICExIDogZVt4LmNhbWVsQ2FzZShcImRlZmF1bHQtXCIgKyBuKV0gPSBlW3JdID0gITEgOiB4LmF0dHIoZSwgbiwgXCJcIiksIGUucmVtb3ZlQXR0cmlidXRlKFEgPyBuIDogcilcbiAgICAgICAgfSwgYXR0ckhvb2tzOiB7dHlwZToge3NldDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF4LnN1cHBvcnQucmFkaW9WYWx1ZSAmJiBcInJhZGlvXCIgPT09IHQgJiYgeC5ub2RlTmFtZShlLCBcImlucHV0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHQpLCBuICYmIChlLnZhbHVlID0gbiksIHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH19fSwgcHJvcEZpeDoge1wiZm9yXCI6IFwiaHRtbEZvclwiLCBcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJ9LCBwcm9wOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGksIG8sIGEsIHMgPSBlLm5vZGVUeXBlO1xuICAgICAgICAgICAgaWYgKGUgJiYgMyAhPT0gcyAmJiA4ICE9PSBzICYmIDIgIT09IHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPSAxICE9PSBzIHx8ICF4LmlzWE1MRG9jKGUpLCBhICYmIChuID0geC5wcm9wRml4W25dIHx8IG4sIG8gPSB4LnByb3BIb29rc1tuXSksIHIgIT09IHQgPyBvICYmIFwic2V0XCJpbiBvICYmIChpID0gby5zZXQoZSwgciwgbikpICE9PSB0ID8gaSA6IGVbbl0gPSByIDogbyAmJiBcImdldFwiaW4gbyAmJiBudWxsICE9PSAoaSA9IG8uZ2V0KGUsIG4pKSA/IGkgOiBlW25dXG4gICAgICAgIH0sIHByb3BIb29rczoge3RhYkluZGV4OiB7Z2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHguZmluZC5hdHRyKGUsIFwidGFiaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID8gcGFyc2VJbnQodCwgMTApIDogWS50ZXN0KGUubm9kZU5hbWUpIHx8IEoudGVzdChlLm5vZGVOYW1lKSAmJiBlLmhyZWYgPyAwIDogLTFcbiAgICAgICAgICAgICAgICB9fX19KSwgWCA9IHtzZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gdCA9PT0gITEgPyB4LnJlbW92ZUF0dHIoZSwgbikgOiBLICYmIFEgfHwgIUcudGVzdChuKSA/IGUuc2V0QXR0cmlidXRlKCFRICYmIHgucHJvcEZpeFtuXSB8fCBuLCBuKSA6IGVbeC5jYW1lbENhc2UoXCJkZWZhdWx0LVwiICsgbildID0gZVtuXSA9ICEwLCBuXG4gICAgICAgIH19LCB4LmVhY2goeC5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cXHcrL2cpLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICB2YXIgciA9IHguZXhwci5hdHRySGFuZGxlW25dIHx8IHguZmluZC5hdHRyO1xuICAgICAgICB4LmV4cHIuYXR0ckhhbmRsZVtuXSA9IEsgJiYgUSB8fCAhRy50ZXN0KG4pID8gZnVuY3Rpb24gKGUsIG4sIGkpIHtcbiAgICAgICAgICAgIHZhciBvID0geC5leHByLmF0dHJIYW5kbGVbbl0sIGEgPSBpID8gdCA6ICh4LmV4cHIuYXR0ckhhbmRsZVtuXSA9IHQpICE9IHIoZSwgbiwgaSkgPyBuLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHguZXhwci5hdHRySGFuZGxlW25dID0gbywgYVxuICAgICAgICB9IDogZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiByID8gdCA6IGVbeC5jYW1lbENhc2UoXCJkZWZhdWx0LVwiICsgbildID8gbi50b0xvd2VyQ2FzZSgpIDogbnVsbFxuICAgICAgICB9XG4gICAgfSksIEsgJiYgUSB8fCAoeC5hdHRySG9va3MudmFsdWUgPSB7c2V0OiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgcmV0dXJuIHgubm9kZU5hbWUoZSwgXCJpbnB1dFwiKSA/IChlLmRlZmF1bHRWYWx1ZSA9IG4sIHQpIDogeiAmJiB6LnNldChlLCBuLCByKVxuICAgICAgICB9fSksIFEgfHwgKHogPSB7c2V0OiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGkgPSBlLmdldEF0dHJpYnV0ZU5vZGUocik7XG4gICAgICAgICAgICByZXR1cm4gaSB8fCBlLnNldEF0dHJpYnV0ZU5vZGUoaSA9IGUub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUocikpLCBpLnZhbHVlID0gbiArPSBcIlwiLCBcInZhbHVlXCIgPT09IHIgfHwgbiA9PT0gZS5nZXRBdHRyaWJ1dGUocikgPyBuIDogdFxuICAgICAgICB9fSwgeC5leHByLmF0dHJIYW5kbGUuaWQgPSB4LmV4cHIuYXR0ckhhbmRsZS5uYW1lID0geC5leHByLmF0dHJIYW5kbGUuY29vcmRzID0gZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHJldHVybiByID8gdCA6IChpID0gZS5nZXRBdHRyaWJ1dGVOb2RlKG4pKSAmJiBcIlwiICE9PSBpLnZhbHVlID8gaS52YWx1ZSA6IG51bGxcbiAgICB9LCB4LnZhbEhvb2tzLmJ1dHRvbiA9IHtnZXQ6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICB2YXIgciA9IGUuZ2V0QXR0cmlidXRlTm9kZShuKTtcbiAgICAgICAgICAgIHJldHVybiByICYmIHIuc3BlY2lmaWVkID8gci52YWx1ZSA6IHRcbiAgICAgICAgfSwgc2V0OiB6LnNldH0sIHguYXR0ckhvb2tzLmNvbnRlbnRlZGl0YWJsZSA9IHtzZXQ6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICB6LnNldChlLCBcIlwiID09PSB0ID8gITEgOiB0LCBuKVxuICAgICAgICB9fSwgeC5lYWNoKFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICB4LmF0dHJIb29rc1tuXSA9IHtzZXQ6IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXCJcIiA9PT0gciA/IChlLnNldEF0dHJpYnV0ZShuLCBcImF1dG9cIiksIHIpIDogdFxuICAgICAgICAgICAgfX1cbiAgICB9KSksIHguc3VwcG9ydC5ocmVmTm9ybWFsaXplZCB8fCB4LmVhY2goW1wiaHJlZlwiLCBcInNyY1wiXSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgeC5wcm9wSG9va3NbdF0gPSB7Z2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmdldEF0dHJpYnV0ZSh0LCA0KVxuICAgICAgICAgICAgfX1cbiAgICB9KSwgeC5zdXBwb3J0LnN0eWxlIHx8ICh4LmF0dHJIb29rcy5zdHlsZSA9IHtnZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5zdHlsZS5jc3NUZXh0IHx8IHRcbiAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIGUuc3R5bGUuY3NzVGV4dCA9IHQgKyBcIlwiXG4gICAgICAgIH19KSwgeC5zdXBwb3J0Lm9wdFNlbGVjdGVkIHx8ICh4LnByb3BIb29rcy5zZWxlY3RlZCA9IHtnZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiB0ICYmICh0LnNlbGVjdGVkSW5kZXgsIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCksIG51bGxcbiAgICAgICAgfX0pLCB4LmVhY2goW1widGFiSW5kZXhcIiwgXCJyZWFkT25seVwiLCBcIm1heExlbmd0aFwiLCBcImNlbGxTcGFjaW5nXCIsIFwiY2VsbFBhZGRpbmdcIiwgXCJyb3dTcGFuXCIsIFwiY29sU3BhblwiLCBcInVzZU1hcFwiLCBcImZyYW1lQm9yZGVyXCIsIFwiY29udGVudEVkaXRhYmxlXCJdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHgucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldID0gdGhpc1xuICAgIH0pLCB4LnN1cHBvcnQuZW5jdHlwZSB8fCAoeC5wcm9wRml4LmVuY3R5cGUgPSBcImVuY29kaW5nXCIpLCB4LmVhY2goW1wicmFkaW9cIiwgXCJjaGVja2JveFwiXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB4LnZhbEhvb2tzW3RoaXNdID0ge3NldDogZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5pc0FycmF5KG4pID8gZS5jaGVja2VkID0geC5pbkFycmF5KHgoZSkudmFsKCksIG4pID49IDAgOiB0XG4gICAgICAgICAgICB9fSwgeC5zdXBwb3J0LmNoZWNrT24gfHwgKHgudmFsSG9va3NbdGhpc10uZ2V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsID09PSBlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID8gXCJvblwiIDogZS52YWx1ZVxuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHZhciBaID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWEpJC9pLCBldCA9IC9ea2V5LywgdHQgPSAvXig/Om1vdXNlfGNvbnRleHRtZW51KXxjbGljay8sIG50ID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLCBydCA9IC9eKFteLl0qKSg/OlxcLiguKyl8KSQvO1xuICAgIGZ1bmN0aW9uIGl0KCkge1xuICAgICAgICByZXR1cm4hMFxuICAgIH1cbiAgICBmdW5jdGlvbiBvdCgpIHtcbiAgICAgICAgcmV0dXJuITFcbiAgICB9XG4gICAgZnVuY3Rpb24gYXQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYS5hY3RpdmVFbGVtZW50XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICB4LmV2ZW50ID0ge2dsb2JhbDoge30sIGFkZDogZnVuY3Rpb24gKGUsIG4sIHIsIG8sIGEpIHtcbiAgICAgICAgICAgIHZhciBzLCBsLCB1LCBjLCBwLCBmLCBkLCBoLCBnLCBtLCB5LCB2ID0geC5fZGF0YShlKTtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgci5oYW5kbGVyICYmIChjID0gciwgciA9IGMuaGFuZGxlciwgYSA9IGMuc2VsZWN0b3IpLCByLmd1aWQgfHwgKHIuZ3VpZCA9IHguZ3VpZCsrKSwgKGwgPSB2LmV2ZW50cykgfHwgKGwgPSB2LmV2ZW50cyA9IHt9KSwgKGYgPSB2LmhhbmRsZSkgfHwgKGYgPSB2LmhhbmRsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gaSB8fCBlICYmIHguZXZlbnQudHJpZ2dlcmVkID09PSBlLnR5cGUgPyB0IDogeC5ldmVudC5kaXNwYXRjaC5hcHBseShmLmVsZW0sIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9LCBmLmVsZW0gPSBlKSwgbiA9IChuIHx8IFwiXCIpLm1hdGNoKFQpIHx8IFtcIlwiXSwgdSA9IG4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICh1LS0pXG4gICAgICAgICAgICAgICAgICAgIHMgPSBydC5leGVjKG5bdV0pIHx8IFtdLCBnID0geSA9IHNbMV0sIG0gPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBnICYmIChwID0geC5ldmVudC5zcGVjaWFsW2ddIHx8IHt9LCBnID0gKGEgPyBwLmRlbGVnYXRlVHlwZSA6IHAuYmluZFR5cGUpIHx8IGcsIHAgPSB4LmV2ZW50LnNwZWNpYWxbZ10gfHwge30sIGQgPSB4LmV4dGVuZCh7dHlwZTogZywgb3JpZ1R5cGU6IHksIGRhdGE6IG8sIGhhbmRsZXI6IHIsIGd1aWQ6IHIuZ3VpZCwgc2VsZWN0b3I6IGEsIG5lZWRzQ29udGV4dDogYSAmJiB4LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoYSksIG5hbWVzcGFjZTogbS5qb2luKFwiLlwiKX0sIGMpLCAoaCA9IGxbZ10pIHx8IChoID0gbFtnXSA9IFtdLCBoLmRlbGVnYXRlQ291bnQgPSAwLCBwLnNldHVwICYmIHAuc2V0dXAuY2FsbChlLCBvLCBtLCBmKSAhPT0gITEgfHwgKGUuYWRkRXZlbnRMaXN0ZW5lciA/IGUuYWRkRXZlbnRMaXN0ZW5lcihnLCBmLCAhMSkgOiBlLmF0dGFjaEV2ZW50ICYmIGUuYXR0YWNoRXZlbnQoXCJvblwiICsgZywgZikpKSwgcC5hZGQgJiYgKHAuYWRkLmNhbGwoZSwgZCksIGQuaGFuZGxlci5ndWlkIHx8IChkLmhhbmRsZXIuZ3VpZCA9IHIuZ3VpZCkpLCBhID8gaC5zcGxpY2UoaC5kZWxlZ2F0ZUNvdW50KyssIDAsIGQpIDogaC5wdXNoKGQpLCB4LmV2ZW50Lmdsb2JhbFtnXSA9ICEwKTtcbiAgICAgICAgICAgICAgICBlID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIChlLCB0LCBuLCByLCBpKSB7XG4gICAgICAgICAgICB2YXIgbywgYSwgcywgbCwgdSwgYywgcCwgZiwgZCwgaCwgZywgbSA9IHguaGFzRGF0YShlKSAmJiB4Ll9kYXRhKGUpO1xuICAgICAgICAgICAgaWYgKG0gJiYgKGMgPSBtLmV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICB0ID0gKHQgfHwgXCJcIikubWF0Y2goVCkgfHwgW1wiXCJdLCB1ID0gdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHUtLSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPSBydC5leGVjKHRbdV0pIHx8IFtdLCBkID0gZyA9IHNbMV0sIGggPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0geC5ldmVudC5zcGVjaWFsW2RdIHx8IHt9LCBkID0gKHIgPyBwLmRlbGVnYXRlVHlwZSA6IHAuYmluZFR5cGUpIHx8IGQsIGYgPSBjW2RdIHx8IFtdLCBzID0gc1syXSAmJiBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGguam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiksIGwgPSBvID0gZi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoby0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBmW29dLCAhaSAmJiBnICE9PSBhLm9yaWdUeXBlIHx8IG4gJiYgbi5ndWlkICE9PSBhLmd1aWQgfHwgcyAmJiAhcy50ZXN0KGEubmFtZXNwYWNlKSB8fCByICYmIHIgIT09IGEuc2VsZWN0b3IgJiYgKFwiKipcIiAhPT0gciB8fCAhYS5zZWxlY3RvcikgfHwgKGYuc3BsaWNlKG8sIDEpLCBhLnNlbGVjdG9yICYmIGYuZGVsZWdhdGVDb3VudC0tLCBwLnJlbW92ZSAmJiBwLnJlbW92ZS5jYWxsKGUsIGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgJiYgIWYubGVuZ3RoICYmIChwLnRlYXJkb3duICYmIHAudGVhcmRvd24uY2FsbChlLCBoLCBtLmhhbmRsZSkgIT09ICExIHx8IHgucmVtb3ZlRXZlbnQoZSwgZCwgbS5oYW5kbGUpLCBkZWxldGUgY1tkXSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGQgaW4gYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmV2ZW50LnJlbW92ZShlLCBkICsgdFt1XSwgbiwgciwgITApO1xuICAgICAgICAgICAgICAgIHguaXNFbXB0eU9iamVjdChjKSAmJiAoZGVsZXRlIG0uaGFuZGxlLCB4Ll9yZW1vdmVEYXRhKGUsIFwiZXZlbnRzXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cmlnZ2VyOiBmdW5jdGlvbiAobiwgciwgaSwgbykge1xuICAgICAgICAgICAgdmFyIHMsIGwsIHUsIGMsIHAsIGYsIGQsIGggPSBbaSB8fCBhXSwgZyA9IHYuY2FsbChuLCBcInR5cGVcIikgPyBuLnR5cGUgOiBuLCBtID0gdi5jYWxsKG4sIFwibmFtZXNwYWNlXCIpID8gbi5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpIDogW107XG4gICAgICAgICAgICBpZiAodSA9IGYgPSBpID0gaSB8fCBhLCAzICE9PSBpLm5vZGVUeXBlICYmIDggIT09IGkubm9kZVR5cGUgJiYgIW50LnRlc3QoZyArIHguZXZlbnQudHJpZ2dlcmVkKSAmJiAoZy5pbmRleE9mKFwiLlwiKSA+PSAwICYmIChtID0gZy5zcGxpdChcIi5cIiksIGcgPSBtLnNoaWZ0KCksIG0uc29ydCgpKSwgbCA9IDAgPiBnLmluZGV4T2YoXCI6XCIpICYmIFwib25cIiArIGcsIG4gPSBuW3guZXhwYW5kb10gPyBuIDogbmV3IHguRXZlbnQoZywgXCJvYmplY3RcIiA9PSB0eXBlb2YgbiAmJiBuKSwgbi5pc1RyaWdnZXIgPSBvID8gMiA6IDMsIG4ubmFtZXNwYWNlID0gbS5qb2luKFwiLlwiKSwgbi5uYW1lc3BhY2VfcmUgPSBuLm5hbWVzcGFjZSA/IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbS5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKSA6IG51bGwsIG4ucmVzdWx0ID0gdCwgbi50YXJnZXQgfHwgKG4udGFyZ2V0ID0gaSksIHIgPSBudWxsID09IHIgPyBbbl0gOiB4Lm1ha2VBcnJheShyLCBbbl0pLCBwID0geC5ldmVudC5zcGVjaWFsW2ddIHx8IHt9LCBvIHx8ICFwLnRyaWdnZXIgfHwgcC50cmlnZ2VyLmFwcGx5KGksIHIpICE9PSAhMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW8gJiYgIXAubm9CdWJibGUgJiYgIXguaXNXaW5kb3coaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjID0gcC5kZWxlZ2F0ZVR5cGUgfHwgZywgbnQudGVzdChjICsgZykgfHwgKHUgPSB1LnBhcmVudE5vZGUpOyB1OyB1ID0gdS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaC5wdXNoKHUpLCBmID0gdTtcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gKGkub3duZXJEb2N1bWVudCB8fCBhKSAmJiBoLnB1c2goZi5kZWZhdWx0VmlldyB8fCBmLnBhcmVudFdpbmRvdyB8fCBlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHUgPSBoW2QrK10pICYmICFuLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpXG4gICAgICAgICAgICAgICAgICAgIG4udHlwZSA9IGQgPiAxID8gYyA6IHAuYmluZFR5cGUgfHwgZywgcyA9ICh4Ll9kYXRhKHUsIFwiZXZlbnRzXCIpIHx8IHt9KVtuLnR5cGVdICYmIHguX2RhdGEodSwgXCJoYW5kbGVcIiksIHMgJiYgcy5hcHBseSh1LCByKSwgcyA9IGwgJiYgdVtsXSwgcyAmJiB4LmFjY2VwdERhdGEodSkgJiYgcy5hcHBseSAmJiBzLmFwcGx5KHUsIHIpID09PSAhMSAmJiBuLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9IGcsICFvICYmICFuLmlzRGVmYXVsdFByZXZlbnRlZCgpICYmICghcC5fZGVmYXVsdCB8fCBwLl9kZWZhdWx0LmFwcGx5KGgucG9wKCksIHIpID09PSAhMSkgJiYgeC5hY2NlcHREYXRhKGkpICYmIGwgJiYgaVtnXSAmJiAheC5pc1dpbmRvdyhpKSkge1xuICAgICAgICAgICAgICAgICAgICBmID0gaVtsXSwgZiAmJiAoaVtsXSA9IG51bGwpLCB4LmV2ZW50LnRyaWdnZXJlZCA9IGc7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpW2ddKClcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeSkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHguZXZlbnQudHJpZ2dlcmVkID0gdCwgZiAmJiAoaVtsXSA9IGYpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuLnJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkaXNwYXRjaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUgPSB4LmV2ZW50LmZpeChlKTtcbiAgICAgICAgICAgIHZhciBuLCByLCBpLCBvLCBhLCBzID0gW10sIGwgPSBnLmNhbGwoYXJndW1lbnRzKSwgdSA9ICh4Ll9kYXRhKHRoaXMsIFwiZXZlbnRzXCIpIHx8IHt9KVtlLnR5cGVdIHx8IFtdLCBjID0geC5ldmVudC5zcGVjaWFsW2UudHlwZV0gfHwge307XG4gICAgICAgICAgICBpZiAobFswXSA9IGUsIGUuZGVsZWdhdGVUYXJnZXQgPSB0aGlzLCAhYy5wcmVEaXNwYXRjaCB8fCBjLnByZURpc3BhdGNoLmNhbGwodGhpcywgZSkgIT09ICExKSB7XG4gICAgICAgICAgICAgICAgcyA9IHguZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBlLCB1KSwgbiA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChvID0gc1tuKytdKSAmJiAhZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldCA9IG8uZWxlbSwgYSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaSA9IG8uaGFuZGxlcnNbYSsrXSkgJiYgIWUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICghZS5uYW1lc3BhY2VfcmUgfHwgZS5uYW1lc3BhY2VfcmUudGVzdChpLm5hbWVzcGFjZSkpICYmIChlLmhhbmRsZU9iaiA9IGksIGUuZGF0YSA9IGkuZGF0YSwgciA9ICgoeC5ldmVudC5zcGVjaWFsW2kub3JpZ1R5cGVdIHx8IHt9KS5oYW5kbGUgfHwgaS5oYW5kbGVyKS5hcHBseShvLmVsZW0sIGwpLCByICE9PSB0ICYmIChlLnJlc3VsdCA9IHIpID09PSAhMSAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMucG9zdERpc3BhdGNoICYmIGMucG9zdERpc3BhdGNoLmNhbGwodGhpcywgZSksIGUucmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXJzOiBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgdmFyIHIsIGksIG8sIGEsIHMgPSBbXSwgbCA9IG4uZGVsZWdhdGVDb3VudCwgdSA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGwgJiYgdS5ub2RlVHlwZSAmJiAoIWUuYnV0dG9uIHx8IFwiY2xpY2tcIiAhPT0gZS50eXBlKSlcbiAgICAgICAgICAgICAgICBmb3IgKDsgdSAhPSB0aGlzOyB1ID0gdS5wYXJlbnROb2RlIHx8IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIGlmICgxID09PSB1Lm5vZGVUeXBlICYmICh1LmRpc2FibGVkICE9PSAhMCB8fCBcImNsaWNrXCIgIT09IGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobyA9IFtdLCBhID0gMDsgbCA+IGE7IGErKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gblthXSwgciA9IGkuc2VsZWN0b3IgKyBcIiBcIiwgb1tyXSA9PT0gdCAmJiAob1tyXSA9IGkubmVlZHNDb250ZXh0ID8geChyLCB0aGlzKS5pbmRleCh1KSA+PSAwIDogeC5maW5kKHIsIHRoaXMsIG51bGwsIFt1XSkubGVuZ3RoKSwgb1tyXSAmJiBvLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvLmxlbmd0aCAmJiBzLnB1c2goe2VsZW06IHUsIGhhbmRsZXJzOiBvfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG4ubGVuZ3RoID4gbCAmJiBzLnB1c2goe2VsZW06IHRoaXMsIGhhbmRsZXJzOiBuLnNsaWNlKGwpfSksIHNcbiAgICAgICAgfSwgZml4OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGVbeC5leHBhbmRvXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIHZhciB0LCBuLCByLCBpID0gZS50eXBlLCBvID0gZSwgcyA9IHRoaXMuZml4SG9va3NbaV07XG4gICAgICAgICAgICBzIHx8ICh0aGlzLmZpeEhvb2tzW2ldID0gcyA9IHR0LnRlc3QoaSkgPyB0aGlzLm1vdXNlSG9va3MgOiBldC50ZXN0KGkpID8gdGhpcy5rZXlIb29rcyA6IHt9KSwgciA9IHMucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdChzLnByb3BzKSA6IHRoaXMucHJvcHMsIGUgPSBuZXcgeC5FdmVudChvKSwgdCA9IHIubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHQtLSlcbiAgICAgICAgICAgICAgICBuID0gclt0XSwgZVtuXSA9IG9bbl07XG4gICAgICAgICAgICByZXR1cm4gZS50YXJnZXQgfHwgKGUudGFyZ2V0ID0gby5zcmNFbGVtZW50IHx8IGEpLCAzID09PSBlLnRhcmdldC5ub2RlVHlwZSAmJiAoZS50YXJnZXQgPSBlLnRhcmdldC5wYXJlbnROb2RlKSwgZS5tZXRhS2V5ID0gISFlLm1ldGFLZXksIHMuZmlsdGVyID8gcy5maWx0ZXIoZSwgbykgOiBlXG4gICAgICAgIH0sIHByb3BzOiBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiLnNwbGl0KFwiIFwiKSwgZml4SG9va3M6IHt9LCBrZXlIb29rczoge3Byb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksIGZpbHRlcjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBlLndoaWNoICYmIChlLndoaWNoID0gbnVsbCAhPSB0LmNoYXJDb2RlID8gdC5jaGFyQ29kZSA6IHQua2V5Q29kZSksIGVcbiAgICAgICAgICAgIH19LCBtb3VzZUhvb2tzOiB7cHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLCBmaWx0ZXI6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIsIGksIG8sIHMgPSBuLmJ1dHRvbiwgbCA9IG4uZnJvbUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZS5wYWdlWCAmJiBudWxsICE9IG4uY2xpZW50WCAmJiAoaSA9IGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgYSwgbyA9IGkuZG9jdW1lbnRFbGVtZW50LCByID0gaS5ib2R5LCBlLnBhZ2VYID0gbi5jbGllbnRYICsgKG8gJiYgby5zY3JvbGxMZWZ0IHx8IHIgJiYgci5zY3JvbGxMZWZ0IHx8IDApIC0gKG8gJiYgby5jbGllbnRMZWZ0IHx8IHIgJiYgci5jbGllbnRMZWZ0IHx8IDApLCBlLnBhZ2VZID0gbi5jbGllbnRZICsgKG8gJiYgby5zY3JvbGxUb3AgfHwgciAmJiByLnNjcm9sbFRvcCB8fCAwKSAtIChvICYmIG8uY2xpZW50VG9wIHx8IHIgJiYgci5jbGllbnRUb3AgfHwgMCkpLCAhZS5yZWxhdGVkVGFyZ2V0ICYmIGwgJiYgKGUucmVsYXRlZFRhcmdldCA9IGwgPT09IGUudGFyZ2V0ID8gbi50b0VsZW1lbnQgOiBsKSwgZS53aGljaCB8fCBzID09PSB0IHx8IChlLndoaWNoID0gMSAmIHMgPyAxIDogMiAmIHMgPyAzIDogNCAmIHMgPyAyIDogMCksIGVcbiAgICAgICAgICAgIH19LCBzcGVjaWFsOiB7bG9hZDoge25vQnViYmxlOiAhMH0sIGZvY3VzOiB7dHJpZ2dlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcyAhPT0gYXQoKSAmJiB0aGlzLmZvY3VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb2N1cygpLCAhMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJ9LCBibHVyOiB7dHJpZ2dlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcyA9PT0gYXQoKSAmJiB0aGlzLmJsdXIgPyAodGhpcy5ibHVyKCksICExKSA6IHRcbiAgICAgICAgICAgICAgICB9LCBkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIn0sIGNsaWNrOiB7dHJpZ2dlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5ub2RlTmFtZSh0aGlzLCBcImlucHV0XCIpICYmIFwiY2hlY2tib3hcIiA9PT0gdGhpcy50eXBlICYmIHRoaXMuY2xpY2sgPyAodGhpcy5jbGljaygpLCAhMSkgOiB0XG4gICAgICAgICAgICAgICAgfSwgX2RlZmF1bHQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4Lm5vZGVOYW1lKGUudGFyZ2V0LCBcImFcIilcbiAgICAgICAgICAgICAgICB9fSwgYmVmb3JldW5sb2FkOiB7cG9zdERpc3BhdGNoOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnJlc3VsdCAhPT0gdCAmJiAoZS5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZS5yZXN1bHQpXG4gICAgICAgICAgICAgICAgfX19LCBzaW11bGF0ZTogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgIHZhciBpID0geC5leHRlbmQobmV3IHguRXZlbnQsIG4sIHt0eXBlOiBlLCBpc1NpbXVsYXRlZDogITAsIG9yaWdpbmFsRXZlbnQ6IHt9fSk7XG4gICAgICAgICAgICByID8geC5ldmVudC50cmlnZ2VyKGksIG51bGwsIHQpIDogeC5ldmVudC5kaXNwYXRjaC5jYWxsKHQsIGkpLCBpLmlzRGVmYXVsdFByZXZlbnRlZCgpICYmIG4ucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9fSwgeC5yZW1vdmVFdmVudCA9IGEucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgbiwgITEpXG4gICAgfSA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgIHZhciByID0gXCJvblwiICsgdDtcbiAgICAgICAgZS5kZXRhY2hFdmVudCAmJiAodHlwZW9mIGVbcl0gPT09IGkgJiYgKGVbcl0gPSBudWxsKSwgZS5kZXRhY2hFdmVudChyLCBuKSlcbiAgICB9LCB4LkV2ZW50ID0gZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiB4LkV2ZW50ID8gKGUgJiYgZS50eXBlID8gKHRoaXMub3JpZ2luYWxFdmVudCA9IGUsIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgZS5yZXR1cm5WYWx1ZSA9PT0gITEgfHwgZS5nZXRQcmV2ZW50RGVmYXVsdCAmJiBlLmdldFByZXZlbnREZWZhdWx0KCkgPyBpdCA6IG90KSA6IHRoaXMudHlwZSA9IGUsIG4gJiYgeC5leHRlbmQodGhpcywgbiksIHRoaXMudGltZVN0YW1wID0gZSAmJiBlLnRpbWVTdGFtcCB8fCB4Lm5vdygpLCB0aGlzW3guZXhwYW5kb10gPSAhMCwgdCkgOiBuZXcgeC5FdmVudChlLCBuKVxuICAgIH0sIHguRXZlbnQucHJvdG90eXBlID0ge2lzRGVmYXVsdFByZXZlbnRlZDogb3QsIGlzUHJvcGFnYXRpb25TdG9wcGVkOiBvdCwgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IG90LCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGl0LCBlICYmIChlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9ICExKVxuICAgICAgICB9LCBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGl0LCBlICYmIChlLnN0b3BQcm9wYWdhdGlvbiAmJiBlLnN0b3BQcm9wYWdhdGlvbigpLCBlLmNhbmNlbEJ1YmJsZSA9ICEwKVxuICAgICAgICB9LCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBpdCwgdGhpcy5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9fSwgeC5lYWNoKHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9LCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB4LmV2ZW50LnNwZWNpYWxbZV0gPSB7ZGVsZWdhdGVUeXBlOiB0LCBiaW5kVHlwZTogdCwgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBuLCByID0gdGhpcywgaSA9IGUucmVsYXRlZFRhcmdldCwgbyA9IGUuaGFuZGxlT2JqO1xuICAgICAgICAgICAgICAgIHJldHVybighaSB8fCBpICE9PSByICYmICF4LmNvbnRhaW5zKHIsIGkpKSAmJiAoZS50eXBlID0gby5vcmlnVHlwZSwgbiA9IG8uaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBlLnR5cGUgPSB0KSwgblxuICAgICAgICAgICAgfX1cbiAgICB9KSwgeC5zdXBwb3J0LnN1Ym1pdEJ1YmJsZXMgfHwgKHguZXZlbnQuc3BlY2lhbC5zdWJtaXQgPSB7c2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4Lm5vZGVOYW1lKHRoaXMsIFwiZm9ybVwiKSA/ICExIDogKHguZXZlbnQuYWRkKHRoaXMsIFwiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBlLnRhcmdldCwgciA9IHgubm9kZU5hbWUobiwgXCJpbnB1dFwiKSB8fCB4Lm5vZGVOYW1lKG4sIFwiYnV0dG9uXCIpID8gbi5mb3JtIDogdDtcbiAgICAgICAgICAgICAgICByICYmICF4Ll9kYXRhKHIsIFwic3VibWl0QnViYmxlc1wiKSAmJiAoeC5ldmVudC5hZGQociwgXCJzdWJtaXQuX3N1Ym1pdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLl9zdWJtaXRfYnViYmxlID0gITBcbiAgICAgICAgICAgICAgICB9KSwgeC5fZGF0YShyLCBcInN1Ym1pdEJ1YmJsZXNcIiwgITApKVxuICAgICAgICAgICAgfSksIHQpXG4gICAgICAgIH0sIHBvc3REaXNwYXRjaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuX3N1Ym1pdF9idWJibGUgJiYgKGRlbGV0ZSBlLl9zdWJtaXRfYnViYmxlLCB0aGlzLnBhcmVudE5vZGUgJiYgIWUuaXNUcmlnZ2VyICYmIHguZXZlbnQuc2ltdWxhdGUoXCJzdWJtaXRcIiwgdGhpcy5wYXJlbnROb2RlLCBlLCAhMCkpXG4gICAgICAgIH0sIHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geC5ub2RlTmFtZSh0aGlzLCBcImZvcm1cIikgPyAhMSA6ICh4LmV2ZW50LnJlbW92ZSh0aGlzLCBcIi5fc3VibWl0XCIpLCB0KVxuICAgICAgICB9fSksIHguc3VwcG9ydC5jaGFuZ2VCdWJibGVzIHx8ICh4LmV2ZW50LnNwZWNpYWwuY2hhbmdlID0ge3NldHVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gWi50ZXN0KHRoaXMubm9kZU5hbWUpID8gKChcImNoZWNrYm94XCIgPT09IHRoaXMudHlwZSB8fCBcInJhZGlvXCIgPT09IHRoaXMudHlwZSkgJiYgKHguZXZlbnQuYWRkKHRoaXMsIFwicHJvcGVydHljaGFuZ2UuX2NoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIFwiY2hlY2tlZFwiID09PSBlLm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lICYmICh0aGlzLl9qdXN0X2NoYW5nZWQgPSAhMClcbiAgICAgICAgICAgIH0pLCB4LmV2ZW50LmFkZCh0aGlzLCBcImNsaWNrLl9jaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXN0X2NoYW5nZWQgJiYgIWUuaXNUcmlnZ2VyICYmICh0aGlzLl9qdXN0X2NoYW5nZWQgPSAhMSksIHguZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIiwgdGhpcywgZSwgITApXG4gICAgICAgICAgICB9KSksICExKSA6ICh4LmV2ZW50LmFkZCh0aGlzLCBcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIFoudGVzdCh0Lm5vZGVOYW1lKSAmJiAheC5fZGF0YSh0LCBcImNoYW5nZUJ1YmJsZXNcIikgJiYgKHguZXZlbnQuYWRkKHQsIFwiY2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMucGFyZW50Tm9kZSB8fCBlLmlzU2ltdWxhdGVkIHx8IGUuaXNUcmlnZ2VyIHx8IHguZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIiwgdGhpcy5wYXJlbnROb2RlLCBlLCAhMClcbiAgICAgICAgICAgICAgICB9KSwgeC5fZGF0YSh0LCBcImNoYW5nZUJ1YmJsZXNcIiwgITApKVxuICAgICAgICAgICAgfSksIHQpXG4gICAgICAgIH0sIGhhbmRsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBuID0gZS50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcyAhPT0gbiB8fCBlLmlzU2ltdWxhdGVkIHx8IGUuaXNUcmlnZ2VyIHx8IFwicmFkaW9cIiAhPT0gbi50eXBlICYmIFwiY2hlY2tib3hcIiAhPT0gbi50eXBlID8gZS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdFxuICAgICAgICB9LCB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHguZXZlbnQucmVtb3ZlKHRoaXMsIFwiLl9jaGFuZ2VcIiksICFaLnRlc3QodGhpcy5ub2RlTmFtZSlcbiAgICAgICAgfX0pLCB4LnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgfHwgeC5lYWNoKHtmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIn0sIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciBuID0gMCwgciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB4LmV2ZW50LnNpbXVsYXRlKHQsIGUudGFyZ2V0LCB4LmV2ZW50LmZpeChlKSwgITApXG4gICAgICAgIH07XG4gICAgICAgIHguZXZlbnQuc3BlY2lhbFt0XSA9IHtzZXR1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIDAgPT09IG4rKyAmJiBhLmFkZEV2ZW50TGlzdGVuZXIoZSwgciwgITApXG4gICAgICAgICAgICB9LCB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIDAgPT09IC0tbiAmJiBhLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgciwgITApXG4gICAgICAgICAgICB9fVxuICAgIH0pLCB4LmZuLmV4dGVuZCh7b246IGZ1bmN0aW9uIChlLCBuLCByLCBpLCBvKSB7XG4gICAgICAgICAgICB2YXIgYSwgcztcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiAhPSB0eXBlb2YgbiAmJiAociA9IHIgfHwgbiwgbiA9IHQpO1xuICAgICAgICAgICAgICAgIGZvciAoYSBpbiBlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKGEsIG4sIHIsIGVbYV0sIG8pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCA9PSByICYmIG51bGwgPT0gaSA/IChpID0gbiwgciA9IG4gPSB0KSA6IG51bGwgPT0gaSAmJiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiA/IChpID0gciwgciA9IHQpIDogKGkgPSByLCByID0gbiwgbiA9IHQpKSwgaSA9PT0gITEpXG4gICAgICAgICAgICAgICAgaSA9IG90O1xuICAgICAgICAgICAgZWxzZSBpZiAoIWkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gMSA9PT0gbyAmJiAocyA9IGksIGkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4KCkub2ZmKGUpLCBzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIH0sIGkuZ3VpZCA9IHMuZ3VpZCB8fCAocy5ndWlkID0geC5ndWlkKyspKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB4LmV2ZW50LmFkZCh0aGlzLCBlLCBpLCByLCBuKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgb25lOiBmdW5jdGlvbiAoZSwgdCwgbiwgcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oZSwgdCwgbiwgciwgMSlcbiAgICAgICAgfSwgb2ZmOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGksIG87XG4gICAgICAgICAgICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGUuaGFuZGxlT2JqKVxuICAgICAgICAgICAgICAgIHJldHVybiBpID0gZS5oYW5kbGVPYmosIHgoZS5kZWxlZ2F0ZVRhcmdldCkub2ZmKGkubmFtZXNwYWNlID8gaS5vcmlnVHlwZSArIFwiLlwiICsgaS5uYW1lc3BhY2UgOiBpLm9yaWdUeXBlLCBpLnNlbGVjdG9yLCBpLmhhbmRsZXIpLCB0aGlzO1xuICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKG8gaW4gZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYobywgbiwgZVtvXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybihuID09PSAhMSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG4pICYmIChyID0gbiwgbiA9IHQpLCByID09PSAhMSAmJiAociA9IG90KSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB4LmV2ZW50LnJlbW92ZSh0aGlzLCBlLCByLCBuKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgdHJpZ2dlcjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHguZXZlbnQudHJpZ2dlcihlLCB0LCB0aGlzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXNbMF07XG4gICAgICAgICAgICByZXR1cm4gciA/IHguZXZlbnQudHJpZ2dlcihlLCBuLCByLCAhMCkgOiB0XG4gICAgICAgIH19KTtcbiAgICB2YXIgc3QgPSAvXi5bXjojXFxbXFwuLF0qJC8sIGx0ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sIHV0ID0geC5leHByLm1hdGNoLm5lZWRzQ29udGV4dCwgY3QgPSB7Y2hpbGRyZW46ICEwLCBjb250ZW50czogITAsIG5leHQ6ICEwLCBwcmV2OiAhMH07XG4gICAgeC5mbi5leHRlbmQoe2ZpbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCwgbiA9IFtdLCByID0gdGhpcywgaSA9IHIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHgoZSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0ID0gMDsgaSA+IHQ7IHQrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LmNvbnRhaW5zKHJbdF0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiEwXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgZm9yICh0ID0gMDsgaSA+IHQ7IHQrKylcbiAgICAgICAgICAgICAgICB4LmZpbmQoZSwgclt0XSwgbik7XG4gICAgICAgICAgICByZXR1cm4gbiA9IHRoaXMucHVzaFN0YWNrKGkgPiAxID8geC51bmlxdWUobikgOiBuKSwgbi5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXCIgXCIgKyBlIDogZSwgblxuICAgICAgICB9LCBoYXM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCwgbiA9IHgoZSwgdGhpcyksIHIgPSBuLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh0ID0gMDsgciA+IHQ7IHQrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHguY29udGFpbnModGhpcywgblt0XSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4hMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgbm90OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGZ0KHRoaXMsIGUgfHwgW10sICEwKSlcbiAgICAgICAgfSwgZmlsdGVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGZ0KHRoaXMsIGUgfHwgW10sICExKSlcbiAgICAgICAgfSwgaXM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4hIWZ0KHRoaXMsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgdXQudGVzdChlKSA/IHgoZSkgOiBlIHx8IFtdLCAhMSkubGVuZ3RoXG4gICAgICAgIH0sIGNsb3Nlc3Q6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiwgciA9IDAsIGkgPSB0aGlzLmxlbmd0aCwgbyA9IFtdLCBhID0gdXQudGVzdChlKSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBlID8geChlLCB0IHx8IHRoaXMuY29udGV4dCkgOiAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPiByOyByKyspXG4gICAgICAgICAgICAgICAgZm9yIChuID0gdGhpc1tyXTsgbiAmJiBuICE9PSB0OyBuID0gbi5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoMTEgPiBuLm5vZGVUeXBlICYmIChhID8gYS5pbmRleChuKSA+IC0xIDogMSA9PT0gbi5ub2RlVHlwZSAmJiB4LmZpbmQubWF0Y2hlc1NlbGVjdG9yKG4sIGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG8ucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhvLmxlbmd0aCA+IDEgPyB4LnVuaXF1ZShvKSA6IG8pXG4gICAgICAgIH0sIGluZGV4OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgPyBcInN0cmluZ1wiID09IHR5cGVvZiBlID8geC5pbkFycmF5KHRoaXNbMF0sIHgoZSkpIDogeC5pbkFycmF5KGUuanF1ZXJ5ID8gZVswXSA6IGUsIHRoaXMpIDogdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xXG4gICAgICAgIH0sIGFkZDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IHgoZSwgdCkgOiB4Lm1ha2VBcnJheShlICYmIGUubm9kZVR5cGUgPyBbZV0gOiBlKSwgciA9IHgubWVyZ2UodGhpcy5nZXQoKSwgbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soeC51bmlxdWUocikpXG4gICAgICAgIH0sIGFkZEJhY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobnVsbCA9PSBlID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihlKSlcbiAgICAgICAgfX0pO1xuICAgIGZ1bmN0aW9uIHB0KGUsIHQpIHtcbiAgICAgICAgZG9cbiAgICAgICAgICAgIGUgPSBlW3RdO1xuICAgICAgICB3aGlsZSAoZSAmJiAxICE9PSBlLm5vZGVUeXBlKTtcbiAgICAgICAgcmV0dXJuIGVcbiAgICB9XG4gICAgeC5lYWNoKHtwYXJlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiB0ICYmIDExICE9PSB0Lm5vZGVUeXBlID8gdCA6IG51bGxcbiAgICAgICAgfSwgcGFyZW50czogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmRpcihlLCBcInBhcmVudE5vZGVcIilcbiAgICAgICAgfSwgcGFyZW50c1VudGlsOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgcmV0dXJuIHguZGlyKGUsIFwicGFyZW50Tm9kZVwiLCBuKVxuICAgICAgICB9LCBuZXh0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHB0KGUsIFwibmV4dFNpYmxpbmdcIilcbiAgICAgICAgfSwgcHJldjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwdChlLCBcInByZXZpb3VzU2libGluZ1wiKVxuICAgICAgICB9LCBuZXh0QWxsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHguZGlyKGUsIFwibmV4dFNpYmxpbmdcIilcbiAgICAgICAgfSwgcHJldkFsbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmRpcihlLCBcInByZXZpb3VzU2libGluZ1wiKVxuICAgICAgICB9LCBuZXh0VW50aWw6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4geC5kaXIoZSwgXCJuZXh0U2libGluZ1wiLCBuKVxuICAgICAgICB9LCBwcmV2VW50aWw6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4geC5kaXIoZSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgbilcbiAgICAgICAgfSwgc2libGluZ3M6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4geC5zaWJsaW5nKChlLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGUpXG4gICAgICAgIH0sIGNoaWxkcmVuOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHguc2libGluZyhlLmZpcnN0Q2hpbGQpXG4gICAgICAgIH0sIGNvbnRlbnRzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHgubm9kZU5hbWUoZSwgXCJpZnJhbWVcIikgPyBlLmNvbnRlbnREb2N1bWVudCB8fCBlLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQgOiB4Lm1lcmdlKFtdLCBlLmNoaWxkTm9kZXMpXG4gICAgICAgIH19LCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB4LmZuW2VdID0gZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgICAgIHZhciBpID0geC5tYXAodGhpcywgdCwgbik7XG4gICAgICAgICAgICByZXR1cm5cIlVudGlsXCIgIT09IGUuc2xpY2UoLTUpICYmIChyID0gbiksIHIgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgciAmJiAoaSA9IHguZmlsdGVyKHIsIGkpKSwgdGhpcy5sZW5ndGggPiAxICYmIChjdFtlXSB8fCAoaSA9IHgudW5pcXVlKGkpKSwgbHQudGVzdChlKSAmJiAoaSA9IGkucmV2ZXJzZSgpKSksIHRoaXMucHVzaFN0YWNrKGkpXG4gICAgICAgIH1cbiAgICB9KSwgeC5leHRlbmQoe2ZpbHRlcjogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHZhciByID0gdFswXTtcbiAgICAgICAgICAgIHJldHVybiBuICYmIChlID0gXCI6bm90KFwiICsgZSArIFwiKVwiKSwgMSA9PT0gdC5sZW5ndGggJiYgMSA9PT0gci5ub2RlVHlwZSA/IHguZmluZC5tYXRjaGVzU2VsZWN0b3IociwgZSkgPyBbcl0gOiBbXSA6IHguZmluZC5tYXRjaGVzKGUsIHguZ3JlcCh0LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxID09PSBlLm5vZGVUeXBlXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfSwgZGlyOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGkgPSBbXSwgbyA9IGVbbl07XG4gICAgICAgICAgICB3aGlsZSAobyAmJiA5ICE9PSBvLm5vZGVUeXBlICYmIChyID09PSB0IHx8IDEgIT09IG8ubm9kZVR5cGUgfHwgIXgobykuaXMocikpKVxuICAgICAgICAgICAgICAgIDEgPT09IG8ubm9kZVR5cGUgJiYgaS5wdXNoKG8pLCBvID0gb1tuXTtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgIH0sIHNpYmxpbmc6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IFtdO1xuICAgICAgICAgICAgZm9yICg7IGU7IGUgPSBlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIDEgPT09IGUubm9kZVR5cGUgJiYgZSAhPT0gdCAmJiBuLnB1c2goZSk7XG4gICAgICAgICAgICByZXR1cm4gblxuICAgICAgICB9fSk7XG4gICAgZnVuY3Rpb24gZnQoZSwgdCwgbikge1xuICAgICAgICBpZiAoeC5pc0Z1bmN0aW9uKHQpKVxuICAgICAgICAgICAgcmV0dXJuIHguZ3JlcChlLCBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgICAgICAgIHJldHVybiEhdC5jYWxsKGUsIHIsIGUpICE9PSBuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHQubm9kZVR5cGUpXG4gICAgICAgICAgICByZXR1cm4geC5ncmVwKGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IHQgIT09IG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgICAgaWYgKHN0LnRlc3QodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHguZmlsdGVyKHQsIGUsIG4pO1xuICAgICAgICAgICAgdCA9IHguZmlsdGVyKHQsIGUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHguZ3JlcChlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHguaW5BcnJheShlLCB0KSA+PSAwICE9PSBuXG4gICAgICAgIH0pXG4gICAgfVxuICAgIGZ1bmN0aW9uIGR0KGUpIHtcbiAgICAgICAgdmFyIHQgPSBodC5zcGxpdChcInxcIiksIG4gPSBlLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgaWYgKG4uY3JlYXRlRWxlbWVudClcbiAgICAgICAgICAgIHdoaWxlICh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBuLmNyZWF0ZUVsZW1lbnQodC5wb3AoKSk7XG4gICAgICAgIHJldHVybiBuXG4gICAgfVxuICAgIHZhciBodCA9IFwiYWJicnxhcnRpY2xlfGFzaWRlfGF1ZGlvfGJkaXxjYW52YXN8ZGF0YXxkYXRhbGlzdHxkZXRhaWxzfGZpZ2NhcHRpb258ZmlndXJlfGZvb3RlcnxoZWFkZXJ8aGdyb3VwfG1hcmt8bWV0ZXJ8bmF2fG91dHB1dHxwcm9ncmVzc3xzZWN0aW9ufHN1bW1hcnl8dGltZXx2aWRlb1wiLCBndCA9IC8galF1ZXJ5XFxkKz1cIig/Om51bGx8XFxkKylcIi9nLCBtdCA9IFJlZ0V4cChcIjwoPzpcIiArIGh0ICsgXCIpW1xcXFxzLz5dXCIsIFwiaVwiKSwgeXQgPSAvXlxccysvLCB2dCA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSwgYnQgPSAvPChbXFx3Ol0rKS8sIHh0ID0gLzx0Ym9keS9pLCB3dCA9IC88fCYjP1xcdys7LywgVHQgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLCBDdCA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLCBOdCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksIGt0ID0gL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSwgRXQgPSAvXnRydWVcXC8oLiopLywgU3QgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csIEF0ID0ge29wdGlvbjogWzEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiXSwgbGVnZW5kOiBbMSwgXCI8ZmllbGRzZXQ+XCIsIFwiPC9maWVsZHNldD5cIl0sIGFyZWE6IFsxLCBcIjxtYXA+XCIsIFwiPC9tYXA+XCJdLCBwYXJhbTogWzEsIFwiPG9iamVjdD5cIiwgXCI8L29iamVjdD5cIl0sIHRoZWFkOiBbMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIl0sIHRyOiBbMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sIGNvbDogWzIsIFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLCB0ZDogWzMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCJdLCBfZGVmYXVsdDogeC5zdXBwb3J0Lmh0bWxTZXJpYWxpemUgPyBbMCwgXCJcIiwgXCJcIl0gOiBbMSwgXCJYPGRpdj5cIiwgXCI8L2Rpdj5cIl19LCBqdCA9IGR0KGEpLCBEdCA9IGp0LmFwcGVuZENoaWxkKGEuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgQXQub3B0Z3JvdXAgPSBBdC5vcHRpb24sIEF0LnRib2R5ID0gQXQudGZvb3QgPSBBdC5jb2xncm91cCA9IEF0LmNhcHRpb24gPSBBdC50aGVhZCwgQXQudGggPSBBdC50ZCwgeC5mbi5leHRlbmQoe3RleHQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA9PT0gdCA/IHgudGV4dCh0aGlzKSA6IHRoaXMuZW1wdHkoKS5hcHBlbmQoKHRoaXNbMF0gJiYgdGhpc1swXS5vd25lckRvY3VtZW50IHx8IGEpLmNyZWF0ZVRleHROb2RlKGUpKVxuICAgICAgICAgICAgfSwgbnVsbCwgZSwgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgfSwgYXBwZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IEx0KHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgICB0LmFwcGVuZENoaWxkKGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgcHJlcGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICgxID09PSB0aGlzLm5vZGVUeXBlIHx8IDExID09PSB0aGlzLm5vZGVUeXBlIHx8IDkgPT09IHRoaXMubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBMdCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgdC5pbnNlcnRCZWZvcmUoZSwgdC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGJlZm9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBhZnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICB2YXIgbiwgciA9IGUgPyB4LmZpbHRlcihlLCB0aGlzKSA6IHRoaXMsIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IG51bGwgIT0gKG4gPSByW2ldKTsgaSsrKVxuICAgICAgICAgICAgICAgIHQgfHwgMSAhPT0gbi5ub2RlVHlwZSB8fCB4LmNsZWFuRGF0YShGdChuKSksIG4ucGFyZW50Tm9kZSAmJiAodCAmJiB4LmNvbnRhaW5zKG4ub3duZXJEb2N1bWVudCwgbikgJiYgX3QoRnQobiwgXCJzY3JpcHRcIikpLCBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobikpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSwgZW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlLCB0ID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBudWxsICE9IChlID0gdGhpc1t0XSk7IHQrKykge1xuICAgICAgICAgICAgICAgIDEgPT09IGUubm9kZVR5cGUgJiYgeC5jbGVhbkRhdGEoRnQoZSwgITEpKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZS5vcHRpb25zICYmIHgubm9kZU5hbWUoZSwgXCJzZWxlY3RcIikgJiYgKGUub3B0aW9ucy5sZW5ndGggPSAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSwgY2xvbmU6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gZSA9IG51bGwgPT0gZSA/ICExIDogZSwgdCA9IG51bGwgPT0gdCA/IGUgOiB0LCB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguY2xvbmUodGhpcywgZSwgdClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGh0bWw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXNbMF0gfHwge30sIHIgPSAwLCBpID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxID09PSBuLm5vZGVUeXBlID8gbi5pbm5lckhUTUwucmVwbGFjZShndCwgXCJcIikgOiB0O1xuICAgICAgICAgICAgICAgIGlmICghKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgfHwgVHQudGVzdChlKSB8fCAheC5zdXBwb3J0Lmh0bWxTZXJpYWxpemUgJiYgbXQudGVzdChlKSB8fCAheC5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHl0LnRlc3QoZSkgfHwgQXRbKGJ0LmV4ZWMoZSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUucmVwbGFjZSh2dCwgXCI8JDE+PC8kMj5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA+IHI7IHIrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gdGhpc1tyXSB8fCB7fSwgMSA9PT0gbi5ub2RlVHlwZSAmJiAoeC5jbGVhbkRhdGEoRnQobiwgITEpKSwgbi5pbm5lckhUTUwgPSBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAwXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuICYmIHRoaXMuZW1wdHkoKS5hcHBlbmQoZSlcbiAgICAgICAgICAgIH0sIG51bGwsIGUsIGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIH0sIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHgubWFwKHRoaXMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuW2UubmV4dFNpYmxpbmcsIGUucGFyZW50Tm9kZV1cbiAgICAgICAgICAgIH0pLCB0ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGVbdCsrXSwgaSA9IGVbdCsrXTtcbiAgICAgICAgICAgICAgICBpICYmIChyICYmIHIucGFyZW50Tm9kZSAhPT0gaSAmJiAociA9IHRoaXMubmV4dFNpYmxpbmcpLCB4KHRoaXMpLnJlbW92ZSgpLCBpLmluc2VydEJlZm9yZShuLCByKSlcbiAgICAgICAgICAgIH0sICEwKSwgdCA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpXG4gICAgICAgIH0sIGRldGFjaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZShlLCAhMClcbiAgICAgICAgfSwgZG9tTWFuaXA6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICBlID0gZC5hcHBseShbXSwgZSk7XG4gICAgICAgICAgICB2YXIgciwgaSwgbywgYSwgcywgbCwgdSA9IDAsIGMgPSB0aGlzLmxlbmd0aCwgcCA9IHRoaXMsIGYgPSBjIC0gMSwgaCA9IGVbMF0sIGcgPSB4LmlzRnVuY3Rpb24oaCk7XG4gICAgICAgICAgICBpZiAoZyB8fCAhKDEgPj0gYyB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBoIHx8IHguc3VwcG9ydC5jaGVja0Nsb25lKSAmJiBOdC50ZXN0KGgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBwLmVxKHIpO1xuICAgICAgICAgICAgICAgICAgICBnICYmIChlWzBdID0gaC5jYWxsKHRoaXMsIHIsIGkuaHRtbCgpKSksIGkuZG9tTWFuaXAoZSwgdCwgbilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjICYmIChsID0geC5idWlsZEZyYWdtZW50KGUsIHRoaXNbMF0ub3duZXJEb2N1bWVudCwgITEsICFuICYmIHRoaXMpLCByID0gbC5maXJzdENoaWxkLCAxID09PSBsLmNoaWxkTm9kZXMubGVuZ3RoICYmIChsID0gciksIHIpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChhID0geC5tYXAoRnQobCwgXCJzY3JpcHRcIiksIEh0KSwgbyA9IGEubGVuZ3RoOyBjID4gdTsgdSsrKVxuICAgICAgICAgICAgICAgICAgICBpID0gbCwgdSAhPT0gZiAmJiAoaSA9IHguY2xvbmUoaSwgITAsICEwKSwgbyAmJiB4Lm1lcmdlKGEsIEZ0KGksIFwic2NyaXB0XCIpKSksIHQuY2FsbCh0aGlzW3VdLCBpLCB1KTtcbiAgICAgICAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChzID0gYVthLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQsIHgubWFwKGEsIHF0KSwgdSA9IDA7IG8gPiB1OyB1KyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gYVt1XSwga3QudGVzdChpLnR5cGUgfHwgXCJcIikgJiYgIXguX2RhdGEoaSwgXCJnbG9iYWxFdmFsXCIpICYmIHguY29udGFpbnMocywgaSkgJiYgKGkuc3JjID8geC5fZXZhbFVybChpLnNyYykgOiB4Lmdsb2JhbEV2YWwoKGkudGV4dCB8fCBpLnRleHRDb250ZW50IHx8IGkuaW5uZXJIVE1MIHx8IFwiXCIpLnJlcGxhY2UoU3QsIFwiXCIpKSk7XG4gICAgICAgICAgICAgICAgbCA9IHIgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9fSk7XG4gICAgZnVuY3Rpb24gTHQoZSwgdCkge1xuICAgICAgICByZXR1cm4geC5ub2RlTmFtZShlLCBcInRhYmxlXCIpICYmIHgubm9kZU5hbWUoMSA9PT0gdC5ub2RlVHlwZSA/IHQgOiB0LmZpcnN0Q2hpbGQsIFwidHJcIikgPyBlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHwgZS5hcHBlbmRDaGlsZChlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKSA6IGVcbiAgICB9XG4gICAgZnVuY3Rpb24gSHQoZSkge1xuICAgICAgICByZXR1cm4gZS50eXBlID0gKG51bGwgIT09IHguZmluZC5hdHRyKGUsIFwidHlwZVwiKSkgKyBcIi9cIiArIGUudHlwZSwgZVxuICAgIH1cbiAgICBmdW5jdGlvbiBxdChlKSB7XG4gICAgICAgIHZhciB0ID0gRXQuZXhlYyhlLnR5cGUpO1xuICAgICAgICByZXR1cm4gdCA/IGUudHlwZSA9IHRbMV0gOiBlLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIiksIGVcbiAgICB9XG4gICAgZnVuY3Rpb24gX3QoZSwgdCkge1xuICAgICAgICB2YXIgbiwgciA9IDA7XG4gICAgICAgIGZvciAoOyBudWxsICE9IChuID0gZVtyXSk7IHIrKylcbiAgICAgICAgICAgIHguX2RhdGEobiwgXCJnbG9iYWxFdmFsXCIsICF0IHx8IHguX2RhdGEodFtyXSwgXCJnbG9iYWxFdmFsXCIpKVxuICAgIH1cbiAgICBmdW5jdGlvbiBNdChlLCB0KSB7XG4gICAgICAgIGlmICgxID09PSB0Lm5vZGVUeXBlICYmIHguaGFzRGF0YShlKSkge1xuICAgICAgICAgICAgdmFyIG4sIHIsIGksIG8gPSB4Ll9kYXRhKGUpLCBhID0geC5fZGF0YSh0LCBvKSwgcyA9IG8uZXZlbnRzO1xuICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYS5oYW5kbGUsIGEuZXZlbnRzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChuIGluIHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAociA9IDAsIGkgPSBzW25dLmxlbmd0aDsgaSA+IHI7IHIrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHguZXZlbnQuYWRkKHQsIG4sIHNbbl1bcl0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLmRhdGEgJiYgKGEuZGF0YSA9IHguZXh0ZW5kKHt9LCBhLmRhdGEpKVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIE90KGUsIHQpIHtcbiAgICAgICAgdmFyIG4sIHIsIGk7XG4gICAgICAgIGlmICgxID09PSB0Lm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBpZiAobiA9IHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgIXguc3VwcG9ydC5ub0Nsb25lRXZlbnQgJiYgdFt4LmV4cGFuZG9dKSB7XG4gICAgICAgICAgICAgICAgaSA9IHguX2RhdGEodCk7XG4gICAgICAgICAgICAgICAgZm9yIChyIGluIGkuZXZlbnRzKVxuICAgICAgICAgICAgICAgICAgICB4LnJlbW92ZUV2ZW50KHQsIHIsIGkuaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB0LnJlbW92ZUF0dHJpYnV0ZSh4LmV4cGFuZG8pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcInNjcmlwdFwiID09PSBuICYmIHQudGV4dCAhPT0gZS50ZXh0ID8gKEh0KHQpLnRleHQgPSBlLnRleHQsIHF0KHQpKSA6IFwib2JqZWN0XCIgPT09IG4gPyAodC5wYXJlbnROb2RlICYmICh0Lm91dGVySFRNTCA9IGUub3V0ZXJIVE1MKSwgeC5zdXBwb3J0Lmh0bWw1Q2xvbmUgJiYgZS5pbm5lckhUTUwgJiYgIXgudHJpbSh0LmlubmVySFRNTCkgJiYgKHQuaW5uZXJIVE1MID0gZS5pbm5lckhUTUwpKSA6IFwiaW5wdXRcIiA9PT0gbiAmJiBDdC50ZXN0KGUudHlwZSkgPyAodC5kZWZhdWx0Q2hlY2tlZCA9IHQuY2hlY2tlZCA9IGUuY2hlY2tlZCwgdC52YWx1ZSAhPT0gZS52YWx1ZSAmJiAodC52YWx1ZSA9IGUudmFsdWUpKSA6IFwib3B0aW9uXCIgPT09IG4gPyB0LmRlZmF1bHRTZWxlY3RlZCA9IHQuc2VsZWN0ZWQgPSBlLmRlZmF1bHRTZWxlY3RlZCA6IChcImlucHV0XCIgPT09IG4gfHwgXCJ0ZXh0YXJlYVwiID09PSBuKSAmJiAodC5kZWZhdWx0VmFsdWUgPSBlLmRlZmF1bHRWYWx1ZSlcbiAgICAgICAgfVxuICAgIH1cbiAgICB4LmVhY2goe2FwcGVuZFRvOiBcImFwcGVuZFwiLCBwcmVwZW5kVG86IFwicHJlcGVuZFwiLCBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsIGluc2VydEFmdGVyOiBcImFmdGVyXCIsIHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIn0sIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHguZm5bZV0gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIG4sIHIgPSAwLCBpID0gW10sIG8gPSB4KGUpLCBhID0gby5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm9yICg7IGEgPj0gcjsgcisrKVxuICAgICAgICAgICAgICAgIG4gPSByID09PSBhID8gdGhpcyA6IHRoaXMuY2xvbmUoITApLCB4KG9bcl0pW3RdKG4pLCBoLmFwcGx5KGksIG4uZ2V0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGkpXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBGdChlLCBuKSB7XG4gICAgICAgIHZhciByLCBvLCBhID0gMCwgcyA9IHR5cGVvZiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBpID8gZS5nZXRFbGVtZW50c0J5VGFnTmFtZShuIHx8IFwiKlwiKSA6IHR5cGVvZiBlLnF1ZXJ5U2VsZWN0b3JBbGwgIT09IGkgPyBlLnF1ZXJ5U2VsZWN0b3JBbGwobiB8fCBcIipcIikgOiB0O1xuICAgICAgICBpZiAoIXMpXG4gICAgICAgICAgICBmb3IgKHMgPSBbXSwgciA9IGUuY2hpbGROb2RlcyB8fCBlOyBudWxsICE9IChvID0gclthXSk7IGErKylcbiAgICAgICAgICAgICAgICAhbiB8fCB4Lm5vZGVOYW1lKG8sIG4pID8gcy5wdXNoKG8pIDogeC5tZXJnZShzLCBGdChvLCBuKSk7XG4gICAgICAgIHJldHVybiBuID09PSB0IHx8IG4gJiYgeC5ub2RlTmFtZShlLCBuKSA/IHgubWVyZ2UoW2VdLCBzKSA6IHNcbiAgICB9XG4gICAgZnVuY3Rpb24gQnQoZSkge1xuICAgICAgICBDdC50ZXN0KGUudHlwZSkgJiYgKGUuZGVmYXVsdENoZWNrZWQgPSBlLmNoZWNrZWQpXG4gICAgfVxuICAgIHguZXh0ZW5kKHtjbG9uZTogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHZhciByLCBpLCBvLCBhLCBzLCBsID0geC5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsIGUpO1xuICAgICAgICAgICAgaWYgKHguc3VwcG9ydC5odG1sNUNsb25lIHx8IHguaXNYTUxEb2MoZSkgfHwgIW10LnRlc3QoXCI8XCIgKyBlLm5vZGVOYW1lICsgXCI+XCIpID8gbyA9IGUuY2xvbmVOb2RlKCEwKSA6IChEdC5pbm5lckhUTUwgPSBlLm91dGVySFRNTCwgRHQucmVtb3ZlQ2hpbGQobyA9IER0LmZpcnN0Q2hpbGQpKSwgISh4LnN1cHBvcnQubm9DbG9uZUV2ZW50ICYmIHguc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCB8fCAxICE9PSBlLm5vZGVUeXBlICYmIDExICE9PSBlLm5vZGVUeXBlIHx8IHguaXNYTUxEb2MoZSkpKVxuICAgICAgICAgICAgICAgIGZvciAociA9IEZ0KG8pLCBzID0gRnQoZSksIGEgPSAwOyBudWxsICE9IChpID0gc1thXSk7ICsrYSlcbiAgICAgICAgICAgICAgICAgICAgclthXSAmJiBPdChpLCByW2FdKTtcbiAgICAgICAgICAgIGlmICh0KVxuICAgICAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHMgPSBzIHx8IEZ0KGUpLCByID0gciB8fCBGdChvKSwgYSA9IDA7IG51bGwgIT0gKGkgPSBzW2FdKTsgYSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgTXQoaSwgclthXSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBNdChlLCBvKTtcbiAgICAgICAgICAgIHJldHVybiByID0gRnQobywgXCJzY3JpcHRcIiksIHIubGVuZ3RoID4gMCAmJiBfdChyLCAhbCAmJiBGdChlLCBcInNjcmlwdFwiKSksIHIgPSBzID0gaSA9IG51bGwsIG9cbiAgICAgICAgfSwgYnVpbGRGcmFnbWVudDogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgIHZhciBpLCBvLCBhLCBzLCBsLCB1LCBjLCBwID0gZS5sZW5ndGgsIGYgPSBkdCh0KSwgZCA9IFtdLCBoID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBwID4gaDsgaCsrKVxuICAgICAgICAgICAgICAgIGlmIChvID0gZVtoXSwgbyB8fCAwID09PSBvKVxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0geC50eXBlKG8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgeC5tZXJnZShkLCBvLm5vZGVUeXBlID8gW29dIDogbyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHd0LnRlc3QobykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzIHx8IGYuYXBwZW5kQ2hpbGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwgbCA9IChidC5leGVjKG8pIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSwgYyA9IEF0W2xdIHx8IEF0Ll9kZWZhdWx0LCBzLmlubmVySFRNTCA9IGNbMV0gKyBvLnJlcGxhY2UodnQsIFwiPCQxPjwvJDI+XCIpICsgY1syXSwgaSA9IGNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgheC5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHl0LnRlc3QobykgJiYgZC5wdXNoKHQuY3JlYXRlVGV4dE5vZGUoeXQuZXhlYyhvKVswXSkpLCAheC5zdXBwb3J0LnRib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IFwidGFibGVcIiAhPT0gbCB8fCB4dC50ZXN0KG8pID8gXCI8dGFibGU+XCIgIT09IGNbMV0gfHwgeHQudGVzdChvKSA/IDAgOiBzIDogcy5maXJzdENoaWxkLCBpID0gbyAmJiBvLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgubm9kZU5hbWUodSA9IG8uY2hpbGROb2Rlc1tpXSwgXCJ0Ym9keVwiKSAmJiAhdS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBvLnJlbW92ZUNoaWxkKHUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4Lm1lcmdlKGQsIHMuY2hpbGROb2RlcyksIHMudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHMuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnJlbW92ZUNoaWxkKHMuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gZi5sYXN0Q2hpbGRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnB1c2godC5jcmVhdGVUZXh0Tm9kZShvKSk7XG4gICAgICAgICAgICBzICYmIGYucmVtb3ZlQ2hpbGQocyksIHguc3VwcG9ydC5hcHBlbmRDaGVja2VkIHx8IHguZ3JlcChGdChkLCBcImlucHV0XCIpLCBCdCksIGggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG8gPSBkW2grK10pXG4gICAgICAgICAgICAgICAgaWYgKCghciB8fCAtMSA9PT0geC5pbkFycmF5KG8sIHIpKSAmJiAoYSA9IHguY29udGFpbnMoby5vd25lckRvY3VtZW50LCBvKSwgcyA9IEZ0KGYuYXBwZW5kQ2hpbGQobyksIFwic2NyaXB0XCIpLCBhICYmIF90KHMpLCBuKSkge1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG8gPSBzW2krK10pXG4gICAgICAgICAgICAgICAgICAgICAgICBrdC50ZXN0KG8udHlwZSB8fCBcIlwiKSAmJiBuLnB1c2gobylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcyA9IG51bGwsIGZcbiAgICAgICAgfSwgY2xlYW5EYXRhOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgdmFyIG4sIHIsIG8sIGEsIHMgPSAwLCBsID0geC5leHBhbmRvLCB1ID0geC5jYWNoZSwgYyA9IHguc3VwcG9ydC5kZWxldGVFeHBhbmRvLCBmID0geC5ldmVudC5zcGVjaWFsO1xuICAgICAgICAgICAgZm9yICg7IG51bGwgIT0gKG4gPSBlW3NdKTsgcysrKVxuICAgICAgICAgICAgICAgIGlmICgodCB8fCB4LmFjY2VwdERhdGEobikpICYmIChvID0gbltsXSwgYSA9IG8gJiYgdVtvXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEuZXZlbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChyIGluIGEuZXZlbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZbcl0gPyB4LmV2ZW50LnJlbW92ZShuLCByKSA6IHgucmVtb3ZlRXZlbnQobiwgciwgYS5oYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICB1W29dICYmIChkZWxldGUgdVtvXSwgYyA/IGRlbGV0ZSBuW2xdIDogdHlwZW9mIG4ucmVtb3ZlQXR0cmlidXRlICE9PSBpID8gbi5yZW1vdmVBdHRyaWJ1dGUobCkgOiBuW2xdID0gbnVsbCwgcC5wdXNoKG8pKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSwgX2V2YWxVcmw6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hamF4KHt1cmw6IGUsIHR5cGU6IFwiR0VUXCIsIGRhdGFUeXBlOiBcInNjcmlwdFwiLCBhc3luYzogITEsIGdsb2JhbDogITEsIFwidGhyb3dzXCI6ICEwfSlcbiAgICAgICAgfX0pLCB4LmZuLmV4dGVuZCh7d3JhcEFsbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh4LmlzRnVuY3Rpb24oZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB4KHRoaXMpLndyYXBBbGwoZS5jYWxsKHRoaXMsIHQpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHgoZSwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCk7XG4gICAgICAgICAgICAgICAgdGhpc1swXS5wYXJlbnROb2RlICYmIHQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLCB0Lm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGUuZmlyc3RDaGlsZCAmJiAxID09PSBlLmZpcnN0Q2hpbGQubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICAgICAgICAgIH0pLmFwcGVuZCh0aGlzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSwgd3JhcElubmVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHguaXNGdW5jdGlvbihlKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHgodGhpcykud3JhcElubmVyKGUuY2FsbCh0aGlzLCB0KSlcbiAgICAgICAgICAgIH0pIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHgodGhpcyksIG4gPSB0LmNvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgbi5sZW5ndGggPyBuLndyYXBBbGwoZSkgOiB0LmFwcGVuZChlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgd3JhcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0geC5pc0Z1bmN0aW9uKGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHgodGhpcykud3JhcEFsbCh0ID8gZS5jYWxsKHRoaXMsIG4pIDogZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHVud3JhcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeC5ub2RlTmFtZSh0aGlzLCBcImJvZHlcIikgfHwgeCh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpXG4gICAgICAgICAgICB9KS5lbmQoKVxuICAgICAgICB9fSk7XG4gICAgdmFyIFB0LCBSdCwgV3QsICR0ID0gL2FscGhhXFwoW14pXSpcXCkvaSwgSXQgPSAvb3BhY2l0eVxccyo9XFxzKihbXildKikvLCB6dCA9IC9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkLywgWHQgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sIFV0ID0gL15tYXJnaW4vLCBWdCA9IFJlZ0V4cChcIl4oXCIgKyB3ICsgXCIpKC4qKSRcIiwgXCJpXCIpLCBZdCA9IFJlZ0V4cChcIl4oXCIgKyB3ICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpLCBKdCA9IFJlZ0V4cChcIl4oWystXSk9KFwiICsgdyArIFwiKVwiLCBcImlcIiksIEd0ID0ge0JPRFk6IFwiYmxvY2tcIn0sIFF0ID0ge3Bvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIn0sIEt0ID0ge2xldHRlclNwYWNpbmc6IDAsIGZvbnRXZWlnaHQ6IDQwMH0sIFp0ID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdLCBlbiA9IFtcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiXTtcbiAgICBmdW5jdGlvbiB0bihlLCB0KSB7XG4gICAgICAgIGlmICh0IGluIGUpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgdmFyIG4gPSB0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdC5zbGljZSgxKSwgciA9IHQsIGkgPSBlbi5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICBpZiAodCA9IGVuW2ldICsgbiwgdCBpbiBlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICByZXR1cm4gclxuICAgIH1cbiAgICBmdW5jdGlvbiBubihlLCB0KSB7XG4gICAgICAgIHJldHVybiBlID0gdCB8fCBlLCBcIm5vbmVcIiA9PT0geC5jc3MoZSwgXCJkaXNwbGF5XCIpIHx8ICF4LmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCwgZSlcbiAgICB9XG4gICAgZnVuY3Rpb24gcm4oZSwgdCkge1xuICAgICAgICB2YXIgbiwgciwgaSwgbyA9IFtdLCBhID0gMCwgcyA9IGUubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgcyA+IGE7IGErKylcbiAgICAgICAgICAgIHIgPSBlW2FdLCByLnN0eWxlICYmIChvW2FdID0geC5fZGF0YShyLCBcIm9sZGRpc3BsYXlcIiksIG4gPSByLnN0eWxlLmRpc3BsYXksIHQgPyAob1thXSB8fCBcIm5vbmVcIiAhPT0gbiB8fCAoci5zdHlsZS5kaXNwbGF5ID0gXCJcIiksIFwiXCIgPT09IHIuc3R5bGUuZGlzcGxheSAmJiBubihyKSAmJiAob1thXSA9IHguX2RhdGEociwgXCJvbGRkaXNwbGF5XCIsIGxuKHIubm9kZU5hbWUpKSkpIDogb1thXSB8fCAoaSA9IG5uKHIpLCAobiAmJiBcIm5vbmVcIiAhPT0gbiB8fCAhaSkgJiYgeC5fZGF0YShyLCBcIm9sZGRpc3BsYXlcIiwgaSA/IG4gOiB4LmNzcyhyLCBcImRpc3BsYXlcIikpKSk7XG4gICAgICAgIGZvciAoYSA9IDA7IHMgPiBhOyBhKyspXG4gICAgICAgICAgICByID0gZVthXSwgci5zdHlsZSAmJiAodCAmJiBcIm5vbmVcIiAhPT0gci5zdHlsZS5kaXNwbGF5ICYmIFwiXCIgIT09IHIuc3R5bGUuZGlzcGxheSB8fCAoci5zdHlsZS5kaXNwbGF5ID0gdCA/IG9bYV0gfHwgXCJcIiA6IFwibm9uZVwiKSk7XG4gICAgICAgIHJldHVybiBlXG4gICAgfVxuICAgIHguZm4uZXh0ZW5kKHtjc3M6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbywgYSA9IHt9LCBzID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoeC5pc0FycmF5KG4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobyA9IFJ0KGUpLCBpID0gbi5sZW5ndGg7IGkgPiBzOyBzKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBhW25bc11dID0geC5jc3MoZSwgbltzXSwgITEsIG8pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gciAhPT0gdCA/IHguc3R5bGUoZSwgbiwgcikgOiB4LmNzcyhlLCBuKVxuICAgICAgICAgICAgfSwgZSwgbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICAgIH0sIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBybih0aGlzLCAhMClcbiAgICAgICAgfSwgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJuKHRoaXMpXG4gICAgICAgIH0sIHRvZ2dsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVyblwiYm9vbGVhblwiID09IHR5cGVvZiBlID8gZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5uKHRoaXMpID8geCh0aGlzKS5zaG93KCkgOiB4KHRoaXMpLmhpZGUoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfX0pLCB4LmV4dGVuZCh7Y3NzSG9va3M6IHtvcGFjaXR5OiB7Z2V0OiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBXdChlLCBcIm9wYWNpdHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cIlwiID09PSBuID8gXCIxXCIgOiBuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fX0sIGNzc051bWJlcjoge2NvbHVtbkNvdW50OiAhMCwgZmlsbE9wYWNpdHk6ICEwLCBmb250V2VpZ2h0OiAhMCwgbGluZUhlaWdodDogITAsIG9wYWNpdHk6ICEwLCBvcmRlcjogITAsIG9ycGhhbnM6ICEwLCB3aWRvd3M6ICEwLCB6SW5kZXg6ICEwLCB6b29tOiAhMH0sIGNzc1Byb3BzOiB7XCJmbG9hdFwiOiB4LnN1cHBvcnQuY3NzRmxvYXQgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIn0sIHN0eWxlOiBmdW5jdGlvbiAoZSwgbiwgciwgaSkge1xuICAgICAgICAgICAgaWYgKGUgJiYgMyAhPT0gZS5ub2RlVHlwZSAmJiA4ICE9PSBlLm5vZGVUeXBlICYmIGUuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbywgYSwgcywgbCA9IHguY2FtZWxDYXNlKG4pLCB1ID0gZS5zdHlsZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9IHguY3NzUHJvcHNbbF0gfHwgKHguY3NzUHJvcHNbbF0gPSB0bih1LCBsKSksIHMgPSB4LmNzc0hvb2tzW25dIHx8IHguY3NzSG9va3NbbF0sIHIgPT09IHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzICYmIFwiZ2V0XCJpbiBzICYmIChvID0gcy5nZXQoZSwgITEsIGkpKSAhPT0gdCA/IG8gOiB1W25dO1xuICAgICAgICAgICAgICAgIGlmIChhID0gdHlwZW9mIHIsIFwic3RyaW5nXCIgPT09IGEgJiYgKG8gPSBKdC5leGVjKHIpKSAmJiAociA9IChvWzFdICsgMSkgKiBvWzJdICsgcGFyc2VGbG9hdCh4LmNzcyhlLCBuKSksIGEgPSBcIm51bWJlclwiKSwgIShudWxsID09IHIgfHwgXCJudW1iZXJcIiA9PT0gYSAmJiBpc05hTihyKSB8fCAoXCJudW1iZXJcIiAhPT0gYSB8fCB4LmNzc051bWJlcltsXSB8fCAociArPSBcInB4XCIpLCB4LnN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlIHx8IFwiXCIgIT09IHIgfHwgMCAhPT0gbi5pbmRleE9mKFwiYmFja2dyb3VuZFwiKSB8fCAodVtuXSA9IFwiaW5oZXJpdFwiKSwgcyAmJiBcInNldFwiaW4gcyAmJiAociA9IHMuc2V0KGUsIHIsIGkpKSA9PT0gdCkpKVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdVtuXSA9IHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNzczogZnVuY3Rpb24gKGUsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgIHZhciBvLCBhLCBzLCBsID0geC5jYW1lbENhc2Uobik7XG4gICAgICAgICAgICByZXR1cm4gbiA9IHguY3NzUHJvcHNbbF0gfHwgKHguY3NzUHJvcHNbbF0gPSB0bihlLnN0eWxlLCBsKSksIHMgPSB4LmNzc0hvb2tzW25dIHx8IHguY3NzSG9va3NbbF0sIHMgJiYgXCJnZXRcImluIHMgJiYgKGEgPSBzLmdldChlLCAhMCwgcikpLCBhID09PSB0ICYmIChhID0gV3QoZSwgbiwgaSkpLCBcIm5vcm1hbFwiID09PSBhICYmIG4gaW4gS3QgJiYgKGEgPSBLdFtuXSksIFwiXCIgPT09IHIgfHwgciA/IChvID0gcGFyc2VGbG9hdChhKSwgciA9PT0gITAgfHwgeC5pc051bWVyaWMobykgPyBvIHx8IDAgOiBhKSA6IGFcbiAgICAgICAgfX0pLCBlLmdldENvbXB1dGVkU3R5bGUgPyAoUnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gZS5nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpXG4gICAgfSwgV3QgPSBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICB2YXIgaSwgbywgYSwgcyA9IHIgfHwgUnQoZSksIGwgPSBzID8gcy5nZXRQcm9wZXJ0eVZhbHVlKG4pIHx8IHNbbl0gOiB0LCB1ID0gZS5zdHlsZTtcbiAgICAgICAgcmV0dXJuIHMgJiYgKFwiXCIgIT09IGwgfHwgeC5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsIGUpIHx8IChsID0geC5zdHlsZShlLCBuKSksIFl0LnRlc3QobCkgJiYgVXQudGVzdChuKSAmJiAoaSA9IHUud2lkdGgsIG8gPSB1Lm1pbldpZHRoLCBhID0gdS5tYXhXaWR0aCwgdS5taW5XaWR0aCA9IHUubWF4V2lkdGggPSB1LndpZHRoID0gbCwgbCA9IHMud2lkdGgsIHUud2lkdGggPSBpLCB1Lm1pbldpZHRoID0gbywgdS5tYXhXaWR0aCA9IGEpKSwgbFxuICAgIH0pIDogYS5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlICYmIChSdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmN1cnJlbnRTdHlsZVxuICAgIH0sIFd0ID0gZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgdmFyIGksIG8sIGEsIHMgPSByIHx8IFJ0KGUpLCBsID0gcyA/IHNbbl0gOiB0LCB1ID0gZS5zdHlsZTtcbiAgICAgICAgcmV0dXJuIG51bGwgPT0gbCAmJiB1ICYmIHVbbl0gJiYgKGwgPSB1W25dKSwgWXQudGVzdChsKSAmJiAhenQudGVzdChuKSAmJiAoaSA9IHUubGVmdCwgbyA9IGUucnVudGltZVN0eWxlLCBhID0gbyAmJiBvLmxlZnQsIGEgJiYgKG8ubGVmdCA9IGUuY3VycmVudFN0eWxlLmxlZnQpLCB1LmxlZnQgPSBcImZvbnRTaXplXCIgPT09IG4gPyBcIjFlbVwiIDogbCwgbCA9IHUucGl4ZWxMZWZ0ICsgXCJweFwiLCB1LmxlZnQgPSBpLCBhICYmIChvLmxlZnQgPSBhKSksIFwiXCIgPT09IGwgPyBcImF1dG9cIiA6IGxcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBvbihlLCB0LCBuKSB7XG4gICAgICAgIHZhciByID0gVnQuZXhlYyh0KTtcbiAgICAgICAgcmV0dXJuIHIgPyBNYXRoLm1heCgwLCByWzFdIC0gKG4gfHwgMCkpICsgKHJbMl0gfHwgXCJweFwiKSA6IHRcbiAgICB9XG4gICAgZnVuY3Rpb24gYW4oZSwgdCwgbiwgciwgaSkge1xuICAgICAgICB2YXIgbyA9IG4gPT09IChyID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSA/IDQgOiBcIndpZHRoXCIgPT09IHQgPyAxIDogMCwgYSA9IDA7XG4gICAgICAgIGZvciAoOyA0ID4gbzsgbyArPSAyKVxuICAgICAgICAgICAgXCJtYXJnaW5cIiA9PT0gbiAmJiAoYSArPSB4LmNzcyhlLCBuICsgWnRbb10sICEwLCBpKSksIHIgPyAoXCJjb250ZW50XCIgPT09IG4gJiYgKGEgLT0geC5jc3MoZSwgXCJwYWRkaW5nXCIgKyBadFtvXSwgITAsIGkpKSwgXCJtYXJnaW5cIiAhPT0gbiAmJiAoYSAtPSB4LmNzcyhlLCBcImJvcmRlclwiICsgWnRbb10gKyBcIldpZHRoXCIsICEwLCBpKSkpIDogKGEgKz0geC5jc3MoZSwgXCJwYWRkaW5nXCIgKyBadFtvXSwgITAsIGkpLCBcInBhZGRpbmdcIiAhPT0gbiAmJiAoYSArPSB4LmNzcyhlLCBcImJvcmRlclwiICsgWnRbb10gKyBcIldpZHRoXCIsICEwLCBpKSkpO1xuICAgICAgICByZXR1cm4gYVxuICAgIH1cbiAgICBmdW5jdGlvbiBzbihlLCB0LCBuKSB7XG4gICAgICAgIHZhciByID0gITAsIGkgPSBcIndpZHRoXCIgPT09IHQgPyBlLm9mZnNldFdpZHRoIDogZS5vZmZzZXRIZWlnaHQsIG8gPSBSdChlKSwgYSA9IHguc3VwcG9ydC5ib3hTaXppbmcgJiYgXCJib3JkZXItYm94XCIgPT09IHguY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCBvKTtcbiAgICAgICAgaWYgKDAgPj0gaSB8fCBudWxsID09IGkpIHtcbiAgICAgICAgICAgIGlmIChpID0gV3QoZSwgdCwgbyksICgwID4gaSB8fCBudWxsID09IGkpICYmIChpID0gZS5zdHlsZVt0XSksIFl0LnRlc3QoaSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICByID0gYSAmJiAoeC5zdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlIHx8IGkgPT09IGUuc3R5bGVbdF0pLCBpID0gcGFyc2VGbG9hdChpKSB8fCAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGkgKyBhbihlLCB0LCBuIHx8IChhID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSwgciwgbykgKyBcInB4XCJcbiAgICB9XG4gICAgZnVuY3Rpb24gbG4oZSkge1xuICAgICAgICB2YXIgdCA9IGEsIG4gPSBHdFtlXTtcbiAgICAgICAgcmV0dXJuIG4gfHwgKG4gPSB1bihlLCB0KSwgXCJub25lXCIgIT09IG4gJiYgbiB8fCAoUHQgPSAoUHQgfHwgeChcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIikuY3NzKFwiY3NzVGV4dFwiLCBcImRpc3BsYXk6YmxvY2sgIWltcG9ydGFudFwiKSkuYXBwZW5kVG8odC5kb2N1bWVudEVsZW1lbnQpLCB0ID0gKFB0WzBdLmNvbnRlbnRXaW5kb3cgfHwgUHRbMF0uY29udGVudERvY3VtZW50KS5kb2N1bWVudCwgdC53cml0ZShcIjwhZG9jdHlwZSBodG1sPjxodG1sPjxib2R5PlwiKSwgdC5jbG9zZSgpLCBuID0gdW4oZSwgdCksIFB0LmRldGFjaCgpKSwgR3RbZV0gPSBuKSwgblxuICAgIH1cbiAgICBmdW5jdGlvbiB1bihlLCB0KSB7XG4gICAgICAgIHZhciBuID0geCh0LmNyZWF0ZUVsZW1lbnQoZSkpLmFwcGVuZFRvKHQuYm9keSksIHIgPSB4LmNzcyhuWzBdLCBcImRpc3BsYXlcIik7XG4gICAgICAgIHJldHVybiBuLnJlbW92ZSgpLCByXG4gICAgfVxuICAgIHguZWFjaChbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXSwgZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgeC5jc3NIb29rc1tuXSA9IHtnZXQ6IGZ1bmN0aW9uIChlLCByLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgPyAwID09PSBlLm9mZnNldFdpZHRoICYmIFh0LnRlc3QoeC5jc3MoZSwgXCJkaXNwbGF5XCIpKSA/IHguc3dhcChlLCBRdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc24oZSwgbiwgaSlcbiAgICAgICAgICAgICAgICB9KSA6IHNuKGUsIG4sIGkpIDogdFxuICAgICAgICAgICAgfSwgc2V0OiBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgICAgICAgICAgIHZhciBpID0gciAmJiBSdChlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb24oZSwgdCwgciA/IGFuKGUsIG4sIHIsIHguc3VwcG9ydC5ib3hTaXppbmcgJiYgXCJib3JkZXItYm94XCIgPT09IHguY3NzKGUsIFwiYm94U2l6aW5nXCIsICExLCBpKSwgaSkgOiAwKVxuICAgICAgICAgICAgfX1cbiAgICB9KSwgeC5zdXBwb3J0Lm9wYWNpdHkgfHwgKHguY3NzSG9va3Mub3BhY2l0eSA9IHtnZXQ6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gSXQudGVzdCgodCAmJiBlLmN1cnJlbnRTdHlsZSA/IGUuY3VycmVudFN0eWxlLmZpbHRlciA6IGUuc3R5bGUuZmlsdGVyKSB8fCBcIlwiKSA/IC4wMSAqIHBhcnNlRmxvYXQoUmVnRXhwLiQxKSArIFwiXCIgOiB0ID8gXCIxXCIgOiBcIlwiXG4gICAgICAgIH0sIHNldDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gZS5zdHlsZSwgciA9IGUuY3VycmVudFN0eWxlLCBpID0geC5pc051bWVyaWModCkgPyBcImFscGhhKG9wYWNpdHk9XCIgKyAxMDAgKiB0ICsgXCIpXCIgOiBcIlwiLCBvID0gciAmJiByLmZpbHRlciB8fCBuLmZpbHRlciB8fCBcIlwiO1xuICAgICAgICAgICAgbi56b29tID0gMSwgKHQgPj0gMSB8fCBcIlwiID09PSB0KSAmJiBcIlwiID09PSB4LnRyaW0oby5yZXBsYWNlKCR0LCBcIlwiKSkgJiYgbi5yZW1vdmVBdHRyaWJ1dGUgJiYgKG4ucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpLCBcIlwiID09PSB0IHx8IHIgJiYgIXIuZmlsdGVyKSB8fCAobi5maWx0ZXIgPSAkdC50ZXN0KG8pID8gby5yZXBsYWNlKCR0LCBpKSA6IG8gKyBcIiBcIiArIGkpXG4gICAgICAgIH19KSwgeChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHguc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0IHx8ICh4LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0ge2dldDogZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbiA/IHguc3dhcChlLCB7ZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIn0sIFd0LCBbZSwgXCJtYXJnaW5SaWdodFwiXSkgOiB0XG4gICAgICAgICAgICB9fSksICF4LnN1cHBvcnQucGl4ZWxQb3NpdGlvbiAmJiB4LmZuLnBvc2l0aW9uICYmIHguZWFjaChbXCJ0b3BcIiwgXCJsZWZ0XCJdLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgeC5jc3NIb29rc1tuXSA9IHtnZXQ6IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByID8gKHIgPSBXdChlLCBuKSwgWXQudGVzdChyKSA/IHgoZSkucG9zaXRpb24oKVtuXSArIFwicHhcIiA6IHIpIDogdFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgIH0pXG4gICAgfSksIHguZXhwciAmJiB4LmV4cHIuZmlsdGVycyAmJiAoeC5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIDAgPj0gZS5vZmZzZXRXaWR0aCAmJiAwID49IGUub2Zmc2V0SGVpZ2h0IHx8ICF4LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzICYmIFwibm9uZVwiID09PSAoZS5zdHlsZSAmJiBlLnN0eWxlLmRpc3BsYXkgfHwgeC5jc3MoZSwgXCJkaXNwbGF5XCIpKVxuICAgIH0sIHguZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4heC5leHByLmZpbHRlcnMuaGlkZGVuKGUpXG4gICAgfSksIHguZWFjaCh7bWFyZ2luOiBcIlwiLCBwYWRkaW5nOiBcIlwiLCBib3JkZXI6IFwiV2lkdGhcIn0sIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHguY3NzSG9va3NbZSArIHRdID0ge2V4cGFuZDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IDAsIGkgPSB7fSwgbyA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gPyBuLnNwbGl0KFwiIFwiKSA6IFtuXTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgNCA+IHI7IHIrKylcbiAgICAgICAgICAgICAgICAgICAgaVtlICsgWnRbcl0gKyB0XSA9IG9bcl0gfHwgb1tyIC0gMl0gfHwgb1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgfX0sIFV0LnRlc3QoZSkgfHwgKHguY3NzSG9va3NbZSArIHRdLnNldCA9IG9uKVxuICAgIH0pO1xuICAgIHZhciBjbiA9IC8lMjAvZywgcG4gPSAvXFxbXFxdJC8sIGZuID0gL1xccj9cXG4vZywgZG4gPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksIGhuID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuICAgIHguZm4uZXh0ZW5kKHtzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB4LnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSlcbiAgICAgICAgfSwgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB4LnByb3AodGhpcywgXCJlbGVtZW50c1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA/IHgubWFrZUFycmF5KGUpIDogdGhpc1xuICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMudHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICYmICF4KHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpICYmIGhuLnRlc3QodGhpcy5ub2RlTmFtZSkgJiYgIWRuLnRlc3QoZSkgJiYgKHRoaXMuY2hlY2tlZCB8fCAhQ3QudGVzdChlKSlcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0geCh0aGlzKS52YWwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBuID8gbnVsbCA6IHguaXNBcnJheShuKSA/IHgubWFwKG4sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybntuYW1lOiB0Lm5hbWUsIHZhbHVlOiBlLnJlcGxhY2UoZm4sIFwiXFxyXFxuXCIpfVxuICAgICAgICAgICAgICAgIH0pIDoge25hbWU6IHQubmFtZSwgdmFsdWU6IG4ucmVwbGFjZShmbiwgXCJcXHJcXG5cIil9XG4gICAgICAgICAgICB9KS5nZXQoKVxuICAgICAgICB9fSksIHgucGFyYW0gPSBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICB2YXIgciwgaSA9IFtdLCBvID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHQgPSB4LmlzRnVuY3Rpb24odCkgPyB0KCkgOiBudWxsID09IHQgPyBcIlwiIDogdCwgaVtpLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoZSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh0KVxuICAgICAgICB9O1xuICAgICAgICBpZiAobiA9PT0gdCAmJiAobiA9IHguYWpheFNldHRpbmdzICYmIHguYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKSwgeC5pc0FycmF5KGUpIHx8IGUuanF1ZXJ5ICYmICF4LmlzUGxhaW5PYmplY3QoZSkpXG4gICAgICAgICAgICB4LmVhY2goZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG8odGhpcy5uYW1lLCB0aGlzLnZhbHVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAociBpbiBlKVxuICAgICAgICAgICAgICAgIGduKHIsIGVbcl0sIG4sIG8pO1xuICAgICAgICByZXR1cm4gaS5qb2luKFwiJlwiKS5yZXBsYWNlKGNuLCBcIitcIilcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGduKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmICh4LmlzQXJyYXkodCkpXG4gICAgICAgICAgICB4LmVhY2godCwgZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICAgICAgICBuIHx8IHBuLnRlc3QoZSkgPyByKGUsIGkpIDogZ24oZSArIFwiW1wiICsgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGkgPyB0IDogXCJcIikgKyBcIl1cIiwgaSwgbiwgcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBlbHNlIGlmIChuIHx8IFwib2JqZWN0XCIgIT09IHgudHlwZSh0KSlcbiAgICAgICAgICAgIHIoZSwgdCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAoaSBpbiB0KVxuICAgICAgICAgICAgICAgIGduKGUgKyBcIltcIiArIGkgKyBcIl1cIiwgdFtpXSwgbiwgcilcbiAgICB9XG4gICAgeC5lYWNoKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgeC5mblt0XSA9IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKHQsIG51bGwsIGUsIG4pIDogdGhpcy50cmlnZ2VyKHQpXG4gICAgICAgIH1cbiAgICB9KSwgeC5mbi5leHRlbmQoe2hvdmVyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW91c2VlbnRlcihlKS5tb3VzZWxlYXZlKHQgfHwgZSlcbiAgICAgICAgfSwgYmluZDogZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKGUsIG51bGwsIHQsIG4pXG4gICAgICAgIH0sIHVuYmluZDogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZihlLCBudWxsLCB0KVxuICAgICAgICB9LCBkZWxlZ2F0ZTogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKHQsIGUsIG4sIHIpXG4gICAgICAgIH0sIHVuZGVsZWdhdGU6IGZ1bmN0aW9uIChlLCB0LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMub2ZmKGUsIFwiKipcIikgOiB0aGlzLm9mZih0LCBlIHx8IFwiKipcIiwgbilcbiAgICAgICAgfX0pO1xuICAgIHZhciBtbiwgeW4sIHZuID0geC5ub3coKSwgYm4gPSAvXFw/LywgeG4gPSAvIy4qJC8sIHduID0gLyhbPyZdKV89W14mXSovLCBUbiA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKVxccj8kL2dtLCBDbiA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLCBObiA9IC9eKD86R0VUfEhFQUQpJC8sIGtuID0gL15cXC9cXC8vLCBFbiA9IC9eKFtcXHcuKy1dKzopKD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLCBTbiA9IHguZm4ubG9hZCwgQW4gPSB7fSwgam4gPSB7fSwgRG4gPSBcIiovXCIuY29uY2F0KFwiKlwiKTtcbiAgICB0cnkge1xuICAgICAgICB5biA9IG8uaHJlZlxuICAgIH0gY2F0Y2ggKExuKSB7XG4gICAgICAgIHluID0gYS5jcmVhdGVFbGVtZW50KFwiYVwiKSwgeW4uaHJlZiA9IFwiXCIsIHluID0geW4uaHJlZlxuICAgIH1cbiAgICBtbiA9IEVuLmV4ZWMoeW4udG9Mb3dlckNhc2UoKSkgfHwgW107XG4gICAgZnVuY3Rpb24gSG4oZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIG4pIHtcbiAgICAgICAgICAgIFwic3RyaW5nXCIgIT0gdHlwZW9mIHQgJiYgKG4gPSB0LCB0ID0gXCIqXCIpO1xuICAgICAgICAgICAgdmFyIHIsIGkgPSAwLCBvID0gdC50b0xvd2VyQ2FzZSgpLm1hdGNoKFQpIHx8IFtdO1xuICAgICAgICAgICAgaWYgKHguaXNGdW5jdGlvbihuKSlcbiAgICAgICAgICAgICAgICB3aGlsZSAociA9IG9baSsrXSlcbiAgICAgICAgICAgICAgICAgICAgXCIrXCIgPT09IHJbMF0gPyAociA9IHIuc2xpY2UoMSkgfHwgXCIqXCIsIChlW3JdID0gZVtyXSB8fCBbXSkudW5zaGlmdChuKSkgOiAoZVtyXSA9IGVbcl0gfHwgW10pLnB1c2gobilcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBxbihlLCBuLCByLCBpKSB7XG4gICAgICAgIHZhciBvID0ge30sIGEgPSBlID09PSBqbjtcbiAgICAgICAgZnVuY3Rpb24gcyhsKSB7XG4gICAgICAgICAgICB2YXIgdTtcbiAgICAgICAgICAgIHJldHVybiBvW2xdID0gITAsIHguZWFjaChlW2xdIHx8IFtdLCBmdW5jdGlvbiAoZSwgbCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gbChuLCByLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm5cInN0cmluZ1wiICE9IHR5cGVvZiBjIHx8IGEgfHwgb1tjXSA/IGEgPyAhKHUgPSBjKSA6IHQgOiAobi5kYXRhVHlwZXMudW5zaGlmdChjKSwgcyhjKSwgITEpXG4gICAgICAgICAgICB9KSwgdVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzKG4uZGF0YVR5cGVzWzBdKSB8fCAhb1tcIipcIl0gJiYgcyhcIipcIilcbiAgICB9XG4gICAgZnVuY3Rpb24gX24oZSwgbikge1xuICAgICAgICB2YXIgciwgaSwgbyA9IHguYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuICAgICAgICBmb3IgKGkgaW4gbilcbiAgICAgICAgICAgIG5baV0gIT09IHQgJiYgKChvW2ldID8gZSA6IHIgfHwgKHIgPSB7fSkpW2ldID0gbltpXSk7XG4gICAgICAgIHJldHVybiByICYmIHguZXh0ZW5kKCEwLCBlLCByKSwgZVxuICAgIH1cbiAgICB4LmZuLmxvYWQgPSBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSAmJiBTbilcbiAgICAgICAgICAgIHJldHVybiBTbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgaSwgbywgYSwgcyA9IHRoaXMsIGwgPSBlLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICByZXR1cm4gbCA+PSAwICYmIChpID0gZS5zbGljZShsLCBlLmxlbmd0aCksIGUgPSBlLnNsaWNlKDAsIGwpKSwgeC5pc0Z1bmN0aW9uKG4pID8gKHIgPSBuLCBuID0gdCkgOiBuICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG4gJiYgKGEgPSBcIlBPU1RcIiksIHMubGVuZ3RoID4gMCAmJiB4LmFqYXgoe3VybDogZSwgdHlwZTogYSwgZGF0YVR5cGU6IFwiaHRtbFwiLCBkYXRhOiBufSkuZG9uZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgbyA9IGFyZ3VtZW50cywgcy5odG1sKGkgPyB4KFwiPGRpdj5cIikuYXBwZW5kKHgucGFyc2VIVE1MKGUpKS5maW5kKGkpIDogZSlcbiAgICAgICAgfSkuY29tcGxldGUociAmJiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcy5lYWNoKHIsIG8gfHwgW2UucmVzcG9uc2VUZXh0LCB0LCBlXSlcbiAgICAgICAgfSksIHRoaXNcbiAgICB9LCB4LmVhY2goW1wiYWpheFN0YXJ0XCIsIFwiYWpheFN0b3BcIiwgXCJhamF4Q29tcGxldGVcIiwgXCJhamF4RXJyb3JcIiwgXCJhamF4U3VjY2Vzc1wiLCBcImFqYXhTZW5kXCJdLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB4LmZuW3RdID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKHQsIGUpXG4gICAgICAgIH1cbiAgICB9KSwgeC5leHRlbmQoe2FjdGl2ZTogMCwgbGFzdE1vZGlmaWVkOiB7fSwgZXRhZzoge30sIGFqYXhTZXR0aW5nczoge3VybDogeW4sIHR5cGU6IFwiR0VUXCIsIGlzTG9jYWw6IENuLnRlc3QobW5bMV0pLCBnbG9iYWw6ICEwLCBwcm9jZXNzRGF0YTogITAsIGFzeW5jOiAhMCwgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsIGFjY2VwdHM6IHtcIipcIjogRG4sIHRleHQ6IFwidGV4dC9wbGFpblwiLCBodG1sOiBcInRleHQvaHRtbFwiLCB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLCBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwifSwgY29udGVudHM6IHt4bWw6IC94bWwvLCBodG1sOiAvaHRtbC8sIGpzb246IC9qc29uL30sIHJlc3BvbnNlRmllbGRzOiB7eG1sOiBcInJlc3BvbnNlWE1MXCIsIHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsIGpzb246IFwicmVzcG9uc2VKU09OXCJ9LCBjb252ZXJ0ZXJzOiB7XCIqIHRleHRcIjogU3RyaW5nLCBcInRleHQgaHRtbFwiOiAhMCwgXCJ0ZXh0IGpzb25cIjogeC5wYXJzZUpTT04sIFwidGV4dCB4bWxcIjogeC5wYXJzZVhNTH0sIGZsYXRPcHRpb25zOiB7dXJsOiAhMCwgY29udGV4dDogITB9fSwgYWpheFNldHVwOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgPyBfbihfbihlLCB4LmFqYXhTZXR0aW5ncyksIHQpIDogX24oeC5hamF4U2V0dGluZ3MsIGUpXG4gICAgICAgIH0sIGFqYXhQcmVmaWx0ZXI6IEhuKEFuKSwgYWpheFRyYW5zcG9ydDogSG4oam4pLCBhamF4OiBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiAobiA9IGUsIGUgPSB0KSwgbiA9IG4gfHwge307XG4gICAgICAgICAgICB2YXIgciwgaSwgbywgYSwgcywgbCwgdSwgYywgcCA9IHguYWpheFNldHVwKHt9LCBuKSwgZiA9IHAuY29udGV4dCB8fCBwLCBkID0gcC5jb250ZXh0ICYmIChmLm5vZGVUeXBlIHx8IGYuanF1ZXJ5KSA/IHgoZikgOiB4LmV2ZW50LCBoID0geC5EZWZlcnJlZCgpLCBnID0geC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgbSA9IHAuc3RhdHVzQ29kZSB8fCB7fSwgeSA9IHt9LCB2ID0ge30sIGIgPSAwLCB3ID0gXCJjYW5jZWxlZFwiLCBDID0ge3JlYWR5U3RhdGU6IDAsIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDIgPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA9IFRuLmV4ZWMoYSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNbdFsxXS50b0xvd2VyQ2FzZSgpXSA9IHRbMl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBjW2UudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCA9PSB0ID8gbnVsbCA6IHRcbiAgICAgICAgICAgICAgICB9LCBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgPT09IGIgPyBhIDogbnVsbFxuICAgICAgICAgICAgICAgIH0sIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYiB8fCAoZSA9IHZbbl0gPSB2W25dIHx8IGUsIHlbZV0gPSB0KSwgdGhpc1xuICAgICAgICAgICAgICAgIH0sIG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiIHx8IChwLm1pbWVUeXBlID0gZSksIHRoaXNcbiAgICAgICAgICAgICAgICB9LCBzdGF0dXNDb2RlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMiA+IGIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh0IGluIGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1bdF0gPSBbbVt0XSwgZVt0XV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQy5hbHdheXMoZVtDLnN0YXR1c10pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIH0sIGFib3J0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGUgfHwgdztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHUgJiYgdS5hYm9ydCh0KSwgaygwLCB0KSwgdGhpc1xuICAgICAgICAgICAgICAgIH19O1xuICAgICAgICAgICAgaWYgKGgucHJvbWlzZShDKS5jb21wbGV0ZSA9IGcuYWRkLCBDLnN1Y2Nlc3MgPSBDLmRvbmUsIEMuZXJyb3IgPSBDLmZhaWwsIHAudXJsID0gKChlIHx8IHAudXJsIHx8IHluKSArIFwiXCIpLnJlcGxhY2UoeG4sIFwiXCIpLnJlcGxhY2Uoa24sIG1uWzFdICsgXCIvL1wiKSwgcC50eXBlID0gbi5tZXRob2QgfHwgbi50eXBlIHx8IHAubWV0aG9kIHx8IHAudHlwZSwgcC5kYXRhVHlwZXMgPSB4LnRyaW0ocC5kYXRhVHlwZSB8fCBcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChUKSB8fCBbXCJcIl0sIG51bGwgPT0gcC5jcm9zc0RvbWFpbiAmJiAociA9IEVuLmV4ZWMocC51cmwudG9Mb3dlckNhc2UoKSksIHAuY3Jvc3NEb21haW4gPSAhKCFyIHx8IHJbMV0gPT09IG1uWzFdICYmIHJbMl0gPT09IG1uWzJdICYmIChyWzNdIHx8IChcImh0dHA6XCIgPT09IHJbMV0gPyBcIjgwXCIgOiBcIjQ0M1wiKSkgPT09IChtblszXSB8fCAoXCJodHRwOlwiID09PSBtblsxXSA/IFwiODBcIiA6IFwiNDQzXCIpKSkpLCBwLmRhdGEgJiYgcC5wcm9jZXNzRGF0YSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBwLmRhdGEgJiYgKHAuZGF0YSA9IHgucGFyYW0ocC5kYXRhLCBwLnRyYWRpdGlvbmFsKSksIHFuKEFuLCBwLCBuLCBDKSwgMiA9PT0gYilcbiAgICAgICAgICAgICAgICByZXR1cm4gQztcbiAgICAgICAgICAgIGwgPSBwLmdsb2JhbCwgbCAmJiAwID09PSB4LmFjdGl2ZSsrICYmIHguZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSwgcC50eXBlID0gcC50eXBlLnRvVXBwZXJDYXNlKCksIHAuaGFzQ29udGVudCA9ICFObi50ZXN0KHAudHlwZSksIG8gPSBwLnVybCwgcC5oYXNDb250ZW50IHx8IChwLmRhdGEgJiYgKG8gPSBwLnVybCArPSAoYm4udGVzdChvKSA/IFwiJlwiIDogXCI/XCIpICsgcC5kYXRhLCBkZWxldGUgcC5kYXRhKSwgcC5jYWNoZSA9PT0gITEgJiYgKHAudXJsID0gd24udGVzdChvKSA/IG8ucmVwbGFjZSh3biwgXCIkMV89XCIgKyB2bisrKSA6IG8gKyAoYm4udGVzdChvKSA/IFwiJlwiIDogXCI/XCIpICsgXCJfPVwiICsgdm4rKykpLCBwLmlmTW9kaWZpZWQgJiYgKHgubGFzdE1vZGlmaWVkW29dICYmIEMuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsIHgubGFzdE1vZGlmaWVkW29dKSwgeC5ldGFnW29dICYmIEMuc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIiwgeC5ldGFnW29dKSksIChwLmRhdGEgJiYgcC5oYXNDb250ZW50ICYmIHAuY29udGVudFR5cGUgIT09ICExIHx8IG4uY29udGVudFR5cGUpICYmIEMuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBwLmNvbnRlbnRUeXBlKSwgQy5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIHAuZGF0YVR5cGVzWzBdICYmIHAuYWNjZXB0c1twLmRhdGFUeXBlc1swXV0gPyBwLmFjY2VwdHNbcC5kYXRhVHlwZXNbMF1dICsgKFwiKlwiICE9PSBwLmRhdGFUeXBlc1swXSA/IFwiLCBcIiArIERuICsgXCI7IHE9MC4wMVwiIDogXCJcIikgOiBwLmFjY2VwdHNbXCIqXCJdKTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBwLmhlYWRlcnMpXG4gICAgICAgICAgICAgICAgQy5zZXRSZXF1ZXN0SGVhZGVyKGksIHAuaGVhZGVyc1tpXSk7XG4gICAgICAgICAgICBpZiAocC5iZWZvcmVTZW5kICYmIChwLmJlZm9yZVNlbmQuY2FsbChmLCBDLCBwKSA9PT0gITEgfHwgMiA9PT0gYikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEMuYWJvcnQoKTtcbiAgICAgICAgICAgIHcgPSBcImFib3J0XCI7XG4gICAgICAgICAgICBmb3IgKGkgaW57c3VjY2VzczoxLCBlcnJvcjoxLCBjb21wbGV0ZToxfSlcbiAgICAgICAgICAgICAgICBDW2ldKHBbaV0pO1xuICAgICAgICAgICAgaWYgKHUgPSBxbihqbiwgcCwgbiwgQykpIHtcbiAgICAgICAgICAgICAgICBDLnJlYWR5U3RhdGUgPSAxLCBsICYmIGQudHJpZ2dlcihcImFqYXhTZW5kXCIsIFtDLCBwXSksIHAuYXN5bmMgJiYgcC50aW1lb3V0ID4gMCAmJiAocyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBDLmFib3J0KFwidGltZW91dFwiKVxuICAgICAgICAgICAgICAgIH0sIHAudGltZW91dCkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGIgPSAxLCB1LnNlbmQoeSwgaylcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChOKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDIgPiBiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IE47XG4gICAgICAgICAgICAgICAgICAgIGsoLTEsIE4pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgaygtMSwgXCJObyBUcmFuc3BvcnRcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBrKGUsIG4sIHIsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYywgeSwgdiwgdywgVCwgTiA9IG47XG4gICAgICAgICAgICAgICAgMiAhPT0gYiAmJiAoYiA9IDIsIHMgJiYgY2xlYXJUaW1lb3V0KHMpLCB1ID0gdCwgYSA9IGkgfHwgXCJcIiwgQy5yZWFkeVN0YXRlID0gZSA+IDAgPyA0IDogMCwgYyA9IGUgPj0gMjAwICYmIDMwMCA+IGUgfHwgMzA0ID09PSBlLCByICYmICh3ID0gTW4ocCwgQywgcikpLCB3ID0gT24ocCwgdywgQywgYyksIGMgPyAocC5pZk1vZGlmaWVkICYmIChUID0gQy5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIiksIFQgJiYgKHgubGFzdE1vZGlmaWVkW29dID0gVCksIFQgPSBDLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKSwgVCAmJiAoeC5ldGFnW29dID0gVCkpLCAyMDQgPT09IGUgfHwgXCJIRUFEXCIgPT09IHAudHlwZSA/IE4gPSBcIm5vY29udGVudFwiIDogMzA0ID09PSBlID8gTiA9IFwibm90bW9kaWZpZWRcIiA6IChOID0gdy5zdGF0ZSwgeSA9IHcuZGF0YSwgdiA9IHcuZXJyb3IsIGMgPSAhdikpIDogKHYgPSBOLCAoZSB8fCAhTikgJiYgKE4gPSBcImVycm9yXCIsIDAgPiBlICYmIChlID0gMCkpKSwgQy5zdGF0dXMgPSBlLCBDLnN0YXR1c1RleHQgPSAobiB8fCBOKSArIFwiXCIsIGMgPyBoLnJlc29sdmVXaXRoKGYsIFt5LCBOLCBDXSkgOiBoLnJlamVjdFdpdGgoZiwgW0MsIE4sIHZdKSwgQy5zdGF0dXNDb2RlKG0pLCBtID0gdCwgbCAmJiBkLnRyaWdnZXIoYyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsIFtDLCBwLCBjID8geSA6IHZdKSwgZy5maXJlV2l0aChmLCBbQywgTl0pLCBsICYmIChkLnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIiwgW0MsIHBdKSwgLS14LmFjdGl2ZSB8fCB4LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ1xuICAgICAgICB9LCBnZXRKU09OOiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgcmV0dXJuIHguZ2V0KGUsIHQsIG4sIFwianNvblwiKVxuICAgICAgICB9LCBnZXRTY3JpcHQ6IGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgICAgICByZXR1cm4geC5nZXQoZSwgdCwgbiwgXCJzY3JpcHRcIilcbiAgICAgICAgfX0pLCB4LmVhY2goW1wiZ2V0XCIsIFwicG9zdFwiXSwgZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgeFtuXSA9IGZ1bmN0aW9uIChlLCByLCBpLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4geC5pc0Z1bmN0aW9uKHIpICYmIChvID0gbyB8fCBpLCBpID0gciwgciA9IHQpLCB4LmFqYXgoe3VybDogZSwgdHlwZTogbiwgZGF0YVR5cGU6IG8sIGRhdGE6IHIsIHN1Y2Nlc3M6IGl9KVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gTW4oZSwgbiwgcikge1xuICAgICAgICB2YXIgaSwgbywgYSwgcywgbCA9IGUuY29udGVudHMsIHUgPSBlLmRhdGFUeXBlcztcbiAgICAgICAgd2hpbGUgKFwiKlwiID09PSB1WzBdKVxuICAgICAgICAgICAgdS5zaGlmdCgpLCBvID09PSB0ICYmIChvID0gZS5taW1lVHlwZSB8fCBuLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpKTtcbiAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICBmb3IgKHMgaW4gbClcbiAgICAgICAgICAgICAgICBpZiAobFtzXSAmJiBsW3NdLnRlc3QobykpIHtcbiAgICAgICAgICAgICAgICAgICAgdS51bnNoaWZ0KHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKHVbMF1pbiByKVxuICAgICAgICAgICAgYSA9IHVbMF07XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChzIGluIHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVbMF0gfHwgZS5jb252ZXJ0ZXJzW3MgKyBcIiBcIiArIHVbMF1dKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBzO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpIHx8IChpID0gcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBhIHx8IGlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYSA/IChhICE9PSB1WzBdICYmIHUudW5zaGlmdChhKSwgclthXSkgOiB0XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9uKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgdmFyIGksIG8sIGEsIHMsIGwsIHUgPSB7fSwgYyA9IGUuZGF0YVR5cGVzLnNsaWNlKCk7XG4gICAgICAgIGlmIChjWzFdKVxuICAgICAgICAgICAgZm9yIChhIGluIGUuY29udmVydGVycylcbiAgICAgICAgICAgICAgICB1W2EudG9Mb3dlckNhc2UoKV0gPSBlLmNvbnZlcnRlcnNbYV07XG4gICAgICAgIG8gPSBjLnNoaWZ0KCk7XG4gICAgICAgIHdoaWxlIChvKVxuICAgICAgICAgICAgaWYgKGUucmVzcG9uc2VGaWVsZHNbb10gJiYgKG5bZS5yZXNwb25zZUZpZWxkc1tvXV0gPSB0KSwgIWwgJiYgciAmJiBlLmRhdGFGaWx0ZXIgJiYgKHQgPSBlLmRhdGFGaWx0ZXIodCwgZS5kYXRhVHlwZSkpLCBsID0gbywgbyA9IGMuc2hpZnQoKSlcbiAgICAgICAgICAgICAgICBpZiAoXCIqXCIgPT09IG8pXG4gICAgICAgICAgICAgICAgICAgIG8gPSBsO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiKlwiICE9PSBsICYmIGwgIT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPSB1W2wgKyBcIiBcIiArIG9dIHx8IHVbXCIqIFwiICsgb10sICFhKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIHUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPSBpLnNwbGl0KFwiIFwiKSwgc1sxXSA9PT0gbyAmJiAoYSA9IHVbbCArIFwiIFwiICsgc1swXV0gfHwgdVtcIiogXCIgKyBzWzBdXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9PT0gITAgPyBhID0gdVtpXSA6IHVbaV0gIT09ICEwICYmIChvID0gc1swXSwgYy51bnNoaWZ0KHNbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhICE9PSAhMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhICYmIGVbXCJ0aHJvd3NcIl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGEodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGEodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybntzdGF0ZTogXCJwYXJzZXJlcnJvclwiLCBlcnJvcjogYSA/IHAgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIGwgKyBcIiB0byBcIiArIG99XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJue3N0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogdH1cbiAgICB9XG4gICAgeC5hamF4U2V0dXAoe2FjY2VwdHM6IHtzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIn0sIGNvbnRlbnRzOiB7c2NyaXB0OiAvKD86amF2YXxlY21hKXNjcmlwdC99LCBjb252ZXJ0ZXJzOiB7XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4Lmdsb2JhbEV2YWwoZSksIGVcbiAgICAgICAgICAgIH19fSksIHguYWpheFByZWZpbHRlcihcInNjcmlwdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmNhY2hlID09PSB0ICYmIChlLmNhY2hlID0gITEpLCBlLmNyb3NzRG9tYWluICYmIChlLnR5cGUgPSBcIkdFVFwiLCBlLmdsb2JhbCA9ICExKVxuICAgIH0pLCB4LmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuY3Jvc3NEb21haW4pIHtcbiAgICAgICAgICAgIHZhciBuLCByID0gYS5oZWFkIHx8IHgoXCJoZWFkXCIpWzBdIHx8IGEuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJue3NlbmQ6IGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBhLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksIG4uYXN5bmMgPSAhMCwgZS5zY3JpcHRDaGFyc2V0ICYmIChuLmNoYXJzZXQgPSBlLnNjcmlwdENoYXJzZXQpLCBuLnNyYyA9IGUudXJsLCBuLm9ubG9hZCA9IG4ub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICh0IHx8ICFuLnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdChuLnJlYWR5U3RhdGUpKSAmJiAobi5vbmxvYWQgPSBuLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGwsIG4ucGFyZW50Tm9kZSAmJiBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobiksIG4gPSBudWxsLCB0IHx8IGkoMjAwLCBcInN1Y2Nlc3NcIikpXG4gICAgICAgICAgICAgICAgICAgIH0sIHIuaW5zZXJ0QmVmb3JlKG4sIHIuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICB9LCBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBuICYmIG4ub25sb2FkKHQsICEwKVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgRm4gPSBbXSwgQm4gPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuICAgIHguYWpheFNldHVwKHtqc29ucDogXCJjYWxsYmFja1wiLCBqc29ucENhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IEZuLnBvcCgpIHx8IHguZXhwYW5kbyArIFwiX1wiICsgdm4rKztcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2VdID0gITAsIGVcbiAgICAgICAgfX0pLCB4LmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uIChuLCByLCBpKSB7XG4gICAgICAgIHZhciBvLCBhLCBzLCBsID0gbi5qc29ucCAhPT0gITEgJiYgKEJuLnRlc3Qobi51cmwpID8gXCJ1cmxcIiA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIG4uZGF0YSAmJiAhKG4uY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiBCbi50ZXN0KG4uZGF0YSkgJiYgXCJkYXRhXCIpO1xuICAgICAgICByZXR1cm4gbCB8fCBcImpzb25wXCIgPT09IG4uZGF0YVR5cGVzWzBdID8gKG8gPSBuLmpzb25wQ2FsbGJhY2sgPSB4LmlzRnVuY3Rpb24obi5qc29ucENhbGxiYWNrKSA/IG4uanNvbnBDYWxsYmFjaygpIDogbi5qc29ucENhbGxiYWNrLCBsID8gbltsXSA9IG5bbF0ucmVwbGFjZShCbiwgXCIkMVwiICsgbykgOiBuLmpzb25wICE9PSAhMSAmJiAobi51cmwgKz0gKGJuLnRlc3Qobi51cmwpID8gXCImXCIgOiBcIj9cIikgKyBuLmpzb25wICsgXCI9XCIgKyBvKSwgbi5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcyB8fCB4LmVycm9yKG8gKyBcIiB3YXMgbm90IGNhbGxlZFwiKSwgc1swXVxuICAgICAgICB9LCBuLmRhdGFUeXBlc1swXSA9IFwianNvblwiLCBhID0gZVtvXSwgZVtvXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNcbiAgICAgICAgfSwgaS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZVtvXSA9IGEsIG5bb10gJiYgKG4uanNvbnBDYWxsYmFjayA9IHIuanNvbnBDYWxsYmFjaywgRm4ucHVzaChvKSksIHMgJiYgeC5pc0Z1bmN0aW9uKGEpICYmIGEoc1swXSksIHMgPSBhID0gdFxuICAgICAgICB9KSwgXCJzY3JpcHRcIikgOiB0XG4gICAgfSk7XG4gICAgdmFyIFBuLCBSbiwgV24gPSAwLCAkbiA9IGUuQWN0aXZlWE9iamVjdCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBmb3IgKGUgaW4gUG4pXG4gICAgICAgICAgICBQbltlXSh0LCAhMClcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEluKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBlLlhNTEh0dHBSZXF1ZXN0XG4gICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB6bigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZS5BY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIilcbiAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICB9XG4gICAgfVxuICAgIHguYWpheFNldHRpbmdzLnhociA9IGUuQWN0aXZlWE9iamVjdCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIXRoaXMuaXNMb2NhbCAmJiBJbigpIHx8IHpuKClcbiAgICB9IDogSW4sIFJuID0geC5hamF4U2V0dGluZ3MueGhyKCksIHguc3VwcG9ydC5jb3JzID0gISFSbiAmJiBcIndpdGhDcmVkZW50aWFsc1wiaW4gUm4sIFJuID0geC5zdXBwb3J0LmFqYXggPSAhIVJuLCBSbiAmJiB4LmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKCFuLmNyb3NzRG9tYWluIHx8IHguc3VwcG9ydC5jb3JzKSB7XG4gICAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICAgIHJldHVybntzZW5kOiBmdW5jdGlvbiAoaSwgbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSwgcywgbCA9IG4ueGhyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnVzZXJuYW1lID8gbC5vcGVuKG4udHlwZSwgbi51cmwsIG4uYXN5bmMsIG4udXNlcm5hbWUsIG4ucGFzc3dvcmQpIDogbC5vcGVuKG4udHlwZSwgbi51cmwsIG4uYXN5bmMpLCBuLnhockZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocyBpbiBuLnhockZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsW3NdID0gbi54aHJGaWVsZHNbc107XG4gICAgICAgICAgICAgICAgICAgIG4ubWltZVR5cGUgJiYgbC5vdmVycmlkZU1pbWVUeXBlICYmIGwub3ZlcnJpZGVNaW1lVHlwZShuLm1pbWVUeXBlKSwgbi5jcm9zc0RvbWFpbiB8fCBpW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSB8fCAoaVtcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzIGluIGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbC5zZXRSZXF1ZXN0SGVhZGVyKHMsIGlbc10pXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsLnNlbmQobi5oYXNDb250ZW50ICYmIG4uZGF0YSB8fCBudWxsKSwgciA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcywgdSwgYywgcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgJiYgKGkgfHwgNCA9PT0gbC5yZWFkeVN0YXRlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPSB0LCBhICYmIChsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHgubm9vcCwgJG4gJiYgZGVsZXRlIFBuW2FdKSwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQgIT09IGwucmVhZHlTdGF0ZSAmJiBsLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHt9LCBzID0gbC5zdGF0dXMsIHUgPSBsLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLCBcInN0cmluZ1wiID09IHR5cGVvZiBsLnJlc3BvbnNlVGV4dCAmJiAocC50ZXh0ID0gbC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gbC5zdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgfHwgIW4uaXNMb2NhbCB8fCBuLmNyb3NzRG9tYWluID8gMTIyMyA9PT0gcyAmJiAocyA9IDIwNCkgOiBzID0gcC50ZXh0ID8gMjAwIDogNDA0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIHx8IG8oLTEsIGQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwICYmIG8ocywgYywgcCwgdSlcbiAgICAgICAgICAgICAgICAgICAgfSwgbi5hc3luYyA/IDQgPT09IGwucmVhZHlTdGF0ZSA/IHNldFRpbWVvdXQocikgOiAoYSA9ICsrV24sICRuICYmIChQbiB8fCAoUG4gPSB7fSwgeChlKS51bmxvYWQoJG4pKSwgUG5bYV0gPSByKSwgbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByKSA6IHIoKVxuICAgICAgICAgICAgICAgIH0sIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgJiYgcih0LCAhMClcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIFhuLCBVbiwgVm4gPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sIFluID0gUmVnRXhwKFwiXig/OihbKy1dKT18KShcIiArIHcgKyBcIikoW2EteiVdKikkXCIsIFwiaVwiKSwgSm4gPSAvcXVldWVIb29rcyQvLCBHbiA9IFtucl0sIFFuID0ge1wiKlwiOiBbZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuY3JlYXRlVHdlZW4oZSwgdCksIHIgPSBuLmN1cigpLCBpID0gWW4uZXhlYyh0KSwgbyA9IGkgJiYgaVszXSB8fCAoeC5jc3NOdW1iZXJbZV0gPyBcIlwiIDogXCJweFwiKSwgYSA9ICh4LmNzc051bWJlcltlXSB8fCBcInB4XCIgIT09IG8gJiYgK3IpICYmIFluLmV4ZWMoeC5jc3Mobi5lbGVtLCBlKSksIHMgPSAxLCBsID0gMjA7XG4gICAgICAgICAgICAgICAgaWYgKGEgJiYgYVszXSAhPT0gbykge1xuICAgICAgICAgICAgICAgICAgICBvID0gbyB8fCBhWzNdLCBpID0gaSB8fCBbXSwgYSA9ICtyIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcyB8fCBcIi41XCIsIGEgLz0gcywgeC5zdHlsZShuLmVsZW0sIGUsIGEgKyBvKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHMgIT09IChzID0gbi5jdXIoKSAvIHIpICYmIDEgIT09IHMgJiYgLS1sKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaSAmJiAoYSA9IG4uc3RhcnQgPSArYSB8fCArciB8fCAwLCBuLnVuaXQgPSBvLCBuLmVuZCA9IGlbMV0gPyBhICsgKGlbMV0gKyAxKSAqIGlbMl0gOiAraVsyXSksIG5cbiAgICAgICAgICAgIH1dfTtcbiAgICBmdW5jdGlvbiBLbigpIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgWG4gPSB0XG4gICAgICAgIH0pLCBYbiA9IHgubm93KClcbiAgICB9XG4gICAgZnVuY3Rpb24gWm4oZSwgdCwgbikge1xuICAgICAgICB2YXIgciwgaSA9IChRblt0XSB8fCBbXSkuY29uY2F0KFFuW1wiKlwiXSksIG8gPSAwLCBhID0gaS5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBhID4gbzsgbysrKVxuICAgICAgICAgICAgaWYgKHIgPSBpW29dLmNhbGwobiwgdCwgZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJcbiAgICB9XG4gICAgZnVuY3Rpb24gZXIoZSwgdCwgbikge1xuICAgICAgICB2YXIgciwgaSwgbyA9IDAsIGEgPSBHbi5sZW5ndGgsIHMgPSB4LkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsLmVsZW1cbiAgICAgICAgfSksIGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4hMTtcbiAgICAgICAgICAgIHZhciB0ID0gWG4gfHwgS24oKSwgbiA9IE1hdGgubWF4KDAsIHUuc3RhcnRUaW1lICsgdS5kdXJhdGlvbiAtIHQpLCByID0gbiAvIHUuZHVyYXRpb24gfHwgMCwgbyA9IDEgLSByLCBhID0gMCwgbCA9IHUudHdlZW5zLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBsID4gYTsgYSsrKVxuICAgICAgICAgICAgICAgIHUudHdlZW5zW2FdLnJ1bihvKTtcbiAgICAgICAgICAgIHJldHVybiBzLm5vdGlmeVdpdGgoZSwgW3UsIG8sIG5dKSwgMSA+IG8gJiYgbCA/IG4gOiAocy5yZXNvbHZlV2l0aChlLCBbdV0pLCAhMSlcbiAgICAgICAgfSwgdSA9IHMucHJvbWlzZSh7ZWxlbTogZSwgcHJvcHM6IHguZXh0ZW5kKHt9LCB0KSwgb3B0czogeC5leHRlbmQoITAsIHtzcGVjaWFsRWFzaW5nOiB7fX0sIG4pLCBvcmlnaW5hbFByb3BlcnRpZXM6IHQsIG9yaWdpbmFsT3B0aW9uczogbiwgc3RhcnRUaW1lOiBYbiB8fCBLbigpLCBkdXJhdGlvbjogbi5kdXJhdGlvbiwgdHdlZW5zOiBbXSwgY3JlYXRlVHdlZW46IGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB4LlR3ZWVuKGUsIHUub3B0cywgdCwgbiwgdS5vcHRzLnNwZWNpYWxFYXNpbmdbdF0gfHwgdS5vcHRzLmVhc2luZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHUudHdlZW5zLnB1c2gociksIHJcbiAgICAgICAgICAgIH0sIHN0b3A6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSAwLCByID0gdCA/IHUudHdlZW5zLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9ICEwOyByID4gbjsgbisrKVxuICAgICAgICAgICAgICAgICAgICB1LnR3ZWVuc1tuXS5ydW4oMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQgPyBzLnJlc29sdmVXaXRoKGUsIFt1LCB0XSkgOiBzLnJlamVjdFdpdGgoZSwgW3UsIHRdKSwgdGhpc1xuICAgICAgICAgICAgfX0pLCBjID0gdS5wcm9wcztcbiAgICAgICAgZm9yICh0cihjLCB1Lm9wdHMuc3BlY2lhbEVhc2luZyk7IGEgPiBvOyBvKyspXG4gICAgICAgICAgICBpZiAociA9IEduW29dLmNhbGwodSwgZSwgYywgdS5vcHRzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgcmV0dXJuIHgubWFwKGMsIFpuLCB1KSwgeC5pc0Z1bmN0aW9uKHUub3B0cy5zdGFydCkgJiYgdS5vcHRzLnN0YXJ0LmNhbGwoZSwgdSksIHguZngudGltZXIoeC5leHRlbmQobCwge2VsZW06IGUsIGFuaW06IHUsIHF1ZXVlOiB1Lm9wdHMucXVldWV9KSksIHUucHJvZ3Jlc3ModS5vcHRzLnByb2dyZXNzKS5kb25lKHUub3B0cy5kb25lLCB1Lm9wdHMuY29tcGxldGUpLmZhaWwodS5vcHRzLmZhaWwpLmFsd2F5cyh1Lm9wdHMuYWx3YXlzKVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cihlLCB0KSB7XG4gICAgICAgIHZhciBuLCByLCBpLCBvLCBhO1xuICAgICAgICBmb3IgKG4gaW4gZSlcbiAgICAgICAgICAgIGlmIChyID0geC5jYW1lbENhc2UobiksIGkgPSB0W3JdLCBvID0gZVtuXSwgeC5pc0FycmF5KG8pICYmIChpID0gb1sxXSwgbyA9IGVbbl0gPSBvWzBdKSwgbiAhPT0gciAmJiAoZVtyXSA9IG8sIGRlbGV0ZSBlW25dKSwgYSA9IHguY3NzSG9va3Nbcl0sIGEgJiYgXCJleHBhbmRcImluIGEpIHtcbiAgICAgICAgICAgICAgICBvID0gYS5leHBhbmQobyksIGRlbGV0ZSBlW3JdO1xuICAgICAgICAgICAgICAgIGZvciAobiBpbiBvKVxuICAgICAgICAgICAgICAgICAgICBuIGluIGUgfHwgKGVbbl0gPSBvW25dLCB0W25dID0gaSlcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRbcl0gPSBpXG4gICAgfVxuICAgIHguQW5pbWF0aW9uID0geC5leHRlbmQoZXIsIHt0d2VlbmVyOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgeC5pc0Z1bmN0aW9uKGUpID8gKHQgPSBlLCBlID0gW1wiKlwiXSkgOiBlID0gZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICB2YXIgbiwgciA9IDAsIGkgPSBlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpID4gcjsgcisrKVxuICAgICAgICAgICAgICAgIG4gPSBlW3JdLCBRbltuXSA9IFFuW25dIHx8IFtdLCBRbltuXS51bnNoaWZ0KHQpXG4gICAgICAgIH0sIHByZWZpbHRlcjogZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICAgIHQgPyBHbi51bnNoaWZ0KGUpIDogR24ucHVzaChlKVxuICAgICAgICB9fSk7XG4gICAgZnVuY3Rpb24gbnIoZSwgdCwgbikge1xuICAgICAgICB2YXIgciwgaSwgbywgYSwgcywgbCwgdSA9IHRoaXMsIGMgPSB7fSwgcCA9IGUuc3R5bGUsIGYgPSBlLm5vZGVUeXBlICYmIG5uKGUpLCBkID0geC5fZGF0YShlLCBcImZ4c2hvd1wiKTtcbiAgICAgICAgbi5xdWV1ZSB8fCAocyA9IHguX3F1ZXVlSG9va3MoZSwgXCJmeFwiKSwgbnVsbCA9PSBzLnVucXVldWVkICYmIChzLnVucXVldWVkID0gMCwgbCA9IHMuZW1wdHkuZmlyZSwgcy5lbXB0eS5maXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcy51bnF1ZXVlZCB8fCBsKClcbiAgICAgICAgfSksIHMudW5xdWV1ZWQrKywgdS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHMudW5xdWV1ZWQtLSwgeC5xdWV1ZShlLCBcImZ4XCIpLmxlbmd0aCB8fCBzLmVtcHR5LmZpcmUoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSkpLCAxID09PSBlLm5vZGVUeXBlICYmIChcImhlaWdodFwiaW4gdCB8fCBcIndpZHRoXCJpbiB0KSAmJiAobi5vdmVyZmxvdyA9IFtwLm92ZXJmbG93LCBwLm92ZXJmbG93WCwgcC5vdmVyZmxvd1ldLCBcImlubGluZVwiID09PSB4LmNzcyhlLCBcImRpc3BsYXlcIikgJiYgXCJub25lXCIgPT09IHguY3NzKGUsIFwiZmxvYXRcIikgJiYgKHguc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ICYmIFwiaW5saW5lXCIgIT09IGxuKGUubm9kZU5hbWUpID8gcC56b29tID0gMSA6IHAuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCIpKSwgbi5vdmVyZmxvdyAmJiAocC5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIHguc3VwcG9ydC5zaHJpbmtXcmFwQmxvY2tzIHx8IHUuYWx3YXlzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHAub3ZlcmZsb3cgPSBuLm92ZXJmbG93WzBdLCBwLm92ZXJmbG93WCA9IG4ub3ZlcmZsb3dbMV0sIHAub3ZlcmZsb3dZID0gbi5vdmVyZmxvd1syXVxuICAgICAgICB9KSk7XG4gICAgICAgIGZvciAociBpbiB0KVxuICAgICAgICAgICAgaWYgKGkgPSB0W3JdLCBWbi5leGVjKGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZSB0W3JdLCBvID0gbyB8fCBcInRvZ2dsZVwiID09PSBpLCBpID09PSAoZiA/IFwiaGlkZVwiIDogXCJzaG93XCIpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjW3JdID0gZCAmJiBkW3JdIHx8IHguc3R5bGUoZSwgcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKCF4LmlzRW1wdHlPYmplY3QoYykpIHtcbiAgICAgICAgICAgIGQgPyBcImhpZGRlblwiaW4gZCAmJiAoZiA9IGQuaGlkZGVuKSA6IGQgPSB4Ll9kYXRhKGUsIFwiZnhzaG93XCIsIHt9KSwgbyAmJiAoZC5oaWRkZW4gPSAhZiksIGYgPyB4KGUpLnNob3coKSA6IHUuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgeChlKS5oaWRlKClcbiAgICAgICAgICAgIH0pLCB1LmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgICAgIHguX3JlbW92ZURhdGEoZSwgXCJmeHNob3dcIik7XG4gICAgICAgICAgICAgICAgZm9yICh0IGluIGMpXG4gICAgICAgICAgICAgICAgICAgIHguc3R5bGUoZSwgdCwgY1t0XSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChyIGluIGMpXG4gICAgICAgICAgICAgICAgYSA9IFpuKGYgPyBkW3JdIDogMCwgciwgdSksIHIgaW4gZCB8fCAoZFtyXSA9IGEuc3RhcnQsIGYgJiYgKGEuZW5kID0gYS5zdGFydCwgYS5zdGFydCA9IFwid2lkdGhcIiA9PT0gciB8fCBcImhlaWdodFwiID09PSByID8gMSA6IDApKVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJyKGUsIHQsIG4sIHIsIGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByci5wcm90b3R5cGUuaW5pdChlLCB0LCBuLCByLCBpKVxuICAgIH1cbiAgICB4LlR3ZWVuID0gcnIsIHJyLnByb3RvdHlwZSA9IHtjb25zdHJ1Y3RvcjogcnIsIGluaXQ6IGZ1bmN0aW9uIChlLCB0LCBuLCByLCBpLCBvKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW0gPSBlLCB0aGlzLnByb3AgPSBuLCB0aGlzLmVhc2luZyA9IGkgfHwgXCJzd2luZ1wiLCB0aGlzLm9wdGlvbnMgPSB0LCB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpLCB0aGlzLmVuZCA9IHIsIHRoaXMudW5pdCA9IG8gfHwgKHguY3NzTnVtYmVyW25dID8gXCJcIiA6IFwicHhcIilcbiAgICAgICAgfSwgY3VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHJyLnByb3BIb29rc1t0aGlzLnByb3BdO1xuICAgICAgICAgICAgcmV0dXJuIGUgJiYgZS5nZXQgPyBlLmdldCh0aGlzKSA6IHJyLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcylcbiAgICAgICAgfSwgcnVuOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHQsIG4gPSByci5wcm9wSG9va3NbdGhpcy5wcm9wXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcyA9IHQgPSB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPyB4LmVhc2luZ1t0aGlzLmVhc2luZ10oZSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogZSwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uKSA6IGUsIHRoaXMubm93ID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiB0ICsgdGhpcy5zdGFydCwgdGhpcy5vcHRpb25zLnN0ZXAgJiYgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKSwgbiAmJiBuLnNldCA/IG4uc2V0KHRoaXMpIDogcnIucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSwgdGhpc1xuICAgICAgICB9fSwgcnIucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gcnIucHJvdG90eXBlLCByci5wcm9wSG9va3MgPSB7X2RlZmF1bHQ6IHtnZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZS5lbGVtW2UucHJvcF0gfHwgZS5lbGVtLnN0eWxlICYmIG51bGwgIT0gZS5lbGVtLnN0eWxlW2UucHJvcF0gPyAodCA9IHguY3NzKGUuZWxlbSwgZS5wcm9wLCBcIlwiKSwgdCAmJiBcImF1dG9cIiAhPT0gdCA/IHQgOiAwKSA6IGUuZWxlbVtlLnByb3BdXG4gICAgICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgeC5meC5zdGVwW2UucHJvcF0gPyB4LmZ4LnN0ZXBbZS5wcm9wXShlKSA6IGUuZWxlbS5zdHlsZSAmJiAobnVsbCAhPSBlLmVsZW0uc3R5bGVbeC5jc3NQcm9wc1tlLnByb3BdXSB8fCB4LmNzc0hvb2tzW2UucHJvcF0pID8geC5zdHlsZShlLmVsZW0sIGUucHJvcCwgZS5ub3cgKyBlLnVuaXQpIDogZS5lbGVtW2UucHJvcF0gPSBlLm5vd1xuICAgICAgICAgICAgfX19LCByci5wcm9wSG9va3Muc2Nyb2xsVG9wID0gcnIucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7c2V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5lbGVtLm5vZGVUeXBlICYmIGUuZWxlbS5wYXJlbnROb2RlICYmIChlLmVsZW1bZS5wcm9wXSA9IGUubm93KVxuICAgICAgICB9fSwgeC5lYWNoKFtcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCJdLCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB2YXIgbiA9IHguZm5bdF07XG4gICAgICAgIHguZm5bdF0gPSBmdW5jdGlvbiAoZSwgciwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gZSB8fCBcImJvb2xlYW5cIiA9PSB0eXBlb2YgZSA/IG4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXMuYW5pbWF0ZShpcih0LCAhMCksIGUsIHIsIGkpXG4gICAgICAgIH1cbiAgICB9KSwgeC5mbi5leHRlbmQoe2ZhZGVUbzogZnVuY3Rpb24gKGUsIHQsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihubikuY3NzKFwib3BhY2l0eVwiLCAwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7b3BhY2l0eTogdH0sIGUsIG4sIHIpXG4gICAgICAgIH0sIGFuaW1hdGU6IGZ1bmN0aW9uIChlLCB0LCBuLCByKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHguaXNFbXB0eU9iamVjdChlKSwgbyA9IHguc3BlZWQodCwgbiwgciksIGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBlcih0aGlzLCB4LmV4dGVuZCh7fSwgZSksIG8pO1xuICAgICAgICAgICAgICAgIChpIHx8IHguX2RhdGEodGhpcywgXCJmaW5pc2hcIikpICYmIHQuc3RvcCghMClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYS5maW5pc2ggPSBhLCBpIHx8IG8ucXVldWUgPT09ICExID8gdGhpcy5lYWNoKGEpIDogdGhpcy5xdWV1ZShvLnF1ZXVlLCBhKVxuICAgICAgICB9LCBzdG9wOiBmdW5jdGlvbiAoZSwgbiwgcikge1xuICAgICAgICAgICAgdmFyIGkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5zdG9wO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlLnN0b3AsIHQocilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm5cInN0cmluZ1wiICE9IHR5cGVvZiBlICYmIChyID0gbiwgbiA9IGUsIGUgPSB0KSwgbiAmJiBlICE9PSAhMSAmJiB0aGlzLnF1ZXVlKGUgfHwgXCJmeFwiLCBbXSksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSAhMCwgbiA9IG51bGwgIT0gZSAmJiBlICsgXCJxdWV1ZUhvb2tzXCIsIG8gPSB4LnRpbWVycywgYSA9IHguX2RhdGEodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKG4pXG4gICAgICAgICAgICAgICAgICAgIGFbbl0gJiYgYVtuXS5zdG9wICYmIGkoYVtuXSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKG4gaW4gYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbbl0gJiYgYVtuXS5zdG9wICYmIEpuLnRlc3QobikgJiYgaShhW25dKTtcbiAgICAgICAgICAgICAgICBmb3IgKG4gPSBvLmxlbmd0aDsgbi0tOyApXG4gICAgICAgICAgICAgICAgICAgIG9bbl0uZWxlbSAhPT0gdGhpcyB8fCBudWxsICE9IGUgJiYgb1tuXS5xdWV1ZSAhPT0gZSB8fCAob1tuXS5hbmltLnN0b3AociksIHQgPSAhMSwgby5zcGxpY2UobiwgMSkpO1xuICAgICAgICAgICAgICAgICh0IHx8ICFyKSAmJiB4LmRlcXVldWUodGhpcywgZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIGZpbmlzaDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlICE9PSAhMSAmJiAoZSA9IGUgfHwgXCJmeFwiKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCwgbiA9IHguX2RhdGEodGhpcyksIHIgPSBuW2UgKyBcInF1ZXVlXCJdLCBpID0gbltlICsgXCJxdWV1ZUhvb2tzXCJdLCBvID0geC50aW1lcnMsIGEgPSByID8gci5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgIGZvciAobi5maW5pc2ggPSAhMCwgeC5xdWV1ZSh0aGlzLCBlLCBbXSksIGkgJiYgaS5zdG9wICYmIGkuc3RvcC5jYWxsKHRoaXMsICEwKSwgdCA9IG8ubGVuZ3RoOyB0LS07IClcbiAgICAgICAgICAgICAgICAgICAgb1t0XS5lbGVtID09PSB0aGlzICYmIG9bdF0ucXVldWUgPT09IGUgJiYgKG9bdF0uYW5pbS5zdG9wKCEwKSwgby5zcGxpY2UodCwgMSkpO1xuICAgICAgICAgICAgICAgIGZvciAodCA9IDA7IGEgPiB0OyB0KyspXG4gICAgICAgICAgICAgICAgICAgIHJbdF0gJiYgclt0XS5maW5pc2ggJiYgclt0XS5maW5pc2guY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbi5maW5pc2hcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH19KTtcbiAgICBmdW5jdGlvbiBpcihlLCB0KSB7XG4gICAgICAgIHZhciBuLCByID0ge2hlaWdodDogZX0sIGkgPSAwO1xuICAgICAgICBmb3IgKHQgPSB0PzE6MDsgNCA+IGk7IGkgKz0gMiAtIHQpXG4gICAgICAgICAgICBuID0gWnRbaV0sIHJbXCJtYXJnaW5cIiArIG5dID0gcltcInBhZGRpbmdcIiArIG5dID0gZTtcbiAgICAgICAgcmV0dXJuIHQgJiYgKHIub3BhY2l0eSA9IHIud2lkdGggPSBlKSwgclxuICAgIH1cbiAgICB4LmVhY2goe3NsaWRlRG93bjogaXIoXCJzaG93XCIpLCBzbGlkZVVwOiBpcihcImhpZGVcIiksIHNsaWRlVG9nZ2xlOiBpcihcInRvZ2dsZVwiKSwgZmFkZUluOiB7b3BhY2l0eTogXCJzaG93XCJ9LCBmYWRlT3V0OiB7b3BhY2l0eTogXCJoaWRlXCJ9LCBmYWRlVG9nZ2xlOiB7b3BhY2l0eTogXCJ0b2dnbGVcIn19LCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICB4LmZuW2VdID0gZnVuY3Rpb24gKGUsIG4sIHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUodCwgZSwgbiwgcilcbiAgICAgICAgfVxuICAgIH0pLCB4LnNwZWVkID0gZnVuY3Rpb24gKGUsIHQsIG4pIHtcbiAgICAgICAgdmFyIHIgPSBlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgPyB4LmV4dGVuZCh7fSwgZSkgOiB7Y29tcGxldGU6IG4gfHwgIW4gJiYgdCB8fCB4LmlzRnVuY3Rpb24oZSkgJiYgZSwgZHVyYXRpb246IGUsIGVhc2luZzogbiAmJiB0IHx8IHQgJiYgIXguaXNGdW5jdGlvbih0KSAmJiB0fTtcbiAgICAgICAgcmV0dXJuIHIuZHVyYXRpb24gPSB4LmZ4Lm9mZiA/IDAgOiBcIm51bWJlclwiID09IHR5cGVvZiByLmR1cmF0aW9uID8gci5kdXJhdGlvbiA6IHIuZHVyYXRpb24gaW4geC5meC5zcGVlZHMgPyB4LmZ4LnNwZWVkc1tyLmR1cmF0aW9uXSA6IHguZnguc3BlZWRzLl9kZWZhdWx0LCAobnVsbCA9PSByLnF1ZXVlIHx8IHIucXVldWUgPT09ICEwKSAmJiAoci5xdWV1ZSA9IFwiZnhcIiksIHIub2xkID0gci5jb21wbGV0ZSwgci5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHguaXNGdW5jdGlvbihyLm9sZCkgJiYgci5vbGQuY2FsbCh0aGlzKSwgci5xdWV1ZSAmJiB4LmRlcXVldWUodGhpcywgci5xdWV1ZSlcbiAgICAgICAgfSwgclxuICAgIH0sIHguZWFzaW5nID0ge2xpbmVhcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgIH0sIHN3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuLjUgLSBNYXRoLmNvcyhlICogTWF0aC5QSSkgLyAyXG4gICAgICAgIH19LCB4LnRpbWVycyA9IFtdLCB4LmZ4ID0gcnIucHJvdG90eXBlLmluaXQsIHguZngudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsIG4gPSB4LnRpbWVycywgciA9IDA7XG4gICAgICAgIGZvciAoWG4gPSB4Lm5vdygpOyBuLmxlbmd0aCA+IHI7IHIrKylcbiAgICAgICAgICAgIGUgPSBuW3JdLCBlKCkgfHwgbltyXSAhPT0gZSB8fCBuLnNwbGljZShyLS0sIDEpO1xuICAgICAgICBuLmxlbmd0aCB8fCB4LmZ4LnN0b3AoKSwgWG4gPSB0XG4gICAgfSwgeC5meC50aW1lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUoKSAmJiB4LnRpbWVycy5wdXNoKGUpICYmIHguZnguc3RhcnQoKVxuICAgIH0sIHguZnguaW50ZXJ2YWwgPSAxMywgeC5meC5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVW4gfHwgKFVuID0gc2V0SW50ZXJ2YWwoeC5meC50aWNrLCB4LmZ4LmludGVydmFsKSlcbiAgICB9LCB4LmZ4LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoVW4pLCBVbiA9IG51bGxcbiAgICB9LCB4LmZ4LnNwZWVkcyA9IHtzbG93OiA2MDAsIGZhc3Q6IDIwMCwgX2RlZmF1bHQ6IDQwMH0sIHguZnguc3RlcCA9IHt9LCB4LmV4cHIgJiYgeC5leHByLmZpbHRlcnMgJiYgKHguZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIHguZ3JlcCh4LnRpbWVycywgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlID09PSB0LmVsZW1cbiAgICAgICAgfSkubGVuZ3RoXG4gICAgfSksIHguZm4ub2Zmc2V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZSA9PT0gdCA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB4Lm9mZnNldC5zZXRPZmZzZXQodGhpcywgZSwgdClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgbiwgciwgbyA9IHt0b3A6IDAsIGxlZnQ6IDB9LCBhID0gdGhpc1swXSwgcyA9IGEgJiYgYS5vd25lckRvY3VtZW50O1xuICAgICAgICBpZiAocylcbiAgICAgICAgICAgIHJldHVybiBuID0gcy5kb2N1bWVudEVsZW1lbnQsIHguY29udGFpbnMobiwgYSkgPyAodHlwZW9mIGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSBpICYmIChvID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksIHIgPSBvcihzKSwge3RvcDogby50b3AgKyAoci5wYWdlWU9mZnNldCB8fCBuLnNjcm9sbFRvcCkgLSAobi5jbGllbnRUb3AgfHwgMCksIGxlZnQ6IG8ubGVmdCArIChyLnBhZ2VYT2Zmc2V0IHx8IG4uc2Nyb2xsTGVmdCkgLSAobi5jbGllbnRMZWZ0IHx8IDApfSkgOiBvXG4gICAgfSwgeC5vZmZzZXQgPSB7c2V0T2Zmc2V0OiBmdW5jdGlvbiAoZSwgdCwgbikge1xuICAgICAgICAgICAgdmFyIHIgPSB4LmNzcyhlLCBcInBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgXCJzdGF0aWNcIiA9PT0gciAmJiAoZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIik7XG4gICAgICAgICAgICB2YXIgaSA9IHgoZSksIG8gPSBpLm9mZnNldCgpLCBhID0geC5jc3MoZSwgXCJ0b3BcIiksIHMgPSB4LmNzcyhlLCBcImxlZnRcIiksIGwgPSAoXCJhYnNvbHV0ZVwiID09PSByIHx8IFwiZml4ZWRcIiA9PT0gcikgJiYgeC5pbkFycmF5KFwiYXV0b1wiLCBbYSwgc10pID4gLTEsIHUgPSB7fSwgYyA9IHt9LCBwLCBmO1xuICAgICAgICAgICAgbCA/IChjID0gaS5wb3NpdGlvbigpLCBwID0gYy50b3AsIGYgPSBjLmxlZnQpIDogKHAgPSBwYXJzZUZsb2F0KGEpIHx8IDAsIGYgPSBwYXJzZUZsb2F0KHMpIHx8IDApLCB4LmlzRnVuY3Rpb24odCkgJiYgKHQgPSB0LmNhbGwoZSwgbiwgbykpLCBudWxsICE9IHQudG9wICYmICh1LnRvcCA9IHQudG9wIC0gby50b3AgKyBwKSwgbnVsbCAhPSB0LmxlZnQgJiYgKHUubGVmdCA9IHQubGVmdCAtIG8ubGVmdCArIGYpLCBcInVzaW5nXCJpbiB0ID8gdC51c2luZy5jYWxsKGUsIHUpIDogaS5jc3ModSlcbiAgICAgICAgfX0sIHguZm4uZXh0ZW5kKHtwb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZSwgdCwgbiA9IHt0b3A6IDAsIGxlZnQ6IDB9LCByID0gdGhpc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm5cImZpeGVkXCIgPT09IHguY3NzKHIsIFwicG9zaXRpb25cIikgPyB0ID0gci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IChlID0gdGhpcy5vZmZzZXRQYXJlbnQoKSwgdCA9IHRoaXMub2Zmc2V0KCksIHgubm9kZU5hbWUoZVswXSwgXCJodG1sXCIpIHx8IChuID0gZS5vZmZzZXQoKSksIG4udG9wICs9IHguY3NzKGVbMF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgITApLCBuLmxlZnQgKz0geC5jc3MoZVswXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgITApKSwge3RvcDogdC50b3AgLSBuLnRvcCAtIHguY3NzKHIsIFwibWFyZ2luVG9wXCIsICEwKSwgbGVmdDogdC5sZWZ0IC0gbi5sZWZ0IC0geC5jc3MociwgXCJtYXJnaW5MZWZ0XCIsICEwKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgcztcbiAgICAgICAgICAgICAgICB3aGlsZSAoZSAmJiAheC5ub2RlTmFtZShlLCBcImh0bWxcIikgJiYgXCJzdGF0aWNcIiA9PT0geC5jc3MoZSwgXCJwb3NpdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBlIHx8IHNcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH19KSwgeC5lYWNoKHtzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwifSwgZnVuY3Rpb24gKGUsIG4pIHtcbiAgICAgICAgdmFyIHIgPSAvWS8udGVzdChuKTtcbiAgICAgICAgeC5mbltlXSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4geC5hY2Nlc3ModGhpcywgZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG9yKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvID09PSB0ID8gYSA/IG4gaW4gYSA/IGFbbl0gOiBhLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtpXSA6IGVbaV0gOiAoYSA/IGEuc2Nyb2xsVG8ociA/IHgoYSkuc2Nyb2xsTGVmdCgpIDogbywgciA/IG8gOiB4KGEpLnNjcm9sbFRvcCgpKSA6IGVbaV0gPSBvLCB0KVxuICAgICAgICAgICAgfSwgZSwgaSwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbClcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG9yKGUpIHtcbiAgICAgICAgcmV0dXJuIHguaXNXaW5kb3coZSkgPyBlIDogOSA9PT0gZS5ub2RlVHlwZSA/IGUuZGVmYXVsdFZpZXcgfHwgZS5wYXJlbnRXaW5kb3cgOiAhMVxuICAgIH1cbiAgICB4LmVhY2goe0hlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIn0sIGZ1bmN0aW9uIChlLCBuKSB7XG4gICAgICAgIHguZWFjaCh7cGFkZGluZzogXCJpbm5lclwiICsgZSwgY29udGVudDogbiwgXCJcIjogXCJvdXRlclwiICsgZX0sIGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICAgICAgICB4LmZuW2ldID0gZnVuY3Rpb24gKGksIG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKHIgfHwgXCJib29sZWFuXCIgIT0gdHlwZW9mIGkpLCBzID0gciB8fCAoaSA9PT0gITAgfHwgbyA9PT0gITAgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguYWNjZXNzKHRoaXMsIGZ1bmN0aW9uIChuLCByLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5pc1dpbmRvdyhuKSA/IG4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIgKyBlXSA6IDkgPT09IG4ubm9kZVR5cGUgPyAobyA9IG4uZG9jdW1lbnRFbGVtZW50LCBNYXRoLm1heChuLmJvZHlbXCJzY3JvbGxcIiArIGVdLCBvW1wic2Nyb2xsXCIgKyBlXSwgbi5ib2R5W1wib2Zmc2V0XCIgKyBlXSwgb1tcIm9mZnNldFwiICsgZV0sIG9bXCJjbGllbnRcIiArIGVdKSkgOiBpID09PSB0ID8geC5jc3MobiwgciwgcykgOiB4LnN0eWxlKG4sIHIsIGksIHMpXG4gICAgICAgICAgICAgICAgfSwgbiwgYSA/IGkgOiB0LCBhLCBudWxsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pLCB4LmZuLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aFxuICAgIH0sIHguZm4uYW5kU2VsZiA9IHguZm4uYWRkQmFjaywgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlICYmIG1vZHVsZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzID0geCA6IChlLmpRdWVyeSA9IGUuJCA9IHgsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lKFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB4XG4gICAgfSkpXG59KSh3aW5kb3cpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2Fzc2V0cy9qcy92ZW5kb3IvanF1ZXJ5Lm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzPzE3YTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vYW1kLW9wdGlvbnMuanM/NjY4ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3dlYnBhY2svYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.6.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function () {\n\n    // Baseline setup\n    // --------------\n\n    // Establish the root object, `window` in the browser, or `exports` on the server.\n    var root = this;\n\n    // Save the previous value of the `_` variable.\n    var previousUnderscore = root._;\n\n    // Establish the object that gets returned to break out of a loop iteration.\n    var breaker = {};\n\n    // Save bytes in the minified (but not gzipped) version:\n    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n    // Create quick reference variables for speed access to core prototypes.\n    var\n        push = ArrayProto.push,\n        slice = ArrayProto.slice,\n        concat = ArrayProto.concat,\n        toString = ObjProto.toString,\n        hasOwnProperty = ObjProto.hasOwnProperty;\n\n    // All **ECMAScript 5** native function implementations that we hope to use\n    // are declared here.\n    var\n        nativeForEach = ArrayProto.forEach,\n        nativeMap = ArrayProto.map,\n        nativeReduce = ArrayProto.reduce,\n        nativeReduceRight = ArrayProto.reduceRight,\n        nativeFilter = ArrayProto.filter,\n        nativeEvery = ArrayProto.every,\n        nativeSome = ArrayProto.some,\n        nativeIndexOf = ArrayProto.indexOf,\n        nativeLastIndexOf = ArrayProto.lastIndexOf,\n        nativeIsArray = Array.isArray,\n        nativeKeys = Object.keys,\n        nativeBind = FuncProto.bind;\n\n    // Create a safe reference to the Underscore object for use below.\n    var _ = function (obj) {\n        if (obj instanceof _)\n            return obj;\n        if (!(this instanceof _))\n            return new _(obj);\n        this._wrapped = obj;\n    };\n\n    // Export the Underscore object for **Node.js**, with\n    // backwards-compatibility for the old `require()` API. If we're in\n    // the browser, add `_` as a global object via a string identifier,\n    // for Closure Compiler \"advanced\" mode.\n    if (true) {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = _;\n        }\n        exports._ = _;\n    } else {\n        root._ = _;\n    }\n\n    // Current version.\n    _.VERSION = '1.6.0';\n\n    // Collection Functions\n    // --------------------\n\n    // The cornerstone, an `each` implementation, aka `forEach`.\n    // Handles objects with the built-in `forEach`, arrays, and raw objects.\n    // Delegates to **ECMAScript 5**'s native `forEach` if available.\n    var each = _.each = _.forEach = function (obj, iterator, context) {\n        if (obj == null)\n            return obj;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n            for (var i = 0, length = obj.length; i < length; i++) {\n                if (iterator.call(context, obj[i], i, obj) === breaker)\n                    return;\n            }\n        } else {\n            var keys = _.keys(obj);\n            for (var i = 0, length = keys.length; i < length; i++) {\n                if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker)\n                    return;\n            }\n        }\n        return obj;\n    };\n\n    // Return the results of applying the iterator to each element.\n    // Delegates to **ECMAScript 5**'s native `map` if available.\n    _.map = _.collect = function (obj, iterator, context) {\n        var results = [];\n        if (obj == null)\n            return results;\n        if (nativeMap && obj.map === nativeMap)\n            return obj.map(iterator, context);\n        each(obj, function (value, index, list) {\n            results.push(iterator.call(context, value, index, list));\n        });\n        return results;\n    };\n\n    var reduceError = 'Reduce of empty array with no initial value';\n\n    // **Reduce** builds up a single result from a list of values, aka `inject`,\n    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n    _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {\n        var initial = arguments.length > 2;\n        if (obj == null)\n            obj = [];\n        if (nativeReduce && obj.reduce === nativeReduce) {\n            if (context)\n                iterator = _.bind(iterator, context);\n            return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n        }\n        each(obj, function (value, index, list) {\n            if (!initial) {\n                memo = value;\n                initial = true;\n            } else {\n                memo = iterator.call(context, memo, value, index, list);\n            }\n        });\n        if (!initial)\n            throw new TypeError(reduceError);\n        return memo;\n    };\n\n    // The right-associative version of reduce, also known as `foldr`.\n    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n    _.reduceRight = _.foldr = function (obj, iterator, memo, context) {\n        var initial = arguments.length > 2;\n        if (obj == null)\n            obj = [];\n        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n            if (context)\n                iterator = _.bind(iterator, context);\n            return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n        }\n        var length = obj.length;\n        if (length !== +length) {\n            var keys = _.keys(obj);\n            length = keys.length;\n        }\n        each(obj, function (value, index, list) {\n            index = keys ? keys[--length] : --length;\n            if (!initial) {\n                memo = obj[index];\n                initial = true;\n            } else {\n                memo = iterator.call(context, memo, obj[index], index, list);\n            }\n        });\n        if (!initial)\n            throw new TypeError(reduceError);\n        return memo;\n    };\n\n    // Return the first value which passes a truth test. Aliased as `detect`.\n    _.find = _.detect = function (obj, predicate, context) {\n        var result;\n        any(obj, function (value, index, list) {\n            if (predicate.call(context, value, index, list)) {\n                result = value;\n                return true;\n            }\n        });\n        return result;\n    };\n\n    // Return all the elements that pass a truth test.\n    // Delegates to **ECMAScript 5**'s native `filter` if available.\n    // Aliased as `select`.\n    _.filter = _.select = function (obj, predicate, context) {\n        var results = [];\n        if (obj == null)\n            return results;\n        if (nativeFilter && obj.filter === nativeFilter)\n            return obj.filter(predicate, context);\n        each(obj, function (value, index, list) {\n            if (predicate.call(context, value, index, list))\n                results.push(value);\n        });\n        return results;\n    };\n\n    // Return all the elements for which a truth test fails.\n    _.reject = function (obj, predicate, context) {\n        return _.filter(obj, function (value, index, list) {\n            return !predicate.call(context, value, index, list);\n        }, context);\n    };\n\n    // Determine whether all of the elements match a truth test.\n    // Delegates to **ECMAScript 5**'s native `every` if available.\n    // Aliased as `all`.\n    _.every = _.all = function (obj, predicate, context) {\n        predicate || (predicate = _.identity);\n        var result = true;\n        if (obj == null)\n            return result;\n        if (nativeEvery && obj.every === nativeEvery)\n            return obj.every(predicate, context);\n        each(obj, function (value, index, list) {\n            if (!(result = result && predicate.call(context, value, index, list)))\n                return breaker;\n        });\n        return !!result;\n    };\n\n    // Determine if at least one element in the object matches a truth test.\n    // Delegates to **ECMAScript 5**'s native `some` if available.\n    // Aliased as `any`.\n    var any = _.some = _.any = function (obj, predicate, context) {\n        predicate || (predicate = _.identity);\n        var result = false;\n        if (obj == null)\n            return result;\n        if (nativeSome && obj.some === nativeSome)\n            return obj.some(predicate, context);\n        each(obj, function (value, index, list) {\n            if (result || (result = predicate.call(context, value, index, list)))\n                return breaker;\n        });\n        return !!result;\n    };\n\n    // Determine if the array or object contains a given value (using `===`).\n    // Aliased as `include`.\n    _.contains = _.include = function (obj, target) {\n        if (obj == null)\n            return false;\n        if (nativeIndexOf && obj.indexOf === nativeIndexOf)\n            return obj.indexOf(target) != -1;\n        return any(obj, function (value) {\n            return value === target;\n        });\n    };\n\n    // Invoke a method (with arguments) on every item in a collection.\n    _.invoke = function (obj, method) {\n        var args = slice.call(arguments, 2);\n        var isFunc = _.isFunction(method);\n        return _.map(obj, function (value) {\n            return (isFunc ? method : value[method]).apply(value, args);\n        });\n    };\n\n    // Convenience version of a common use case of `map`: fetching a property.\n    _.pluck = function (obj, key) {\n        return _.map(obj, _.property(key));\n    };\n\n    // Convenience version of a common use case of `filter`: selecting only objects\n    // containing specific `key:value` pairs.\n    _.where = function (obj, attrs) {\n        return _.filter(obj, _.matches(attrs));\n    };\n\n    // Convenience version of a common use case of `find`: getting the first object\n    // containing specific `key:value` pairs.\n    _.findWhere = function (obj, attrs) {\n        return _.find(obj, _.matches(attrs));\n    };\n\n    // Return the maximum element or (element-based computation).\n    // Can't optimize arrays of integers longer than 65,535 elements.\n    // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n    _.max = function (obj, iterator, context) {\n        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n            return Math.max.apply(Math, obj);\n        }\n        var result = -Infinity, lastComputed = -Infinity;\n        each(obj, function (value, index, list) {\n            var computed = iterator ? iterator.call(context, value, index, list) : value;\n            if (computed > lastComputed) {\n                result = value;\n                lastComputed = computed;\n            }\n        });\n        return result;\n    };\n\n    // Return the minimum element (or element-based computation).\n    _.min = function (obj, iterator, context) {\n        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n            return Math.min.apply(Math, obj);\n        }\n        var result = Infinity, lastComputed = Infinity;\n        each(obj, function (value, index, list) {\n            var computed = iterator ? iterator.call(context, value, index, list) : value;\n            if (computed < lastComputed) {\n                result = value;\n                lastComputed = computed;\n            }\n        });\n        return result;\n    };\n\n    // Shuffle an array, using the modern version of the\n    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n    _.shuffle = function (obj) {\n        var rand;\n        var index = 0;\n        var shuffled = [];\n        each(obj, function (value) {\n            rand = _.random(index++);\n            shuffled[index - 1] = shuffled[rand];\n            shuffled[rand] = value;\n        });\n        return shuffled;\n    };\n\n    // Sample **n** random values from a collection.\n    // If **n** is not specified, returns a single random element.\n    // The internal `guard` argument allows it to work with `map`.\n    _.sample = function (obj, n, guard) {\n        if (n == null || guard) {\n            if (obj.length !== +obj.length)\n                obj = _.values(obj);\n            return obj[_.random(obj.length - 1)];\n        }\n        return _.shuffle(obj).slice(0, Math.max(0, n));\n    };\n\n    // An internal function to generate lookup iterators.\n    var lookupIterator = function (value) {\n        if (value == null)\n            return _.identity;\n        if (_.isFunction(value))\n            return value;\n        return _.property(value);\n    };\n\n    // Sort the object's values by a criterion produced by an iterator.\n    _.sortBy = function (obj, iterator, context) {\n        iterator = lookupIterator(iterator);\n        return _.pluck(_.map(obj, function (value, index, list) {\n            return {\n                value: value,\n                index: index,\n                criteria: iterator.call(context, value, index, list)\n            };\n        }).sort(function (left, right) {\n            var a = left.criteria;\n            var b = right.criteria;\n            if (a !== b) {\n                if (a > b || a === void 0)\n                    return 1;\n                if (a < b || b === void 0)\n                    return -1;\n            }\n            return left.index - right.index;\n        }), 'value');\n    };\n\n    // An internal function used for aggregate \"group by\" operations.\n    var group = function (behavior) {\n        return function (obj, iterator, context) {\n            var result = {};\n            iterator = lookupIterator(iterator);\n            each(obj, function (value, index) {\n                var key = iterator.call(context, value, index, obj);\n                behavior(result, key, value);\n            });\n            return result;\n        };\n    };\n\n    // Groups the object's values by a criterion. Pass either a string attribute\n    // to group by, or a function that returns the criterion.\n    _.groupBy = group(function (result, key, value) {\n        _.has(result, key) ? result[key].push(value) : result[key] = [value];\n    });\n\n    // Indexes the object's values by a criterion, similar to `groupBy`, but for\n    // when you know that your index values will be unique.\n    _.indexBy = group(function (result, key, value) {\n        result[key] = value;\n    });\n\n    // Counts instances of an object that group by a certain criterion. Pass\n    // either a string attribute to count by, or a function that returns the\n    // criterion.\n    _.countBy = group(function (result, key) {\n        _.has(result, key) ? result[key]++ : result[key] = 1;\n    });\n\n    // Use a comparator function to figure out the smallest index at which\n    // an object should be inserted so as to maintain order. Uses binary search.\n    _.sortedIndex = function (array, obj, iterator, context) {\n        iterator = lookupIterator(iterator);\n        var value = iterator.call(context, obj);\n        var low = 0, high = array.length;\n        while (low < high) {\n            var mid = (low + high) >>> 1;\n            iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n        }\n        return low;\n    };\n\n    // Safely create a real, live array from anything iterable.\n    _.toArray = function (obj) {\n        if (!obj)\n            return [];\n        if (_.isArray(obj))\n            return slice.call(obj);\n        if (obj.length === +obj.length)\n            return _.map(obj, _.identity);\n        return _.values(obj);\n    };\n\n    // Return the number of elements in an object.\n    _.size = function (obj) {\n        if (obj == null)\n            return 0;\n        return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n    };\n\n    // Array Functions\n    // ---------------\n\n    // Get the first element of an array. Passing **n** will return the first N\n    // values in the array. Aliased as `head` and `take`. The **guard** check\n    // allows it to work with `_.map`.\n    _.first = _.head = _.take = function (array, n, guard) {\n        if (array == null)\n            return void 0;\n        if ((n == null) || guard)\n            return array[0];\n        if (n < 0)\n            return [];\n        return slice.call(array, 0, n);\n    };\n\n    // Returns everything but the last entry of the array. Especially useful on\n    // the arguments object. Passing **n** will return all the values in\n    // the array, excluding the last N. The **guard** check allows it to work with\n    // `_.map`.\n    _.initial = function (array, n, guard) {\n        return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n    };\n\n    // Get the last element of an array. Passing **n** will return the last N\n    // values in the array. The **guard** check allows it to work with `_.map`.\n    _.last = function (array, n, guard) {\n        if (array == null)\n            return void 0;\n        if ((n == null) || guard)\n            return array[array.length - 1];\n        return slice.call(array, Math.max(array.length - n, 0));\n    };\n\n    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n    // Especially useful on the arguments object. Passing an **n** will return\n    // the rest N values in the array. The **guard**\n    // check allows it to work with `_.map`.\n    _.rest = _.tail = _.drop = function (array, n, guard) {\n        return slice.call(array, (n == null) || guard ? 1 : n);\n    };\n\n    // Trim out all falsy values from an array.\n    _.compact = function (array) {\n        return _.filter(array, _.identity);\n    };\n\n    // Internal implementation of a recursive `flatten` function.\n    var flatten = function (input, shallow, output) {\n        if (shallow && _.every(input, _.isArray)) {\n            return concat.apply(output, input);\n        }\n        each(input, function (value) {\n            if (_.isArray(value) || _.isArguments(value)) {\n                shallow ? push.apply(output, value) : flatten(value, shallow, output);\n            } else {\n                output.push(value);\n            }\n        });\n        return output;\n    };\n\n    // Flatten out an array, either recursively (by default), or just one level.\n    _.flatten = function (array, shallow) {\n        return flatten(array, shallow, []);\n    };\n\n    // Return a version of the array that does not contain the specified value(s).\n    _.without = function (array) {\n        return _.difference(array, slice.call(arguments, 1));\n    };\n\n    // Split an array into two arrays: one whose elements all satisfy the given\n    // predicate, and one whose elements all do not satisfy the predicate.\n    _.partition = function (array, predicate) {\n        var pass = [], fail = [];\n        each(array, function (elem) {\n            (predicate(elem) ? pass : fail).push(elem);\n        });\n        return [pass, fail];\n    };\n\n    // Produce a duplicate-free version of the array. If the array has already\n    // been sorted, you have the option of using a faster algorithm.\n    // Aliased as `unique`.\n    _.uniq = _.unique = function (array, isSorted, iterator, context) {\n        if (_.isFunction(isSorted)) {\n            context = iterator;\n            iterator = isSorted;\n            isSorted = false;\n        }\n        var initial = iterator ? _.map(array, iterator, context) : array;\n        var results = [];\n        var seen = [];\n        each(initial, function (value, index) {\n            if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n                seen.push(value);\n                results.push(array[index]);\n            }\n        });\n        return results;\n    };\n\n    // Produce an array that contains the union: each distinct element from all of\n    // the passed-in arrays.\n    _.union = function () {\n        return _.uniq(_.flatten(arguments, true));\n    };\n\n    // Produce an array that contains every item shared between all the\n    // passed-in arrays.\n    _.intersection = function (array) {\n        var rest = slice.call(arguments, 1);\n        return _.filter(_.uniq(array), function (item) {\n            return _.every(rest, function (other) {\n                return _.contains(other, item);\n            });\n        });\n    };\n\n    // Take the difference between one array and a number of other arrays.\n    // Only the elements present in just the first array will remain.\n    _.difference = function (array) {\n        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n        return _.filter(array, function (value) {\n            return !_.contains(rest, value);\n        });\n    };\n\n    // Zip together multiple lists into a single array -- elements that share\n    // an index go together.\n    _.zip = function () {\n        var length = _.max(_.pluck(arguments, 'length').concat(0));\n        var results = new Array(length);\n        for (var i = 0; i < length; i++) {\n            results[i] = _.pluck(arguments, '' + i);\n        }\n        return results;\n    };\n\n    // Converts lists into objects. Pass either a single array of `[key, value]`\n    // pairs, or two parallel arrays of the same length -- one of keys, and one of\n    // the corresponding values.\n    _.object = function (list, values) {\n        if (list == null)\n            return {};\n        var result = {};\n        for (var i = 0, length = list.length; i < length; i++) {\n            if (values) {\n                result[list[i]] = values[i];\n            } else {\n                result[list[i][0]] = list[i][1];\n            }\n        }\n        return result;\n    };\n\n    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n    // we need this function. Return the position of the first occurrence of an\n    // item in an array, or -1 if the item is not included in the array.\n    // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n    // If the array is large and already in sort order, pass `true`\n    // for **isSorted** to use binary search.\n    _.indexOf = function (array, item, isSorted) {\n        if (array == null)\n            return -1;\n        var i = 0, length = array.length;\n        if (isSorted) {\n            if (typeof isSorted == 'number') {\n                i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n            } else {\n                i = _.sortedIndex(array, item);\n                return array[i] === item ? i : -1;\n            }\n        }\n        if (nativeIndexOf && array.indexOf === nativeIndexOf)\n            return array.indexOf(item, isSorted);\n        for (; i < length; i++)\n            if (array[i] === item)\n                return i;\n        return -1;\n    };\n\n    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n    _.lastIndexOf = function (array, item, from) {\n        if (array == null)\n            return -1;\n        var hasIndex = from != null;\n        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n            return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n        }\n        var i = (hasIndex ? from : array.length);\n        while (i--)\n            if (array[i] === item)\n                return i;\n        return -1;\n    };\n\n    // Generate an integer Array containing an arithmetic progression. A port of\n    // the native Python `range()` function. See\n    // [the Python documentation](http://docs.python.org/library/functions.html#range).\n    _.range = function (start, stop, step) {\n        if (arguments.length <= 1) {\n            stop = start || 0;\n            start = 0;\n        }\n        step = arguments[2] || 1;\n\n        var length = Math.max(Math.ceil((stop - start) / step), 0);\n        var idx = 0;\n        var range = new Array(length);\n\n        while (idx < length) {\n            range[idx++] = start;\n            start += step;\n        }\n\n        return range;\n    };\n\n    // Function (ahem) Functions\n    // ------------------\n\n    // Reusable constructor function for prototype setting.\n    var ctor = function () {\n    };\n\n    // Create a function bound to a given object (assigning `this`, and arguments,\n    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n    // available.\n    _.bind = function (func, context) {\n        var args, bound;\n        if (nativeBind && func.bind === nativeBind)\n            return nativeBind.apply(func, slice.call(arguments, 1));\n        if (!_.isFunction(func))\n            throw new TypeError;\n        args = slice.call(arguments, 2);\n        return bound = function () {\n            if (!(this instanceof bound))\n                return func.apply(context, args.concat(slice.call(arguments)));\n            ctor.prototype = func.prototype;\n            var self = new ctor;\n            ctor.prototype = null;\n            var result = func.apply(self, args.concat(slice.call(arguments)));\n            if (Object(result) === result)\n                return result;\n            return self;\n        };\n    };\n\n    // Partially apply a function by creating a version that has had some of its\n    // arguments pre-filled, without changing its dynamic `this` context. _ acts\n    // as a placeholder, allowing any combination of arguments to be pre-filled.\n    _.partial = function (func) {\n        var boundArgs = slice.call(arguments, 1);\n        return function () {\n            var position = 0;\n            var args = boundArgs.slice();\n            for (var i = 0, length = args.length; i < length; i++) {\n                if (args[i] === _)\n                    args[i] = arguments[position++];\n            }\n            while (position < arguments.length)\n                args.push(arguments[position++]);\n            return func.apply(this, args);\n        };\n    };\n\n    // Bind a number of an object's methods to that object. Remaining arguments\n    // are the method names to be bound. Useful for ensuring that all callbacks\n    // defined on an object belong to it.\n    _.bindAll = function (obj) {\n        var funcs = slice.call(arguments, 1);\n        if (funcs.length === 0)\n            throw new Error('bindAll must be passed function names');\n        each(funcs, function (f) {\n            obj[f] = _.bind(obj[f], obj);\n        });\n        return obj;\n    };\n\n    // Memoize an expensive function by storing its results.\n    _.memoize = function (func, hasher) {\n        var memo = {};\n        hasher || (hasher = _.identity);\n        return function () {\n            var key = hasher.apply(this, arguments);\n            return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n        };\n    };\n\n    // Delays a function for the given number of milliseconds, and then calls\n    // it with the arguments supplied.\n    _.delay = function (func, wait) {\n        var args = slice.call(arguments, 2);\n        return setTimeout(function () {\n            return func.apply(null, args);\n        }, wait);\n    };\n\n    // Defers a function, scheduling it to run after the current call stack has\n    // cleared.\n    _.defer = function (func) {\n        return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n    };\n\n    // Returns a function, that, when invoked, will only be triggered at most once\n    // during a given window of time. Normally, the throttled function will run\n    // as much as it can, without ever going more than once per `wait` duration;\n    // but if you'd like to disable the execution on the leading edge, pass\n    // `{leading: false}`. To disable execution on the trailing edge, ditto.\n    _.throttle = function (func, wait, options) {\n        var context, args, result;\n        var timeout = null;\n        var previous = 0;\n        options || (options = {});\n        var later = function () {\n            previous = options.leading === false ? 0 : _.now();\n            timeout = null;\n            result = func.apply(context, args);\n            context = args = null;\n        };\n        return function () {\n            var now = _.now();\n            if (!previous && options.leading === false)\n                previous = now;\n            var remaining = wait - (now - previous);\n            context = this;\n            args = arguments;\n            if (remaining <= 0) {\n                clearTimeout(timeout);\n                timeout = null;\n                previous = now;\n                result = func.apply(context, args);\n                context = args = null;\n            } else if (!timeout && options.trailing !== false) {\n                timeout = setTimeout(later, remaining);\n            }\n            return result;\n        };\n    };\n\n    // Returns a function, that, as long as it continues to be invoked, will not\n    // be triggered. The function will be called after it stops being called for\n    // N milliseconds. If `immediate` is passed, trigger the function on the\n    // leading edge, instead of the trailing.\n    _.debounce = function (func, wait, immediate) {\n        var timeout, args, context, timestamp, result;\n\n        var later = function () {\n            var last = _.now() - timestamp;\n            if (last < wait) {\n                timeout = setTimeout(later, wait - last);\n            } else {\n                timeout = null;\n                if (!immediate) {\n                    result = func.apply(context, args);\n                    context = args = null;\n                }\n            }\n        };\n\n        return function () {\n            context = this;\n            args = arguments;\n            timestamp = _.now();\n            var callNow = immediate && !timeout;\n            if (!timeout) {\n                timeout = setTimeout(later, wait);\n            }\n            if (callNow) {\n                result = func.apply(context, args);\n                context = args = null;\n            }\n\n            return result;\n        };\n    };\n\n    // Returns a function that will be executed at most one time, no matter how\n    // often you call it. Useful for lazy initialization.\n    _.once = function (func) {\n        var ran = false, memo;\n        return function () {\n            if (ran)\n                return memo;\n            ran = true;\n            memo = func.apply(this, arguments);\n            func = null;\n            return memo;\n        };\n    };\n\n    // Returns the first function passed as an argument to the second,\n    // allowing you to adjust arguments, run code before and after, and\n    // conditionally execute the original function.\n    _.wrap = function (func, wrapper) {\n        return _.partial(wrapper, func);\n    };\n\n    // Returns a function that is the composition of a list of functions, each\n    // consuming the return value of the function that follows.\n    _.compose = function () {\n        var funcs = arguments;\n        return function () {\n            var args = arguments;\n            for (var i = funcs.length - 1; i >= 0; i--) {\n                args = [funcs[i].apply(this, args)];\n            }\n            return args[0];\n        };\n    };\n\n    // Returns a function that will only be executed after being called N times.\n    _.after = function (times, func) {\n        return function () {\n            if (--times < 1) {\n                return func.apply(this, arguments);\n            }\n        };\n    };\n\n    // Object Functions\n    // ----------------\n\n    // Retrieve the names of an object's properties.\n    // Delegates to **ECMAScript 5**'s native `Object.keys`\n    _.keys = function (obj) {\n        if (!_.isObject(obj))\n            return [];\n        if (nativeKeys)\n            return nativeKeys(obj);\n        var keys = [];\n        for (var key in obj)\n            if (_.has(obj, key))\n                keys.push(key);\n        return keys;\n    };\n\n    // Retrieve the values of an object's properties.\n    _.values = function (obj) {\n        var keys = _.keys(obj);\n        var length = keys.length;\n        var values = new Array(length);\n        for (var i = 0; i < length; i++) {\n            values[i] = obj[keys[i]];\n        }\n        return values;\n    };\n\n    // Convert an object into a list of `[key, value]` pairs.\n    _.pairs = function (obj) {\n        var keys = _.keys(obj);\n        var length = keys.length;\n        var pairs = new Array(length);\n        for (var i = 0; i < length; i++) {\n            pairs[i] = [keys[i], obj[keys[i]]];\n        }\n        return pairs;\n    };\n\n    // Invert the keys and values of an object. The values must be serializable.\n    _.invert = function (obj) {\n        var result = {};\n        var keys = _.keys(obj);\n        for (var i = 0, length = keys.length; i < length; i++) {\n            result[obj[keys[i]]] = keys[i];\n        }\n        return result;\n    };\n\n    // Return a sorted list of the function names available on the object.\n    // Aliased as `methods`\n    _.functions = _.methods = function (obj) {\n        var names = [];\n        for (var key in obj) {\n            if (_.isFunction(obj[key]))\n                names.push(key);\n        }\n        return names.sort();\n    };\n\n    // Extend a given object with all the properties in passed-in object(s).\n    _.extend = function (obj) {\n        each(slice.call(arguments, 1), function (source) {\n            if (source) {\n                for (var prop in source) {\n                    obj[prop] = source[prop];\n                }\n            }\n        });\n        return obj;\n    };\n\n    // Return a copy of the object only containing the whitelisted properties.\n    _.pick = function (obj) {\n        var copy = {};\n        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n        each(keys, function (key) {\n            if (key in obj)\n                copy[key] = obj[key];\n        });\n        return copy;\n    };\n\n    // Return a copy of the object without the blacklisted properties.\n    _.omit = function (obj) {\n        var copy = {};\n        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n        for (var key in obj) {\n            if (!_.contains(keys, key))\n                copy[key] = obj[key];\n        }\n        return copy;\n    };\n\n    // Fill in a given object with default properties.\n    _.defaults = function (obj) {\n        each(slice.call(arguments, 1), function (source) {\n            if (source) {\n                for (var prop in source) {\n                    if (obj[prop] === void 0)\n                        obj[prop] = source[prop];\n                }\n            }\n        });\n        return obj;\n    };\n\n    // Create a (shallow-cloned) duplicate of an object.\n    _.clone = function (obj) {\n        if (!_.isObject(obj))\n            return obj;\n        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n    };\n\n    // Invokes interceptor with the obj, and then returns obj.\n    // The primary purpose of this method is to \"tap into\" a method chain, in\n    // order to perform operations on intermediate results within the chain.\n    _.tap = function (obj, interceptor) {\n        interceptor(obj);\n        return obj;\n    };\n\n    // Internal recursive comparison function for `isEqual`.\n    var eq = function (a, b, aStack, bStack) {\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n        if (a === b)\n            return a !== 0 || 1 / a == 1 / b;\n        // A strict comparison is necessary because `null == undefined`.\n        if (a == null || b == null)\n            return a === b;\n        // Unwrap any wrapped objects.\n        if (a instanceof _)\n            a = a._wrapped;\n        if (b instanceof _)\n            b = b._wrapped;\n        // Compare `[[Class]]` names.\n        var className = toString.call(a);\n        if (className != toString.call(b))\n            return false;\n        switch (className) {\n            // Strings, numbers, dates, and booleans are compared by value.\n            case '[object String]':\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n                // equivalent to `new String(\"5\")`.\n                return a == String(b);\n            case '[object Number]':\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n                // other numeric values.\n                return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n            case '[object Date]':\n            case '[object Boolean]':\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n                // millisecond representations. Note that invalid dates with millisecond representations\n                // of `NaN` are not equivalent.\n                return +a == +b;\n                // RegExps are compared by their source patterns and flags.\n            case '[object RegExp]':\n                return a.source == b.source &&\n                    a.global == b.global &&\n                    a.multiline == b.multiline &&\n                    a.ignoreCase == b.ignoreCase;\n        }\n        if (typeof a != 'object' || typeof b != 'object')\n            return false;\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n        var length = aStack.length;\n        while (length--) {\n            // Linear search. Performance is inversely proportional to the number of\n            // unique nested structures.\n            if (aStack[length] == a)\n                return bStack[length] == b;\n        }\n        // Objects with different constructors are not equivalent, but `Object`s\n        // from different frames are.\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n            _.isFunction(bCtor) && (bCtor instanceof bCtor))\n            && ('constructor' in a && 'constructor' in b)) {\n            return false;\n        }\n        // Add the first object to the stack of traversed objects.\n        aStack.push(a);\n        bStack.push(b);\n        var size = 0, result = true;\n        // Recursively compare objects and arrays.\n        if (className == '[object Array]') {\n            // Compare array lengths to determine if a deep comparison is necessary.\n            size = a.length;\n            result = size == b.length;\n            if (result) {\n                // Deep compare the contents, ignoring non-numeric properties.\n                while (size--) {\n                    if (!(result = eq(a[size], b[size], aStack, bStack)))\n                        break;\n                }\n            }\n        } else {\n            // Deep compare objects.\n            for (var key in a) {\n                if (_.has(a, key)) {\n                    // Count the expected number of properties.\n                    size++;\n                    // Deep compare each member.\n                    if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)))\n                        break;\n                }\n            }\n            // Ensure that both objects contain the same number of properties.\n            if (result) {\n                for (key in b) {\n                    if (_.has(b, key) && !(size--))\n                        break;\n                }\n                result = !size;\n            }\n        }\n        // Remove the first object from the stack of traversed objects.\n        aStack.pop();\n        bStack.pop();\n        return result;\n    };\n\n    // Perform a deep comparison to check if two objects are equal.\n    _.isEqual = function (a, b) {\n        return eq(a, b, [], []);\n    };\n\n    // Is a given array, string, or object empty?\n    // An \"empty\" object has no enumerable own-properties.\n    _.isEmpty = function (obj) {\n        if (obj == null)\n            return true;\n        if (_.isArray(obj) || _.isString(obj))\n            return obj.length === 0;\n        for (var key in obj)\n            if (_.has(obj, key))\n                return false;\n        return true;\n    };\n\n    // Is a given value a DOM element?\n    _.isElement = function (obj) {\n        return !!(obj && obj.nodeType === 1);\n    };\n\n    // Is a given value an array?\n    // Delegates to ECMA5's native Array.isArray\n    _.isArray = nativeIsArray || function (obj) {\n        return toString.call(obj) == '[object Array]';\n    };\n\n    // Is a given variable an object?\n    _.isObject = function (obj) {\n        return obj === Object(obj);\n    };\n\n    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {\n        _['is' + name] = function (obj) {\n            return toString.call(obj) == '[object ' + name + ']';\n        };\n    });\n\n    // Define a fallback version of the method in browsers (ahem, IE), where\n    // there isn't any inspectable \"Arguments\" type.\n    if (!_.isArguments(arguments)) {\n        _.isArguments = function (obj) {\n            return !!(obj && _.has(obj, 'callee'));\n        };\n    }\n\n    // Optimize `isFunction` if appropriate.\n    if (true) {\n        _.isFunction = function (obj) {\n            return typeof obj === 'function';\n        };\n    }\n\n    // Is a given object a finite number?\n    _.isFinite = function (obj) {\n        return isFinite(obj) && !isNaN(parseFloat(obj));\n    };\n\n    // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n    _.isNaN = function (obj) {\n        return _.isNumber(obj) && obj != +obj;\n    };\n\n    // Is a given value a boolean?\n    _.isBoolean = function (obj) {\n        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n    };\n\n    // Is a given value equal to null?\n    _.isNull = function (obj) {\n        return obj === null;\n    };\n\n    // Is a given variable undefined?\n    _.isUndefined = function (obj) {\n        return obj === void 0;\n    };\n\n    // Shortcut function for checking if an object has a given property directly\n    // on itself (in other words, not on a prototype).\n    _.has = function (obj, key) {\n        return hasOwnProperty.call(obj, key);\n    };\n\n    // Utility Functions\n    // -----------------\n\n    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n    // previous owner. Returns a reference to the Underscore object.\n    _.noConflict = function () {\n        root._ = previousUnderscore;\n        return this;\n    };\n\n    // Keep the identity function around for default iterators.\n    _.identity = function (value) {\n        return value;\n    };\n\n    _.constant = function (value) {\n        return function () {\n            return value;\n        };\n    };\n\n    _.property = function (key) {\n        return function (obj) {\n            return obj[key];\n        };\n    };\n\n    // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n    _.matches = function (attrs) {\n        return function (obj) {\n            if (obj === attrs)\n                return true; //avoid comparing an object to itself.\n            for (var key in attrs) {\n                if (attrs[key] !== obj[key])\n                    return false;\n            }\n            return true;\n        }\n    };\n\n    // Run a function **n** times.\n    _.times = function (n, iterator, context) {\n        var accum = Array(Math.max(0, n));\n        for (var i = 0; i < n; i++)\n            accum[i] = iterator.call(context, i);\n        return accum;\n    };\n\n    // Return a random integer between min and max (inclusive).\n    _.random = function (min, max) {\n        if (max == null) {\n            max = min;\n            min = 0;\n        }\n        return min + Math.floor(Math.random() * (max - min + 1));\n    };\n\n    // A (possibly faster) way to get the current timestamp as an integer.\n    _.now = Date.now || function () {\n        return new Date().getTime();\n    };\n\n    // List of HTML entities for escaping.\n    var entityMap = {\n        escape: {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#x27;'\n        }\n    };\n    entityMap.unescape = _.invert(entityMap.escape);\n\n    // Regexes containing the keys and values listed immediately above.\n    var entityRegexes = {\n        escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n        unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n    };\n\n    // Functions for escaping and unescaping strings to/from HTML interpolation.\n    _.each(['escape', 'unescape'], function (method) {\n        _[method] = function (string) {\n            if (string == null)\n                return '';\n            return ('' + string).replace(entityRegexes[method], function (match) {\n                return entityMap[method][match];\n            });\n        };\n    });\n\n    // If the value of the named `property` is a function then invoke it with the\n    // `object` as context; otherwise, return it.\n    _.result = function (object, property) {\n        if (object == null)\n            return void 0;\n        var value = object[property];\n        return _.isFunction(value) ? value.call(object) : value;\n    };\n\n    // Add your own custom functions to the Underscore object.\n    _.mixin = function (obj) {\n        each(_.functions(obj), function (name) {\n            var func = _[name] = obj[name];\n            _.prototype[name] = function () {\n                var args = [this._wrapped];\n                push.apply(args, arguments);\n                return result.call(this, func.apply(_, args));\n            };\n        });\n    };\n\n    // Generate a unique integer id (unique within the entire client session).\n    // Useful for temporary DOM ids.\n    var idCounter = 0;\n    _.uniqueId = function (prefix) {\n        var id = ++idCounter + '';\n        return prefix ? prefix + id : id;\n    };\n\n    // By default, Underscore uses ERB-style template delimiters, change the\n    // following template settings to use alternative delimiters.\n    _.templateSettings = {\n        evaluate: /<%([\\s\\S]+?)%>/g,\n        interpolate: /<%=([\\s\\S]+?)%>/g,\n        escape: /<%-([\\s\\S]+?)%>/g\n    };\n\n    // When customizing `templateSettings`, if you don't want to define an\n    // interpolation, evaluation or escaping regex, we need one that is\n    // guaranteed not to match.\n    var noMatch = /(.)^/;\n\n    // Certain characters need to be escaped so that they can be put into a\n    // string literal.\n    var escapes = {\n        \"'\": \"'\",\n        '\\\\': '\\\\',\n        '\\r': 'r',\n        '\\n': 'n',\n        '\\t': 't',\n        '\\u2028': 'u2028',\n        '\\u2029': 'u2029'\n    };\n\n    var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n    // JavaScript micro-templating, similar to John Resig's implementation.\n    // Underscore templating handles arbitrary delimiters, preserves whitespace,\n    // and correctly escapes quotes within interpolated code.\n    _.template = function (text, data, settings) {\n        var render;\n        settings = _.defaults({}, settings, _.templateSettings);\n\n        // Combine delimiters into one regular expression via alternation.\n        var matcher = new RegExp([\n            (settings.escape || noMatch).source,\n            (settings.interpolate || noMatch).source,\n            (settings.evaluate || noMatch).source\n        ].join('|') + '|$', 'g');\n\n        // Compile the template source, escaping string literals appropriately.\n        var index = 0;\n        var source = \"__p+='\";\n        text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {\n            source += text.slice(index, offset)\n                .replace(escaper, function (match) {\n                    return '\\\\' + escapes[match];\n                });\n\n            if (escape) {\n                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n            }\n            if (interpolate) {\n                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n            }\n            if (evaluate) {\n                source += \"';\\n\" + evaluate + \"\\n__p+='\";\n            }\n            index = offset + match.length;\n            return match;\n        });\n        source += \"';\\n\";\n\n        // If a variable is not specified, place data values in local scope.\n        if (!settings.variable)\n            source = 'with(obj||{}){\\n' + source + '}\\n';\n\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\n            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n            source + \"return __p;\\n\";\n\n        try {\n            render = new Function(settings.variable || 'obj', '_', source);\n        } catch (e) {\n            e.source = source;\n            throw e;\n        }\n\n        if (data)\n            return render(data, _);\n        var template = function (data) {\n            return render.call(this, data, _);\n        };\n\n        // Provide the compiled function source as a convenience for precompilation.\n        template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n        return template;\n    };\n\n    // Add a \"chain\" function, which will delegate to the wrapper.\n    _.chain = function (obj) {\n        return _(obj).chain();\n    };\n\n    // OOP\n    // ---------------\n    // If Underscore is called as a function, it returns a wrapped object that\n    // can be used OO-style. This wrapper holds altered versions of all the\n    // underscore functions. Wrapped objects may be chained.\n\n    // Helper function to continue chaining intermediate results.\n    var result = function (obj) {\n        return this._chain ? _(obj).chain() : obj;\n    };\n\n    // Add all of the Underscore functions to the wrapper object.\n    _.mixin(_);\n\n    // Add all mutator Array functions to the wrapper.\n    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {\n        var method = ArrayProto[name];\n        _.prototype[name] = function () {\n            var obj = this._wrapped;\n            method.apply(obj, arguments);\n            if ((name == 'shift' || name == 'splice') && obj.length === 0)\n                delete obj[0];\n            return result.call(this, obj);\n        };\n    });\n\n    // Add all accessor Array functions to the wrapper.\n    each(['concat', 'join', 'slice'], function (name) {\n        var method = ArrayProto[name];\n        _.prototype[name] = function () {\n            return result.call(this, method.apply(this._wrapped, arguments));\n        };\n    });\n\n    _.extend(_.prototype, {\n        // Start chaining a wrapped Underscore object.\n        chain: function () {\n            this._chain = true;\n            return this;\n        },\n        // Extracts the result from a wrapped and chained object.\n        value: function () {\n            return this._wrapped;\n        }\n\n    });\n\n    // AMD registration happens at the end for compatibility with AMD loaders\n    // that may not enforce next-turn semantics on modules. Even though general\n    // practice for AMD registration is to be anonymous, underscore registers\n    // as a named module because, like jQuery, it is a base library that is\n    // popular enough to be bundled in a third party lib, but not be part of\n    // an AMD load request. Those cases could generate an error when an\n    // anonymous define() is called outside of a loader request.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return _;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n}).call(this);\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = _;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdmVuZG9yL3VuZGVyc2NvcmUuanM/NmExYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0Esa0NBQWtDLEVBQUUsaUJBQWlCOztBQUVyRDtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLGlCQUFpQjs7QUFFM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgIFVuZGVyc2NvcmUuanMgMS42LjBcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICAgIHZhciByb290ID0gdGhpcztcblxuICAgIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gICAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAgIC8vIEVzdGFibGlzaCB0aGUgb2JqZWN0IHRoYXQgZ2V0cyByZXR1cm5lZCB0byBicmVhayBvdXQgb2YgYSBsb29wIGl0ZXJhdGlvbi5cbiAgICB2YXIgYnJlYWtlciA9IHt9O1xuXG4gICAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgICB2YXJcbiAgICAgICAgcHVzaCA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICAgICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgICBjb25jYXQgPSBBcnJheVByb3RvLmNvbmNhdCxcbiAgICAgICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAgIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICAgIHZhclxuICAgICAgICBuYXRpdmVGb3JFYWNoID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgICAgICBuYXRpdmVNYXAgPSBBcnJheVByb3RvLm1hcCxcbiAgICAgICAgbmF0aXZlUmVkdWNlID0gQXJyYXlQcm90by5yZWR1Y2UsXG4gICAgICAgIG5hdGl2ZVJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodCxcbiAgICAgICAgbmF0aXZlRmlsdGVyID0gQXJyYXlQcm90by5maWx0ZXIsXG4gICAgICAgIG5hdGl2ZUV2ZXJ5ID0gQXJyYXlQcm90by5ldmVyeSxcbiAgICAgICAgbmF0aXZlU29tZSA9IEFycmF5UHJvdG8uc29tZSxcbiAgICAgICAgbmF0aXZlSW5kZXhPZiA9IEFycmF5UHJvdG8uaW5kZXhPZixcbiAgICAgICAgbmF0aXZlTGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mLFxuICAgICAgICBuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICAgICAgbmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzLFxuICAgICAgICBuYXRpdmVCaW5kID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgICB2YXIgXyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpXG4gICAgICAgICAgICByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICAgICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gICAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAgIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMuXyA9IF87XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5fID0gXztcbiAgICB9XG5cbiAgICAvLyBDdXJyZW50IHZlcnNpb24uXG4gICAgXy5WRVJTSU9OID0gJzEuNi4wJztcblxuICAgIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAgIC8vIEhhbmRsZXMgb2JqZWN0cyB3aXRoIHRoZSBidWlsdC1pbiBgZm9yRWFjaGAsIGFycmF5cywgYW5kIHJhdyBvYmplY3RzLlxuICAgIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmb3JFYWNoYCBpZiBhdmFpbGFibGUuXG4gICAgdmFyIGVhY2ggPSBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAob2JqID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaikgPT09IGJyZWFrZXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuXG4gICAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAob2JqID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApXG4gICAgICAgICAgICByZXR1cm4gb2JqLm1hcChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICAgIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gICAgLy8gb3IgYGZvbGRsYC4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZWAgaWYgYXZhaWxhYmxlLlxuICAgIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKVxuICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dClcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZShpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5pdGlhbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gICAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZVJpZ2h0YCBpZiBhdmFpbGFibGUuXG4gICAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgICAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgICAgICBpZiAob2JqID09IG51bGwpXG4gICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KVxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09ICtsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgaW5kZXggPSBrZXlzID8ga2V5c1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgICAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIG1lbW8gPSBvYmpbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaW5kZXhdLCBpbmRleCwgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWluaXRpYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uIChvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBhbnkob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuXG4gICAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24gKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICBpZiAobmF0aXZlRmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiBvYmouZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICAgIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSlcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gICAgXy5yZWplY3QgPSBmdW5jdGlvbiAob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICB9LCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gICAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGV2ZXJ5YCBpZiBhdmFpbGFibGUuXG4gICAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbiAob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBfLmlkZW50aXR5KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChuYXRpdmVFdmVyeSAmJiBvYmouZXZlcnkgPT09IG5hdGl2ZUV2ZXJ5KVxuICAgICAgICAgICAgcmV0dXJuIG9iai5ldmVyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgaWYgKCEocmVzdWx0ID0gcmVzdWx0ICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBicmVha2VyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgc29tZWAgaWYgYXZhaWxhYmxlLlxuICAgIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gICAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24gKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gXy5pZGVudGl0eSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpXG4gICAgICAgICAgICByZXR1cm4gb2JqLnNvbWUocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgICAgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgfHwgKHJlc3VsdCA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBicmVha2VyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXG4gICAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZWAuXG4gICAgXy5jb250YWlucyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uIChvYmosIHRhcmdldCkge1xuICAgICAgICBpZiAob2JqID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKVxuICAgICAgICAgICAgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgICAgIHJldHVybiBhbnkob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gICAgXy5pbnZva2UgPSBmdW5jdGlvbiAob2JqLCBtZXRob2QpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICAgICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gICAgXy5wbHVjayA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICAgIH07XG5cbiAgICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gICAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgICBfLndoZXJlID0gZnVuY3Rpb24gKG9iaiwgYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XG4gICAgfTtcblxuICAgIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICAgIF8uZmluZFdoZXJlID0gZnVuY3Rpb24gKG9iaiwgYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCBvciAoZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gICAgLy8gQ2FuJ3Qgb3B0aW1pemUgYXJyYXlzIG9mIGludGVnZXJzIGxvbmdlciB0aGFuIDY1LDUzNSBlbGVtZW50cy5cbiAgICAvLyBTZWUgW1dlYktpdCBCdWcgODA3OTddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD04MDc5NylcbiAgICBfLm1heCA9IGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5O1xuICAgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICAgIF8ubWluID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5O1xuICAgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gU2h1ZmZsZSBhbiBhcnJheSwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAgIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgICBfLnNodWZmbGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciByYW5kO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgc2h1ZmZsZWQgPSBbXTtcbiAgICAgICAgZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmFuZCA9IF8ucmFuZG9tKGluZGV4KyspO1xuICAgICAgICAgICAgc2h1ZmZsZWRbaW5kZXggLSAxXSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaHVmZmxlZDtcbiAgICB9O1xuXG4gICAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICAgIF8uc2FtcGxlID0gZnVuY3Rpb24gKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgICB9O1xuXG4gICAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbG9va3VwIGl0ZXJhdG9ycy5cbiAgICB2YXIgbG9va3VwSXRlcmF0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXy5pZGVudGl0eTtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdG9yLlxuICAgIF8uc29ydEJ5ID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIGNyaXRlcmlhOiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICAgICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgICAgICB9KSwgJ3ZhbHVlJyk7XG4gICAgfTtcblxuICAgIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgICB2YXIgZ3JvdXAgPSBmdW5jdGlvbiAoYmVoYXZpb3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpdGVyYXRvciA9IGxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIGVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbiAocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldLnB1c2godmFsdWUpIDogcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICAgIH0pO1xuXG4gICAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAgIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbiAocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBjcml0ZXJpb24uXG4gICAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgICAgIF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldKysgOiByZXN1bHRba2V5XSA9IDE7XG4gICAgfSk7XG5cbiAgICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gICAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICAgIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqKTtcbiAgICAgICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVttaWRdKSA8IHZhbHVlID8gbG93ID0gbWlkICsgMSA6IGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvdztcbiAgICB9O1xuXG4gICAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgICBfLnRvQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoXy5pc0FycmF5KG9iaikpXG4gICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICAgICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgICBfLnNpemUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gICAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAgIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24gKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIGlmICgobiA9PSBudWxsKSB8fCBndWFyZClcbiAgICAgICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICAgICAgaWYgKG4gPCAwKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgbik7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAgIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gICAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXG4gICAgLy8gYF8ubWFwYC5cbiAgICBfLmluaXRpYWwgPSBmdW5jdGlvbiAoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbikpO1xuICAgIH07XG5cbiAgICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gICAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gICAgXy5sYXN0ID0gZnVuY3Rpb24gKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIGlmICgobiA9PSBudWxsKSB8fCBndWFyZClcbiAgICAgICAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAgIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gICAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqXG4gICAgLy8gY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICAgIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uIChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pO1xuICAgIH07XG5cbiAgICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gICAgXy5jb21wYWN0ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gICAgfTtcblxuICAgIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uIChpbnB1dCwgc2hhbGxvdywgb3V0cHV0KSB7XG4gICAgICAgIGlmIChzaGFsbG93ICYmIF8uZXZlcnkoaW5wdXQsIF8uaXNBcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQuYXBwbHkob3V0cHV0LCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWFjaChpbnB1dCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHNoYWxsb3cgPyBwdXNoLmFwcGx5KG91dHB1dCwgdmFsdWUpIDogZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgb3V0cHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICAgIF8uZmxhdHRlbiA9IGZ1bmN0aW9uIChhcnJheSwgc2hhbGxvdykge1xuICAgICAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgW10pO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgICBfLndpdGhvdXQgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xuXG4gICAgLy8gU3BsaXQgYW4gYXJyYXkgaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gICAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICAgIF8ucGFydGl0aW9uID0gZnVuY3Rpb24gKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgICAgICBlYWNoKGFycmF5LCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgKHByZWRpY2F0ZShlbGVtKSA/IHBhc3MgOiBmYWlsKS5wdXNoKGVsZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgICB9O1xuXG4gICAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gICAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oaXNTb3J0ZWQpKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gaXRlcmF0b3I7XG4gICAgICAgICAgICBpdGVyYXRvciA9IGlzU29ydGVkO1xuICAgICAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5pdGlhbCA9IGl0ZXJhdG9yID8gXy5tYXAoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSA6IGFycmF5O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgc2VlbiA9IFtdO1xuICAgICAgICBlYWNoKGluaXRpYWwsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpc1NvcnRlZCA/ICghaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSB2YWx1ZSkgOiAhXy5jb250YWlucyhzZWVuLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChhcnJheVtpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAgIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICAgIF8udW5pb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfLnVuaXEoXy5mbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSkpO1xuICAgIH07XG5cbiAgICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gICAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgcmVzdCA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5ldmVyeShyZXN0LCBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5jb250YWlucyhvdGhlciwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICAgIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgICBfLnppcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IF8ubWF4KF8ucGx1Y2soYXJndW1lbnRzLCAnbGVuZ3RoJykuY29uY2F0KDApKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJndW1lbnRzLCAnJyArIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gICAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gICAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgIF8ub2JqZWN0ID0gZnVuY3Rpb24gKGxpc3QsIHZhbHVlcykge1xuICAgICAgICBpZiAobGlzdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcGx5IHVzIHdpdGggaW5kZXhPZiAoSSdtIGxvb2tpbmcgYXQgeW91LCAqKk1TSUUqKiksXG4gICAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuXG4gICAgLy8gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgaW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICAgIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAgIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gICAgXy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGkgPSAoaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpXG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtLCBpc1NvcnRlZCk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGxhc3RJbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gICAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgdmFyIGhhc0luZGV4ID0gZnJvbSAhPSBudWxsO1xuICAgICAgICBpZiAobmF0aXZlTGFzdEluZGV4T2YgJiYgYXJyYXkubGFzdEluZGV4T2YgPT09IG5hdGl2ZUxhc3RJbmRleE9mKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzSW5kZXggPyBhcnJheS5sYXN0SW5kZXhPZihpdGVtLCBmcm9tKSA6IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gKGhhc0luZGV4ID8gZnJvbSA6IGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAgIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gICAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgICBfLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBhcmd1bWVudHNbMl0gfHwgMTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgdmFyIHJhbmdlID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKGlkeCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBSZXVzYWJsZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgcHJvdG90eXBlIHNldHRpbmcuXG4gICAgdmFyIGN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAgIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgICAvLyBhdmFpbGFibGUuXG4gICAgXy5iaW5kID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgICAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpXG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBib3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcjtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gICAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAgIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgICBfLnBhcnRpYWwgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzW2ldID09PSBfKVxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW3Bvc2l0aW9uKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gICAgXy5iaW5kQWxsID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgZnVuY3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGlmIChmdW5jcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICAgICAgZWFjaChmdW5jcywgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICAgIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uIChmdW5jLCBoYXNoZXIpIHtcbiAgICAgICAgdmFyIG1lbW8gPSB7fTtcbiAgICAgICAgaGFzaGVyIHx8IChoYXNoZXIgPSBfLmlkZW50aXR5KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gICAgXy5kZWxheSA9IGZ1bmN0aW9uIChmdW5jLCB3YWl0KSB7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgfTtcblxuICAgIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAgIC8vIGNsZWFyZWQuXG4gICAgXy5kZWZlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAgIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAgIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAgIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICAgIF8udGhyb3R0bGUgPSBmdW5jdGlvbiAoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gICAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAgIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAgIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gICAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICAgICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAgIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gICAgXy5vbmNlID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgdmFyIHJhbiA9IGZhbHNlLCBtZW1vO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJhbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gICAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAgIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gICAgXy53cmFwID0gZnVuY3Rpb24gKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICAgIF8uY29tcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZnVuY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gICAgXy5hZnRlciA9IGZ1bmN0aW9uICh0aW1lcywgZnVuYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAgIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgICBfLmtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghXy5pc09iamVjdChvYmopKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBpZiAobmF0aXZlS2V5cylcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgICBpZiAoXy5oYXMob2JqLCBrZXkpKVxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAgIF8udmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcblxuICAgIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICAgIF8ucGFpcnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgdmFyIHBhaXJzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH07XG5cbiAgICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gICAgXy5pbnZlcnQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gICAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKVxuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICAgIH07XG5cbiAgICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgICBfLmV4dGVuZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgICBfLnBpY2sgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBjb3B5ID0ge307XG4gICAgICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIGVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmopXG4gICAgICAgICAgICAgICAgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gICAgXy5vbWl0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgY29weSA9IHt9O1xuICAgICAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoIV8uY29udGFpbnMoa2V5cywga2V5KSlcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9O1xuXG4gICAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICBfLmRlZmF1bHRzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpbcHJvcF0gPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gICAgXy5jbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICAgIH07XG5cbiAgICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gICAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gICAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gICAgXy50YXAgPSBmdW5jdGlvbiAob2JqLCBpbnRlcmNlcHRvcikge1xuICAgICAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICAgIHZhciBlcSA9IGZ1bmN0aW9uIChhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgICAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgICAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgICAgIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiO1xuICAgICAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIF8pXG4gICAgICAgICAgICBhID0gYS5fd3JhcHBlZDtcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBfKVxuICAgICAgICAgICAgYiA9IGIuX3dyYXBwZWQ7XG4gICAgICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLiBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgIT0gK2EgPyBiICE9ICtiIDogKGEgPT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYik7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAgICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgICAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICAgICAgICAgIHJldHVybiArYSA9PSArYjtcbiAgICAgICAgICAgICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLlxuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zb3VyY2UgPT0gYi5zb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgYS5pZ25vcmVDYXNlID09IGIuaWdub3JlQ2FzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAgICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09IGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IpICYmXG4gICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIChiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSlcbiAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgYVN0YWNrLnB1c2goYSk7XG4gICAgICAgIGJTdGFjay5wdXNoKGIpO1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgc2l6ZSA9IGEubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBiLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzdWx0ID0gZXEoYVtzaXplXSwgYltzaXplXSwgYVN0YWNrLCBiU3RhY2spKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5oYXMoYSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXN1bHQgPSBfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5oYXMoYiwga2V5KSAmJiAhKHNpemUtLSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gIXNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgIGFTdGFjay5wb3AoKTtcbiAgICAgICAgYlN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgICBfLmlzRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZXEoYSwgYiwgW10sIFtdKTtcbiAgICB9O1xuXG4gICAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gICAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgICBfLmlzRW1wdHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopKVxuICAgICAgICAgICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgICBpZiAoXy5oYXMob2JqLCBrZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICAgIH07XG5cbiAgICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAgIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gICAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gICAgXy5pc09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gICAgfTtcblxuICAgIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLlxuICAgIGVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICAgIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuXG4gICAgaWYgKHR5cGVvZiAoLy4vKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gICAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gICAgfTtcblxuICAgIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgICBfLmlzTmFOID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPSArb2JqO1xuICAgIH07XG5cbiAgICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG4gICAgfTtcblxuICAgIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgICBfLmlzTnVsbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gICAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICAgIH07XG5cbiAgICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gICAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgICBfLmhhcyA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgfTtcblxuICAgIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gICAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0b3JzLlxuICAgIF8uaWRlbnRpdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBfLmNvbnN0YW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIF8ucHJvcGVydHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgICBfLm1hdGNoZXMgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogPT09IGF0dHJzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvL2F2b2lkIGNvbXBhcmluZyBhbiBvYmplY3QgdG8gaXRzZWxmLlxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgICBfLnRpbWVzID0gZnVuY3Rpb24gKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgICAgICBhY2N1bVtpXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgICBfLnJhbmRvbSA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgICAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gICAgfTtcblxuICAgIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICAgIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgICAgIGVzY2FwZToge1xuICAgICAgICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAgICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgICAgICAgXCInXCI6ICcmI3gyNzsnXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGVudGl0eU1hcC51bmVzY2FwZSA9IF8uaW52ZXJ0KGVudGl0eU1hcC5lc2NhcGUpO1xuXG4gICAgLy8gUmVnZXhlcyBjb250YWluaW5nIHRoZSBrZXlzIGFuZCB2YWx1ZXMgbGlzdGVkIGltbWVkaWF0ZWx5IGFib3ZlLlxuICAgIHZhciBlbnRpdHlSZWdleGVzID0ge1xuICAgICAgICBlc2NhcGU6IG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxuICAgICAgICB1bmVzY2FwZTogbmV3IFJlZ0V4cCgnKCcgKyBfLmtleXMoZW50aXR5TWFwLnVuZXNjYXBlKS5qb2luKCd8JykgKyAnKScsICdnJylcbiAgICB9O1xuXG4gICAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICAgIF8uZWFjaChbJ2VzY2FwZScsICd1bmVzY2FwZSddLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgICBfLnJlc3VsdCA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgICBfLm1peGluID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBlYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICAgICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gICAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcbiAgICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgICAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgICB9O1xuXG4gICAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gICAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICAgICAgZXZhbHVhdGU6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgICAgZXNjYXBlOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICAgIH07XG5cbiAgICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gICAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAgIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICAgIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gICAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgICB2YXIgZXNjYXBlcyA9IHtcbiAgICAgICAgXCInXCI6IFwiJ1wiLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJ1xccic6ICdyJyxcbiAgICAgICAgJ1xcbic6ICduJyxcbiAgICAgICAgJ1xcdCc6ICd0JyxcbiAgICAgICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgICB9O1xuXG4gICAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx0fFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gICAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gICAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0LCBkYXRhLCBzZXR0aW5ncykge1xuICAgICAgICB2YXIgcmVuZGVyO1xuICAgICAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgICAgICB2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoW1xuICAgICAgICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAgICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgICAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAgICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoZXNjYXBlciwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmFsdWF0ZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSk7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICAgICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSlcbiAgICAgICAgICAgIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICAgICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgICAgICAgIHNvdXJjZSArIFwicmV0dXJuIF9fcDtcXG5cIjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcihkYXRhLCBfKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbiBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgZGVsZWdhdGUgdG8gdGhlIHdyYXBwZXIuXG4gICAgXy5jaGFpbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICAgIH07XG5cbiAgICAvLyBPT1BcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAgIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gICAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgIF8ubWl4aW4oXyk7XG5cbiAgICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICAgIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKChuYW1lID09ICdzaGlmdCcgfHwgbmFtZSA9PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG9iaik7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgICBlYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIF8uZXh0ZW5kKF8ucHJvdG90eXBlLCB7XG4gICAgICAgIC8vIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgICAgICAgY2hhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gICAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gICAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF87XG4gICAgICAgIH0pO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG5cblxuLyoqKiBFWFBPUlRTIEZST00gZXhwb3J0cy1sb2FkZXIgKioqL1xubW9kdWxlLmV4cG9ydHMgPSBfO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hc3NldHMvanMvdmVuZG9yL3VuZGVyc2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar jquery = __webpack_require__(2);\n\n/*\n Highcharts JS v4.1.8 (2015-08-20)\n\n (c) 2009-2014 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function(){function A(){var a,b=arguments,c,d={},e=function(a,b){var c,d;typeof a!==\"object\"&&(a={});for(d in b)b.hasOwnProperty(d)&&(c=b[d],a[d]=c&&typeof c===\"object\"&&Object.prototype.toString.call(c)!==\"[object Array]\"&&d!==\"renderTo\"&&typeof c.nodeType!==\"number\"?e(a[d]||{},c):b[d]);return a};b[0]===!0&&(d=b[1],b=Array.prototype.slice.call(b,2));c=b.length;for(a=0;a<c;a++)d=e(d,b[a]);return d}function F(a,b){return parseInt(a,b||10)}function Aa(a){return typeof a===\"string\"}function da(a){return a&&\ntypeof a===\"object\"}function Fa(a){return Object.prototype.toString.call(a)===\"[object Array]\"}function qa(a){return typeof a===\"number\"}function Ba(a){return W.log(a)/W.LN10}function ia(a){return W.pow(10,a)}function ja(a,b){for(var c=a.length;c--;)if(a[c]===b){a.splice(c,1);break}}function s(a){return a!==v&&a!==null}function J(a,b,c){var d,e;if(Aa(b))s(c)?a.setAttribute(b,c):a&&a.getAttribute&&(e=a.getAttribute(b));else if(s(b)&&da(b))for(d in b)a.setAttribute(d,b[d]);return e}function ra(a){return Fa(a)?\na:[a]}function L(a,b){if(xa&&!ca&&b&&b.opacity!==v)b.filter=\"alpha(opacity=\"+b.opacity*100+\")\";r(a.style,b)}function $(a,b,c,d,e){a=C.createElement(a);b&&r(a,b);e&&L(a,{padding:0,border:O,margin:0});c&&L(a,c);d&&d.appendChild(a);return a}function ka(a,b){var c=function(){return v};c.prototype=new a;r(c.prototype,b);return c}function Ga(a,b){return Array((b||2)+1-String(a).length).join(0)+a}function Va(a){return(bb&&bb(a)||mb||0)*6E4}function Ha(a,b){for(var c=\"{\",d=!1,e,f,g,h,i,j=[];(c=a.indexOf(c))!==\n-1;){e=a.slice(0,c);if(d){f=e.split(\":\");g=f.shift().split(\".\");i=g.length;e=b;for(h=0;h<i;h++)e=e[g[h]];if(f.length)f=f.join(\":\"),g=/\\.([0-9])/,h=S.lang,i=void 0,/f$/.test(f)?(i=(i=f.match(g))?i[1]:-1,e!==null&&(e=B.numberFormat(e,i,h.decimalPoint,f.indexOf(\",\")>-1?h.thousandsSep:\"\"))):e=Ma(f,e)}j.push(e);a=a.slice(c+1);c=(d=!d)?\"}\":\"{\"}j.push(a);return j.join(\"\")}function nb(a){return W.pow(10,V(W.log(a)/W.LN10))}function ob(a,b,c,d,e){var f,g=a,c=p(c,1);f=a/c;b||(b=[1,2,2.5,5,10],d===!1&&(c===\n1?b=[1,2,5,10]:c<=0.1&&(b=[1/c])));for(d=0;d<b.length;d++)if(g=b[d],e&&g*c>=a||!e&&f<=(b[d]+(b[d+1]||b[d]))/2)break;g*=c;return g}function pb(a,b){var c=a.length,d,e;for(e=0;e<c;e++)a[e].ss_i=e;a.sort(function(a,c){d=b(a,c);return d===0?a.ss_i-c.ss_i:d});for(e=0;e<c;e++)delete a[e].ss_i}function Na(a){for(var b=a.length,c=a[0];b--;)a[b]<c&&(c=a[b]);return c}function Ca(a){for(var b=a.length,c=a[0];b--;)a[b]>c&&(c=a[b]);return c}function Oa(a,b){for(var c in a)a[c]&&a[c]!==b&&a[c].destroy&&a[c].destroy(),\ndelete a[c]}function Pa(a){cb||(cb=$(Ia));a&&cb.appendChild(a);cb.innerHTML=\"\"}function la(a,b){var c=\"Highcharts error #\"+a+\": www.highcharts.com/errors/\"+a;if(b)throw c;K.console&&console.log(c)}function ea(a,b){return parseFloat(a.toPrecision(b||14))}function Qa(a,b){b.renderer.globalAnimation=p(a,b.animation)}function Cb(){var a=S.global,b=a.useUTC,c=b?\"getUTC\":\"get\",d=b?\"setUTC\":\"set\";ya=a.Date||window.Date;mb=b&&a.timezoneOffset;bb=b&&a.getTimezoneOffset;db=function(a,c,d,h,i,j){var k;b?(k=\nya.UTC.apply(0,arguments),k+=Va(k)):k=(new ya(a,c,p(d,1),p(h,0),p(i,0),p(j,0))).getTime();return k};qb=c+\"Minutes\";rb=c+\"Hours\";sb=c+\"Day\";Wa=c+\"Date\";Xa=c+\"Month\";Ya=c+\"FullYear\";Db=d+\"Milliseconds\";Eb=d+\"Seconds\";Fb=d+\"Minutes\";Gb=d+\"Hours\";tb=d+\"Date\";ub=d+\"Month\";vb=d+\"FullYear\"}function P(){}function Ra(a,b,c,d){this.axis=a;this.pos=b;this.type=c||\"\";this.isNew=!0;!c&&!d&&this.addLabel()}function Hb(a,b,c,d,e){var f=a.chart.inverted;this.axis=a;this.isNegative=c;this.options=b;this.x=d;this.total=\nnull;this.points={};this.stack=e;this.alignOptions={align:b.align||(f?c?\"left\":\"right\":\"center\"),verticalAlign:b.verticalAlign||(f?\"middle\":c?\"bottom\":\"top\"),y:p(b.y,f?4:c?14:-6),x:p(b.x,f?c?-6:6:0)};this.textAlign=b.textAlign||(f?c?\"right\":\"left\":\"center\")}var v,C=document,K=window,W=Math,w=W.round,V=W.floor,sa=W.ceil,t=W.max,z=W.min,N=W.abs,X=W.cos,aa=W.sin,ma=W.PI,ga=ma*2/360,za=navigator.userAgent,Ib=K.opera,xa=/(msie|trident)/i.test(za)&&!Ib,eb=C.documentMode===8,fb=/AppleWebKit/.test(za),Ja=\n/Firefox/.test(za),Jb=/(Mobile|Android|Windows Phone)/.test(za),Da=\"http://www.w3.org/2000/svg\",ca=!!C.createElementNS&&!!C.createElementNS(Da,\"svg\").createSVGRect,Nb=Ja&&parseInt(za.split(\"Firefox/\")[1],10)<4,fa=!ca&&!xa&&!!C.createElement(\"canvas\").getContext,Za,$a,Kb={},wb=0,cb,S,Ma,xb,E,ta=function(){return v},Y=[],ab=0,Ia=\"div\",O=\"none\",Ob=/^[0-9]+$/,gb=[\"plotTop\",\"marginRight\",\"marginBottom\",\"plotLeft\"],Pb=\"stroke-width\",ya,db,mb,bb,qb,rb,sb,Wa,Xa,Ya,Db,Eb,Fb,Gb,tb,ub,vb,M={},B;B=K.Highcharts=\nK.Highcharts?la(16,!0):{};B.seriesTypes=M;var r=B.extend=function(a,b){var c;a||(a={});for(c in b)a[c]=b[c];return a},p=B.pick=function(){var a=arguments,b,c,d=a.length;for(b=0;b<d;b++)if(c=a[b],c!==v&&c!==null)return c},Sa=B.wrap=function(a,b,c){var d=a[b];a[b]=function(){var a=Array.prototype.slice.call(arguments);a.unshift(d);return c.apply(this,a)}};Ma=function(a,b,c){if(!s(b)||isNaN(b))return S.lang.invalidDate||\"\";var a=p(a,\"%Y-%m-%d %H:%M:%S\"),d=new ya(b-Va(b)),e,f=d[rb](),g=d[sb](),h=d[Wa](),\ni=d[Xa](),j=d[Ya](),k=S.lang,m=k.weekdays,d=r({a:m[g].substr(0,3),A:m[g],d:Ga(h),e:h,w:g,b:k.shortMonths[i],B:k.months[i],m:Ga(i+1),y:j.toString().substr(2,2),Y:j,H:Ga(f),k:f,I:Ga(f%12||12),l:f%12||12,M:Ga(d[qb]()),p:f<12?\"AM\":\"PM\",P:f<12?\"am\":\"pm\",S:Ga(d.getSeconds()),L:Ga(w(b%1E3),3)},B.dateFormats);for(e in d)for(;a.indexOf(\"%\"+e)!==-1;)a=a.replace(\"%\"+e,typeof d[e]===\"function\"?d[e](b):d[e]);return c?a.substr(0,1).toUpperCase()+a.substr(1):a};E={millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,\nweek:6048E5,month:24192E5,year:314496E5};B.numberFormat=function(a,b,c,d){var e=S.lang,a=+a||0,f=b===-1?z((a.toString().split(\".\")[1]||\"\").length,20):isNaN(b=N(b))?2:b,b=c===void 0?e.decimalPoint:c,d=d===void 0?e.thousandsSep:d,e=a<0?\"-\":\"\",c=String(F(a=N(a).toFixed(f))),g=c.length>3?c.length%3:0;return e+(g?c.substr(0,g)+d:\"\")+c.substr(g).replace(/(\\d{3})(?=\\d)/g,\"$1\"+d)+(f?b+N(a-c).toFixed(f).slice(2):\"\")};xb={init:function(a,b,c){var b=b||\"\",d=a.shift,e=b.indexOf(\"C\")>-1,f=e?7:3,g,b=b.split(\" \"),\nc=[].concat(c),h,i,j=function(a){for(g=a.length;g--;)a[g]===\"M\"&&a.splice(g+1,0,a[g+1],a[g+2],a[g+1],a[g+2])};e&&(j(b),j(c));a.isArea&&(h=b.splice(b.length-6,6),i=c.splice(c.length-6,6));if(d<=c.length/f&&b.length===c.length)for(;d--;)c=[].concat(c).splice(0,f).concat(c);a.shift=0;if(b.length)for(a=c.length;b.length<a;)d=[].concat(b).splice(b.length-f,f),e&&(d[f-6]=d[f-2],d[f-5]=d[f-1]),b=b.concat(d);h&&(b=b.concat(h),c=c.concat(i));return[b,c]},step:function(a,b,c,d){var e=[],f=a.length;if(c===1)e=\nd;else if(f===b.length&&c<1)for(;f--;)d=parseFloat(a[f]),e[f]=isNaN(d)?a[f]:c*parseFloat(b[f]-d)+d;else e=b;return e}};(function(a){K.HighchartsAdapter=K.HighchartsAdapter||a&&{init:function(b){var c=a.fx;a.extend(a.easing,{easeOutQuad:function(a,b,c,g,h){return-g*(b/=h)*(b-2)+c}});a.each([\"cur\",\"_default\",\"width\",\"height\",\"opacity\"],function(b,e){var f=c.step,g;e===\"cur\"?f=c.prototype:e===\"_default\"&&a.Tween&&(f=a.Tween.propHooks[e],e=\"set\");(g=f[e])&&(f[e]=function(a){var c,a=b?a:this;if(a.prop!==\n\"align\")return c=a.elem,c.attr?c.attr(a.prop,e===\"cur\"?v:a.now):g.apply(this,arguments)})});Sa(a.cssHooks.opacity,\"get\",function(a,b,c){return b.attr?b.opacity||0:a.call(this,b,c)});this.addAnimSetter(\"d\",function(a){var c=a.elem,f;if(!a.started)f=b.init(c,c.d,c.toD),a.start=f[0],a.end=f[1],a.started=!0;c.attr(\"d\",b.step(a.start,a.end,a.pos,c.toD))});this.each=Array.prototype.forEach?function(a,b){return Array.prototype.forEach.call(a,b)}:function(a,b){var c,g=a.length;for(c=0;c<g;c++)if(b.call(a[c],\na[c],c,a)===!1)return c};a.fn.highcharts=function(){var a=\"Chart\",b=arguments,c,g;if(this[0]){Aa(b[0])&&(a=b[0],b=Array.prototype.slice.call(b,1));c=b[0];if(c!==v)c.chart=c.chart||{},c.chart.renderTo=this[0],new B[a](c,b[1]),g=this;c===v&&(g=Y[J(this[0],\"data-highcharts-chart\")])}return g}},addAnimSetter:function(b,c){a.Tween?a.Tween.propHooks[b]={set:c}:a.fx.step[b]=c},getScript:a.getScript,inArray:a.inArray,adapterRun:function(b,c){return a(b)[c]()},grep:a.grep,map:function(a,c){for(var d=[],e=\n0,f=a.length;e<f;e++)d[e]=c.call(a[e],a[e],e,a);return d},offset:function(b){return a(b).offset()},addEvent:function(b,c,d){a(b).bind(c,d)},removeEvent:function(b,c,d){var e=C.removeEventListener?\"removeEventListener\":\"detachEvent\";C[e]&&b&&!b[e]&&(b[e]=function(){});a(b).unbind(c,d)},fireEvent:function(b,c,d,e){var f=a.Event(c),g=\"detached\"+c,h;!xa&&d&&(delete d.layerX,delete d.layerY,delete d.returnValue);r(f,d);b[c]&&(b[g]=b[c],b[c]=null);a.each([\"preventDefault\",\"stopPropagation\"],function(a,\nb){var c=f[b];f[b]=function(){try{c.call(f)}catch(a){b===\"preventDefault\"&&(h=!0)}}});a(b).trigger(f);b[g]&&(b[c]=b[g],b[g]=null);e&&!f.isDefaultPrevented()&&!h&&e(f)},washMouseEvent:function(a){var c=a.originalEvent||a;if(c.pageX===v)c.pageX=a.pageX,c.pageY=a.pageY;return c},animate:function(b,c,d){var e=a(b);if(!b.style)b.style={};if(c.d)b.toD=c.d,c.d=1;e.stop();c.opacity!==v&&b.attr&&(c.opacity+=\"px\");b.hasAnim=1;e.animate(c,d)},stop:function(b){b.hasAnim&&a(b).stop()}}})(K.jQuery);var U=K.HighchartsAdapter,\nD=U||{};U&&U.init.call(U,xb);var hb=D.adapterRun,Qb=D.getScript,Ka=D.inArray,o=B.each=D.each,ib=D.grep,Rb=D.offset,Ta=D.map,H=D.addEvent,Z=D.removeEvent,I=D.fireEvent,Sb=D.washMouseEvent,jb=D.animate,kb=D.stop;S={colors:\"#7cb5ec,#434348,#90ed7d,#f7a35c,#8085e9,#f15c80,#e4d354,#2b908f,#f45b5b,#91e8e1\".split(\",\"),symbols:[\"circle\",\"diamond\",\"square\",\"triangle\",\"triangle-down\"],lang:{loading:\"Loading...\",months:\"January,February,March,April,May,June,July,August,September,October,November,December\".split(\",\"),\nshortMonths:\"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\".split(\",\"),weekdays:\"Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday\".split(\",\"),decimalPoint:\".\",numericSymbols:\"k,M,G,T,P,E\".split(\",\"),resetZoom:\"Reset zoom\",resetZoomTitle:\"Reset zoom level 1:1\",thousandsSep:\" \"},global:{useUTC:!0,canvasToolsURL:\"http://code.highcharts.com/4.1.8/modules/canvas-tools.js\",VMLRadialGradientURL:\"http://code.highcharts.com/4.1.8/gfx/vml-radial-gradient.png\"},chart:{borderColor:\"#4572A7\",borderRadius:0,\ndefaultSeriesType:\"line\",ignoreHiddenSeries:!0,spacing:[10,10,15,10],backgroundColor:\"#FFFFFF\",plotBorderColor:\"#C0C0C0\",resetZoomButton:{theme:{zIndex:20},position:{align:\"right\",x:-10,y:10}}},title:{text:\"Chart title\",align:\"center\",margin:15,style:{color:\"#333333\",fontSize:\"18px\"}},subtitle:{text:\"\",align:\"center\",style:{color:\"#555555\"}},plotOptions:{line:{allowPointSelect:!1,showCheckbox:!1,animation:{duration:1E3},events:{},lineWidth:2,marker:{lineWidth:0,radius:4,lineColor:\"#FFFFFF\",states:{hover:{enabled:!0,\nlineWidthPlus:1,radiusPlus:2},select:{fillColor:\"#FFFFFF\",lineColor:\"#000000\",lineWidth:2}}},point:{events:{}},dataLabels:{align:\"center\",formatter:function(){return this.y===null?\"\":B.numberFormat(this.y,-1)},style:{color:\"contrast\",fontSize:\"11px\",fontWeight:\"bold\",textShadow:\"0 0 6px contrast, 0 0 3px contrast\"},verticalAlign:\"bottom\",x:0,y:0,padding:5},cropThreshold:300,pointRange:0,states:{hover:{lineWidthPlus:1,marker:{},halo:{size:10,opacity:0.25}},select:{marker:{}}},stickyTracking:!0,turboThreshold:1E3}},\nlabels:{style:{position:\"absolute\",color:\"#3E576F\"}},legend:{enabled:!0,align:\"center\",layout:\"horizontal\",labelFormatter:function(){return this.name},borderColor:\"#909090\",borderRadius:0,navigation:{activeColor:\"#274b6d\",inactiveColor:\"#CCC\"},shadow:!1,itemStyle:{color:\"#333333\",fontSize:\"12px\",fontWeight:\"bold\"},itemHoverStyle:{color:\"#000\"},itemHiddenStyle:{color:\"#CCC\"},itemCheckboxStyle:{position:\"absolute\",width:\"13px\",height:\"13px\"},symbolPadding:5,verticalAlign:\"bottom\",x:0,y:0,title:{style:{fontWeight:\"bold\"}}},\nloading:{labelStyle:{fontWeight:\"bold\",position:\"relative\",top:\"45%\"},style:{position:\"absolute\",backgroundColor:\"white\",opacity:0.5,textAlign:\"center\"}},tooltip:{enabled:!0,animation:ca,backgroundColor:\"rgba(249, 249, 249, .85)\",borderWidth:1,borderRadius:3,dateTimeLabelFormats:{millisecond:\"%A, %b %e, %H:%M:%S.%L\",second:\"%A, %b %e, %H:%M:%S\",minute:\"%A, %b %e, %H:%M\",hour:\"%A, %b %e, %H:%M\",day:\"%A, %b %e, %Y\",week:\"Week from %A, %b %e, %Y\",month:\"%B %Y\",year:\"%Y\"},footerFormat:\"\",headerFormat:'<span style=\"font-size: 10px\">{point.key}</span><br/>',\npointFormat:'<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',shadow:!0,snap:Jb?25:10,style:{color:\"#333333\",cursor:\"default\",fontSize:\"12px\",padding:\"8px\",whiteSpace:\"nowrap\"}},credits:{enabled:!0,text:\"Highcharts.com\",href:\"http://www.highcharts.com\",position:{align:\"right\",x:-10,verticalAlign:\"bottom\",y:-5},style:{cursor:\"pointer\",color:\"#909090\",fontSize:\"9px\"}}};var ba=S.plotOptions,U=ba.line;Cb();var Tb=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\nUb=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,Vb=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,na=function(a){var b=[],c,d;(function(a){a&&a.stops?d=Ta(a.stops,function(a){return na(a[1])}):(c=Tb.exec(a))?b=[F(c[1]),F(c[2]),F(c[3]),parseFloat(c[4],10)]:(c=Ub.exec(a))?b=[F(c[1],16),F(c[2],16),F(c[3],16),1]:(c=Vb.exec(a))&&(b=[F(c[1]),F(c[2]),F(c[3]),1])})(a);return{get:function(c){var f;d?(f=A(a),f.stops=[].concat(f.stops),o(d,function(a,b){f.stops[b]=[f.stops[b][0],a.get(c)]})):\nf=b&&!isNaN(b[0])?c===\"rgb\"?\"rgb(\"+b[0]+\",\"+b[1]+\",\"+b[2]+\")\":c===\"a\"?b[3]:\"rgba(\"+b.join(\",\")+\")\":a;return f},brighten:function(a){if(d)o(d,function(b){b.brighten(a)});else if(qa(a)&&a!==0){var c;for(c=0;c<3;c++)b[c]+=F(a*255),b[c]<0&&(b[c]=0),b[c]>255&&(b[c]=255)}return this},rgba:b,setOpacity:function(a){b[3]=a;return this},raw:a}};P.prototype={opacity:1,textProps:\"fontSize,fontWeight,fontFamily,fontStyle,color,lineHeight,width,textDecoration,textOverflow,textShadow\".split(\",\"),init:function(a,\nb){this.element=b===\"span\"?$(b):C.createElementNS(Da,b);this.renderer=a},animate:function(a,b,c){b=p(b,this.renderer.globalAnimation,!0);kb(this);if(b){b=A(b,{});if(c)b.complete=c;jb(this,a,b)}else this.attr(a,null,c);return this},colorGradient:function(a,b,c){var d=this.renderer,e,f,g,h,i,j,k,m,l,n,q=[];a.linearGradient?f=\"linearGradient\":a.radialGradient&&(f=\"radialGradient\");if(f){g=a[f];h=d.gradients;j=a.stops;l=c.radialReference;Fa(g)&&(a[f]=g={x1:g[0],y1:g[1],x2:g[2],y2:g[3],gradientUnits:\"userSpaceOnUse\"});\nf===\"radialGradient\"&&l&&!s(g.gradientUnits)&&(g=A(g,{cx:l[0]-l[2]/2+g.cx*l[2],cy:l[1]-l[2]/2+g.cy*l[2],r:g.r*l[2],gradientUnits:\"userSpaceOnUse\"}));for(n in g)n!==\"id\"&&q.push(n,g[n]);for(n in j)q.push(j[n]);q=q.join(\",\");h[q]?a=h[q].attr(\"id\"):(g.id=a=\"highcharts-\"+wb++,h[q]=i=d.createElement(f).attr(g).add(d.defs),i.stops=[],o(j,function(a){a[1].indexOf(\"rgba\")===0?(e=na(a[1]),k=e.get(\"rgb\"),m=e.get(\"a\")):(k=a[1],m=1);a=d.createElement(\"stop\").attr({offset:a[0],\"stop-color\":k,\"stop-opacity\":m}).add(i);\ni.stops.push(a)}));c.setAttribute(b,\"url(\"+d.url+\"#\"+a+\")\")}},applyTextShadow:function(a){var b=this.element,c,d=a.indexOf(\"contrast\")!==-1,e={},f=this.renderer.forExport||b.style.textShadow!==v&&!xa;if(d)e.textShadow=a=a.replace(/contrast/g,this.renderer.getContrast(b.style.fill));if(fb)e.textRendering=\"geometricPrecision\";f?L(b,e):(this.fakeTS=!0,this.ySetter=this.xSetter,c=[].slice.call(b.getElementsByTagName(\"tspan\")),o(a.split(/\\s?,\\s?/g),function(a){var d=b.firstChild,e,f,a=a.split(\" \");e=a[a.length-\n1];(f=a[a.length-2])&&o(c,function(a,c){var g;c===0&&(a.setAttribute(\"x\",b.getAttribute(\"x\")),c=b.getAttribute(\"y\"),a.setAttribute(\"y\",c||0),c===null&&b.setAttribute(\"y\",0));g=a.cloneNode(1);J(g,{\"class\":\"highcharts-text-shadow\",fill:e,stroke:e,\"stroke-opacity\":1/t(F(f),3),\"stroke-width\":f,\"stroke-linejoin\":\"round\"});b.insertBefore(g,d)})}))},attr:function(a,b,c){var d,e=this.element,f,g=this,h;typeof a===\"string\"&&b!==v&&(d=a,a={},a[d]=b);if(typeof a===\"string\")g=(this[a+\"Getter\"]||this._defaultGetter).call(this,\na,e);else{for(d in a){b=a[d];h=!1;this.symbolName&&/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(d)&&(f||(this.symbolAttr(a),f=!0),h=!0);if(this.rotation&&(d===\"x\"||d===\"y\"))this.doTransform=!0;h||(this[d+\"Setter\"]||this._defaultSetter).call(this,b,d,e);this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d)&&this.updateShadows(d,b)}if(this.doTransform)this.updateTransform(),this.doTransform=!1}c&&c();return g},updateShadows:function(a,b){for(var c=this.shadows,\nd=c.length;d--;)c[d].setAttribute(a,a===\"height\"?t(b-(c[d].cutHeight||0),0):a===\"d\"?this.d:b)},addClass:function(a){var b=this.element,c=J(b,\"class\")||\"\";c.indexOf(a)===-1&&J(b,\"class\",c+\" \"+a);return this},symbolAttr:function(a){var b=this;o(\"x,y,r,start,end,width,height,innerR,anchorX,anchorY\".split(\",\"),function(c){b[c]=p(a[c],b[c])});b.attr({d:b.renderer.symbols[b.symbolName](b.x,b.y,b.width,b.height,b)})},clip:function(a){return this.attr(\"clip-path\",a?\"url(\"+this.renderer.url+\"#\"+a.id+\")\":O)},\ncrisp:function(a){var b,c={},d,e=a.strokeWidth||this.strokeWidth||0;d=w(e)%2/2;a.x=V(a.x||this.x||0)+d;a.y=V(a.y||this.y||0)+d;a.width=V((a.width||this.width||0)-2*d);a.height=V((a.height||this.height||0)-2*d);a.strokeWidth=e;for(b in a)this[b]!==a[b]&&(this[b]=c[b]=a[b]);return c},css:function(a){var b=this.styles,c={},d=this.element,e,f,g=\"\";e=!b;if(a&&a.color)a.fill=a.color;if(b)for(f in a)a[f]!==b[f]&&(c[f]=a[f],e=!0);if(e){e=this.textWidth=a&&a.width&&d.nodeName.toLowerCase()===\"text\"&&F(a.width)||\nthis.textWidth;b&&(a=r(b,c));this.styles=a;e&&(fa||!ca&&this.renderer.forExport)&&delete a.width;if(xa&&!ca)L(this.element,a);else{b=function(a,b){return\"-\"+b.toLowerCase()};for(f in a)g+=f.replace(/([A-Z])/g,b)+\":\"+a[f]+\";\";J(d,\"style\",g)}e&&this.added&&this.renderer.buildText(this)}return this},on:function(a,b){var c=this,d=c.element;$a&&a===\"click\"?(d.ontouchstart=function(a){c.touchEventFired=ya.now();a.preventDefault();b.call(d,a)},d.onclick=function(a){(za.indexOf(\"Android\")===-1||ya.now()-\n(c.touchEventFired||0)>1100)&&b.call(d,a)}):d[\"on\"+a]=b;return this},setRadialReference:function(a){this.element.radialReference=a;return this},translate:function(a,b){return this.attr({translateX:a,translateY:b})},invert:function(){this.inverted=!0;this.updateTransform();return this},updateTransform:function(){var a=this.translateX||0,b=this.translateY||0,c=this.scaleX,d=this.scaleY,e=this.inverted,f=this.rotation,g=this.element;e&&(a+=this.attr(\"width\"),b+=this.attr(\"height\"));a=[\"translate(\"+a+\n\",\"+b+\")\"];e?a.push(\"rotate(90) scale(-1,1)\"):f&&a.push(\"rotate(\"+f+\" \"+(g.getAttribute(\"x\")||0)+\" \"+(g.getAttribute(\"y\")||0)+\")\");(s(c)||s(d))&&a.push(\"scale(\"+p(c,1)+\" \"+p(d,1)+\")\");a.length&&g.setAttribute(\"transform\",a.join(\" \"))},toFront:function(){var a=this.element;a.parentNode.appendChild(a);return this},align:function(a,b,c){var d,e,f,g,h={};e=this.renderer;f=e.alignedObjects;if(a){if(this.alignOptions=a,this.alignByTranslate=b,!c||Aa(c))this.alignTo=d=c||\"renderer\",ja(f,this),f.push(this),\nc=null}else a=this.alignOptions,b=this.alignByTranslate,d=this.alignTo;c=p(c,e[d],e);d=a.align;e=a.verticalAlign;f=(c.x||0)+(a.x||0);g=(c.y||0)+(a.y||0);if(d===\"right\"||d===\"center\")f+=(c.width-(a.width||0))/{right:1,center:2}[d];h[b?\"translateX\":\"x\"]=w(f);if(e===\"bottom\"||e===\"middle\")g+=(c.height-(a.height||0))/({bottom:1,middle:2}[e]||1);h[b?\"translateY\":\"y\"]=w(g);this[this.placed?\"animate\":\"attr\"](h);this.placed=!0;this.alignAttr=h;return this},getBBox:function(a){var b,c=this.renderer,d,e=this.rotation,\nf=this.element,g=this.styles,h=e*ga;d=this.textStr;var i,j=f.style,k,m;d!==v&&(m=[\"\",e||0,g&&g.fontSize,f.style.width].join(\",\"),m=d===\"\"||Ob.test(d)?\"num:\"+d.toString().length+m:d+m);m&&!a&&(b=c.cache[m]);if(!b){if(f.namespaceURI===Da||c.forExport){try{k=this.fakeTS&&function(a){o(f.querySelectorAll(\".highcharts-text-shadow\"),function(b){b.style.display=a})},Ja&&j.textShadow?(i=j.textShadow,j.textShadow=\"\"):k&&k(O),b=f.getBBox?r({},f.getBBox()):{width:f.offsetWidth,height:f.offsetHeight},i?j.textShadow=\ni:k&&k(\"\")}catch(l){}if(!b||b.width<0)b={width:0,height:0}}else b=this.htmlGetBBox();if(c.isSVG){a=b.width;d=b.height;if(xa&&g&&g.fontSize===\"11px\"&&d.toPrecision(3)===\"16.9\")b.height=d=14;if(e)b.width=N(d*aa(h))+N(a*X(h)),b.height=N(d*X(h))+N(a*aa(h))}m&&(c.cache[m]=b)}return b},show:function(a){return this.attr({visibility:a?\"inherit\":\"visible\"})},hide:function(){return this.attr({visibility:\"hidden\"})},fadeOut:function(a){var b=this;b.animate({opacity:0},{duration:a||150,complete:function(){b.attr({y:-9999})}})},\nadd:function(a){var b=this.renderer,c=this.element,d;if(a)this.parentGroup=a;this.parentInverted=a&&a.inverted;this.textStr!==void 0&&b.buildText(this);this.added=!0;if(!a||a.handleZ||this.zIndex)d=this.zIndexSetter();d||(a?a.element:b.box).appendChild(c);if(this.onAdd)this.onAdd();return this},safeRemoveChild:function(a){var b=a.parentNode;b&&b.removeChild(a)},destroy:function(){var a=this,b=a.element||{},c=a.shadows,d=a.renderer.isSVG&&b.nodeName===\"SPAN\"&&a.parentGroup,e,f;b.onclick=b.onmouseout=\nb.onmouseover=b.onmousemove=b.point=null;kb(a);if(a.clipPath)a.clipPath=a.clipPath.destroy();if(a.stops){for(f=0;f<a.stops.length;f++)a.stops[f]=a.stops[f].destroy();a.stops=null}a.safeRemoveChild(b);for(c&&o(c,function(b){a.safeRemoveChild(b)});d&&d.div&&d.div.childNodes.length===0;)b=d.parentGroup,a.safeRemoveChild(d.div),delete d.div,d=b;a.alignTo&&ja(a.renderer.alignedObjects,a);for(e in a)delete a[e];return null},shadow:function(a,b,c){var d=[],e,f,g=this.element,h,i,j,k;if(a){i=p(a.width,3);\nj=(a.opacity||0.15)/i;k=this.parentInverted?\"(-1,-1)\":\"(\"+p(a.offsetX,1)+\", \"+p(a.offsetY,1)+\")\";for(e=1;e<=i;e++){f=g.cloneNode(0);h=i*2+1-2*e;J(f,{isShadow:\"true\",stroke:a.color||\"black\",\"stroke-opacity\":j*e,\"stroke-width\":h,transform:\"translate\"+k,fill:O});if(c)J(f,\"height\",t(J(f,\"height\")-h,0)),f.cutHeight=h;b?b.element.appendChild(f):g.parentNode.insertBefore(f,g);d.push(f)}this.shadows=d}return this},xGetter:function(a){this.element.nodeName===\"circle\"&&(a={x:\"cx\",y:\"cy\"}[a]||a);return this._defaultGetter(a)},\n_defaultGetter:function(a){a=p(this[a],this.element?this.element.getAttribute(a):null,0);/^[\\-0-9\\.]+$/.test(a)&&(a=parseFloat(a));return a},dSetter:function(a,b,c){a&&a.join&&(a=a.join(\" \"));/(NaN| {2}|^$)/.test(a)&&(a=\"M 0 0\");c.setAttribute(b,a);this[b]=a},dashstyleSetter:function(a){var b;if(a=a&&a.toLowerCase()){a=a.replace(\"shortdashdotdot\",\"3,1,1,1,1,1,\").replace(\"shortdashdot\",\"3,1,1,1\").replace(\"shortdot\",\"1,1,\").replace(\"shortdash\",\"3,1,\").replace(\"longdash\",\"8,3,\").replace(/dot/g,\"1,3,\").replace(\"dash\",\n\"4,3,\").replace(/,$/,\"\").split(\",\");for(b=a.length;b--;)a[b]=F(a[b])*this[\"stroke-width\"];a=a.join(\",\").replace(\"NaN\",\"none\");this.element.setAttribute(\"stroke-dasharray\",a)}},alignSetter:function(a){this.element.setAttribute(\"text-anchor\",{left:\"start\",center:\"middle\",right:\"end\"}[a])},opacitySetter:function(a,b,c){this[b]=a;c.setAttribute(b,a)},titleSetter:function(a){var b=this.element.getElementsByTagName(\"title\")[0];b||(b=C.createElementNS(Da,\"title\"),this.element.appendChild(b));b.appendChild(C.createTextNode(String(p(a),\n\"\").replace(/<[^>]*>/g,\"\")))},textSetter:function(a){if(a!==this.textStr)delete this.bBox,this.textStr=a,this.added&&this.renderer.buildText(this)},fillSetter:function(a,b,c){typeof a===\"string\"?c.setAttribute(b,a):a&&this.colorGradient(a,b,c)},visibilitySetter:function(a,b,c){a===\"inherit\"?c.removeAttribute(b):c.setAttribute(b,a)},zIndexSetter:function(a,b){var c=this.renderer,d=this.parentGroup,c=(d||c).element||c.box,e,f,g=this.element,h;e=this.added;var i;s(a)&&(g.setAttribute(b,a),a=+a,this[b]===\na&&(e=!1),this[b]=a);if(e){if((a=this.zIndex)&&d)d.handleZ=!0;d=c.childNodes;for(i=0;i<d.length&&!h;i++)if(e=d[i],f=J(e,\"zIndex\"),e!==g&&(F(f)>a||!s(a)&&s(f)))c.insertBefore(g,e),h=!0;h||c.appendChild(g)}return h},_defaultSetter:function(a,b,c){c.setAttribute(b,a)}};P.prototype.yGetter=P.prototype.xGetter;P.prototype.translateXSetter=P.prototype.translateYSetter=P.prototype.rotationSetter=P.prototype.verticalAlignSetter=P.prototype.scaleXSetter=P.prototype.scaleYSetter=function(a,b){this[b]=a;this.doTransform=\n!0};P.prototype[\"stroke-widthSetter\"]=P.prototype.strokeSetter=function(a,b,c){this[b]=a;if(this.stroke&&this[\"stroke-width\"])this.strokeWidth=this[\"stroke-width\"],P.prototype.fillSetter.call(this,this.stroke,\"stroke\",c),c.setAttribute(\"stroke-width\",this[\"stroke-width\"]),this.hasStroke=!0;else if(b===\"stroke-width\"&&a===0&&this.hasStroke)c.removeAttribute(\"stroke\"),this.hasStroke=!1};var ua=function(){this.init.apply(this,arguments)};ua.prototype={Element:P,init:function(a,b,c,d,e){var f=location,\ng,d=this.createElement(\"svg\").attr({version:\"1.1\"}).css(this.getStyle(d));g=d.element;a.appendChild(g);a.innerHTML.indexOf(\"xmlns\")===-1&&J(g,\"xmlns\",Da);this.isSVG=!0;this.box=g;this.boxWrapper=d;this.alignedObjects=[];this.url=(Ja||fb)&&C.getElementsByTagName(\"base\").length?f.href.replace(/#.*?$/,\"\").replace(/([\\('\\)])/g,\"\\\\$1\").replace(/ /g,\"%20\"):\"\";this.createElement(\"desc\").add().element.appendChild(C.createTextNode(\"Created with Highcharts 4.1.8\"));this.defs=this.createElement(\"defs\").add();\nthis.forExport=e;this.gradients={};this.cache={};this.setSize(b,c,!1);var h;if(Ja&&a.getBoundingClientRect)this.subPixelFix=b=function(){L(a,{left:0,top:0});h=a.getBoundingClientRect();L(a,{left:sa(h.left)-h.left+\"px\",top:sa(h.top)-h.top+\"px\"})},b(),H(K,\"resize\",b)},getStyle:function(a){return this.style=r({fontFamily:'\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',fontSize:\"12px\"},a)},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=this.defs;\nthis.box=null;this.boxWrapper=this.boxWrapper.destroy();Oa(this.gradients||{});this.gradients=null;if(a)this.defs=a.destroy();this.subPixelFix&&Z(K,\"resize\",this.subPixelFix);return this.alignedObjects=null},createElement:function(a){var b=new this.Element;b.init(this,a);return b},draw:function(){},buildText:function(a){for(var b=a.element,c=this,d=c.forExport,e=p(a.textStr,\"\").toString(),f=e.indexOf(\"<\")!==-1,g=b.childNodes,h,i,j=J(b,\"x\"),k=a.styles,m=a.textWidth,l=k&&k.lineHeight,n=k&&k.textShadow,\nq=k&&k.textOverflow===\"ellipsis\",x=g.length,T=m&&!a.added&&this.box,Q=function(a){return l?F(l):c.fontMetrics(/(px|em)$/.test(a&&a.style.fontSize)?a.style.fontSize:k&&k.fontSize||c.style.fontSize||12,a).h},u=function(a){return a.replace(/&lt;/g,\"<\").replace(/&gt;/g,\">\")};x--;)b.removeChild(g[x]);!f&&!n&&!q&&e.indexOf(\" \")===-1?b.appendChild(C.createTextNode(u(e))):(h=/<.*style=\"([^\"]+)\".*>/,i=/<.*href=\"(http[^\"]+)\".*>/,T&&T.appendChild(b),e=f?e.replace(/<(b|strong)>/g,'<span style=\"font-weight:bold\">').replace(/<(i|em)>/g,\n'<span style=\"font-style:italic\">').replace(/<a/g,\"<span\").replace(/<\\/(b|strong|i|em|a)>/g,\"</span>\").split(/<br.*?>/g):[e],e[e.length-1]===\"\"&&e.pop(),o(e,function(e,f){var g,l=0,e=e.replace(/<span/g,\"|||<span\").replace(/<\\/span>/g,\"</span>|||\");g=e.split(\"|||\");o(g,function(e){if(e!==\"\"||g.length===1){var n={},x=C.createElementNS(Da,\"tspan\"),p;h.test(e)&&(p=e.match(h)[1].replace(/(;| |^)color([ :])/,\"$1fill$2\"),J(x,\"style\",p));i.test(e)&&!d&&(J(x,\"onclick\",'location.href=\"'+e.match(i)[1]+'\"'),\nL(x,{cursor:\"pointer\"}));e=u(e.replace(/<(.|\\n)*?>/g,\"\")||\" \");if(e!==\" \"){x.appendChild(C.createTextNode(e));if(l)n.dx=0;else if(f&&j!==null)n.x=j;J(x,n);b.appendChild(x);!l&&f&&(!ca&&d&&L(x,{display:\"block\"}),J(x,\"dy\",Q(x)));if(m){for(var n=e.replace(/([^\\^])-/g,\"$1- \").split(\" \"),o=g.length>1||f||n.length>1&&k.whiteSpace!==\"nowrap\",T,y,s,t=[],v=Q(x),w=1,r=a.rotation,z=e,A=z.length;(o||q)&&(n.length||t.length);)a.rotation=0,T=a.getBBox(!0),s=T.width,!ca&&c.forExport&&(s=c.measureSpanWidth(x.firstChild.data,\na.styles)),T=s>m,y===void 0&&(y=T),q&&y?(A/=2,z===\"\"||!T&&A<0.5?n=[]:(T&&(y=!0),z=e.substring(0,z.length+(T?-1:1)*sa(A)),n=[z+(m>3?\"\\u2026\":\"\")],x.removeChild(x.firstChild))):!T||n.length===1?(n=t,t=[],n.length&&(w++,x=C.createElementNS(Da,\"tspan\"),J(x,{dy:v,x:j}),p&&J(x,\"style\",p),b.appendChild(x)),s>m&&(m=s)):(x.removeChild(x.firstChild),t.unshift(n.pop())),n.length&&x.appendChild(C.createTextNode(n.join(\" \").replace(/- /g,\"-\")));y&&a.attr(\"title\",a.textStr);a.rotation=r}l++}}})}),T&&T.removeChild(b),\nn&&a.applyTextShadow&&a.applyTextShadow(n))},getContrast:function(a){a=na(a).rgba;return a[0]+a[1]+a[2]>384?\"#000000\":\"#FFFFFF\"},button:function(a,b,c,d,e,f,g,h,i){var j=this.label(a,b,c,i,null,null,null,null,\"button\"),k=0,m,l,n,q,x,p,a={x1:0,y1:0,x2:0,y2:1},e=A({\"stroke-width\":1,stroke:\"#CCCCCC\",fill:{linearGradient:a,stops:[[0,\"#FEFEFE\"],[1,\"#F6F6F6\"]]},r:2,padding:5,style:{color:\"black\"}},e);n=e.style;delete e.style;f=A(e,{stroke:\"#68A\",fill:{linearGradient:a,stops:[[0,\"#FFF\"],[1,\"#ACF\"]]}},f);\nq=f.style;delete f.style;g=A(e,{stroke:\"#68A\",fill:{linearGradient:a,stops:[[0,\"#9BD\"],[1,\"#CDF\"]]}},g);x=g.style;delete g.style;h=A(e,{style:{color:\"#CCC\"}},h);p=h.style;delete h.style;H(j.element,xa?\"mouseover\":\"mouseenter\",function(){k!==3&&j.attr(f).css(q)});H(j.element,xa?\"mouseout\":\"mouseleave\",function(){k!==3&&(m=[e,f,g][k],l=[n,q,x][k],j.attr(m).css(l))});j.setState=function(a){(j.state=k=a)?a===2?j.attr(g).css(x):a===3&&j.attr(h).css(p):j.attr(e).css(n)};return j.on(\"click\",function(a){k!==\n3&&d.call(j,a)}).attr(e).css(r({cursor:\"default\"},n))},crispLine:function(a,b){a[1]===a[4]&&(a[1]=a[4]=w(a[1])-b%2/2);a[2]===a[5]&&(a[2]=a[5]=w(a[2])+b%2/2);return a},path:function(a){var b={fill:O};Fa(a)?b.d=a:da(a)&&r(b,a);return this.createElement(\"path\").attr(b)},circle:function(a,b,c){a=da(a)?a:{x:a,y:b,r:c};b=this.createElement(\"circle\");b.xSetter=function(a){this.element.setAttribute(\"cx\",a)};b.ySetter=function(a){this.element.setAttribute(\"cy\",a)};return b.attr(a)},arc:function(a,b,c,d,e,\nf){if(da(a))b=a.y,c=a.r,d=a.innerR,e=a.start,f=a.end,a=a.x;a=this.symbol(\"arc\",a||0,b||0,c||0,c||0,{innerR:d||0,start:e||0,end:f||0});a.r=c;return a},rect:function(a,b,c,d,e,f){var e=da(a)?a.r:e,g=this.createElement(\"rect\"),a=da(a)?a:a===v?{}:{x:a,y:b,width:t(c,0),height:t(d,0)};if(f!==v)a.strokeWidth=f,a=g.crisp(a);if(e)a.r=e;g.rSetter=function(a){J(this.element,{rx:a,ry:a})};return g.attr(a)},setSize:function(a,b,c){var d=this.alignedObjects,e=d.length;this.width=a;this.height=b;for(this.boxWrapper[p(c,\n!0)?\"animate\":\"attr\"]({width:a,height:b});e--;)d[e].align()},g:function(a){var b=this.createElement(\"g\");return s(a)?b.attr({\"class\":\"highcharts-\"+a}):b},image:function(a,b,c,d,e){var f={preserveAspectRatio:O};arguments.length>1&&r(f,{x:b,y:c,width:d,height:e});f=this.createElement(\"image\").attr(f);f.element.setAttributeNS?f.element.setAttributeNS(\"http://www.w3.org/1999/xlink\",\"href\",a):f.element.setAttribute(\"hc-svg-href\",a);return f},symbol:function(a,b,c,d,e,f){var g,h=this.symbols[a],h=h&&h(w(b),\nw(c),d,e,f),i=/^url\\((.*?)\\)$/,j,k;if(h)g=this.path(h),r(g,{symbolName:a,x:b,y:c,width:d,height:e}),f&&r(g,f);else if(i.test(a))k=function(a,b){a.element&&(a.attr({width:b[0],height:b[1]}),a.alignByTranslate||a.translate(w((d-b[0])/2),w((e-b[1])/2)))},j=a.match(i)[1],a=Kb[j]||f&&f.width&&f.height&&[f.width,f.height],g=this.image(j).attr({x:b,y:c}),g.isImg=!0,a?k(g,a):(g.attr({width:0,height:0}),$(\"img\",{onload:function(){k(g,Kb[j]=[this.width,this.height])},src:j}));return g},symbols:{circle:function(a,\nb,c,d){var e=0.166*c;return[\"M\",a+c/2,b,\"C\",a+c+e,b,a+c+e,b+d,a+c/2,b+d,\"C\",a-e,b+d,a-e,b,a+c/2,b,\"Z\"]},square:function(a,b,c,d){return[\"M\",a,b,\"L\",a+c,b,a+c,b+d,a,b+d,\"Z\"]},triangle:function(a,b,c,d){return[\"M\",a+c/2,b,\"L\",a+c,b+d,a,b+d,\"Z\"]},\"triangle-down\":function(a,b,c,d){return[\"M\",a,b,\"L\",a+c,b,a+c/2,b+d,\"Z\"]},diamond:function(a,b,c,d){return[\"M\",a+c/2,b,\"L\",a+c,b+d/2,a+c/2,b+d,a,b+d/2,\"Z\"]},arc:function(a,b,c,d,e){var f=e.start,c=e.r||c||d,g=e.end-0.001,d=e.innerR,h=e.open,i=X(f),j=aa(f),\nk=X(g),g=aa(g),e=e.end-f<ma?0:1;return[\"M\",a+c*i,b+c*j,\"A\",c,c,0,e,1,a+c*k,b+c*g,h?\"M\":\"L\",a+d*k,b+d*g,\"A\",d,d,0,e,0,a+d*i,b+d*j,h?\"\":\"Z\"]},callout:function(a,b,c,d,e){var f=z(e&&e.r||0,c,d),g=f+6,h=e&&e.anchorX,e=e&&e.anchorY,i;i=[\"M\",a+f,b,\"L\",a+c-f,b,\"C\",a+c,b,a+c,b,a+c,b+f,\"L\",a+c,b+d-f,\"C\",a+c,b+d,a+c,b+d,a+c-f,b+d,\"L\",a+f,b+d,\"C\",a,b+d,a,b+d,a,b+d-f,\"L\",a,b+f,\"C\",a,b,a,b,a+f,b];h&&h>c&&e>b+g&&e<b+d-g?i.splice(13,3,\"L\",a+c,e-6,a+c+6,e,a+c,e+6,a+c,b+d-f):h&&h<0&&e>b+g&&e<b+d-g?i.splice(33,3,\"L\",\na,e+6,a-6,e,a,e-6,a,b+f):e&&e>d&&h>a+g&&h<a+c-g?i.splice(23,3,\"L\",h+6,b+d,h,b+d+6,h-6,b+d,a+f,b+d):e&&e<0&&h>a+g&&h<a+c-g&&i.splice(3,3,\"L\",h-6,b,h,b-6,h+6,b,c-f,b);return i}},clipRect:function(a,b,c,d){var e=\"highcharts-\"+wb++,f=this.createElement(\"clipPath\").attr({id:e}).add(this.defs),a=this.rect(a,b,c,d,0).add(f);a.id=e;a.clipPath=f;a.count=0;return a},text:function(a,b,c,d){var e=fa||!ca&&this.forExport,f={};if(d&&!this.forExport)return this.html(a,b,c);f.x=Math.round(b||0);if(c)f.y=Math.round(c);\nif(a||a===0)f.text=a;a=this.createElement(\"text\").attr(f);e&&a.css({position:\"absolute\"});if(!d)a.xSetter=function(a,b,c){var d=c.getElementsByTagName(\"tspan\"),e,f=c.getAttribute(b),l;for(l=0;l<d.length;l++)e=d[l],e.getAttribute(b)===f&&e.setAttribute(b,a);c.setAttribute(b,a)};return a},fontMetrics:function(a,b){var c,d,a=a||this.style.fontSize;b&&K.getComputedStyle&&(b=b.element||b,a=(c=K.getComputedStyle(b,\"\"))&&c.fontSize);a=/px/.test(a)?F(a):/em/.test(a)?parseFloat(a)*12:12;c=a<24?a+3:w(a*1.2);\nd=w(c*0.8);return{h:c,b:d,f:a}},rotCorr:function(a,b,c){var d=a;b&&c&&(d=t(d*X(b*ga),4));return{x:-a/3*aa(b*ga),y:d}},label:function(a,b,c,d,e,f,g,h,i){function j(){var a,b;a=q.element.style;p=(t===void 0||yb===void 0||n.styles.textAlign)&&s(q.textStr)&&q.getBBox();n.width=(t||p.width||0)+2*u+y;n.height=(yb||p.height||0)+2*u;B=u+l.fontMetrics(a&&a.fontSize,q).b;if(D){if(!x)a=w(-Q*u)+C,b=(h?-B:0)+C,n.box=x=d?l.symbol(d,a,b,n.width,n.height,G):l.rect(a,b,n.width,n.height,0,G[Pb]),x.isImg||x.attr(\"fill\",\nO),x.add(n);x.isImg||x.attr(r({width:w(n.width),height:w(n.height)},G));G=null}}function k(){var a=n.styles,a=a&&a.textAlign,b=y+u*(1-Q),c;c=h?0:B;if(s(t)&&p&&(a===\"center\"||a===\"right\"))b+={center:0.5,right:1}[a]*(t-p.width);if(b!==q.x||c!==q.y)q.attr(\"x\",b),c!==v&&q.attr(\"y\",c);q.x=b;q.y=c}function m(a,b){x?x.attr(a,b):G[a]=b}var l=this,n=l.g(i),q=l.text(\"\",0,0,g).attr({zIndex:1}),x,p,Q=0,u=3,y=0,t,yb,zb,z,C=0,G={},B,D;n.onAdd=function(){q.add(n);n.attr({text:a||a===0?a:\"\",x:b,y:c});x&&s(e)&&n.attr({anchorX:e,\nanchorY:f})};n.widthSetter=function(a){t=a};n.heightSetter=function(a){yb=a};n.paddingSetter=function(a){if(s(a)&&a!==u)u=n.padding=a,k()};n.paddingLeftSetter=function(a){s(a)&&a!==y&&(y=a,k())};n.alignSetter=function(a){Q={left:0,center:0.5,right:1}[a]};n.textSetter=function(a){a!==v&&q.textSetter(a);j();k()};n[\"stroke-widthSetter\"]=function(a,b){a&&(D=!0);C=a%2/2;m(b,a)};n.strokeSetter=n.fillSetter=n.rSetter=function(a,b){b===\"fill\"&&a&&(D=!0);m(b,a)};n.anchorXSetter=function(a,b){e=a;m(b,w(a)-\nC-zb)};n.anchorYSetter=function(a,b){f=a;m(b,a-z)};n.xSetter=function(a){n.x=a;Q&&(a-=Q*((t||p.width)+u));zb=w(a);n.attr(\"translateX\",zb)};n.ySetter=function(a){z=n.y=w(a);n.attr(\"translateY\",z)};var F=n.css;return r(n,{css:function(a){if(a){var b={},a=A(a);o(n.textProps,function(c){a[c]!==v&&(b[c]=a[c],delete a[c])});q.css(b)}return F.call(n,a)},getBBox:function(){return{width:p.width+2*u,height:p.height+2*u,x:p.x-u,y:p.y-u}},shadow:function(a){x&&x.shadow(a);return n},destroy:function(){Z(n.element,\n\"mouseenter\");Z(n.element,\"mouseleave\");q&&(q=q.destroy());x&&(x=x.destroy());P.prototype.destroy.call(n);n=l=j=k=m=null}})}};Za=ua;r(P.prototype,{htmlCss:function(a){var b=this.element;if(b=a&&b.tagName===\"SPAN\"&&a.width)delete a.width,this.textWidth=b,this.updateTransform();if(a&&a.textOverflow===\"ellipsis\")a.whiteSpace=\"nowrap\",a.overflow=\"hidden\";this.styles=r(this.styles,a);L(this.element,a);return this},htmlGetBBox:function(){var a=this.element;if(a.nodeName===\"text\")a.style.position=\"absolute\";\nreturn{x:a.offsetLeft,y:a.offsetTop,width:a.offsetWidth,height:a.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var a=this.renderer,b=this.element,c=this.translateX||0,d=this.translateY||0,e=this.x||0,f=this.y||0,g=this.textAlign||\"left\",h={left:0,center:0.5,right:1}[g],i=this.shadows,j=this.styles;L(b,{marginLeft:c,marginTop:d});i&&o(i,function(a){L(a,{marginLeft:c+1,marginTop:d+1})});this.inverted&&o(b.childNodes,function(c){a.invertChild(c,b)});if(b.tagName===\"SPAN\"){var k=this.rotation,\nm,l=F(this.textWidth),n=[k,g,b.innerHTML,this.textWidth,this.textAlign].join(\",\");if(n!==this.cTT){m=a.fontMetrics(b.style.fontSize).b;s(k)&&this.setSpanRotation(k,h,m);i=p(this.elemWidth,b.offsetWidth);if(i>l&&/[ \\-]/.test(b.textContent||b.innerText))L(b,{width:l+\"px\",display:\"block\",whiteSpace:j&&j.whiteSpace||\"normal\"}),i=l;this.getSpanCorrection(i,m,h,k,g)}L(b,{left:e+(this.xCorr||0)+\"px\",top:f+(this.yCorr||0)+\"px\"});if(fb)m=b.offsetHeight;this.cTT=n}}else this.alignOnAdd=!0},setSpanRotation:function(a,\nb,c){var d={},e=xa?\"-ms-transform\":fb?\"-webkit-transform\":Ja?\"MozTransform\":Ib?\"-o-transform\":\"\";d[e]=d.transform=\"rotate(\"+a+\"deg)\";d[e+(Ja?\"Origin\":\"-origin\")]=d.transformOrigin=b*100+\"% \"+c+\"px\";L(this.element,d)},getSpanCorrection:function(a,b,c){this.xCorr=-a*c;this.yCorr=-b}});r(ua.prototype,{html:function(a,b,c){var d=this.createElement(\"span\"),e=d.element,f=d.renderer;d.textSetter=function(a){a!==e.innerHTML&&delete this.bBox;e.innerHTML=this.textStr=a;d.htmlUpdateTransform()};d.xSetter=d.ySetter=\nd.alignSetter=d.rotationSetter=function(a,b){b===\"align\"&&(b=\"textAlign\");d[b]=a;d.htmlUpdateTransform()};d.attr({text:a,x:w(b),y:w(c)}).css({position:\"absolute\",fontFamily:this.style.fontFamily,fontSize:this.style.fontSize});e.style.whiteSpace=\"nowrap\";d.css=d.htmlCss;if(f.isSVG)d.add=function(a){var b,c=f.box.parentNode,j=[];if(this.parentGroup=a){if(b=a.div,!b){for(;a;)j.push(a),a=a.parentGroup;o(j.reverse(),function(a){var d,e=J(a.element,\"class\");e&&(e={className:e});b=a.div=a.div||$(Ia,e,{position:\"absolute\",\nleft:(a.translateX||0)+\"px\",top:(a.translateY||0)+\"px\"},b||c);d=b.style;r(a,{translateXSetter:function(b,c){d.left=b+\"px\";a[c]=b;a.doTransform=!0},translateYSetter:function(b,c){d.top=b+\"px\";a[c]=b;a.doTransform=!0}});Sa(a,\"visibilitySetter\",function(a,b,c,e){a.call(this,b,c,e);d[c]=b})})}}else b=c;b.appendChild(e);d.added=!0;d.alignOnAdd&&d.htmlUpdateTransform();return d};return d}});if(!ca&&!fa){D={init:function(a,b){var c=[\"<\",b,' filled=\"f\" stroked=\"f\"'],d=[\"position: \",\"absolute\",\";\"],e=b===\nIa;(b===\"shape\"||e)&&d.push(\"left:0;top:0;width:1px;height:1px;\");d.push(\"visibility: \",e?\"hidden\":\"visible\");c.push(' style=\"',d.join(\"\"),'\"/>');if(b)c=e||b===\"span\"||b===\"img\"?c.join(\"\"):a.prepVML(c),this.element=$(c);this.renderer=a},add:function(a){var b=this.renderer,c=this.element,d=b.box,d=a?a.element||a:d;a&&a.inverted&&b.invertChild(c,d);d.appendChild(c);this.added=!0;this.alignOnAdd&&!this.deferUpdateTransform&&this.updateTransform();if(this.onAdd)this.onAdd();return this},updateTransform:P.prototype.htmlUpdateTransform,\nsetSpanRotation:function(){var a=this.rotation,b=X(a*ga),c=aa(a*ga);L(this.element,{filter:a?[\"progid:DXImageTransform.Microsoft.Matrix(M11=\",b,\", M12=\",-c,\", M21=\",c,\", M22=\",b,\", sizingMethod='auto expand')\"].join(\"\"):O})},getSpanCorrection:function(a,b,c,d,e){var f=d?X(d*ga):1,g=d?aa(d*ga):0,h=p(this.elemHeight,this.element.offsetHeight),i;this.xCorr=f<0&&-a;this.yCorr=g<0&&-h;i=f*g<0;this.xCorr+=g*b*(i?1-c:c);this.yCorr-=f*b*(d?i?c:1-c:1);e&&e!==\"left\"&&(this.xCorr-=a*c*(f<0?-1:1),d&&(this.yCorr-=\nh*c*(g<0?-1:1)),L(this.element,{textAlign:e}))},pathToVML:function(a){for(var b=a.length,c=[];b--;)if(qa(a[b]))c[b]=w(a[b]*10)-5;else if(a[b]===\"Z\")c[b]=\"x\";else if(c[b]=a[b],a.isArc&&(a[b]===\"wa\"||a[b]===\"at\"))c[b+5]===c[b+7]&&(c[b+7]+=a[b+7]>a[b+5]?1:-1),c[b+6]===c[b+8]&&(c[b+8]+=a[b+8]>a[b+6]?1:-1);return c.join(\" \")||\"x\"},clip:function(a){var b=this,c;a?(c=a.members,ja(c,b),c.push(b),b.destroyClip=function(){ja(c,b)},a=a.getCSS(b)):(b.destroyClip&&b.destroyClip(),a={clip:eb?\"inherit\":\"rect(auto)\"});\nreturn b.css(a)},css:P.prototype.htmlCss,safeRemoveChild:function(a){a.parentNode&&Pa(a)},destroy:function(){this.destroyClip&&this.destroyClip();return P.prototype.destroy.apply(this)},on:function(a,b){this.element[\"on\"+a]=function(){var a=K.event;a.target=a.srcElement;b(a)};return this},cutOffPath:function(a,b){var c,a=a.split(/[ ,]/);c=a.length;if(c===9||c===11)a[c-4]=a[c-2]=F(a[c-2])-10*b;return a.join(\" \")},shadow:function(a,b,c){var d=[],e,f=this.element,g=this.renderer,h,i=f.style,j,k=f.path,\nm,l,n,q;k&&typeof k.value!==\"string\"&&(k=\"x\");l=k;if(a){n=p(a.width,3);q=(a.opacity||0.15)/n;for(e=1;e<=3;e++){m=n*2+1-2*e;c&&(l=this.cutOffPath(k.value,m+0.5));j=['<shape isShadow=\"true\" strokeweight=\"',m,'\" filled=\"false\" path=\"',l,'\" coordsize=\"10 10\" style=\"',f.style.cssText,'\" />'];h=$(g.prepVML(j),null,{left:F(i.left)+p(a.offsetX,1),top:F(i.top)+p(a.offsetY,1)});if(c)h.cutOff=m+1;j=['<stroke color=\"',a.color||\"black\",'\" opacity=\"',q*e,'\"/>'];$(g.prepVML(j),null,null,h);b?b.element.appendChild(h):\nf.parentNode.insertBefore(h,f);d.push(h)}this.shadows=d}return this},updateShadows:ta,setAttr:function(a,b){eb?this.element[a]=b:this.element.setAttribute(a,b)},classSetter:function(a){this.element.className=a},dashstyleSetter:function(a,b,c){(c.getElementsByTagName(\"stroke\")[0]||$(this.renderer.prepVML([\"<stroke/>\"]),null,null,c))[b]=a||\"solid\";this[b]=a},dSetter:function(a,b,c){var d=this.shadows,a=a||[];this.d=a.join&&a.join(\" \");c.path=a=this.pathToVML(a);if(d)for(c=d.length;c--;)d[c].path=d[c].cutOff?\nthis.cutOffPath(a,d[c].cutOff):a;this.setAttr(b,a)},fillSetter:function(a,b,c){var d=c.nodeName;if(d===\"SPAN\")c.style.color=a;else if(d!==\"IMG\")c.filled=a!==O,this.setAttr(\"fillcolor\",this.renderer.color(a,c,b,this))},opacitySetter:ta,rotationSetter:function(a,b,c){c=c.style;this[b]=c[b]=a;c.left=-w(aa(a*ga)+1)+\"px\";c.top=w(X(a*ga))+\"px\"},strokeSetter:function(a,b,c){this.setAttr(\"strokecolor\",this.renderer.color(a,c,b))},\"stroke-widthSetter\":function(a,b,c){c.stroked=!!a;this[b]=a;qa(a)&&(a+=\"px\");\nthis.setAttr(\"strokeweight\",a)},titleSetter:function(a,b){this.setAttr(b,a)},visibilitySetter:function(a,b,c){a===\"inherit\"&&(a=\"visible\");this.shadows&&o(this.shadows,function(c){c.style[b]=a});c.nodeName===\"DIV\"&&(a=a===\"hidden\"?\"-999em\":0,eb||(c.style[b]=a?\"visible\":\"hidden\"),b=\"top\");c.style[b]=a},xSetter:function(a,b,c){this[b]=a;b===\"x\"?b=\"left\":b===\"y\"&&(b=\"top\");this.updateClipping?(this[b]=a,this.updateClipping()):c.style[b]=a},zIndexSetter:function(a,b,c){c.style[b]=a}};B.VMLElement=D=ka(P,\nD);D.prototype.ySetter=D.prototype.widthSetter=D.prototype.heightSetter=D.prototype.xSetter;var La={Element:D,isIE8:za.indexOf(\"MSIE 8.0\")>-1,init:function(a,b,c,d){var e;this.alignedObjects=[];d=this.createElement(Ia).css(r(this.getStyle(d),{position:\"relative\"}));e=d.element;a.appendChild(d.element);this.isVML=!0;this.box=e;this.boxWrapper=d;this.cache={};this.setSize(b,c,!1);if(!C.namespaces.hcv){C.namespaces.add(\"hcv\",\"urn:schemas-microsoft-com:vml\");try{C.createStyleSheet().cssText=\"hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } \"}catch(f){C.styleSheets[0].cssText+=\n\"hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } \"}}},isHidden:function(){return!this.box.offsetWidth},clipRect:function(a,b,c,d){var e=this.createElement(),f=da(a);return r(e,{members:[],count:0,left:(f?a.x:a)+1,top:(f?a.y:b)+1,width:(f?a.width:c)-1,height:(f?a.height:d)-1,getCSS:function(a){var b=a.element,c=b.nodeName,a=a.inverted,d=this.top-(c===\"shape\"?b.offsetTop:0),e=this.left,b=e+this.width,f=d+this.height,d={clip:\"rect(\"+w(a?e:d)+\"px,\"+\nw(a?f:b)+\"px,\"+w(a?b:f)+\"px,\"+w(a?d:e)+\"px)\"};!a&&eb&&c===\"DIV\"&&r(d,{width:b+\"px\",height:f+\"px\"});return d},updateClipping:function(){o(e.members,function(a){a.element&&a.css(e.getCSS(a))})}})},color:function(a,b,c,d){var e=this,f,g=/^rgba/,h,i,j=O;a&&a.linearGradient?i=\"gradient\":a&&a.radialGradient&&(i=\"pattern\");if(i){var k,m,l=a.linearGradient||a.radialGradient,n,q,x,p,Q,u=\"\",a=a.stops,y,t=[],s=function(){h=['<fill colors=\"'+t.join(\",\")+'\" opacity=\"',x,'\" o:opacity2=\"',q,'\" type=\"',i,'\" ',u,\n'focus=\"100%\" method=\"any\" />'];$(e.prepVML(h),null,null,b)};n=a[0];y=a[a.length-1];n[0]>0&&a.unshift([0,n[1]]);y[0]<1&&a.push([1,y[1]]);o(a,function(a,b){g.test(a[1])?(f=na(a[1]),k=f.get(\"rgb\"),m=f.get(\"a\")):(k=a[1],m=1);t.push(a[0]*100+\"% \"+k);b?(x=m,p=k):(q=m,Q=k)});if(c===\"fill\")if(i===\"gradient\")c=l.x1||l[0]||0,a=l.y1||l[1]||0,n=l.x2||l[2]||0,l=l.y2||l[3]||0,u='angle=\"'+(90-W.atan((l-a)/(n-c))*180/ma)+'\"',s();else{var j=l.r,v=j*2,w=j*2,r=l.cx,z=l.cy,A=b.radialReference,C,j=function(){A&&(C=d.getBBox(),\nr+=(A[0]-C.x)/C.width-0.5,z+=(A[1]-C.y)/C.height-0.5,v*=A[2]/C.width,w*=A[2]/C.height);u='src=\"'+S.global.VMLRadialGradientURL+'\" size=\"'+v+\",\"+w+'\" origin=\"0.5,0.5\" position=\"'+r+\",\"+z+'\" color2=\"'+Q+'\" ';s()};d.added?j():d.onAdd=j;j=p}else j=k}else if(g.test(a)&&b.tagName!==\"IMG\")f=na(a),h=[\"<\",c,' opacity=\"',f.get(\"a\"),'\"/>'],$(this.prepVML(h),null,null,b),j=f.get(\"rgb\");else{j=b.getElementsByTagName(c);if(j.length)j[0].opacity=1,j[0].type=\"solid\";j=a}return j},prepVML:function(a){var b=this.isIE8,\na=a.join(\"\");b?(a=a.replace(\"/>\",' xmlns=\"urn:schemas-microsoft-com:vml\" />'),a=a.indexOf('style=\"')===-1?a.replace(\"/>\",' style=\"display:inline-block;behavior:url(#default#VML);\" />'):a.replace('style=\"','style=\"display:inline-block;behavior:url(#default#VML);')):a=a.replace(\"<\",\"<hcv:\");return a},text:ua.prototype.html,path:function(a){var b={coordsize:\"10 10\"};Fa(a)?b.d=a:da(a)&&r(b,a);return this.createElement(\"shape\").attr(b)},circle:function(a,b,c){var d=this.symbol(\"circle\");if(da(a))c=a.r,\nb=a.y,a=a.x;d.isCircle=!0;d.r=c;return d.attr({x:a,y:b})},g:function(a){var b;a&&(b={className:\"highcharts-\"+a,\"class\":\"highcharts-\"+a});return this.createElement(Ia).attr(b)},image:function(a,b,c,d,e){var f=this.createElement(\"img\").attr({src:a});arguments.length>1&&f.attr({x:b,y:c,width:d,height:e});return f},createElement:function(a){return a===\"rect\"?this.symbol(a):ua.prototype.createElement.call(this,a)},invertChild:function(a,b){var c=this,d=b.style,e=a.tagName===\"IMG\"&&a.style;L(a,{flip:\"x\",\nleft:F(d.width)-(e?F(e.top):1),top:F(d.height)-(e?F(e.left):1),rotation:-90});o(a.childNodes,function(b){c.invertChild(b,a)})},symbols:{arc:function(a,b,c,d,e){var f=e.start,g=e.end,h=e.r||c||d,c=e.innerR,d=X(f),i=aa(f),j=X(g),k=aa(g);if(g-f===0)return[\"x\"];f=[\"wa\",a-h,b-h,a+h,b+h,a+h*d,b+h*i,a+h*j,b+h*k];e.open&&!c&&f.push(\"e\",\"M\",a,b);f.push(\"at\",a-c,b-c,a+c,b+c,a+c*j,b+c*k,a+c*d,b+c*i,\"x\",\"e\");f.isArc=!0;return f},circle:function(a,b,c,d,e){e&&(c=d=2*e.r);e&&e.isCircle&&(a-=c/2,b-=d/2);return[\"wa\",\na,b,a+c,b+d,a+c,b+d/2,a+c,b+d/2,\"e\"]},rect:function(a,b,c,d,e){return ua.prototype.symbols[!s(e)||!e.r?\"square\":\"callout\"].call(0,a,b,c,d,e)}}};B.VMLRenderer=D=function(){this.init.apply(this,arguments)};D.prototype=A(ua.prototype,La);Za=D}ua.prototype.measureSpanWidth=function(a,b){var c=C.createElement(\"span\"),d;d=C.createTextNode(a);c.appendChild(d);L(c,b);this.box.appendChild(c);d=c.offsetWidth;Pa(c);return d};var Lb;if(fa)B.CanVGRenderer=D=function(){Da=\"http://www.w3.org/1999/xhtml\"},D.prototype.symbols=\n{},Lb=function(){function a(){var a=b.length,d;for(d=0;d<a;d++)b[d]();b=[]}var b=[];return{push:function(c,d){b.length===0&&Qb(d,a);b.push(c)}}}(),Za=D;Ra.prototype={addLabel:function(){var a=this.axis,b=a.options,c=a.chart,d=a.categories,e=a.names,f=this.pos,g=b.labels,h=a.tickPositions,i=f===h[0],j=f===h[h.length-1],e=d?p(d[f],e[f],f):f,d=this.label,h=h.info,k;a.isDatetimeAxis&&h&&(k=b.dateTimeLabelFormats[h.higherRanks[f]||h.unitName]);this.isFirst=i;this.isLast=j;b=a.labelFormatter.call({axis:a,\nchart:c,isFirst:i,isLast:j,dateTimeLabelFormat:k,value:a.isLog?ea(ia(e)):e});s(d)?d&&d.attr({text:b}):(this.labelLength=(this.label=d=s(b)&&g.enabled?c.renderer.text(b,0,0,g.useHTML).css(A(g.style)).add(a.labelGroup):null)&&d.getBBox().width,this.rotation=0)},getLabelSize:function(){return this.label?this.label.getBBox()[this.axis.horiz?\"height\":\"width\"]:0},handleOverflow:function(a){var b=this.axis,c=a.x,d=b.chart.chartWidth,e=b.chart.spacing,f=p(b.labelLeft,z(b.pos,e[3])),e=p(b.labelRight,t(b.pos+\nb.len,d-e[1])),g=this.label,h=this.rotation,i={left:0,center:0.5,right:1}[b.labelAlign],j=g.getBBox().width,k=b.slotWidth,m=1,l,n={};if(h)h<0&&c-i*j<f?l=w(c/X(h*ga)-f):h>0&&c+i*j>e&&(l=w((d-c)/X(h*ga)));else if(d=c+(1-i)*j,c-i*j<f?k=a.x+k*(1-i)-f:d>e&&(k=e-a.x+k*i,m=-1),k=z(b.slotWidth,k),k<b.slotWidth&&b.labelAlign===\"center\"&&(a.x+=m*(b.slotWidth-k-i*(b.slotWidth-z(j,k)))),j>k||b.autoRotation&&g.styles.width)l=k;if(l){n.width=l;if(!b.options.labels.style.textOverflow)n.textOverflow=\"ellipsis\";g.css(n)}},\ngetPosition:function(a,b,c,d){var e=this.axis,f=e.chart,g=d&&f.oldChartHeight||f.chartHeight;return{x:a?e.translate(b+c,null,null,d)+e.transB:e.left+e.offset+(e.opposite?(d&&f.oldChartWidth||f.chartWidth)-e.right-e.left:0),y:a?g-e.bottom+e.offset-(e.opposite?e.height:0):g-e.translate(b+c,null,null,d)-e.transB}},getLabelPosition:function(a,b,c,d,e,f,g,h){var i=this.axis,j=i.transA,k=i.reversed,m=i.staggerLines,l=i.tickRotCorr||{x:0,y:0},c=p(e.y,l.y+(i.side===2?8:-(c.getBBox().height/2))),a=a+e.x+l.x-\n(f&&d?f*j*(k?-1:1):0),b=b+c-(f&&!d?f*j*(k?1:-1):0);m&&(b+=g/(h||1)%m*(i.labelOffset/m));return{x:a,y:w(b)}},getMarkPath:function(a,b,c,d,e,f){return f.crispLine([\"M\",a,b,\"L\",a+(e?0:-c),b+(e?c:0)],d)},render:function(a,b,c){var d=this.axis,e=d.options,f=d.chart.renderer,g=d.horiz,h=this.type,i=this.label,j=this.pos,k=e.labels,m=this.gridLine,l=h?h+\"Grid\":\"grid\",n=h?h+\"Tick\":\"tick\",q=e[l+\"LineWidth\"],x=e[l+\"LineColor\"],o=e[l+\"LineDashStyle\"],Q=e[n+\"Length\"],l=p(e[n+\"Width\"],!h&&d.isXAxis?1:0),u=e[n+\n\"Color\"],y=e[n+\"Position\"],n=this.mark,t=k.step,s=!0,w=d.tickmarkOffset,r=this.getPosition(g,j,w,b),z=r.x,r=r.y,C=g&&z===d.pos+d.len||!g&&r===d.pos?-1:1,c=p(c,1);this.isActive=!0;if(q){j=d.getPlotLinePath(j+w,q*C,b,!0);if(m===v){m={stroke:x,\"stroke-width\":q};if(o)m.dashstyle=o;if(!h)m.zIndex=1;if(b)m.opacity=0;this.gridLine=m=q?f.path(j).attr(m).add(d.gridGroup):null}if(!b&&m&&j)m[this.isNew?\"attr\":\"animate\"]({d:j,opacity:c})}if(l&&Q)y===\"inside\"&&(Q=-Q),d.opposite&&(Q=-Q),h=this.getMarkPath(z,r,\nQ,l*C,g,f),n?n.animate({d:h,opacity:c}):this.mark=f.path(h).attr({stroke:u,\"stroke-width\":l,opacity:c}).add(d.axisGroup);if(i&&!isNaN(z))i.xy=r=this.getLabelPosition(z,r,i,g,k,w,a,t),this.isFirst&&!this.isLast&&!p(e.showFirstLabel,1)||this.isLast&&!this.isFirst&&!p(e.showLastLabel,1)?s=!1:g&&!d.isRadial&&!k.step&&!k.rotation&&!b&&c!==0&&this.handleOverflow(r),t&&a%t&&(s=!1),s&&!isNaN(r.y)?(r.opacity=c,i[this.isNew?\"attr\":\"animate\"](r),this.isNew=!1):i.attr(\"y\",-9999)},destroy:function(){Oa(this,this.axis)}};\nB.PlotLineOrBand=function(a,b){this.axis=a;if(b)this.options=b,this.id=b.id};B.PlotLineOrBand.prototype={render:function(){var a=this,b=a.axis,c=b.horiz,d=a.options,e=d.label,f=a.label,g=d.width,h=d.to,i=d.from,j=s(i)&&s(h),k=d.value,m=d.dashStyle,l=a.svgElem,n=[],q,x=d.color,p=d.zIndex,o=d.events,u={},y=b.chart.renderer;b.isLog&&(i=Ba(i),h=Ba(h),k=Ba(k));if(g){if(n=b.getPlotLinePath(k,g),u={stroke:x,\"stroke-width\":g},m)u.dashstyle=m}else if(j){n=b.getPlotBandPath(i,h,d);if(x)u.fill=x;if(d.borderWidth)u.stroke=\nd.borderColor,u[\"stroke-width\"]=d.borderWidth}else return;if(s(p))u.zIndex=p;if(l)if(n)l.animate({d:n},null,l.onGetPath);else{if(l.hide(),l.onGetPath=function(){l.show()},f)a.label=f=f.destroy()}else if(n&&n.length&&(a.svgElem=l=y.path(n).attr(u).add(),o))for(q in d=function(b){l.on(b,function(c){o[b].apply(a,[c])})},o)d(q);if(e&&s(e.text)&&n&&n.length&&b.width>0&&b.height>0){e=A({align:c&&j&&\"center\",x:c?!j&&4:10,verticalAlign:!c&&j&&\"middle\",y:c?j?16:10:j?6:-4,rotation:c&&!j&&90},e);if(!f){u={align:e.textAlign||\ne.align,rotation:e.rotation};if(s(p))u.zIndex=p;a.label=f=y.text(e.text,0,0,e.useHTML).attr(u).css(e.style).add()}b=[n[1],n[4],j?n[6]:n[1]];j=[n[2],n[5],j?n[7]:n[2]];n=Na(b);c=Na(j);f.align(e,!1,{x:n,y:c,width:Ca(b)-n,height:Ca(j)-c});f.show()}else f&&f.hide();return a},destroy:function(){ja(this.axis.plotLinesAndBands,this);delete this.axis;Oa(this)}};var ha=B.Axis=function(){this.init.apply(this,arguments)};ha.prototype={defaultOptions:{dateTimeLabelFormats:{millisecond:\"%H:%M:%S.%L\",second:\"%H:%M:%S\",\nminute:\"%H:%M\",hour:\"%H:%M\",day:\"%e. %b\",week:\"%e. %b\",month:\"%b '%y\",year:\"%Y\"},endOnTick:!1,gridLineColor:\"#D8D8D8\",labels:{enabled:!0,style:{color:\"#606060\",cursor:\"default\",fontSize:\"11px\"},x:0,y:15},lineColor:\"#C0D0E0\",lineWidth:1,minPadding:0.01,maxPadding:0.01,minorGridLineColor:\"#E0E0E0\",minorGridLineWidth:1,minorTickColor:\"#A0A0A0\",minorTickLength:2,minorTickPosition:\"outside\",startOfWeek:1,startOnTick:!1,tickColor:\"#C0D0E0\",tickLength:10,tickmarkPlacement:\"between\",tickPixelInterval:100,\ntickPosition:\"outside\",title:{align:\"middle\",style:{color:\"#707070\"}},type:\"linear\"},defaultYAxisOptions:{endOnTick:!0,gridLineWidth:1,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8,y:3},lineWidth:0,maxPadding:0.05,minPadding:0.05,startOnTick:!0,title:{rotation:270,text:\"Values\"},stackLabels:{enabled:!1,formatter:function(){return B.numberFormat(this.total,-1)},style:A(ba.line.dataLabels.style,{color:\"#000000\"})}},defaultLeftAxisOptions:{labels:{x:-15,y:null},title:{rotation:270}},defaultRightAxisOptions:{labels:{x:15,\ny:null},title:{rotation:90}},defaultBottomAxisOptions:{labels:{autoRotation:[-45],x:0,y:null},title:{rotation:0}},defaultTopAxisOptions:{labels:{autoRotation:[-45],x:0,y:-15},title:{rotation:0}},init:function(a,b){var c=b.isX;this.chart=a;this.horiz=a.inverted?!c:c;this.coll=(this.isXAxis=c)?\"xAxis\":\"yAxis\";this.opposite=b.opposite;this.side=b.side||(this.horiz?this.opposite?0:2:this.opposite?1:3);this.setOptions(b);var d=this.options,e=d.type;this.labelFormatter=d.labels.formatter||this.defaultLabelFormatter;\nthis.userOptions=b;this.minPixelPadding=0;this.reversed=d.reversed;this.zoomEnabled=d.zoomEnabled!==!1;this.categories=d.categories||e===\"category\";this.names=this.names||[];this.isLog=e===\"logarithmic\";this.isDatetimeAxis=e===\"datetime\";this.isLinked=s(d.linkedTo);this.ticks={};this.labelEdge=[];this.minorTicks={};this.plotLinesAndBands=[];this.alternateBands={};this.len=0;this.minRange=this.userMinRange=d.minRange||d.maxZoom;this.range=d.range;this.offset=d.offset||0;this.stacks={};this.oldStacks=\n{};this.stacksTouched=0;this.min=this.max=null;this.crosshair=p(d.crosshair,ra(a.options.tooltip.crosshairs)[c?0:1],!1);var f,d=this.options.events;Ka(this,a.axes)===-1&&(c&&!this.isColorAxis?a.axes.splice(a.xAxis.length,0,this):a.axes.push(this),a[this.coll].push(this));this.series=this.series||[];if(a.inverted&&c&&this.reversed===v)this.reversed=!0;this.removePlotLine=this.removePlotBand=this.removePlotBandOrLine;for(f in d)H(this,f,d[f]);if(this.isLog)this.val2lin=Ba,this.lin2val=ia},setOptions:function(a){this.options=\nA(this.defaultOptions,this.isXAxis?{}:this.defaultYAxisOptions,[this.defaultTopAxisOptions,this.defaultRightAxisOptions,this.defaultBottomAxisOptions,this.defaultLeftAxisOptions][this.side],A(S[this.coll],a))},defaultLabelFormatter:function(){var a=this.axis,b=this.value,c=a.categories,d=this.dateTimeLabelFormat,e=S.lang.numericSymbols,f=e&&e.length,g,h=a.options.labels.format,a=a.isLog?b:a.tickInterval;if(h)g=Ha(h,this);else if(c)g=b;else if(d)g=Ma(d,b);else if(f&&a>=1E3)for(;f--&&g===v;)c=Math.pow(1E3,\nf+1),a>=c&&b*10%c===0&&e[f]!==null&&(g=B.numberFormat(b/c,-1)+e[f]);g===v&&(g=N(b)>=1E4?B.numberFormat(b,-1):B.numberFormat(b,-1,v,\"\"));return g},getSeriesExtremes:function(){var a=this,b=a.chart;a.hasVisibleSeries=!1;a.dataMin=a.dataMax=a.ignoreMinPadding=a.ignoreMaxPadding=null;a.buildStacks&&a.buildStacks();o(a.series,function(c){if(c.visible||!b.options.chart.ignoreHiddenSeries){var d;d=c.options.threshold;var e;a.hasVisibleSeries=!0;a.isLog&&d<=0&&(d=null);if(a.isXAxis){if(d=c.xData,d.length)a.dataMin=\nz(p(a.dataMin,d[0]),Na(d)),a.dataMax=t(p(a.dataMax,d[0]),Ca(d))}else{c.getExtremes();e=c.dataMax;c=c.dataMin;if(s(c)&&s(e))a.dataMin=z(p(a.dataMin,c),c),a.dataMax=t(p(a.dataMax,e),e);if(s(d))if(a.dataMin>=d)a.dataMin=d,a.ignoreMinPadding=!0;else if(a.dataMax<d)a.dataMax=d,a.ignoreMaxPadding=!0}}})},translate:function(a,b,c,d,e,f){var g=this.linkedParent||this,h=1,i=0,j=d?g.oldTransA:g.transA,d=d?g.oldMin:g.min,k=g.minPixelPadding,e=(g.doPostTranslate||g.isLog&&e)&&g.lin2val;if(!j)j=g.transA;if(c)h*=\n-1,i=g.len;g.reversed&&(h*=-1,i-=h*(g.sector||g.len));b?(a=a*h+i,a-=k,a=a/j+d,e&&(a=g.lin2val(a))):(e&&(a=g.val2lin(a)),f===\"between\"&&(f=0.5),a=h*(a-d)*j+i+h*k+(qa(f)?j*f*g.pointRange:0));return a},toPixels:function(a,b){return this.translate(a,!1,!this.horiz,null,!0)+(b?0:this.pos)},toValue:function(a,b){return this.translate(a-(b?0:this.pos),!0,!this.horiz,null,!0)},getPlotLinePath:function(a,b,c,d,e){var f=this.chart,g=this.left,h=this.top,i,j,k=c&&f.oldChartHeight||f.chartHeight,m=c&&f.oldChartWidth||\nf.chartWidth,l;i=this.transB;var n=function(a,b,c){if(a<b||a>c)d?a=z(t(b,a),c):l=!0;return a},e=p(e,this.translate(a,null,null,c)),a=c=w(e+i);i=j=w(k-e-i);isNaN(e)?l=!0:this.horiz?(i=h,j=k-this.bottom,a=c=n(a,g,g+this.width)):(a=g,c=m-this.right,i=j=n(i,h,h+this.height));return l&&!d?null:f.renderer.crispLine([\"M\",a,i,\"L\",c,j],b||1)},getLinearTickPositions:function(a,b,c){var d,e=ea(V(b/a)*a),f=ea(sa(c/a)*a),g=[];if(b===c&&qa(b))return[b];for(b=e;b<=f;){g.push(b);b=ea(b+a);if(b===d)break;d=b}return g},\ngetMinorTickPositions:function(){var a=this.options,b=this.tickPositions,c=this.minorTickInterval,d=[],e,f=this.pointRangePadding||0;e=this.min-f;var f=this.max+f,g=f-e;if(g&&g/c<this.len/3)if(this.isLog){f=b.length;for(e=1;e<f;e++)d=d.concat(this.getLogTickPositions(c,b[e-1],b[e],!0))}else if(this.isDatetimeAxis&&a.minorTickInterval===\"auto\")d=d.concat(this.getTimeTicks(this.normalizeTimeTickInterval(c),e,f,a.startOfWeek));else for(b=e+(b[0]-e)%c;b<=f;b+=c)d.push(b);d.length!==0&&this.trimTicks(d,\na.startOnTick,a.endOnTick);return d},adjustForMinRange:function(){var a=this.options,b=this.min,c=this.max,d,e=this.dataMax-this.dataMin>=this.minRange,f,g,h,i,j;if(this.isXAxis&&this.minRange===v&&!this.isLog)s(a.min)||s(a.max)?this.minRange=null:(o(this.series,function(a){i=a.xData;for(g=j=a.xIncrement?1:i.length-1;g>0;g--)if(h=i[g]-i[g-1],f===v||h<f)f=h}),this.minRange=z(f*5,this.dataMax-this.dataMin));if(c-b<this.minRange){var k=this.minRange;d=(k-c+b)/2;d=[b-d,p(a.min,b-d)];if(e)d[2]=this.dataMin;\nb=Ca(d);c=[b+k,p(a.max,b+k)];if(e)c[2]=this.dataMax;c=Na(c);c-b<k&&(d[0]=c-k,d[1]=p(a.min,c-k),b=Ca(d))}this.min=b;this.max=c},setAxisTranslation:function(a){var b=this,c=b.max-b.min,d=b.axisPointRange||0,e,f=0,g=0,h=b.linkedParent,i=!!b.categories,j=b.transA,k=b.isXAxis;if(k||i||d)if(h?(f=h.minPointOffset,g=h.pointRangePadding):o(b.series,function(a){var h=i?1:k?a.pointRange:b.axisPointRange||0,j=a.options.pointPlacement,q=a.closestPointRange;h>c&&(h=0);d=t(d,h);b.single||(f=t(f,Aa(j)?0:h/2),g=t(g,\nj===\"on\"?0:h));!a.noSharedTooltip&&s(q)&&(e=s(e)?z(e,q):q)}),h=b.ordinalSlope&&e?b.ordinalSlope/e:1,b.minPointOffset=f*=h,b.pointRangePadding=g*=h,b.pointRange=z(d,c),k)b.closestPointRange=e;if(a)b.oldTransA=j;b.translationSlope=b.transA=j=b.len/(c+g||1);b.transB=b.horiz?b.left:b.bottom;b.minPixelPadding=j*f},minFromRange:function(){return this.max-this.range},setTickInterval:function(a){var b=this,c=b.chart,d=b.options,e=b.isLog,f=b.isDatetimeAxis,g=b.isXAxis,h=b.isLinked,i=d.maxPadding,j=d.minPadding,\nk=d.tickInterval,m=d.tickPixelInterval,l=b.categories;!f&&!l&&!h&&this.getTickAmount();h?(b.linkedParent=c[b.coll][d.linkedTo],c=b.linkedParent.getExtremes(),b.min=p(c.min,c.dataMin),b.max=p(c.max,c.dataMax),d.type!==b.linkedParent.options.type&&la(11,1)):(b.min=p(b.userMin,d.min,b.dataMin),b.max=p(b.userMax,d.max,b.dataMax));if(e)!a&&z(b.min,p(b.dataMin,b.min))<=0&&la(10,1),b.min=ea(Ba(b.min),15),b.max=ea(Ba(b.max),15);if(b.range&&s(b.max))b.userMin=b.min=t(b.min,b.minFromRange()),b.userMax=b.max,\nb.range=null;b.beforePadding&&b.beforePadding();b.adjustForMinRange();if(!l&&!b.axisPointRange&&!b.usePercentage&&!h&&s(b.min)&&s(b.max)&&(c=b.max-b.min)){if(!s(d.min)&&!s(b.userMin)&&j&&(b.dataMin<0||!b.ignoreMinPadding))b.min-=c*j;if(!s(d.max)&&!s(b.userMax)&&i&&(b.dataMax>0||!b.ignoreMaxPadding))b.max+=c*i}if(qa(d.floor))b.min=t(b.min,d.floor);if(qa(d.ceiling))b.max=z(b.max,d.ceiling);b.tickInterval=b.min===b.max||b.min===void 0||b.max===void 0?1:h&&!k&&m===b.linkedParent.options.tickPixelInterval?\nk=b.linkedParent.tickInterval:p(k,this.tickAmount?(b.max-b.min)/t(this.tickAmount-1,1):void 0,l?1:(b.max-b.min)*m/t(b.len,m));g&&!a&&o(b.series,function(a){a.processData(b.min!==b.oldMin||b.max!==b.oldMax)});b.setAxisTranslation(!0);b.beforeSetTickPositions&&b.beforeSetTickPositions();if(b.postProcessTickInterval)b.tickInterval=b.postProcessTickInterval(b.tickInterval);if(b.pointRange)b.tickInterval=t(b.pointRange,b.tickInterval);a=p(d.minTickInterval,b.isDatetimeAxis&&b.closestPointRange);if(!k&&\nb.tickInterval<a)b.tickInterval=a;if(!f&&!e&&!k)b.tickInterval=ob(b.tickInterval,null,nb(b.tickInterval),p(d.allowDecimals,!(b.tickInterval>0.5&&b.tickInterval<5&&b.max>1E3&&b.max<9999)),!!this.tickAmount);if(!this.tickAmount&&this.len)b.tickInterval=b.unsquish();this.setTickPositions()},setTickPositions:function(){var a=this.options,b,c=a.tickPositions,d=a.tickPositioner,e=a.startOnTick,f=a.endOnTick,g;this.tickmarkOffset=this.categories&&a.tickmarkPlacement===\"between\"&&this.tickInterval===1?0.5:\n0;this.minorTickInterval=a.minorTickInterval===\"auto\"&&this.tickInterval?this.tickInterval/5:a.minorTickInterval;this.tickPositions=b=c&&c.slice();if(!b&&(b=this.isDatetimeAxis?this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval,a.units),this.min,this.max,a.startOfWeek,this.ordinalPositions,this.closestPointRange,!0):this.isLog?this.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,this.min,this.max),b.length>this.len&&(b=[b[0],b.pop()]),\nthis.tickPositions=b,d&&(d=d.apply(this,[this.min,this.max]))))this.tickPositions=b=d;if(!this.isLinked)this.trimTicks(b,e,f),this.min===this.max&&s(this.min)&&!this.tickAmount&&(g=!0,this.min-=0.5,this.max+=0.5),this.single=g,!c&&!d&&this.adjustTickAmount()},trimTicks:function(a,b,c){var d=a[0],e=a[a.length-1],f=this.minPointOffset||0;b?this.min=d:this.min-f>d&&a.shift();c?this.max=e:this.max+f<e&&a.pop();a.length===0&&s(d)&&a.push((e+d)/2)},getTickAmount:function(){var a={},b,c=this.options,d=c.tickAmount,\ne=c.tickPixelInterval;!s(c.tickInterval)&&this.len<e&&!this.isRadial&&!this.isLog&&c.startOnTick&&c.endOnTick&&(d=2);!d&&this.chart.options.chart.alignTicks!==!1&&c.alignTicks!==!1&&(o(this.chart[this.coll],function(c){var d=c.options,e=c.horiz,d=[e?d.left:d.top,e?d.width:d.height,d.pane].join(\",\");a[d]?c.series.length&&(b=!0):a[d]=1}),b&&(d=sa(this.len/e)+1));if(d<4)this.finalTickAmt=d,d=5;this.tickAmount=d},adjustTickAmount:function(){var a=this.tickInterval,b=this.tickPositions,c=this.tickAmount,\nd=this.finalTickAmt,e=b&&b.length;if(e<c){for(;b.length<c;)b.push(ea(b[b.length-1]+a));this.transA*=(e-1)/(c-1);this.max=b[b.length-1]}else e>c&&(this.tickInterval*=2,this.setTickPositions());if(s(d)){for(a=c=b.length;a--;)(d===3&&a%2===1||d<=2&&a>0&&a<c-1)&&b.splice(a,1);this.finalTickAmt=v}},setScale:function(){var a,b;this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;this.setAxisSize();b=this.len!==this.oldAxisLength;o(this.series,function(b){if(b.isDirtyData||b.isDirty||b.xAxis.isDirty)a=\n!0});if(b||a||this.isLinked||this.forceRedraw||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax){if(this.resetStacks&&this.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,!this.isDirty)this.isDirty=b||this.min!==this.oldMin||this.max!==this.oldMax}else this.cleanStacks&&this.cleanStacks()},setExtremes:function(a,b,c,d,e){var f=this,g=f.chart,c=p(c,!0);o(f.series,function(a){delete a.kdTree});\ne=r(e,{min:a,max:b});I(f,\"setExtremes\",e,function(){f.userMin=a;f.userMax=b;f.eventArgs=e;c&&g.redraw(d)})},zoom:function(a,b){var c=this.dataMin,d=this.dataMax,e=this.options,f=z(c,p(e.min,c)),e=t(d,p(e.max,d));this.allowZoomOutside||(s(c)&&a<=f&&(a=f),s(d)&&b>=e&&(b=e));this.displayBtn=a!==v||b!==v;this.setExtremes(a,b,!1,v,{trigger:\"zoom\"});return!0},setAxisSize:function(){var a=this.chart,b=this.options,c=b.offsetLeft||0,d=this.horiz,e=p(b.width,a.plotWidth-c+(b.offsetRight||0)),f=p(b.height,\na.plotHeight),g=p(b.top,a.plotTop),b=p(b.left,a.plotLeft+c),c=/%$/;c.test(f)&&(f=parseFloat(f)/100*a.plotHeight);c.test(g)&&(g=parseFloat(g)/100*a.plotHeight+a.plotTop);this.left=b;this.top=g;this.width=e;this.height=f;this.bottom=a.chartHeight-f-g;this.right=a.chartWidth-e-b;this.len=t(d?e:f,0);this.pos=d?b:g},getExtremes:function(){var a=this.isLog;return{min:a?ea(ia(this.min)):this.min,max:a?ea(ia(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}},\ngetThreshold:function(a){var b=this.isLog,c=b?ia(this.min):this.min,b=b?ia(this.max):this.max;a===null?a=b<0?b:c:c>a?a=c:b<a&&(a=b);return this.translate(a,0,1,0,1)},autoLabelAlign:function(a){a=(p(a,0)-this.side*90+720)%360;return a>15&&a<165?\"right\":a>195&&a<345?\"left\":\"center\"},unsquish:function(){var a=this.ticks,b=this.options.labels,c=this.horiz,d=this.tickInterval,e=d,f=this.len/(((this.categories?1:0)+this.max-this.min)/d),g,h=b.rotation,i=this.chart.renderer.fontMetrics(b.style.fontSize,\na[0]&&a[0].label),j,k=Number.MAX_VALUE,m,l=function(a){a/=f||1;a=a>1?sa(a):1;return a*d};c?(m=s(h)?[h]:f<p(b.autoRotationLimit,80)&&!b.staggerLines&&!b.step&&b.autoRotation)&&o(m,function(a){var b;if(a===h||a&&a>=-90&&a<=90)j=l(N(i.h/aa(ga*a))),b=j+N(a/360),b<k&&(k=b,g=a,e=j)}):b.step||(e=l(i.h));this.autoRotation=m;this.labelRotation=g;return e},renderUnsquish:function(){var a=this.chart,b=a.renderer,c=this.tickPositions,d=this.ticks,e=this.options.labels,f=this.horiz,g=a.margin,h=this.categories?\nc.length:c.length-1,i=this.slotWidth=f&&!e.step&&!e.rotation&&(this.staggerLines||1)*a.plotWidth/h||!f&&(g[3]&&g[3]-a.spacing[3]||a.chartWidth*0.33),j=t(1,w(i-2*(e.padding||5))),k={},g=b.fontMetrics(e.style.fontSize,d[0]&&d[0].label),h=e.style.textOverflow,m,l=0;if(!Aa(e.rotation))k.rotation=e.rotation||0;if(this.autoRotation)o(c,function(a){if((a=d[a])&&a.labelLength>l)l=a.labelLength}),l>j&&l>g.h?k.rotation=this.labelRotation:this.labelRotation=0;else if(i&&(m={width:j+\"px\"},!h)){m.textOverflow=\n\"clip\";for(i=c.length;!f&&i--;)if(j=c[i],j=d[j].label)if(j.styles.textOverflow===\"ellipsis\"&&j.css({textOverflow:\"clip\"}),j.getBBox().height>this.len/c.length-(g.h-g.f))j.specCss={textOverflow:\"ellipsis\"}}if(k.rotation&&(m={width:(l>a.chartHeight*0.5?a.chartHeight*0.33:a.chartHeight)+\"px\"},!h))m.textOverflow=\"ellipsis\";this.labelAlign=k.align=e.align||this.autoLabelAlign(this.labelRotation);o(c,function(a){var b=(a=d[a])&&a.label;if(b)m&&b.css(A(m,b.specCss)),delete b.specCss,b.attr(k),a.rotation=\nk.rotation});this.tickRotCorr=b.rotCorr(g.b,this.labelRotation||0,this.side===2)},hasData:function(){return this.hasVisibleSeries||s(this.min)&&s(this.max)&&!!this.tickPositions},getOffset:function(){var a=this,b=a.chart,c=b.renderer,d=a.options,e=a.tickPositions,f=a.ticks,g=a.horiz,h=a.side,i=b.inverted?[1,0,3,2][h]:h,j,k,m=0,l,n=0,q=d.title,x=d.labels,T=0,Q=b.axisOffset,b=b.clipOffset,u=[-1,1,1,-1][h],y;j=a.hasData();a.showAxis=k=j||p(d.showEmpty,!0);a.staggerLines=a.horiz&&x.staggerLines;if(!a.axisGroup)a.gridGroup=\nc.g(\"grid\").attr({zIndex:d.gridZIndex||1}).add(),a.axisGroup=c.g(\"axis\").attr({zIndex:d.zIndex||2}).add(),a.labelGroup=c.g(\"axis-labels\").attr({zIndex:x.zIndex||7}).addClass(\"highcharts-\"+a.coll.toLowerCase()+\"-labels\").add();if(j||a.isLinked){if(o(e,function(b){f[b]?f[b].addLabel():f[b]=new Ra(a,b)}),a.renderUnsquish(),o(e,function(b){if(h===0||h===2||{1:\"left\",3:\"right\"}[h]===a.labelAlign)T=t(f[b].getLabelSize(),T)}),a.staggerLines)T*=a.staggerLines,a.labelOffset=T}else for(y in f)f[y].destroy(),\ndelete f[y];if(q&&q.text&&q.enabled!==!1){if(!a.axisTitle)a.axisTitle=c.text(q.text,0,0,q.useHTML).attr({zIndex:7,rotation:q.rotation||0,align:q.textAlign||{low:\"left\",middle:\"center\",high:\"right\"}[q.align]}).addClass(\"highcharts-\"+this.coll.toLowerCase()+\"-title\").css(q.style).add(a.axisGroup),a.axisTitle.isNew=!0;if(k)m=a.axisTitle.getBBox()[g?\"height\":\"width\"],l=q.offset,n=s(l)?0:p(q.margin,g?5:10);a.axisTitle[k?\"show\":\"hide\"]()}a.offset=u*p(d.offset,Q[h]);a.tickRotCorr=a.tickRotCorr||{x:0,y:0};\nc=h===2?a.tickRotCorr.y:0;g=T+n+(T&&u*(g?p(x.y,a.tickRotCorr.y+8):x.x)-c);a.axisTitleMargin=p(l,g);Q[h]=t(Q[h],a.axisTitleMargin+m+u*a.offset,g);d=d.offset?0:V(d.lineWidth/2)*2;b[i]=t(b[i],d)},getLinePath:function(a){var b=this.chart,c=this.opposite,d=this.offset,e=this.horiz,f=this.left+(c?this.width:0)+d,d=b.chartHeight-this.bottom-(c?this.height:0)+d;c&&(a*=-1);return b.renderer.crispLine([\"M\",e?this.left:f,e?d:this.top,\"L\",e?b.chartWidth-this.right:f,e?d:b.chartHeight-this.bottom],a)},getTitlePosition:function(){var a=\nthis.horiz,b=this.left,c=this.top,d=this.len,e=this.options.title,f=a?b:c,g=this.opposite,h=this.offset,i=e.x||0,j=e.y||0,k=F(e.style.fontSize||12),d={low:f+(a?0:d),middle:f+d/2,high:f+(a?d:0)}[e.align],b=(a?c+this.height:b)+(a?1:-1)*(g?-1:1)*this.axisTitleMargin+(this.side===2?k:0);return{x:a?d+i:b+(g?this.width:0)+h+i,y:a?b+j-(g?this.height:0)+h:d+j}},render:function(){var a=this,b=a.chart,c=b.renderer,d=a.options,e=a.isLog,f=a.isLinked,g=a.tickPositions,h=a.axisTitle,i=a.ticks,j=a.minorTicks,k=\na.alternateBands,m=d.stackLabels,l=d.alternateGridColor,n=a.tickmarkOffset,q=d.lineWidth,x,p=b.hasRendered&&s(a.oldMin)&&!isNaN(a.oldMin),Q=a.showAxis,u=c.globalAnimation,y,t;a.labelEdge.length=0;a.overlap=!1;o([i,j,k],function(a){for(var b in a)a[b].isActive=!1});if(a.hasData()||f){a.minorTickInterval&&!a.categories&&o(a.getMinorTickPositions(),function(b){j[b]||(j[b]=new Ra(a,b,\"minor\"));p&&j[b].isNew&&j[b].render(null,!0);j[b].render(null,!1,1)});if(g.length&&(o(g,function(b,c){if(!f||b>=a.min&&\nb<=a.max)i[b]||(i[b]=new Ra(a,b)),p&&i[b].isNew&&i[b].render(c,!0,0.1),i[b].render(c)}),n&&(a.min===0||a.single)))i[-1]||(i[-1]=new Ra(a,-1,null,!0)),i[-1].render(-1);l&&o(g,function(b,c){if(c%2===0&&b<a.max)k[b]||(k[b]=new B.PlotLineOrBand(a)),y=b+n,t=g[c+1]!==v?g[c+1]+n:a.max,k[b].options={from:e?ia(y):y,to:e?ia(t):t,color:l},k[b].render(),k[b].isActive=!0});if(!a._addedPlotLB)o((d.plotLines||[]).concat(d.plotBands||[]),function(b){a.addPlotBandOrLine(b)}),a._addedPlotLB=!0}o([i,j,k],function(a){var c,\nd,e=[],f=u?u.duration||500:0,g=function(){for(d=e.length;d--;)a[e[d]]&&!a[e[d]].isActive&&(a[e[d]].destroy(),delete a[e[d]])};for(c in a)if(!a[c].isActive)a[c].render(c,!1,0),a[c].isActive=!1,e.push(c);a===k||!b.hasRendered||!f?g():f&&setTimeout(g,f)});if(q)x=a.getLinePath(q),a.axisLine?a.axisLine.animate({d:x}):a.axisLine=c.path(x).attr({stroke:d.lineColor,\"stroke-width\":q,zIndex:7}).add(a.axisGroup),a.axisLine[Q?\"show\":\"hide\"]();if(h&&Q)h[h.isNew?\"attr\":\"animate\"](a.getTitlePosition()),h.isNew=\n!1;m&&m.enabled&&a.renderStackTotals();a.isDirty=!1},redraw:function(){this.render();o(this.plotLinesAndBands,function(a){a.render()});o(this.series,function(a){a.isDirty=!0})},destroy:function(a){var b=this,c=b.stacks,d,e=b.plotLinesAndBands;a||Z(b);for(d in c)Oa(c[d]),c[d]=null;o([b.ticks,b.minorTicks,b.alternateBands],function(a){Oa(a)});for(a=e.length;a--;)e[a].destroy();o(\"stackTotalGroup,axisLine,axisTitle,axisGroup,cross,gridGroup,labelGroup\".split(\",\"),function(a){b[a]&&(b[a]=b[a].destroy())});\nthis.cross&&this.cross.destroy()},drawCrosshair:function(a,b){var c,d=this.crosshair,e=d.animation;if(!this.crosshair||(s(b)||!p(this.crosshair.snap,!0))===!1||b&&b.series&&b.series[this.coll]!==this)this.hideCrosshair();else if(p(d.snap,!0)?s(b)&&(c=this.isXAxis?b.plotX:this.len-b.plotY):c=this.horiz?a.chartX-this.pos:this.len-a.chartY+this.pos,c=this.isRadial?this.getPlotLinePath(this.isXAxis?b.x:p(b.stackY,b.y))||null:this.getPlotLinePath(null,null,null,null,c)||null,c===null)this.hideCrosshair();\nelse if(this.cross)this.cross.attr({visibility:\"visible\"})[e?\"animate\":\"attr\"]({d:c},e);else{e=this.categories&&!this.isRadial;e={\"stroke-width\":d.width||(e?this.transA:1),stroke:d.color||(e?\"rgba(155,200,255,0.2)\":\"#C0C0C0\"),zIndex:d.zIndex||2};if(d.dashStyle)e.dashstyle=d.dashStyle;this.cross=this.chart.renderer.path(c).attr(e).add()}},hideCrosshair:function(){this.cross&&this.cross.hide()}};r(ha.prototype,{getPlotBandPath:function(a,b){var c=this.getPlotLinePath(b,null,null,!0),d=this.getPlotLinePath(a,\nnull,null,!0);d&&c&&d.toString()!==c.toString()?d.push(c[4],c[5],c[1],c[2]):d=null;return d},addPlotBand:function(a){return this.addPlotBandOrLine(a,\"plotBands\")},addPlotLine:function(a){return this.addPlotBandOrLine(a,\"plotLines\")},addPlotBandOrLine:function(a,b){var c=(new B.PlotLineOrBand(this,a)).render(),d=this.userOptions;c&&(b&&(d[b]=d[b]||[],d[b].push(a)),this.plotLinesAndBands.push(c));return c},removePlotBandOrLine:function(a){for(var b=this.plotLinesAndBands,c=this.options,d=this.userOptions,\ne=b.length;e--;)b[e].id===a&&b[e].destroy();o([c.plotLines||[],d.plotLines||[],c.plotBands||[],d.plotBands||[]],function(b){for(e=b.length;e--;)b[e].id===a&&ja(b,b[e])})}});ha.prototype.getTimeTicks=function(a,b,c,d){var e=[],f={},g=S.global.useUTC,h,i=new ya(b-Va(b)),j=a.unitRange,k=a.count;if(s(b)){i[Db](j>=E.second?0:k*V(i.getMilliseconds()/k));if(j>=E.second)i[Eb](j>=E.minute?0:k*V(i.getSeconds()/k));if(j>=E.minute)i[Fb](j>=E.hour?0:k*V(i[qb]()/k));if(j>=E.hour)i[Gb](j>=E.day?0:k*V(i[rb]()/k));\nif(j>=E.day)i[tb](j>=E.month?1:k*V(i[Wa]()/k));j>=E.month&&(i[ub](j>=E.year?0:k*V(i[Xa]()/k)),h=i[Ya]());j>=E.year&&(h-=h%k,i[vb](h));if(j===E.week)i[tb](i[Wa]()-i[sb]()+p(d,1));b=1;if(mb||bb)i=i.getTime(),i=new ya(i+Va(i));h=i[Ya]();for(var d=i.getTime(),m=i[Xa](),l=i[Wa](),n=(E.day+(g?Va(i):i.getTimezoneOffset()*6E4))%E.day;d<c;)e.push(d),j===E.year?d=db(h+b*k,0):j===E.month?d=db(h,m+b*k):!g&&(j===E.day||j===E.week)?d=db(h,m,l+b*k*(j===E.day?1:7)):d+=j*k,b++;e.push(d);o(ib(e,function(a){return j<=\nE.hour&&a%E.day===n}),function(a){f[a]=\"day\"})}e.info=r(a,{higherRanks:f,totalRange:j*k});return e};ha.prototype.normalizeTimeTickInterval=function(a,b){var c=b||[[\"millisecond\",[1,2,5,10,20,25,50,100,200,500]],[\"second\",[1,2,5,10,15,30]],[\"minute\",[1,2,5,10,15,30]],[\"hour\",[1,2,3,4,6,8,12]],[\"day\",[1,2]],[\"week\",[1,2]],[\"month\",[1,2,3,4,6]],[\"year\",null]],d=c[c.length-1],e=E[d[0]],f=d[1],g;for(g=0;g<c.length;g++)if(d=c[g],e=E[d[0]],f=d[1],c[g+1]&&a<=(e*f[f.length-1]+E[c[g+1][0]])/2)break;e===E.year&&\na<5*e&&(f=[1,2,5]);c=ob(a/e,f,d[0]===\"year\"?t(nb(a/e),1):1);return{unitRange:e,count:c,unitName:d[0]}};ha.prototype.getLogTickPositions=function(a,b,c,d){var e=this.options,f=this.len,g=[];if(!d)this._minorAutoInterval=null;if(a>=0.5)a=w(a),g=this.getLinearTickPositions(a,b,c);else if(a>=0.08)for(var f=V(b),h,i,j,k,m,e=a>0.3?[1,2,4]:a>0.15?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];f<c+1&&!m;f++){i=e.length;for(h=0;h<i&&!m;h++)j=Ba(ia(f)*e[h]),j>b&&(!d||k<=c)&&k!==v&&g.push(k),k>c&&(m=!0),k=j}else if(b=ia(b),\nc=ia(c),a=e[d?\"minorTickInterval\":\"tickInterval\"],a=p(a===\"auto\"?null:a,this._minorAutoInterval,(c-b)*(e.tickPixelInterval/(d?5:1))/((d?f/this.tickPositions.length:f)||1)),a=ob(a,null,nb(a)),g=Ta(this.getLinearTickPositions(a,b,c),Ba),!d)this._minorAutoInterval=a/5;if(!d)this.tickInterval=a;return g};var Mb=B.Tooltip=function(){this.init.apply(this,arguments)};Mb.prototype={init:function(a,b){var c=b.borderWidth,d=b.style,e=F(d.padding);this.chart=a;this.options=b;this.crosshairs=[];this.now={x:0,\ny:0};this.isHidden=!0;this.label=a.renderer.label(\"\",0,0,b.shape||\"callout\",null,null,b.useHTML,null,\"tooltip\").attr({padding:e,fill:b.backgroundColor,\"stroke-width\":c,r:b.borderRadius,zIndex:8}).css(d).css({padding:0}).add().attr({y:-9999});fa||this.label.shadow(b.shadow);this.shared=b.shared},destroy:function(){if(this.label)this.label=this.label.destroy();clearTimeout(this.hideTimer);clearTimeout(this.tooltipTimeout)},move:function(a,b,c,d){var e=this,f=e.now,g=e.options.animation!==!1&&!e.isHidden&&\n(N(a-f.x)>1||N(b-f.y)>1),h=e.followPointer||e.len>1;r(f,{x:g?(2*f.x+a)/3:a,y:g?(f.y+b)/2:b,anchorX:h?v:g?(2*f.anchorX+c)/3:c,anchorY:h?v:g?(f.anchorY+d)/2:d});e.label.attr(f);if(g)clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){e&&e.move(a,b,c,d)},32)},hide:function(a){var b=this;clearTimeout(this.hideTimer);if(!this.isHidden)this.hideTimer=setTimeout(function(){b.label.fadeOut();b.isHidden=!0},p(a,this.options.hideDelay,500))},getAnchor:function(a,b){var c,d=this.chart,\ne=d.inverted,f=d.plotTop,g=d.plotLeft,h=0,i=0,j,k,a=ra(a);c=a[0].tooltipPos;this.followPointer&&b&&(b.chartX===v&&(b=d.pointer.normalize(b)),c=[b.chartX-d.plotLeft,b.chartY-f]);c||(o(a,function(a){j=a.series.yAxis;k=a.series.xAxis;h+=a.plotX+(!e&&k?k.left-g:0);i+=(a.plotLow?(a.plotLow+a.plotHigh)/2:a.plotY)+(!e&&j?j.top-f:0)}),h/=a.length,i/=a.length,c=[e?d.plotWidth-i:h,this.shared&&!e&&a.length>1&&b?b.chartY-f:e?d.plotHeight-h:i]);return Ta(c,w)},getPosition:function(a,b,c){var d=this.chart,e=this.distance,\nf={},g=c.h||0,h,i=[\"y\",d.chartHeight,b,c.plotY+d.plotTop,d.plotTop,d.plotTop+d.plotHeight],j=[\"x\",d.chartWidth,a,c.plotX+d.plotLeft,d.plotLeft,d.plotLeft+d.plotWidth],k=p(c.ttBelow,d.inverted&&!c.negative||!d.inverted&&c.negative),m=function(a,b,c,d,h,i){var j=c<d-e,l=d+e+c<b,m=d-e-c;d+=e;if(k&&l)f[a]=d;else if(!k&&j)f[a]=m;else if(j)f[a]=z(i-c,m-g<0?m:m-g);else if(l)f[a]=t(h,d+g+c>b?d:d+g);else return!1},l=function(a,b,c,d){if(d<e||d>b-e)return!1;else f[a]=d<c/2?1:d>b-c/2?b-c-2:d-c/2},n=function(a){var b=\ni;i=j;j=b;h=a},q=function(){m.apply(0,i)!==!1?l.apply(0,j)===!1&&!h&&(n(!0),q()):h?f.x=f.y=0:(n(!0),q())};(d.inverted||this.len>1)&&n();q();return f},defaultFormatter:function(a){var b=this.points||ra(this),c;c=[a.tooltipFooterHeaderFormatter(b[0])];c=c.concat(a.bodyFormatter(b));c.push(a.tooltipFooterHeaderFormatter(b[0],!0));return c.join(\"\")},refresh:function(a,b){var c=this.chart,d=this.label,e=this.options,f,g,h,i={},j,k=[];j=e.formatter||this.defaultFormatter;var i=c.hoverPoints,m,l=this.shared;\nclearTimeout(this.hideTimer);this.followPointer=ra(a)[0].series.tooltipOptions.followPointer;h=this.getAnchor(a,b);f=h[0];g=h[1];l&&(!a.series||!a.series.noSharedTooltip)?(c.hoverPoints=a,i&&o(i,function(a){a.setState()}),o(a,function(a){a.setState(\"hover\");k.push(a.getLabelConfig())}),i={x:a[0].category,y:a[0].y},i.points=k,this.len=k.length,a=a[0]):i=a.getLabelConfig();j=j.call(i,this);i=a.series;this.distance=p(i.tooltipOptions.distance,16);j===!1?this.hide():(this.isHidden&&(kb(d),d.attr(\"opacity\",\n1).show()),d.attr({text:j}),m=e.borderColor||a.color||i.color||\"#606060\",d.attr({stroke:m}),this.updatePosition({plotX:f,plotY:g,negative:a.negative,ttBelow:a.ttBelow,h:h[2]||0}),this.isHidden=!1);I(c,\"tooltipRefresh\",{text:j,x:f+c.plotLeft,y:g+c.plotTop,borderColor:m})},updatePosition:function(a){var b=this.chart,c=this.label,c=(this.options.positioner||this.getPosition).call(this,c.width,c.height,a);this.move(w(c.x),w(c.y||0),a.plotX+b.plotLeft,a.plotY+b.plotTop)},getXDateFormat:function(a,b,c){var d,\nb=b.dateTimeLabelFormats,e=c&&c.closestPointRange,f,g={millisecond:15,second:12,minute:9,hour:6,day:3},h,i=\"millisecond\";if(e){h=Ma(\"%m-%d %H:%M:%S.%L\",a.x);for(f in E){if(e===E.week&&+Ma(\"%w\",a.x)===c.options.startOfWeek&&h.substr(6)===\"00:00:00.000\"){f=\"week\";break}else if(E[f]>e){f=i;break}else if(g[f]&&h.substr(g[f])!==\"01-01 00:00:00.000\".substr(g[f]))break;f!==\"week\"&&(i=f)}f&&(d=b[f])}else d=b.day;return d||b.year},tooltipFooterHeaderFormatter:function(a,b){var c=b?\"footer\":\"header\",d=a.series,\ne=d.tooltipOptions,f=e.xDateFormat,g=d.xAxis,h=g&&g.options.type===\"datetime\"&&qa(a.key),c=e[c+\"Format\"];h&&!f&&(f=this.getXDateFormat(a,e,g));h&&f&&(c=c.replace(\"{point.key}\",\"{point.key:\"+f+\"}\"));return Ha(c,{point:a,series:d})},bodyFormatter:function(a){return Ta(a,function(a){var c=a.series.tooltipOptions;return(c.pointFormatter||a.point.tooltipFormatter).call(a.point,c.pointFormat)})}};var oa;$a=C.documentElement.ontouchstart!==v;var Ua=B.Pointer=function(a,b){this.init(a,b)};Ua.prototype={init:function(a,\nb){var c=b.chart,d=c.events,e=fa?\"\":c.zoomType,c=a.inverted,f;this.options=b;this.chart=a;this.zoomX=f=/x/.test(e);this.zoomY=e=/y/.test(e);this.zoomHor=f&&!c||e&&c;this.zoomVert=e&&!c||f&&c;this.hasZoom=f||e;this.runChartClick=d&&!!d.click;this.pinchDown=[];this.lastValidTouch={};if(B.Tooltip&&b.tooltip.enabled)a.tooltip=new Mb(a,b.tooltip),this.followTouchMove=p(b.tooltip.followTouchMove,!0);this.setDOMEvents()},normalize:function(a,b){var c,d,a=a||window.event,a=Sb(a);if(!a.target)a.target=a.srcElement;\nd=a.touches?a.touches.length?a.touches.item(0):a.changedTouches[0]:a;if(!b)this.chartPosition=b=Rb(this.chart.container);d.pageX===v?(c=t(a.x,a.clientX-b.left),d=a.y):(c=d.pageX-b.left,d=d.pageY-b.top);return r(a,{chartX:w(c),chartY:w(d)})},getCoordinates:function(a){var b={xAxis:[],yAxis:[]};o(this.chart.axes,function(c){b[c.isXAxis?\"xAxis\":\"yAxis\"].push({axis:c,value:c.toValue(a[c.horiz?\"chartX\":\"chartY\"])})});return b},runPointActions:function(a){var b=this.chart,c=b.series,d=b.tooltip,e=d?d.shared:\n!1,f=b.hoverPoint,g=b.hoverSeries,h,i=b.chartWidth,j,k,m=[],l,n;if(!e&&!g)for(h=0;h<c.length;h++)if(c[h].directTouch||!c[h].options.stickyTracking)c=[];!e&&g&&g.directTouch&&f?l=f:(o(c,function(b){j=b.noSharedTooltip&&e;k=!e&&b.directTouch;b.visible&&!j&&!k&&p(b.options.enableMouseTracking,!0)&&(n=b.searchPoint(a,!j&&b.kdDimensions===1))&&m.push(n)}),o(m,function(a){if(a&&typeof a.dist===\"number\"&&a.dist<i)i=a.dist,l=a}));if(l&&(l!==this.prevKDPoint||d&&d.isHidden)){if(e&&!l.series.noSharedTooltip){for(h=\nm.length;h--;)(m[h].clientX!==l.clientX||m[h].series.noSharedTooltip)&&m.splice(h,1);m.length&&d&&d.refresh(m,a);o(m,function(b){b.onMouseOver(a,b!==(g&&g.directTouch&&f||l))})}else if(d&&d.refresh(l,a),!g||!g.directTouch)l.onMouseOver(a);this.prevKDPoint=l}else c=g&&g.tooltipOptions.followPointer,d&&c&&!d.isHidden&&(c=d.getAnchor([{}],a),d.updatePosition({plotX:c[0],plotY:c[1]}));if(d&&!this._onDocumentMouseMove)this._onDocumentMouseMove=function(a){if(Y[oa])Y[oa].pointer.onDocumentMouseMove(a)},\nH(C,\"mousemove\",this._onDocumentMouseMove);o(b.axes,function(b){b.drawCrosshair(a,p(l,f))})},reset:function(a,b){var c=this.chart,d=c.hoverSeries,e=c.hoverPoint,f=c.hoverPoints,g=c.tooltip,h=g&&g.shared?f:e;(a=a&&g&&h)&&ra(h)[0].plotX===v&&(a=!1);if(a)g.refresh(h),e&&(e.setState(e.state,!0),o(c.axes,function(a){p(a.options.crosshair&&a.options.crosshair.snap,!0)?a.drawCrosshair(null,e):a.hideCrosshair()}));else{if(e)e.onMouseOut();f&&o(f,function(a){a.setState()});if(d)d.onMouseOut();g&&g.hide(b);\nif(this._onDocumentMouseMove)Z(C,\"mousemove\",this._onDocumentMouseMove),this._onDocumentMouseMove=null;o(c.axes,function(a){a.hideCrosshair()});this.hoverX=c.hoverPoints=c.hoverPoint=null}},scaleGroups:function(a,b){var c=this.chart,d;o(c.series,function(e){d=a||e.getPlotBox();e.xAxis&&e.xAxis.zoomEnabled&&(e.group.attr(d),e.markerGroup&&(e.markerGroup.attr(d),e.markerGroup.clip(b?c.clipRect:null)),e.dataLabelsGroup&&e.dataLabelsGroup.attr(d))});c.clipRect.attr(b||c.clipBox)},dragStart:function(a){var b=\nthis.chart;b.mouseIsDown=a.type;b.cancelClick=!1;b.mouseDownX=this.mouseDownX=a.chartX;b.mouseDownY=this.mouseDownY=a.chartY},drag:function(a){var b=this.chart,c=b.options.chart,d=a.chartX,e=a.chartY,f=this.zoomHor,g=this.zoomVert,h=b.plotLeft,i=b.plotTop,j=b.plotWidth,k=b.plotHeight,m,l=this.selectionMarker,n=this.mouseDownX,q=this.mouseDownY,x=c.panKey&&a[c.panKey+\"Key\"];if(!l||!l.touch)if(d<h?d=h:d>h+j&&(d=h+j),e<i?e=i:e>i+k&&(e=i+k),this.hasDragged=Math.sqrt(Math.pow(n-d,2)+Math.pow(q-e,2)),this.hasDragged>\n10){m=b.isInsidePlot(n-h,q-i);if(b.hasCartesianSeries&&(this.zoomX||this.zoomY)&&m&&!x&&!l)this.selectionMarker=l=b.renderer.rect(h,i,f?1:j,g?1:k,0).attr({fill:c.selectionMarkerFill||\"rgba(69,114,167,0.25)\",zIndex:7}).add();l&&f&&(d-=n,l.attr({width:N(d),x:(d>0?0:d)+n}));l&&g&&(d=e-q,l.attr({height:N(d),y:(d>0?0:d)+q}));m&&!l&&c.panning&&b.pan(a,c.panning)}},drop:function(a){var b=this,c=this.chart,d=this.hasPinched;if(this.selectionMarker){var e={xAxis:[],yAxis:[],originalEvent:a.originalEvent||\na},f=this.selectionMarker,g=f.attr?f.attr(\"x\"):f.x,h=f.attr?f.attr(\"y\"):f.y,i=f.attr?f.attr(\"width\"):f.width,j=f.attr?f.attr(\"height\"):f.height,k;if(this.hasDragged||d)o(c.axes,function(c){if(c.zoomEnabled&&s(c.min)&&(d||b[{xAxis:\"zoomX\",yAxis:\"zoomY\"}[c.coll]])){var f=c.horiz,n=a.type===\"touchend\"?c.minPixelPadding:0,q=c.toValue((f?g:h)+n),f=c.toValue((f?g+i:h+j)-n);e[c.coll].push({axis:c,min:z(q,f),max:t(q,f)});k=!0}}),k&&I(c,\"selection\",e,function(a){c.zoom(r(a,d?{animation:!1}:null))});this.selectionMarker=\nthis.selectionMarker.destroy();d&&this.scaleGroups()}if(c)L(c.container,{cursor:c._cursor}),c.cancelClick=this.hasDragged>10,c.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=[]},onContainerMouseDown:function(a){a=this.normalize(a);a.preventDefault&&a.preventDefault();this.dragStart(a)},onDocumentMouseUp:function(a){Y[oa]&&Y[oa].pointer.drop(a)},onDocumentMouseMove:function(a){var b=this.chart,c=this.chartPosition,a=this.normalize(a,c);c&&!this.inClass(a.target,\"highcharts-tracker\")&&\n!b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop)&&this.reset()},onContainerMouseLeave:function(){var a=Y[oa];if(a)a.pointer.reset(),a.pointer.chartPosition=null},onContainerMouseMove:function(a){var b=this.chart;oa=b.index;a=this.normalize(a);a.returnValue=!1;b.mouseIsDown===\"mousedown\"&&this.drag(a);(this.inClass(a.target,\"highcharts-tracker\")||b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop))&&!b.openMenu&&this.runPointActions(a)},inClass:function(a,b){for(var c;a;){if(c=J(a,\"class\"))if(c.indexOf(b)!==\n-1)return!0;else if(c.indexOf(\"highcharts-container\")!==-1)return!1;a=a.parentNode}},onTrackerMouseOut:function(a){var b=this.chart.hoverSeries,c=(a=a.relatedTarget||a.toElement)&&a.point&&a.point.series;if(b&&!b.options.stickyTracking&&!this.inClass(a,\"highcharts-tooltip\")&&c!==b)b.onMouseOut()},onContainerClick:function(a){var b=this.chart,c=b.hoverPoint,d=b.plotLeft,e=b.plotTop,a=this.normalize(a);a.originalEvent=a;b.cancelClick||(c&&this.inClass(a.target,\"highcharts-tracker\")?(I(c.series,\"click\",\nr(a,{point:c})),b.hoverPoint&&c.firePointEvent(\"click\",a)):(r(a,this.getCoordinates(a)),b.isInsidePlot(a.chartX-d,a.chartY-e)&&I(b,\"click\",a)))},setDOMEvents:function(){var a=this,b=a.chart.container;b.onmousedown=function(b){a.onContainerMouseDown(b)};b.onmousemove=function(b){a.onContainerMouseMove(b)};b.onclick=function(b){a.onContainerClick(b)};H(b,\"mouseleave\",a.onContainerMouseLeave);ab===1&&H(C,\"mouseup\",a.onDocumentMouseUp);if($a)b.ontouchstart=function(b){a.onContainerTouchStart(b)},b.ontouchmove=\nfunction(b){a.onContainerTouchMove(b)},ab===1&&H(C,\"touchend\",a.onDocumentTouchEnd)},destroy:function(){var a;Z(this.chart.container,\"mouseleave\",this.onContainerMouseLeave);ab||(Z(C,\"mouseup\",this.onDocumentMouseUp),Z(C,\"touchend\",this.onDocumentTouchEnd));clearInterval(this.tooltipTimeout);for(a in this)this[a]=null}};r(B.Pointer.prototype,{pinchTranslate:function(a,b,c,d,e,f){(this.zoomHor||this.pinchHor)&&this.pinchTranslateDirection(!0,a,b,c,d,e,f);(this.zoomVert||this.pinchVert)&&this.pinchTranslateDirection(!1,\na,b,c,d,e,f)},pinchTranslateDirection:function(a,b,c,d,e,f,g,h){var i=this.chart,j=a?\"x\":\"y\",k=a?\"X\":\"Y\",m=\"chart\"+k,l=a?\"width\":\"height\",n=i[\"plot\"+(a?\"Left\":\"Top\")],q,x,p=h||1,o=i.inverted,u=i.bounds[a?\"h\":\"v\"],t=b.length===1,s=b[0][m],r=c[0][m],w=!t&&b[1][m],v=!t&&c[1][m],z,c=function(){!t&&N(s-w)>20&&(p=h||N(r-v)/N(s-w));x=(n-r)/p+s;q=i[\"plot\"+(a?\"Width\":\"Height\")]/p};c();b=x;b<u.min?(b=u.min,z=!0):b+q>u.max&&(b=u.max-q,z=!0);z?(r-=0.8*(r-g[j][0]),t||(v-=0.8*(v-g[j][1])),c()):g[j]=[r,v];o||(f[j]=\nx-n,f[l]=q);f=o?1/p:p;e[l]=q;e[j]=b;d[o?a?\"scaleY\":\"scaleX\":\"scale\"+k]=p;d[\"translate\"+k]=f*n+(r-f*s)},pinch:function(a){var b=this,c=b.chart,d=b.pinchDown,e=a.touches,f=e.length,g=b.lastValidTouch,h=b.hasZoom,i=b.selectionMarker,j={},k=f===1&&(b.inClass(a.target,\"highcharts-tracker\")&&c.runTrackerClick||b.runChartClick),m={};if(f>1)b.initiated=!0;h&&b.initiated&&!k&&a.preventDefault();Ta(e,function(a){return b.normalize(a)});if(a.type===\"touchstart\")o(e,function(a,b){d[b]={chartX:a.chartX,chartY:a.chartY}}),\ng.x=[d[0].chartX,d[1]&&d[1].chartX],g.y=[d[0].chartY,d[1]&&d[1].chartY],o(c.axes,function(a){if(a.zoomEnabled){var b=c.bounds[a.horiz?\"h\":\"v\"],d=a.minPixelPadding,e=a.toPixels(p(a.options.min,a.dataMin)),f=a.toPixels(p(a.options.max,a.dataMax)),g=z(e,f),e=t(e,f);b.min=z(a.pos,g-d);b.max=t(a.pos+a.len,e+d)}}),b.res=!0;else if(d.length){if(!i)b.selectionMarker=i=r({destroy:ta,touch:!0},c.plotBox);b.pinchTranslate(d,e,j,i,m,g);b.hasPinched=h;b.scaleGroups(j,m);if(!h&&b.followTouchMove&&f===1)this.runPointActions(b.normalize(a));\nelse if(b.res)b.res=!1,this.reset(!1,0)}},touch:function(a,b){var c=this.chart;oa=c.index;a.touches.length===1?(a=this.normalize(a),c.isInsidePlot(a.chartX-c.plotLeft,a.chartY-c.plotTop)&&!c.openMenu?(b&&this.runPointActions(a),this.pinch(a)):b&&this.reset()):a.touches.length===2&&this.pinch(a)},onContainerTouchStart:function(a){this.touch(a,!0)},onContainerTouchMove:function(a){this.touch(a)},onDocumentTouchEnd:function(a){Y[oa]&&Y[oa].pointer.drop(a)}});if(K.PointerEvent||K.MSPointerEvent){var va=\n{},Ab=!!K.PointerEvent,Wb=function(){var a,b=[];b.item=function(a){return this[a]};for(a in va)va.hasOwnProperty(a)&&b.push({pageX:va[a].pageX,pageY:va[a].pageY,target:va[a].target});return b},Bb=function(a,b,c,d){a=a.originalEvent||a;if((a.pointerType===\"touch\"||a.pointerType===a.MSPOINTER_TYPE_TOUCH)&&Y[oa])d(a),d=Y[oa].pointer,d[b]({type:c,target:a.currentTarget,preventDefault:ta,touches:Wb()})};r(Ua.prototype,{onContainerPointerDown:function(a){Bb(a,\"onContainerTouchStart\",\"touchstart\",function(a){va[a.pointerId]=\n{pageX:a.pageX,pageY:a.pageY,target:a.currentTarget}})},onContainerPointerMove:function(a){Bb(a,\"onContainerTouchMove\",\"touchmove\",function(a){va[a.pointerId]={pageX:a.pageX,pageY:a.pageY};if(!va[a.pointerId].target)va[a.pointerId].target=a.currentTarget})},onDocumentPointerUp:function(a){Bb(a,\"onDocumentTouchEnd\",\"touchend\",function(a){delete va[a.pointerId]})},batchMSEvents:function(a){a(this.chart.container,Ab?\"pointerdown\":\"MSPointerDown\",this.onContainerPointerDown);a(this.chart.container,Ab?\n\"pointermove\":\"MSPointerMove\",this.onContainerPointerMove);a(C,Ab?\"pointerup\":\"MSPointerUp\",this.onDocumentPointerUp)}});Sa(Ua.prototype,\"init\",function(a,b,c){a.call(this,b,c);this.hasZoom&&L(b.container,{\"-ms-touch-action\":O,\"touch-action\":O})});Sa(Ua.prototype,\"setDOMEvents\",function(a){a.apply(this);(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(H)});Sa(Ua.prototype,\"destroy\",function(a){this.batchMSEvents(Z);a.call(this)})}var lb=B.Legend=function(a,b){this.init(a,b)};lb.prototype=\n{init:function(a,b){var c=this,d=b.itemStyle,e=b.itemMarginTop||0;this.options=b;if(b.enabled)c.itemStyle=d,c.itemHiddenStyle=A(d,b.itemHiddenStyle),c.itemMarginTop=e,c.padding=d=p(b.padding,8),c.initialItemX=d,c.initialItemY=d-5,c.maxItemWidth=0,c.chart=a,c.itemHeight=0,c.symbolWidth=p(b.symbolWidth,16),c.pages=[],c.render(),H(c.chart,\"endResize\",function(){c.positionCheckboxes()})},colorizeItem:function(a,b){var c=this.options,d=a.legendItem,e=a.legendLine,f=a.legendSymbol,g=this.itemHiddenStyle.color,\nc=b?c.itemStyle.color:g,h=b?a.legendColor||a.color||\"#CCC\":g,g=a.options&&a.options.marker,i={fill:h},j;d&&d.css({fill:c,color:c});e&&e.attr({stroke:h});if(f){if(g&&f.isMarker)for(j in i.stroke=h,g=a.convertAttribs(g),g)d=g[j],d!==v&&(i[j]=d);f.attr(i)}},positionItem:function(a){var b=this.options,c=b.symbolPadding,b=!b.rtl,d=a._legendItemPos,e=d[0],d=d[1],f=a.checkbox;(a=a.legendGroup)&&a.element&&a.translate(b?e:this.legendWidth-e-2*c-4,d);if(f)f.x=e,f.y=d},destroyItem:function(a){var b=a.checkbox;\no([\"legendItem\",\"legendLine\",\"legendSymbol\",\"legendGroup\"],function(b){a[b]&&(a[b]=a[b].destroy())});b&&Pa(a.checkbox)},destroy:function(){var a=this.group,b=this.box;if(b)this.box=b.destroy();if(a)this.group=a.destroy()},positionCheckboxes:function(a){var b=this.group.alignAttr,c,d=this.clipHeight||this.legendHeight;if(b)c=b.translateY,o(this.allItems,function(e){var f=e.checkbox,g;f&&(g=c+f.y+(a||0)+3,L(f,{left:b.translateX+e.checkboxOffset+f.x-20+\"px\",top:g+\"px\",display:g>c-6&&g<c+d-6?\"\":O}))})},\nrenderTitle:function(){var a=this.padding,b=this.options.title,c=0;if(b.text){if(!this.title)this.title=this.chart.renderer.label(b.text,a-3,a-4,null,null,null,null,null,\"legend-title\").attr({zIndex:1}).css(b.style).add(this.group);a=this.title.getBBox();c=a.height;this.offsetWidth=a.width;this.contentGroup.attr({translateY:c})}this.titleHeight=c},setText:function(a){var b=this.options;a.legendItem.attr({text:b.labelFormat?Ha(b.labelFormat,a):b.labelFormatter.call(a)})},renderItem:function(a){var b=\nthis.chart,c=b.renderer,d=this.options,e=d.layout===\"horizontal\",f=this.symbolWidth,g=d.symbolPadding,h=this.itemStyle,i=this.itemHiddenStyle,j=this.padding,k=e?p(d.itemDistance,20):0,m=!d.rtl,l=d.width,n=d.itemMarginBottom||0,q=this.itemMarginTop,x=this.initialItemX,o=a.legendItem,s=a.series&&a.series.drawLegendSymbol?a.series:a,u=s.options,u=this.createCheckboxForItem&&u&&u.showCheckbox,y=d.useHTML;if(!o){a.legendGroup=c.g(\"legend-item\").attr({zIndex:1}).add(this.scrollGroup);a.legendItem=o=c.text(\"\",\nm?f+g:-g,this.baseline||0,y).css(A(a.visible?h:i)).attr({align:m?\"left\":\"right\",zIndex:2}).add(a.legendGroup);if(!this.baseline)this.fontMetrics=c.fontMetrics(h.fontSize,o),this.baseline=this.fontMetrics.f+3+q,o.attr(\"y\",this.baseline);s.drawLegendSymbol(this,a);this.setItemEvents&&this.setItemEvents(a,o,y,h,i);this.colorizeItem(a,a.visible);u&&this.createCheckboxForItem(a)}this.setText(a);c=o.getBBox();f=a.checkboxOffset=d.itemWidth||a.legendItemWidth||f+g+c.width+k+(u?20:0);this.itemHeight=g=w(a.legendItemHeight||\nc.height);if(e&&this.itemX-x+f>(l||b.chartWidth-2*j-x-d.x))this.itemX=x,this.itemY+=q+this.lastLineHeight+n,this.lastLineHeight=0;this.maxItemWidth=t(this.maxItemWidth,f);this.lastItemY=q+this.itemY+n;this.lastLineHeight=t(g,this.lastLineHeight);a._legendItemPos=[this.itemX,this.itemY];e?this.itemX+=f:(this.itemY+=q+g+n,this.lastLineHeight=g);this.offsetWidth=l||t((e?this.itemX-x-k:f)+j,this.offsetWidth)},getAllItems:function(){var a=[];o(this.chart.series,function(b){var c=b.options;if(p(c.showInLegend,\n!s(c.linkedTo)?v:!1,!0))a=a.concat(b.legendItems||(c.legendType===\"point\"?b.data:b))});return a},adjustMargins:function(a,b){var c=this.chart,d=this.options,e=d.align.charAt(0)+d.verticalAlign.charAt(0)+d.layout.charAt(0);this.display&&!d.floating&&o([/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/],function(f,g){f.test(e)&&!s(a[g])&&(c[gb[g]]=t(c[gb[g]],c.legend[(g+1)%2?\"legendHeight\":\"legendWidth\"]+[1,-1,-1,1][g]*d[g%2?\"x\":\"y\"]+p(d.margin,12)+b[g]))})},render:function(){var a=this,b=\na.chart,c=b.renderer,d=a.group,e,f,g,h,i=a.box,j=a.options,k=a.padding,m=j.borderWidth,l=j.backgroundColor;a.itemX=a.initialItemX;a.itemY=a.initialItemY;a.offsetWidth=0;a.lastItemY=0;if(!d)a.group=d=c.g(\"legend\").attr({zIndex:7}).add(),a.contentGroup=c.g().attr({zIndex:1}).add(d),a.scrollGroup=c.g().add(a.contentGroup);a.renderTitle();e=a.getAllItems();pb(e,function(a,b){return(a.options&&a.options.legendIndex||0)-(b.options&&b.options.legendIndex||0)});j.reversed&&e.reverse();a.allItems=e;a.display=\nf=!!e.length;a.lastLineHeight=0;o(e,function(b){a.renderItem(b)});g=(j.width||a.offsetWidth)+k;h=a.lastItemY+a.lastLineHeight+a.titleHeight;h=a.handleOverflow(h);h+=k;if(m||l){if(i){if(g>0&&h>0)i[i.isNew?\"attr\":\"animate\"](i.crisp({width:g,height:h})),i.isNew=!1}else a.box=i=c.rect(0,0,g,h,j.borderRadius,m||0).attr({stroke:j.borderColor,\"stroke-width\":m||0,fill:l||O}).add(d).shadow(j.shadow),i.isNew=!0;i[f?\"show\":\"hide\"]()}a.legendWidth=g;a.legendHeight=h;o(e,function(b){a.positionItem(b)});f&&d.align(r({width:g,\nheight:h},j),!0,\"spacingBox\");b.isResizing||this.positionCheckboxes()},handleOverflow:function(a){var b=this,c=this.chart,d=c.renderer,e=this.options,f=e.y,f=c.spacingBox.height+(e.verticalAlign===\"top\"?-f:f)-this.padding,g=e.maxHeight,h,i=this.clipRect,j=e.navigation,k=p(j.animation,!0),m=j.arrowSize||12,l=this.nav,n=this.pages,q=this.padding,x,s=this.allItems,r=function(a){i.attr({height:a});if(b.contentGroup.div)b.contentGroup.div.style.clip=\"rect(\"+q+\"px,9999px,\"+(q+a)+\"px,0)\"};e.layout===\"horizontal\"&&\n(f/=2);g&&(f=z(f,g));n.length=0;if(a>f){this.clipHeight=h=t(f-20-this.titleHeight-q,0);this.currentPage=p(this.currentPage,1);this.fullHeight=a;o(s,function(a,b){var c=a._legendItemPos[1],d=w(a.legendItem.getBBox().height),e=n.length;if(!e||c-n[e-1]>h&&(x||c)!==n[e-1])n.push(x||c),e++;b===s.length-1&&c+d-n[e-1]>h&&n.push(c);c!==x&&(x=c)});if(!i)i=b.clipRect=d.clipRect(0,q,9999,0),b.contentGroup.clip(i);r(h);if(!l)this.nav=l=d.g().attr({zIndex:1}).add(this.group),this.up=d.symbol(\"triangle\",0,0,m,\nm).on(\"click\",function(){b.scroll(-1,k)}).add(l),this.pager=d.text(\"\",15,10).css(j.style).add(l),this.down=d.symbol(\"triangle-down\",0,0,m,m).on(\"click\",function(){b.scroll(1,k)}).add(l);b.scroll(0);a=f}else if(l)r(c.chartHeight),l.hide(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0;return a},scroll:function(a,b){var c=this.pages,d=c.length,e=this.currentPage+a,f=this.clipHeight,g=this.options.navigation,h=g.activeColor,g=g.inactiveColor,i=this.pager,j=this.padding;e>d&&(e=d);if(e>0)b!==\nv&&Qa(b,this.chart),this.nav.attr({translateX:j,translateY:f+this.padding+7+this.titleHeight,visibility:\"visible\"}),this.up.attr({fill:e===1?g:h}).css({cursor:e===1?\"default\":\"pointer\"}),i.attr({text:e+\"/\"+d}),this.down.attr({x:18+this.pager.getBBox().width,fill:e===d?g:h}).css({cursor:e===d?\"default\":\"pointer\"}),c=-c[e-1]+this.initialItemY,this.scrollGroup.animate({translateY:c}),this.currentPage=e,this.positionCheckboxes(c)}};La=B.LegendSymbolMixin={drawRectangle:function(a,b){var c=a.options.symbolHeight||\na.fontMetrics.f;b.legendSymbol=this.chart.renderer.rect(0,a.baseline-c+1,a.symbolWidth,c,a.options.symbolRadius||0).attr({zIndex:3}).add(b.legendGroup)},drawLineMarker:function(a){var b=this.options,c=b.marker,d;d=a.symbolWidth;var e=this.chart.renderer,f=this.legendGroup,a=a.baseline-w(a.fontMetrics.b*0.3),g;if(b.lineWidth){g={\"stroke-width\":b.lineWidth};if(b.dashStyle)g.dashstyle=b.dashStyle;this.legendLine=e.path([\"M\",0,a,\"L\",d,a]).attr(g).add(f)}if(c&&c.enabled!==!1)b=c.radius,this.legendSymbol=\nd=e.symbol(this.symbol,d/2-b,a-b,2*b,2*b).add(f),d.isMarker=!0}};(/Trident\\/7\\.0/.test(za)||Ja)&&Sa(lb.prototype,\"positionItem\",function(a,b){var c=this,d=function(){b._legendItemPos&&a.call(c,b)};d();setTimeout(d)});D=B.Chart=function(){this.init.apply(this,arguments)};D.prototype={callbacks:[],init:function(a,b){var c,d=a.series;a.series=null;c=A(S,a);c.series=a.series=d;this.userOptions=a;d=c.chart;this.margin=this.splashArray(\"margin\",d);this.spacing=this.splashArray(\"spacing\",d);var e=d.events;\nthis.bounds={h:{},v:{}};this.callback=b;this.isResizing=0;this.options=c;this.axes=[];this.series=[];this.hasCartesianSeries=d.showAxes;var f=this,g;f.index=Y.length;Y.push(f);ab++;d.reflow!==!1&&H(f,\"load\",function(){f.initReflow()});if(e)for(g in e)H(f,g,e[g]);f.xAxis=[];f.yAxis=[];f.animation=fa?!1:p(d.animation,!0);f.pointCount=f.colorCounter=f.symbolCounter=0;f.firstRender()},initSeries:function(a){var b=this.options.chart;(b=M[a.type||b.type||b.defaultSeriesType])||la(17,!0);b=new b;b.init(this,\na);return b},isInsidePlot:function(a,b,c){var d=c?b:a,a=c?a:b;return d>=0&&d<=this.plotWidth&&a>=0&&a<=this.plotHeight},redraw:function(a){var b=this.axes,c=this.series,d=this.pointer,e=this.legend,f=this.isDirtyLegend,g,h,i=this.hasCartesianSeries,j=this.isDirtyBox,k=c.length,m=k,l=this.renderer,n=l.isHidden(),q=[];Qa(a,this);n&&this.cloneRenderTo();for(this.layOutTitles();m--;)if(a=c[m],a.options.stacking&&(g=!0,a.isDirty)){h=!0;break}if(h)for(m=k;m--;)if(a=c[m],a.options.stacking)a.isDirty=!0;\no(c,function(a){a.isDirty&&a.options.legendType===\"point\"&&(a.updateTotals&&a.updateTotals(),f=!0)});if(f&&e.options.enabled)e.render(),this.isDirtyLegend=!1;g&&this.getStacks();if(i&&!this.isResizing)this.maxTicks=null,o(b,function(a){a.setScale()});this.getMargins();i&&(o(b,function(a){a.isDirty&&(j=!0)}),o(b,function(a){var b=a.min+\",\"+a.max;if(a.extKey!==b)a.extKey=b,q.push(function(){I(a,\"afterSetExtremes\",r(a.eventArgs,a.getExtremes()));delete a.eventArgs});(j||g)&&a.redraw()}));j&&this.drawChartBox();\no(c,function(a){a.isDirty&&a.visible&&(!a.isCartesian||a.xAxis)&&a.redraw()});d&&d.reset(!0);l.draw();I(this,\"redraw\");n&&this.cloneRenderTo(!0);o(q,function(a){a.call()})},get:function(a){var b=this.axes,c=this.series,d,e;for(d=0;d<b.length;d++)if(b[d].options.id===a)return b[d];for(d=0;d<c.length;d++)if(c[d].options.id===a)return c[d];for(d=0;d<c.length;d++){e=c[d].points||[];for(b=0;b<e.length;b++)if(e[b].id===a)return e[b]}return null},getAxes:function(){var a=this,b=this.options,c=b.xAxis=ra(b.xAxis||\n{}),b=b.yAxis=ra(b.yAxis||{});o(c,function(a,b){a.index=b;a.isX=!0});o(b,function(a,b){a.index=b});c=c.concat(b);o(c,function(b){new ha(a,b)})},getSelectedPoints:function(){var a=[];o(this.series,function(b){a=a.concat(ib(b.points||[],function(a){return a.selected}))});return a},getSelectedSeries:function(){return ib(this.series,function(a){return a.selected})},setTitle:function(a,b,c){var g;var d=this,e=d.options,f;f=e.title=A(e.title,a);g=e.subtitle=A(e.subtitle,b),e=g;o([[\"title\",a,f],[\"subtitle\",\nb,e]],function(a){var b=a[0],c=d[b],e=a[1],a=a[2];c&&e&&(d[b]=c=c.destroy());a&&a.text&&!c&&(d[b]=d.renderer.text(a.text,0,0,a.useHTML).attr({align:a.align,\"class\":\"highcharts-\"+b,zIndex:a.zIndex||4}).css(a.style).add())});d.layOutTitles(c)},layOutTitles:function(a){var b=0,c=this.title,d=this.subtitle,e=this.options,f=e.title,e=e.subtitle,g=this.renderer,h=this.spacingBox.width-44;if(c&&(c.css({width:(f.width||h)+\"px\"}).align(r({y:g.fontMetrics(f.style.fontSize,c).b-3},f),!1,\"spacingBox\"),!f.floating&&\n!f.verticalAlign))b=c.getBBox().height;d&&(d.css({width:(e.width||h)+\"px\"}).align(r({y:b+(f.margin-13)+g.fontMetrics(f.style.fontSize,d).b},e),!1,\"spacingBox\"),!e.floating&&!e.verticalAlign&&(b=sa(b+d.getBBox().height)));c=this.titleOffset!==b;this.titleOffset=b;if(!this.isDirtyBox&&c)this.isDirtyBox=c,this.hasRendered&&p(a,!0)&&this.isDirtyBox&&this.redraw()},getChartSize:function(){var a=this.options.chart,b=a.width,a=a.height,c=this.renderToClone||this.renderTo;if(!s(b))this.containerWidth=hb(c,\n\"width\");if(!s(a))this.containerHeight=hb(c,\"height\");this.chartWidth=t(0,b||this.containerWidth||600);this.chartHeight=t(0,p(a,this.containerHeight>19?this.containerHeight:400))},cloneRenderTo:function(a){var b=this.renderToClone,c=this.container;a?b&&(this.renderTo.appendChild(c),Pa(b),delete this.renderToClone):(c&&c.parentNode===this.renderTo&&this.renderTo.removeChild(c),this.renderToClone=b=this.renderTo.cloneNode(0),L(b,{position:\"absolute\",top:\"-9999px\",display:\"block\"}),b.style.setProperty&&\nb.style.setProperty(\"display\",\"block\",\"important\"),C.body.appendChild(b),c&&b.appendChild(c))},getContainer:function(){var a,b=this.options.chart,c,d,e;this.renderTo=a=b.renderTo;e=\"highcharts-\"+wb++;if(Aa(a))this.renderTo=a=C.getElementById(a);a||la(13,!0);c=F(J(a,\"data-highcharts-chart\"));!isNaN(c)&&Y[c]&&Y[c].hasRendered&&Y[c].destroy();J(a,\"data-highcharts-chart\",this.index);a.innerHTML=\"\";!b.skipClone&&!a.offsetWidth&&this.cloneRenderTo();this.getChartSize();c=this.chartWidth;d=this.chartHeight;\nthis.container=a=$(Ia,{className:\"highcharts-container\"+(b.className?\" \"+b.className:\"\"),id:e},r({position:\"relative\",overflow:\"hidden\",width:c+\"px\",height:d+\"px\",textAlign:\"left\",lineHeight:\"normal\",zIndex:0,\"-webkit-tap-highlight-color\":\"rgba(0,0,0,0)\"},b.style),this.renderToClone||a);this._cursor=a.style.cursor;this.renderer=b.forExport?new ua(a,c,d,b.style,!0):new Za(a,c,d,b.style);fa&&this.renderer.create(this,a,c,d);this.renderer.chartIndex=this.index},getMargins:function(a){var b=this.spacing,\nc=this.margin,d=this.titleOffset;this.resetMargins();if(d&&!s(c[0]))this.plotTop=t(this.plotTop,d+this.options.title.margin+b[0]);this.legend.adjustMargins(c,b);this.extraBottomMargin&&(this.marginBottom+=this.extraBottomMargin);this.extraTopMargin&&(this.plotTop+=this.extraTopMargin);a||this.getAxisMargins()},getAxisMargins:function(){var a=this,b=a.axisOffset=[0,0,0,0],c=a.margin;a.hasCartesianSeries&&o(a.axes,function(a){a.getOffset()});o(gb,function(d,e){s(c[e])||(a[d]+=b[e])});a.setChartSize()},\nreflow:function(a){var b=this,c=b.options.chart,d=b.renderTo,e=c.width||hb(d,\"width\"),f=c.height||hb(d,\"height\"),c=a?a.target:K,d=function(){if(b.container)b.setSize(e,f,!1),b.hasUserSize=null};if(!b.hasUserSize&&!b.isPrinting&&e&&f&&(c===K||c===C)){if(e!==b.containerWidth||f!==b.containerHeight)clearTimeout(b.reflowTimeout),a?b.reflowTimeout=setTimeout(d,100):d();b.containerWidth=e;b.containerHeight=f}},initReflow:function(){var a=this,b=function(b){a.reflow(b)};H(K,\"resize\",b);H(a,\"destroy\",function(){Z(K,\n\"resize\",b)})},setSize:function(a,b,c){var d=this,e,f,g,h=d.renderer,i=h.globalAnimation;d.isResizing+=1;g=function(){d&&I(d,\"endResize\",null,function(){d.isResizing-=1})};Qa(c,d);d.oldChartHeight=d.chartHeight;d.oldChartWidth=d.chartWidth;if(s(a))d.chartWidth=e=t(0,w(a)),d.hasUserSize=!!e;if(s(b))d.chartHeight=f=t(0,w(b));(i?jb:L)(d.container,{width:e+\"px\",height:f+\"px\"},i);d.setChartSize(!0);h.setSize(e,f,c);d.maxTicks=null;o(d.axes,function(a){a.isDirty=!0;a.setScale()});o(d.series,function(a){a.isDirty=\n!0});d.isDirtyLegend=!0;d.isDirtyBox=!0;d.layOutTitles();d.getMargins();d.redraw(c);d.oldChartHeight=null;I(d,\"resize\");i===!1?g():setTimeout(g,i&&i.duration||500)},setChartSize:function(a){var b=this.inverted,c=this.renderer,d=this.chartWidth,e=this.chartHeight,f=this.options.chart,g=this.spacing,h=this.clipOffset,i,j,k,m;this.plotLeft=i=w(this.plotLeft);this.plotTop=j=w(this.plotTop);this.plotWidth=k=t(0,w(d-i-this.marginRight));this.plotHeight=m=t(0,w(e-j-this.marginBottom));this.plotSizeX=b?m:\nk;this.plotSizeY=b?k:m;this.plotBorderWidth=f.plotBorderWidth||0;this.spacingBox=c.spacingBox={x:g[3],y:g[0],width:d-g[3]-g[1],height:e-g[0]-g[2]};this.plotBox=c.plotBox={x:i,y:j,width:k,height:m};d=2*V(this.plotBorderWidth/2);b=sa(t(d,h[3])/2);c=sa(t(d,h[0])/2);this.clipBox={x:b,y:c,width:V(this.plotSizeX-t(d,h[1])/2-b),height:t(0,V(this.plotSizeY-t(d,h[2])/2-c))};a||o(this.axes,function(a){a.setAxisSize();a.setAxisTranslation()})},resetMargins:function(){var a=this;o(gb,function(b,c){a[b]=p(a.margin[c],\na.spacing[c])});a.axisOffset=[0,0,0,0];a.clipOffset=[0,0,0,0]},drawChartBox:function(){var a=this.options.chart,b=this.renderer,c=this.chartWidth,d=this.chartHeight,e=this.chartBackground,f=this.plotBackground,g=this.plotBorder,h=this.plotBGImage,i=a.borderWidth||0,j=a.backgroundColor,k=a.plotBackgroundColor,m=a.plotBackgroundImage,l=a.plotBorderWidth||0,n,q=this.plotLeft,p=this.plotTop,o=this.plotWidth,t=this.plotHeight,u=this.plotBox,s=this.clipRect,r=this.clipBox;n=i+(a.shadow?8:0);if(i||j)if(e)e.animate(e.crisp({width:c-\nn,height:d-n}));else{e={fill:j||O};if(i)e.stroke=a.borderColor,e[\"stroke-width\"]=i;this.chartBackground=b.rect(n/2,n/2,c-n,d-n,a.borderRadius,i).attr(e).addClass(\"highcharts-background\").add().shadow(a.shadow)}if(k)f?f.animate(u):this.plotBackground=b.rect(q,p,o,t,0).attr({fill:k}).add().shadow(a.plotShadow);if(m)h?h.animate(u):this.plotBGImage=b.image(m,q,p,o,t).add();s?s.animate({width:r.width,height:r.height}):this.clipRect=b.clipRect(r);if(l)g?g.animate(g.crisp({x:q,y:p,width:o,height:t,strokeWidth:-l})):\nthis.plotBorder=b.rect(q,p,o,t,0,-l).attr({stroke:a.plotBorderColor,\"stroke-width\":l,fill:O,zIndex:1}).add();this.isDirtyBox=!1},propFromSeries:function(){var a=this,b=a.options.chart,c,d=a.options.series,e,f;o([\"inverted\",\"angular\",\"polar\"],function(g){c=M[b.type||b.defaultSeriesType];f=a[g]||b[g]||c&&c.prototype[g];for(e=d&&d.length;!f&&e--;)(c=M[d[e].type])&&c.prototype[g]&&(f=!0);a[g]=f})},linkSeries:function(){var a=this,b=a.series;o(b,function(a){a.linkedSeries.length=0});o(b,function(b){var d=\nb.options.linkedTo;if(Aa(d)&&(d=d===\":previous\"?a.series[b.index-1]:a.get(d)))d.linkedSeries.push(b),b.linkedParent=d,b.visible=p(b.options.visible,d.options.visible,b.visible)})},renderSeries:function(){o(this.series,function(a){a.translate();a.render()})},renderLabels:function(){var a=this,b=a.options.labels;b.items&&o(b.items,function(c){var d=r(b.style,c.style),e=F(d.left)+a.plotLeft,f=F(d.top)+a.plotTop+12;delete d.left;delete d.top;a.renderer.text(c.html,e,f).attr({zIndex:2}).css(d).add()})},\nrender:function(){var a=this.axes,b=this.renderer,c=this.options,d,e,f,g;this.setTitle();this.legend=new lb(this,c.legend);this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();d=this.plotWidth;e=this.plotHeight-=13;o(a,function(a){a.setScale()});this.getAxisMargins();f=d/this.plotWidth>1.1;g=e/this.plotHeight>1.1;if(f||g)this.maxTicks=null,o(a,function(a){(a.horiz&&f||!a.horiz&&g)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries&&o(a,function(a){a.render()});\nif(!this.seriesGroup)this.seriesGroup=b.g(\"series-group\").attr({zIndex:3}).add();this.renderSeries();this.renderLabels();this.showCredits(c.credits);this.hasRendered=!0},showCredits:function(a){if(a.enabled&&!this.credits)this.credits=this.renderer.text(a.text,0,0).on(\"click\",function(){if(a.href)location.href=a.href}).attr({align:a.position.align,zIndex:8}).css(a.style).add().align(a.position)},destroy:function(){var a=this,b=a.axes,c=a.series,d=a.container,e,f=d&&d.parentNode;I(a,\"destroy\");Y[a.index]=\nv;ab--;a.renderTo.removeAttribute(\"data-highcharts-chart\");Z(a);for(e=b.length;e--;)b[e]=b[e].destroy();for(e=c.length;e--;)c[e]=c[e].destroy();o(\"title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,pointer,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer\".split(\",\"),function(b){var c=a[b];c&&c.destroy&&(a[b]=c.destroy())});if(d)d.innerHTML=\"\",Z(d),f&&Pa(d);for(e in a)delete a[e]},isReadyToRender:function(){var a=this;return!ca&&K==K.top&&\nC.readyState!==\"complete\"||fa&&!K.canvg?(fa?Lb.push(function(){a.firstRender()},a.options.global.canvasToolsURL):C.attachEvent(\"onreadystatechange\",function(){C.detachEvent(\"onreadystatechange\",a.firstRender);C.readyState===\"complete\"&&a.firstRender()}),!1):!0},firstRender:function(){var a=this,b=a.options,c=a.callback;if(a.isReadyToRender()){a.getContainer();I(a,\"init\");a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();o(b.series||[],function(b){a.initSeries(b)});a.linkSeries();I(a,\n\"beforeRender\");if(B.Pointer)a.pointer=new Ua(a,b);a.render();a.renderer.draw();c&&c.apply(a,[a]);o(a.callbacks,function(b){a.index!==v&&b.apply(a,[a])});I(a,\"load\");a.cloneRenderTo(!0)}},splashArray:function(a,b){var c=b[a],c=da(c)?c:[c,c,c,c];return[p(b[a+\"Top\"],c[0]),p(b[a+\"Right\"],c[1]),p(b[a+\"Bottom\"],c[2]),p(b[a+\"Left\"],c[3])]}};var Xb=B.CenteredSeriesMixin={getCenter:function(){var a=this.options,b=this.chart,c=2*(a.slicedOffset||0),d=b.plotWidth-2*c,b=b.plotHeight-2*c,e=a.center,e=[p(e[0],\n\"50%\"),p(e[1],\"50%\"),a.size||\"100%\",a.innerSize||0],f=z(d,b),g,h;for(g=0;g<4;++g)h=e[g],a=g<2||g===2&&/%$/.test(h),e[g]=(/%$/.test(h)?[d,b,f,e[2]][g]*parseFloat(h)/100:parseFloat(h))+(a?c:0);return e}},Ea=function(){};Ea.prototype={init:function(a,b,c){this.series=a;this.color=a.color;this.applyOptions(b,c);this.pointAttr={};if(a.options.colorByPoint&&(b=a.options.colors||a.chart.options.colors,this.color=this.color||b[a.colorCounter++],a.colorCounter===b.length))a.colorCounter=0;a.chart.pointCount++;\nreturn this},applyOptions:function(a,b){var c=this.series,d=c.options.pointValKey||c.pointValKey,a=Ea.prototype.optionsToObject.call(this,a);r(this,a);this.options=this.options?r(this.options,a):a;if(d)this.y=this[d];if(this.x===v&&c)this.x=b===v?c.autoIncrement():b;return this},optionsToObject:function(a){var b={},c=this.series,d=c.options.keys,e=d||c.pointArrayMap||[\"y\"],f=e.length,g=0,h=0;if(typeof a===\"number\"||a===null)b[e[0]]=a;else if(Fa(a)){if(!d&&a.length>f){c=typeof a[0];if(c===\"string\")b.name=\na[0];else if(c===\"number\")b.x=a[0];g++}for(;h<f;)b[e[h++]]=a[g++]}else if(typeof a===\"object\"){b=a;if(a.dataLabels)c._hasPointLabels=!0;if(a.marker)c._hasPointMarkers=!0}return b},destroy:function(){var a=this.series.chart,b=a.hoverPoints,c;a.pointCount--;if(b&&(this.setState(),ja(b,this),!b.length))a.hoverPoints=null;if(this===a.hoverPoint)this.onMouseOut();if(this.graphic||this.dataLabel)Z(this),this.destroyElements();this.legendItem&&a.legend.destroyItem(this);for(c in this)this[c]=null},destroyElements:function(){for(var a=\n\"graphic,dataLabel,dataLabelUpper,group,connector,shadowGroup\".split(\",\"),b,c=6;c--;)b=a[c],this[b]&&(this[b]=this[b].destroy())},getLabelConfig:function(){return{x:this.category,y:this.y,color:this.color,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}},tooltipFormatter:function(a){var b=this.series,c=b.tooltipOptions,d=p(c.valueDecimals,\"\"),e=c.valuePrefix||\"\",f=c.valueSuffix||\"\";o(b.pointArrayMap||[\"y\"],function(b){b=\"{point.\"+\nb;if(e||f)a=a.replace(b+\"}\",e+b+\"}\"+f);a=a.replace(b+\"}\",b+\":,.\"+d+\"f}\")});return Ha(a,{point:this,series:this.series})},firePointEvent:function(a,b,c){var d=this,e=this.series.options;(e.point.events[a]||d.options&&d.options.events&&d.options.events[a])&&this.importEvents();a===\"click\"&&e.allowPointSelect&&(c=function(a){d.select&&d.select(null,a.ctrlKey||a.metaKey||a.shiftKey)});I(this,a,b,c)}};var R=B.Series=function(){};R.prototype={isCartesian:!0,type:\"line\",pointClass:Ea,sorted:!0,requireSorting:!0,\npointAttrToOptions:{stroke:\"lineColor\",\"stroke-width\":\"lineWidth\",fill:\"fillColor\",r:\"radius\"},axisTypes:[\"xAxis\",\"yAxis\"],colorCounter:0,parallelArrays:[\"x\",\"y\"],init:function(a,b){var c=this,d,e,f=a.series,g=function(a,b){return p(a.options.index,a._i)-p(b.options.index,b._i)};c.chart=a;c.options=b=c.setOptions(b);c.linkedSeries=[];c.bindAxes();r(c,{name:b.name,state:\"\",pointAttr:{},visible:b.visible!==!1,selected:b.selected===!0});if(fa)b.animation=!1;e=b.events;for(d in e)H(c,d,e[d]);if(e&&e.click||\nb.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=!0;c.getColor();c.getSymbol();o(c.parallelArrays,function(a){c[a+\"Data\"]=[]});c.setData(b.data,!1);if(c.isCartesian)a.hasCartesianSeries=!0;f.push(c);c._i=f.length-1;pb(f,g);this.yAxis&&pb(this.yAxis.series,g);o(f,function(a,b){a.index=b;a.name=a.name||\"Series \"+(b+1)})},bindAxes:function(){var a=this,b=a.options,c=a.chart,d;o(a.axisTypes||[],function(e){o(c[e],function(c){d=c.options;if(b[e]===d.index||b[e]!==v&&\nb[e]===d.id||b[e]===v&&d.index===0)c.series.push(a),a[e]=c,c.isDirty=!0});!a[e]&&a.optionalAxis!==e&&la(18,!0)})},updateParallelArrays:function(a,b){var c=a.series,d=arguments;o(c.parallelArrays,typeof b===\"number\"?function(d){var f=d===\"y\"&&c.toYData?c.toYData(a):a[d];c[d+\"Data\"][b]=f}:function(a){Array.prototype[b].apply(c[a+\"Data\"],Array.prototype.slice.call(d,2))})},autoIncrement:function(){var a=this.options,b=this.xIncrement,c,d=a.pointIntervalUnit,b=p(b,a.pointStart,0);this.pointInterval=c=\np(this.pointInterval,a.pointInterval,1);if(d===\"month\"||d===\"year\")a=new ya(b),a=d===\"month\"?+a[ub](a[Xa]()+c):+a[vb](a[Ya]()+c),c=a-b;this.xIncrement=b+c;return b},getSegments:function(){var a=-1,b=[],c,d=this.points,e=d.length;if(e)if(this.options.connectNulls){for(c=e;c--;)d[c].y===null&&d.splice(c,1);d.length&&(b=[d])}else o(d,function(c,g){c.y===null?(g>a+1&&b.push(d.slice(a+1,g)),a=g):g===e-1&&b.push(d.slice(a+1,g+1))});this.segments=b},setOptions:function(a){var b=this.chart,c=b.options.plotOptions,\nb=b.userOptions||{},d=b.plotOptions||{},e=c[this.type];this.userOptions=a;c=A(e,c.series,a);this.tooltipOptions=A(S.tooltip,S.plotOptions[this.type].tooltip,b.tooltip,d.series&&d.series.tooltip,d[this.type]&&d[this.type].tooltip,a.tooltip);e.marker===null&&delete c.marker;this.zoneAxis=c.zoneAxis;a=this.zones=(c.zones||[]).slice();if((c.negativeColor||c.negativeFillColor)&&!c.zones)a.push({value:c[this.zoneAxis+\"Threshold\"]||c.threshold||0,color:c.negativeColor,fillColor:c.negativeFillColor});a.length&&\ns(a[a.length-1].value)&&a.push({color:this.color,fillColor:this.fillColor});return c},getCyclic:function(a,b,c){var d=this.userOptions,e=\"_\"+a+\"Index\",f=a+\"Counter\";b||(s(d[e])?b=d[e]:(d[e]=b=this.chart[f]%c.length,this.chart[f]+=1),b=c[b]);this[a]=b},getColor:function(){this.options.colorByPoint?this.options.color=null:this.getCyclic(\"color\",this.options.color||ba[this.type].color,this.chart.options.colors)},getSymbol:function(){var a=this.options.marker;this.getCyclic(\"symbol\",a.symbol,this.chart.options.symbols);\nif(/^url/.test(this.symbol))a.radius=0},drawLegendSymbol:La.drawLineMarker,setData:function(a,b,c,d){var e=this,f=e.points,g=f&&f.length||0,h,i=e.options,j=e.chart,k=null,m=e.xAxis,l=m&&!!m.categories,n=i.turboThreshold,q=this.xData,x=this.yData,t=(h=e.pointArrayMap)&&h.length,a=a||[];h=a.length;b=p(b,!0);if(d!==!1&&h&&g===h&&!e.cropped&&!e.hasGroupedData&&e.visible)o(a,function(a,b){f[b].update&&f[b].update(a,!1,null,!1)});else{e.xIncrement=null;e.pointRange=l?1:i.pointRange;e.colorCounter=0;o(this.parallelArrays,\nfunction(a){e[a+\"Data\"].length=0});if(n&&h>n){for(c=0;k===null&&c<h;)k=a[c],c++;if(qa(k)){l=p(i.pointStart,0);i=p(i.pointInterval,1);for(c=0;c<h;c++)q[c]=l,x[c]=a[c],l+=i;e.xIncrement=l}else if(Fa(k))if(t)for(c=0;c<h;c++)i=a[c],q[c]=i[0],x[c]=i.slice(1,t+1);else for(c=0;c<h;c++)i=a[c],q[c]=i[0],x[c]=i[1];else la(12)}else for(c=0;c<h;c++)if(a[c]!==v&&(i={series:e},e.pointClass.prototype.applyOptions.apply(i,[a[c]]),e.updateParallelArrays(i,c),l&&s(i.name)))m.names[i.x]=i.name;Aa(x[0])&&la(14,!0);e.data=\n[];e.options.data=a;for(c=g;c--;)f[c]&&f[c].destroy&&f[c].destroy();if(m)m.minRange=m.userMinRange;e.isDirty=e.isDirtyData=j.isDirtyBox=!0;c=!1}b&&j.redraw(c)},processData:function(a){var b=this.xData,c=this.yData,d=b.length,e;e=0;var f,g,h=this.xAxis,i,j=this.options;i=j.cropThreshold;var k=this.isCartesian,m,l;if(k&&!this.isDirty&&!h.isDirty&&!this.yAxis.isDirty&&!a)return!1;if(h)a=h.getExtremes(),m=a.min,l=a.max;if(k&&this.sorted&&(!i||d>i||this.forceCrop))if(b[d-1]<m||b[0]>l)b=[],c=[];else if(b[0]<\nm||b[d-1]>l)e=this.cropData(this.xData,this.yData,m,l),b=e.xData,c=e.yData,e=e.start,f=!0;for(i=b.length-1;i>=0;i--)d=b[i]-b[i-1],d>0&&(g===v||d<g)?g=d:d<0&&this.requireSorting&&la(15);this.cropped=f;this.cropStart=e;this.processedXData=b;this.processedYData=c;if(j.pointRange===null)this.pointRange=g||1;this.closestPointRange=g},cropData:function(a,b,c,d){var e=a.length,f=0,g=e,h=p(this.cropShoulder,1),i;for(i=0;i<e;i++)if(a[i]>=c){f=t(0,i-h);break}for(;i<e;i++)if(a[i]>d){g=i+h;break}return{xData:a.slice(f,\ng),yData:b.slice(f,g),start:f,end:g}},generatePoints:function(){var a=this.options.data,b=this.data,c,d=this.processedXData,e=this.processedYData,f=this.pointClass,g=d.length,h=this.cropStart||0,i,j=this.hasGroupedData,k,m=[],l;if(!b&&!j)b=[],b.length=a.length,b=this.data=b;for(l=0;l<g;l++)i=h+l,j?m[l]=(new f).init(this,[d[l]].concat(ra(e[l]))):(b[i]?k=b[i]:a[i]!==v&&(b[i]=k=(new f).init(this,a[i],d[l])),m[l]=k),m[l].index=i;if(b&&(g!==(c=b.length)||j))for(l=0;l<c;l++)if(l===h&&!j&&(l+=g),b[l])b[l].destroyElements(),\nb[l].plotX=v;this.data=b;this.points=m},getExtremes:function(a){var b=this.yAxis,c=this.processedXData,d,e=[],f=0;d=this.xAxis.getExtremes();var g=d.min,h=d.max,i,j,k,m,a=a||this.stackedYData||this.processedYData;d=a.length;for(m=0;m<d;m++)if(j=c[m],k=a[m],i=k!==null&&k!==v&&(!b.isLog||k.length||k>0),j=this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||(c[m+1]||j)>=g&&(c[m-1]||j)<=h,i&&j)if(i=k.length)for(;i--;)k[i]!==null&&(e[f++]=k[i]);else e[f++]=k;this.dataMin=Na(e);this.dataMax=\nCa(e)},translate:function(){this.processedXData||this.processData();this.generatePoints();for(var a=this.options,b=a.stacking,c=this.xAxis,d=c.categories,e=this.yAxis,f=this.points,g=f.length,h=!!this.modifyValue,i=a.pointPlacement,j=i===\"between\"||qa(i),k=a.threshold,m=a.startFromThreshold?k:0,l,n,q,o=Number.MAX_VALUE,a=0;a<g;a++){var r=f[a],w=r.x,u=r.y;n=r.low;var y=b&&e.stacks[(this.negStacks&&u<(m?0:k)?\"-\":\"\")+this.stackKey];if(e.isLog&&u!==null&&u<=0)r.y=u=null,la(10);r.plotX=l=z(t(-1E5,c.translate(w,\n0,0,0,1,i,this.type===\"flags\")),1E5);if(b&&this.visible&&y&&y[w])y=y[w],u=y.points[this.index+\",\"+a],n=u[0],u=u[1],n===m&&(n=p(k,e.min)),e.isLog&&n<=0&&(n=null),r.total=r.stackTotal=y.total,r.percentage=y.total&&r.y/y.total*100,r.stackY=u,y.setOffset(this.pointXOffset||0,this.barW||0);r.yBottom=s(n)?e.translate(n,0,1,0,1):null;h&&(u=this.modifyValue(u,r));r.plotY=n=typeof u===\"number\"&&u!==Infinity?z(t(-1E5,e.translate(u,0,1,0,1)),1E5):v;r.isInside=n!==v&&n>=0&&n<=e.len&&l>=0&&l<=c.len;r.clientX=\nj?c.translate(w,0,0,0,1):l;r.negative=r.y<(k||0);r.category=d&&d[r.x]!==v?d[r.x]:r.x;a&&(o=z(o,N(l-q)));q=l}this.closestPointRangePx=o;this.getSegments()},setClip:function(a){var b=this.chart,c=b.renderer,d=b.inverted,e=this.clipBox,f=e||b.clipBox,g=this.sharedClipKey||[\"_sharedClip\",a&&a.duration,a&&a.easing,f.height].join(\",\"),h=b[g],i=b[g+\"m\"];if(!h){if(a)f.width=0,b[g+\"m\"]=i=c.clipRect(-99,d?-b.plotLeft:-b.plotTop,99,d?b.chartWidth:b.chartHeight);b[g]=h=c.clipRect(f)}a&&(h.count+=1);if(this.options.clip!==\n!1)this.group.clip(a||e?h:b.clipRect),this.markerGroup.clip(i),this.sharedClipKey=g;a||(h.count-=1,h.count<=0&&g&&b[g]&&(e||(b[g]=b[g].destroy()),b[g+\"m\"]&&(b[g+\"m\"]=b[g+\"m\"].destroy())))},animate:function(a){var b=this.chart,c=this.options.animation,d;if(c&&!da(c))c=ba[this.type].animation;a?this.setClip(c):(d=this.sharedClipKey,(a=b[d])&&a.animate({width:b.plotSizeX},c),b[d+\"m\"]&&b[d+\"m\"].animate({width:b.plotSizeX+99},c),this.animate=null)},afterAnimate:function(){this.setClip();I(this,\"afterAnimate\")},\ndrawPoints:function(){var a,b=this.points,c=this.chart,d,e,f,g,h,i,j,k,m=this.options.marker,l=this.pointAttr[\"\"],n,q,o,t=this.markerGroup,s=p(m.enabled,this.xAxis.isRadial,this.closestPointRangePx>2*m.radius);if(m.enabled!==!1||this._hasPointMarkers)for(f=b.length;f--;)if(g=b[f],d=V(g.plotX),e=g.plotY,k=g.graphic,n=g.marker||{},q=!!g.marker,a=s&&n.enabled===v||n.enabled,o=g.isInside,a&&e!==v&&!isNaN(e)&&g.y!==null)if(a=g.pointAttr[g.selected?\"select\":\"\"]||l,h=a.r,i=p(n.symbol,this.symbol),j=i.indexOf(\"url\")===\n0,k)k[o?\"show\":\"hide\"](!0).animate(r({x:d-h,y:e-h},k.symbolName?{width:2*h,height:2*h}:{}));else{if(o&&(h>0||j))g.graphic=c.renderer.symbol(i,d-h,e-h,2*h,2*h,q?n:m).attr(a).add(t)}else if(k)g.graphic=k.destroy()},convertAttribs:function(a,b,c,d){var e=this.pointAttrToOptions,f,g,h={},a=a||{},b=b||{},c=c||{},d=d||{};for(f in e)g=e[f],h[f]=p(a[g],b[f],c[f],d[f]);return h},getAttribs:function(){var a=this,b=a.options,c=ba[a.type].marker?b.marker:b,d=c.states,e=d.hover,f,g=a.color,h=a.options.negativeColor;\nf={stroke:g,fill:g};var i=a.points||[],j,k,m=[],l=a.pointAttrToOptions;j=a.hasPointSpecificOptions;var n=c.lineColor,q=c.fillColor;k=b.turboThreshold;var p=a.zones,t=a.zoneAxis||\"y\",w;b.marker?(e.radius=e.radius||c.radius+e.radiusPlus,e.lineWidth=e.lineWidth||c.lineWidth+e.lineWidthPlus):(e.color=e.color||na(e.color||g).brighten(e.brightness).get(),e.negativeColor=e.negativeColor||na(e.negativeColor||h).brighten(e.brightness).get());m[\"\"]=a.convertAttribs(c,f);o([\"hover\",\"select\"],function(b){m[b]=\na.convertAttribs(d[b],m[\"\"])});a.pointAttr=m;g=i.length;if(!k||g<k||j)for(;g--;){k=i[g];if((c=k.options&&k.options.marker||k.options)&&c.enabled===!1)c.radius=0;if(p.length){j=0;for(f=p[j];k[t]>=f.value;)f=p[++j];if(f.color)k.color=k.fillColor=f.color}j=b.colorByPoint||k.color;if(k.options)for(w in l)s(c[l[w]])&&(j=!0);if(j){c=c||{};j=[];d=c.states||{};f=d.hover=d.hover||{};if(!b.marker)f.color=f.color||!k.options.color&&e[k.negative&&h?\"negativeColor\":\"color\"]||na(k.color).brighten(f.brightness||\ne.brightness).get();f={color:k.color};if(!q)f.fillColor=k.color;if(!n)f.lineColor=k.color;c.hasOwnProperty(\"color\")&&!c.color&&delete c.color;j[\"\"]=a.convertAttribs(r(f,c),m[\"\"]);j.hover=a.convertAttribs(d.hover,m.hover,j[\"\"]);j.select=a.convertAttribs(d.select,m.select,j[\"\"])}else j=m;k.pointAttr=j}},destroy:function(){var a=this,b=a.chart,c=/AppleWebKit\\/533/.test(za),d,e=a.data||[],f,g,h;I(a,\"destroy\");Z(a);o(a.axisTypes||[],function(b){if(h=a[b])ja(h.series,a),h.isDirty=h.forceRedraw=!0});a.legendItem&&\na.chart.legend.destroyItem(a);for(d=e.length;d--;)(f=e[d])&&f.destroy&&f.destroy();a.points=null;clearTimeout(a.animationTimeout);for(g in a)a[g]instanceof P&&!a[g].survive&&(d=c&&g===\"group\"?\"hide\":\"destroy\",a[g][d]());if(b.hoverSeries===a)b.hoverSeries=null;ja(b.series,a);for(g in a)delete a[g]},getSegmentPath:function(a){var b=this,c=[],d=b.options.step;o(a,function(e,f){var g=e.plotX,h=e.plotY,i;b.getPointSpline?c.push.apply(c,b.getPointSpline(a,e,f)):(c.push(f?\"L\":\"M\"),d&&f&&(i=a[f-1],d===\"right\"?\nc.push(i.plotX,h):d===\"center\"?c.push((i.plotX+g)/2,i.plotY,(i.plotX+g)/2,h):c.push(g,i.plotY)),c.push(e.plotX,e.plotY))});return c},getGraphPath:function(){var a=this,b=[],c,d=[];o(a.segments,function(e){c=a.getSegmentPath(e);e.length>1?b=b.concat(c):d.push(e[0])});a.singlePoints=d;return a.graphPath=b},drawGraph:function(){var a=this,b=this.options,c=[[\"graph\",b.lineColor||this.color,b.dashStyle]],d=b.lineWidth,e=b.linecap!==\"square\",f=this.getGraphPath(),g=this.fillGraph&&this.color||O;o(this.zones,\nfunction(d,e){c.push([\"zoneGraph\"+e,d.color||a.color,d.dashStyle||b.dashStyle])});o(c,function(c,i){var j=c[0],k=a[j];if(k)k.animate({d:f});else if((d||g)&&f.length)k={stroke:c[1],\"stroke-width\":d,fill:g,zIndex:1},c[2]?k.dashstyle=c[2]:e&&(k[\"stroke-linecap\"]=k[\"stroke-linejoin\"]=\"round\"),a[j]=a.chart.renderer.path(f).attr(k).add(a.group).shadow(i<2&&b.shadow)})},applyZones:function(){var a=this,b=this.chart,c=b.renderer,d=this.zones,e,f,g=this.clips||[],h,i=this.graph,j=this.area,k=t(b.chartWidth,\nb.chartHeight),m=this[(this.zoneAxis||\"y\")+\"Axis\"],l,n=m.reversed,q=b.inverted,x=m.horiz,r,s,u,y=!1;if(d.length&&(i||j)&&m.min!==v)i&&i.hide(),j&&j.hide(),l=m.getExtremes(),o(d,function(d,o){e=n?x?b.plotWidth:0:x?0:m.toPixels(l.min);e=z(t(p(f,e),0),k);f=z(t(w(m.toPixels(p(d.value,l.max),!0)),0),k);y&&(e=f=m.toPixels(l.max));r=Math.abs(e-f);s=z(e,f);u=t(e,f);if(m.isXAxis){if(h={x:q?u:s,y:0,width:r,height:k},!x)h.x=b.plotHeight-h.x}else if(h={x:0,y:q?u:s,width:k,height:r},x)h.y=b.plotWidth-h.y;b.inverted&&\nc.isVML&&(h=m.isXAxis?{x:0,y:n?s:u,height:h.width,width:b.chartWidth}:{x:h.y-b.plotLeft-b.spacingBox.x,y:0,width:h.height,height:b.chartHeight});g[o]?g[o].animate(h):(g[o]=c.clipRect(h),i&&a[\"zoneGraph\"+o].clip(g[o]),j&&a[\"zoneArea\"+o].clip(g[o]));y=d.value>l.max}),this.clips=g},invertGroups:function(){function a(){var a={width:b.yAxis.len,height:b.xAxis.len};o([\"group\",\"markerGroup\"],function(c){b[c]&&b[c].attr(a).invert()})}var b=this,c=b.chart;if(b.xAxis)H(c,\"resize\",a),H(b,\"destroy\",function(){Z(c,\n\"resize\",a)}),a(),b.invertGroups=a},plotGroup:function(a,b,c,d,e){var f=this[a],g=!f;g&&(this[a]=f=this.chart.renderer.g(b).attr({visibility:c,zIndex:d||0.1}).add(e));f[g?\"attr\":\"animate\"](this.getPlotBox());return f},getPlotBox:function(){var a=this.chart,b=this.xAxis,c=this.yAxis;if(a.inverted)b=c,c=this.xAxis;return{translateX:b?b.left:a.plotLeft,translateY:c?c.top:a.plotTop,scaleX:1,scaleY:1}},render:function(){var a=this,b=a.chart,c,d=a.options,e=(c=d.animation)&&!!a.animate&&b.renderer.isSVG&&\np(c.duration,500)||0,f=a.visible?\"visible\":\"hidden\",g=d.zIndex,h=a.hasRendered,i=b.seriesGroup;c=a.plotGroup(\"group\",\"series\",f,g,i);a.markerGroup=a.plotGroup(\"markerGroup\",\"markers\",f,g,i);e&&a.animate(!0);a.getAttribs();c.inverted=a.isCartesian?b.inverted:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());o(a.points,function(a){a.redraw&&a.redraw()});a.drawDataLabels&&a.drawDataLabels();a.visible&&a.drawPoints();a.drawTracker&&a.options.enableMouseTracking!==!1&&a.drawTracker();b.inverted&&a.invertGroups();\nd.clip!==!1&&!a.sharedClipKey&&!h&&c.clip(b.clipRect);e&&a.animate();if(!h)e?a.animationTimeout=setTimeout(function(){a.afterAnimate()},e):a.afterAnimate();a.isDirty=a.isDirtyData=!1;a.hasRendered=!0},redraw:function(){var a=this.chart,b=this.isDirtyData,c=this.isDirty,d=this.group,e=this.xAxis,f=this.yAxis;d&&(a.inverted&&d.attr({width:a.plotWidth,height:a.plotHeight}),d.animate({translateX:p(e&&e.left,a.plotLeft),translateY:p(f&&f.top,a.plotTop)}));this.translate();this.render();b&&I(this,\"updatedData\");\n(c||b)&&delete this.kdTree},kdDimensions:1,kdAxisArray:[\"clientX\",\"plotY\"],searchPoint:function(a,b){var c=this.xAxis,d=this.yAxis,e=this.chart.inverted;return this.searchKDTree({clientX:e?c.len-a.chartY+c.pos:a.chartX-c.pos,plotY:e?d.len-a.chartX+d.pos:a.chartY-d.pos},b)},buildKDTree:function(){function a(b,d,g){var h,i;if(i=b&&b.length)return h=c.kdAxisArray[d%g],b.sort(function(a,b){return a[h]-b[h]}),i=Math.floor(i/2),{point:b[i],left:a(b.slice(0,i),d+1,g),right:a(b.slice(i+1),d+1,g)}}function b(){var b=\nib(c.points||[],function(a){return a.y!==null});c.kdTree=a(b,d,d)}var c=this,d=c.kdDimensions;delete c.kdTree;c.options.kdSync?b():setTimeout(b)},searchKDTree:function(a,b){function c(a,b,j,k){var m=b.point,l=d.kdAxisArray[j%k],n,q,p=m;q=s(a[e])&&s(m[e])?Math.pow(a[e]-m[e],2):null;n=s(a[f])&&s(m[f])?Math.pow(a[f]-m[f],2):null;n=(q||0)+(n||0);m.dist=s(n)?Math.sqrt(n):Number.MAX_VALUE;m.distX=s(q)?Math.sqrt(q):Number.MAX_VALUE;l=a[l]-m[l];n=l<0?\"left\":\"right\";q=l<0?\"right\":\"left\";b[n]&&(n=c(a,b[n],\nj+1,k),p=n[g]<p[g]?n:m);b[q]&&Math.sqrt(l*l)<p[g]&&(a=c(a,b[q],j+1,k),p=a[g]<p[g]?a:p);return p}var d=this,e=this.kdAxisArray[0],f=this.kdAxisArray[1],g=b?\"distX\":\"dist\";this.kdTree||this.buildKDTree();if(this.kdTree)return c(a,this.kdTree,this.kdDimensions,this.kdDimensions)}};Hb.prototype={destroy:function(){Oa(this,this.axis)},render:function(a){var b=this.options,c=b.format,c=c?Ha(c,this):b.formatter.call(this);this.label?this.label.attr({text:c,visibility:\"hidden\"}):this.label=this.axis.chart.renderer.text(c,\nnull,null,b.useHTML).css(b.style).attr({align:this.textAlign,rotation:b.rotation,visibility:\"hidden\"}).add(a)},setOffset:function(a,b){var c=this.axis,d=c.chart,e=d.inverted,f=c.reversed,f=this.isNegative&&!f||!this.isNegative&&f,g=c.translate(c.usePercentage?100:this.total,0,0,0,1),c=c.translate(0),c=N(g-c),h=d.xAxis[0].translate(this.x)+a,i=d.plotHeight,f={x:e?f?g:g-c:h,y:e?i-h-b:f?i-g-c:i-g,width:e?c:b,height:e?b:c};if(e=this.label)e.align(this.alignOptions,null,f),f=e.alignAttr,e[this.options.crop===\n!1||d.isInsidePlot(f.x,f.y)?\"show\":\"hide\"](!0)}};D.prototype.getStacks=function(){var a=this;o(a.yAxis,function(a){if(a.stacks&&a.hasVisibleSeries)a.oldStacks=a.stacks});o(a.series,function(b){if(b.options.stacking&&(b.visible===!0||a.options.chart.ignoreHiddenSeries===!1))b.stackKey=b.type+p(b.options.stack,\"\")})};ha.prototype.buildStacks=function(){var a=this.series,b=p(this.options.reversedStacks,!0),c=a.length;if(!this.isXAxis){for(this.usePercentage=!1;c--;)a[b?c:a.length-c-1].setStackedPoints();\nif(this.usePercentage)for(c=0;c<a.length;c++)a[c].setPercentStacks()}};ha.prototype.renderStackTotals=function(){var a=this.chart,b=a.renderer,c=this.stacks,d,e,f=this.stackTotalGroup;if(!f)this.stackTotalGroup=f=b.g(\"stack-labels\").attr({visibility:\"visible\",zIndex:6}).add();f.translate(a.plotLeft,a.plotTop);for(d in c)for(e in a=c[d],a)a[e].render(f)};ha.prototype.resetStacks=function(){var a=this.stacks,b,c;if(!this.isXAxis)for(b in a)for(c in a[b])a[b][c].touched<this.stacksTouched?(a[b][c].destroy(),\ndelete a[b][c]):(a[b][c].total=null,a[b][c].cum=0)};ha.prototype.cleanStacks=function(){var a,b,c;if(!this.isXAxis){if(this.oldStacks)a=this.stacks=this.oldStacks;for(b in a)for(c in a[b])a[b][c].cum=a[b][c].total}};R.prototype.setStackedPoints=function(){if(this.options.stacking&&!(this.visible!==!0&&this.chart.options.chart.ignoreHiddenSeries!==!1)){var a=this.processedXData,b=this.processedYData,c=[],d=b.length,e=this.options,f=e.threshold,g=e.startFromThreshold?f:0,h=e.stack,e=e.stacking,i=this.stackKey,\nj=\"-\"+i,k=this.negStacks,m=this.yAxis,l=m.stacks,n=m.oldStacks,q,o,r,s,u,y;m.stacksTouched+=1;for(s=0;s<d;s++){u=a[s];y=b[s];r=this.index+\",\"+s;o=(q=k&&y<(g?0:f))?j:i;l[o]||(l[o]={});if(!l[o][u])n[o]&&n[o][u]?(l[o][u]=n[o][u],l[o][u].total=null):l[o][u]=new Hb(m,m.options.stackLabels,q,u,h);o=l[o][u];o.points[r]=[p(o.cum,g)];o.touched=m.stacksTouched;e===\"percent\"?(q=q?i:j,k&&l[q]&&l[q][u]?(q=l[q][u],o.total=q.total=t(q.total,o.total)+N(y)||0):o.total=ea(o.total+(N(y)||0))):o.total=ea(o.total+(y||\n0));o.cum=p(o.cum,g)+(y||0);o.points[r].push(o.cum);c[s]=o.cum}if(e===\"percent\")m.usePercentage=!0;this.stackedYData=c;m.oldStacks={}}};R.prototype.setPercentStacks=function(){var a=this,b=a.stackKey,c=a.yAxis.stacks,d=a.processedXData;o([b,\"-\"+b],function(b){var e;for(var f=d.length,g,h;f--;)if(g=d[f],e=(h=c[b]&&c[b][g])&&h.points[a.index+\",\"+f],g=e)h=h.total?100/h.total:0,g[0]=ea(g[0]*h),g[1]=ea(g[1]*h),a.stackedYData[f]=g[1]})};r(D.prototype,{addSeries:function(a,b,c){var d,e=this;a&&(b=p(b,!0),\nI(e,\"addSeries\",{options:a},function(){d=e.initSeries(a);e.isDirtyLegend=!0;e.linkSeries();b&&e.redraw(c)}));return d},addAxis:function(a,b,c,d){var e=b?\"xAxis\":\"yAxis\",f=this.options;new ha(this,A(a,{index:this[e].length,isX:b}));f[e]=ra(f[e]||{});f[e].push(a);p(c,!0)&&this.redraw(d)},showLoading:function(a){var b=this,c=b.options,d=b.loadingDiv,e=c.loading,f=function(){d&&L(d,{left:b.plotLeft+\"px\",top:b.plotTop+\"px\",width:b.plotWidth+\"px\",height:b.plotHeight+\"px\"})};if(!d)b.loadingDiv=d=$(Ia,{className:\"highcharts-loading\"},\nr(e.style,{zIndex:10,display:O}),b.container),b.loadingSpan=$(\"span\",null,e.labelStyle,d),H(b,\"redraw\",f);b.loadingSpan.innerHTML=a||c.lang.loading;if(!b.loadingShown)L(d,{opacity:0,display:\"\"}),jb(d,{opacity:e.style.opacity},{duration:e.showDuration||0}),b.loadingShown=!0;f()},hideLoading:function(){var a=this.options,b=this.loadingDiv;b&&jb(b,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){L(b,{display:O})}});this.loadingShown=!1}});r(Ea.prototype,{update:function(a,b,c,d){function e(){f.applyOptions(a);\nif(f.y===null&&h)f.graphic=h.destroy();if(da(a)&&!Fa(a))f.redraw=function(){if(h&&h.element&&a&&a.marker&&a.marker.symbol)f.graphic=h.destroy();if(a&&a.dataLabels&&f.dataLabel)f.dataLabel=f.dataLabel.destroy();f.redraw=null};i=f.index;g.updateParallelArrays(f,i);if(m&&f.name)m[f.x]=f.name;k.data[i]=f.options;g.isDirty=g.isDirtyData=!0;if(!g.fixedBox&&g.hasCartesianSeries)j.isDirtyBox=!0;if(k.legendType===\"point\")j.isDirtyLegend=!0;b&&j.redraw(c)}var f=this,g=f.series,h=f.graphic,i,j=g.chart,k=g.options,\nm=g.xAxis&&g.xAxis.names,b=p(b,!0);d===!1?e():f.firePointEvent(\"update\",{options:a},e)},remove:function(a,b){this.series.removePoint(Ka(this,this.series.data),a,b)}});r(R.prototype,{addPoint:function(a,b,c,d){var e=this,f=e.options,g=e.data,h=e.graph,i=e.area,j=e.chart,k=e.xAxis&&e.xAxis.names,m=h&&h.shift||0,l=[\"graph\",\"area\"],h=f.data,n,q=e.xData;Qa(d,j);if(c){for(d=e.zones.length;d--;)l.push(\"zoneGraph\"+d,\"zoneArea\"+d);o(l,function(a){if(e[a])e[a].shift=m+1})}if(i)i.isArea=!0;b=p(b,!0);i={series:e};\ne.pointClass.prototype.applyOptions.apply(i,[a]);l=i.x;d=q.length;if(e.requireSorting&&l<q[d-1])for(n=!0;d&&q[d-1]>l;)d--;e.updateParallelArrays(i,\"splice\",d,0,0);e.updateParallelArrays(i,d);if(k&&i.name)k[l]=i.name;h.splice(d,0,a);n&&(e.data.splice(d,0,null),e.processData());f.legendType===\"point\"&&e.generatePoints();c&&(g[0]&&g[0].remove?g[0].remove(!1):(g.shift(),e.updateParallelArrays(i,\"shift\"),h.shift()));e.isDirty=!0;e.isDirtyData=!0;b&&(e.getAttribs(),j.redraw())},removePoint:function(a,b,\nc){var d=this,e=d.data,f=e[a],g=d.points,h=d.chart,i=function(){e.length===g.length&&g.splice(a,1);e.splice(a,1);d.options.data.splice(a,1);d.updateParallelArrays(f||{series:d},\"splice\",a,1);f&&f.destroy();d.isDirty=!0;d.isDirtyData=!0;b&&h.redraw()};Qa(c,h);b=p(b,!0);f?f.firePointEvent(\"remove\",null,i):i()},remove:function(a,b){var c=this,d=c.chart,a=p(a,!0);if(!c.isRemoving)c.isRemoving=!0,I(c,\"remove\",null,function(){c.destroy();d.isDirtyLegend=d.isDirtyBox=!0;d.linkSeries();a&&d.redraw(b)});c.isRemoving=\n!1},update:function(a,b){var c=this,d=this.chart,e=this.userOptions,f=this.type,g=M[f].prototype,h=[\"group\",\"markerGroup\",\"dataLabelsGroup\"],i;if(a.type&&a.type!==f||a.zIndex!==void 0)h.length=0;o(h,function(a){h[a]=c[a];delete c[a]});a=A(e,{animation:!1,index:this.index,pointStart:this.xData[0]},{data:this.options.data},a);this.remove(!1);for(i in g)this[i]=v;r(this,M[a.type||f].prototype);o(h,function(a){c[a]=h[a]});this.init(d,a);d.linkSeries();p(b,!0)&&d.redraw(!1)}});r(ha.prototype,{update:function(a,\nb){var c=this.chart,a=c.options[this.coll][this.options.index]=A(this.userOptions,a);this.destroy(!0);this._addedPlotLB=this.chart._labelPanes=v;this.init(c,r(a,{events:v}));c.isDirtyBox=!0;p(b,!0)&&c.redraw()},remove:function(a){for(var b=this.chart,c=this.coll,d=this.series,e=d.length;e--;)d[e]&&d[e].remove(!1);ja(b.axes,this);ja(b[c],this);b.options[c].splice(this.options.index,1);o(b[c],function(a,b){a.options.index=b});this.destroy();b.isDirtyBox=!0;p(a,!0)&&b.redraw()},setTitle:function(a,b){this.update({title:a},\nb)},setCategories:function(a,b){this.update({categories:a},b)}});var wa=ka(R);M.line=wa;ba.area=A(U,{threshold:0});var pa=ka(R,{type:\"area\",getSegments:function(){var a=this,b=[],c=[],d=[],e=this.xAxis,f=this.yAxis,g=f.stacks[this.stackKey],h={},i,j,k=this.points,m=this.options.connectNulls,l,n;if(this.options.stacking&&!this.cropped){for(l=0;l<k.length;l++)h[k[l].x]=k[l];for(n in g)g[n].total!==null&&d.push(+n);d.sort(function(a,b){return a-b});o(d,function(b){var d=0,k;if(!m||h[b]&&h[b].y!==null)if(h[b])c.push(h[b]);\nelse{for(l=a.index;l<=f.series.length;l++)if(k=g[b].points[l+\",\"+b]){d=k[1];break}i=e.translate(b);j=f.toPixels(d,!0);c.push({y:null,plotX:i,clientX:i,plotY:j,yBottom:j,onMouseOver:ta})}});c.length&&b.push(c)}else R.prototype.getSegments.call(this),b=this.segments;this.segments=b},getSegmentPath:function(a){var b=R.prototype.getSegmentPath.call(this,a),c=[].concat(b),d,e=this.options;d=b.length;var f=this.yAxis.getThreshold(e.threshold),g;d===3&&c.push(\"L\",b[1],b[2]);if(e.stacking&&!this.closedStacks)for(d=\na.length-1;d>=0;d--)g=p(a[d].yBottom,f),d<a.length-1&&e.step&&c.push(a[d+1].plotX,g),c.push(a[d].plotX,g);else this.closeSegment(c,a,f);this.areaPath=this.areaPath.concat(c);return b},closeSegment:function(a,b,c){a.push(\"L\",b[b.length-1].plotX,c,\"L\",b[0].plotX,c)},drawGraph:function(){this.areaPath=[];R.prototype.drawGraph.apply(this);var a=this,b=this.areaPath,c=this.options,d=[[\"area\",this.color,c.fillColor]];o(this.zones,function(b,f){d.push([\"zoneArea\"+f,b.color||a.color,b.fillColor||c.fillColor])});\no(d,function(d){var f=d[0],g=a[f];g?g.animate({d:b}):a[f]=a.chart.renderer.path(b).attr({fill:p(d[2],na(d[1]).setOpacity(p(c.fillOpacity,0.75)).get()),zIndex:0}).add(a.group)})},drawLegendSymbol:La.drawRectangle});M.area=pa;ba.spline=A(U);wa=ka(R,{type:\"spline\",getPointSpline:function(a,b,c){var d=b.plotX,e=b.plotY,f=a[c-1],g=a[c+1],h,i,j,k;if(f&&g){a=f.plotY;j=g.plotX;var g=g.plotY,m;h=(1.5*d+f.plotX)/2.5;i=(1.5*e+a)/2.5;j=(1.5*d+j)/2.5;k=(1.5*e+g)/2.5;m=(k-i)*(j-d)/(j-h)+e-k;i+=m;k+=m;i>a&&i>e?\n(i=t(a,e),k=2*e-i):i<a&&i<e&&(i=z(a,e),k=2*e-i);k>g&&k>e?(k=t(g,e),i=2*e-k):k<g&&k<e&&(k=z(g,e),i=2*e-k);b.rightContX=j;b.rightContY=k}c?(b=[\"C\",f.rightContX||f.plotX,f.rightContY||f.plotY,h||d,i||e,d,e],f.rightContX=f.rightContY=null):b=[\"M\",d,e];return b}});M.spline=wa;ba.areaspline=A(ba.area);pa=pa.prototype;wa=ka(wa,{type:\"areaspline\",closedStacks:!0,getSegmentPath:pa.getSegmentPath,closeSegment:pa.closeSegment,drawGraph:pa.drawGraph,drawLegendSymbol:La.drawRectangle});M.areaspline=wa;ba.column=\nA(U,{borderColor:\"#FFFFFF\",borderRadius:0,groupPadding:0.2,marker:null,pointPadding:0.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{brightness:0.1,shadow:!1,halo:!1},select:{color:\"#C0C0C0\",borderColor:\"#000000\",shadow:!1}},dataLabels:{align:null,verticalAlign:null,y:null},startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0});wa=ka(R,{type:\"column\",pointAttrToOptions:{stroke:\"borderColor\",fill:\"color\",r:\"borderRadius\"},cropShoulder:0,directTouch:!0,trackerGroups:[\"group\",\n\"dataLabelsGroup\"],negStacks:!0,init:function(){R.prototype.init.apply(this,arguments);var a=this,b=a.chart;b.hasRendered&&o(b.series,function(b){if(b.type===a.type)b.isDirty=!0})},getColumnMetrics:function(){var a=this,b=a.options,c=a.xAxis,d=a.yAxis,e=c.reversed,f,g={},h,i=0;b.grouping===!1?i=1:o(a.chart.series,function(b){var c=b.options,e=b.yAxis;if(b.type===a.type&&b.visible&&d.len===e.len&&d.pos===e.pos)c.stacking?(f=b.stackKey,g[f]===v&&(g[f]=i++),h=g[f]):c.grouping!==!1&&(h=i++),b.columnIndex=\nh});var j=z(N(c.transA)*(c.ordinalSlope||b.pointRange||c.closestPointRange||c.tickInterval||1),c.len),k=j*b.groupPadding,m=(j-2*k)/i,b=z(b.maxPointWidth||c.len,p(b.pointWidth,m*(1-2*b.pointPadding)));return a.columnMetrics={width:b,offset:(m-b)/2+(k+((e?i-(a.columnIndex||0):a.columnIndex)||0)*m-j/2)*(e?-1:1)}},translate:function(){var a=this,b=a.chart,c=a.options,d=a.borderWidth=p(c.borderWidth,a.closestPointRange*a.xAxis.transA<2?0:1),e=a.yAxis,f=a.translatedThreshold=e.getThreshold(c.threshold),\ng=p(c.minPointLength,5),h=a.getColumnMetrics(),i=h.width,j=a.barW=t(i,1+2*d),k=a.pointXOffset=h.offset,m=-(d%2?0.5:0),l=d%2?0.5:1;b.inverted&&(f-=0.5,b.renderer.isVML&&(l+=1));c.pointPadding&&(j=sa(j));R.prototype.translate.apply(a);o(a.points,function(c){var d=p(c.yBottom,f),h=999+N(d),h=z(t(-h,c.plotY),e.len+h),o=c.plotX+k,r=j,s=z(h,d),y,v;y=t(h,d)-s;N(y)<g&&g&&(y=g,v=!e.reversed&&!c.negative||e.reversed&&c.negative,s=w(N(s-f)>g?d-g:f-(v?g:0)));c.barX=o;c.pointWidth=i;r=w(o+r)+m;o=w(o)+m;r-=o;d=\nN(s)<0.5;y=z(w(s+y)+l,9E4);s=w(s)+l;y-=s;d&&(s-=1,y+=1);c.tooltipPos=b.inverted?[e.len+e.pos-b.plotLeft-h,a.xAxis.len-o-r/2,y]:[o+r/2,h+e.pos-b.plotTop,y];c.shapeType=\"rect\";c.shapeArgs={x:o,y:s,width:r,height:y}})},getSymbol:ta,drawLegendSymbol:La.drawRectangle,drawGraph:ta,drawPoints:function(){var a=this,b=this.chart,c=a.options,d=b.renderer,e=c.animationLimit||250,f,g;o(a.points,function(h){var i=h.plotY,j=h.graphic;if(i!==v&&!isNaN(i)&&h.y!==null)f=h.shapeArgs,i=s(a.borderWidth)?{\"stroke-width\":a.borderWidth}:\n{},g=h.pointAttr[h.selected?\"select\":\"\"]||a.pointAttr[\"\"],j?(kb(j),j.attr(i)[b.pointCount<e?\"animate\":\"attr\"](A(f))):h.graphic=d[h.shapeType](f).attr(i).attr(g).add(a.group).shadow(c.shadow,null,c.stacking&&!c.borderRadius);else if(j)h.graphic=j.destroy()})},animate:function(a){var b=this.yAxis,c=this.options,d=this.chart.inverted,e={};if(ca)a?(e.scaleY=0.001,a=z(b.pos+b.len,t(b.pos,b.toPixels(c.threshold))),d?e.translateX=a-b.len:e.translateY=a,this.group.attr(e)):(e.scaleY=1,e[d?\"translateX\":\"translateY\"]=\nb.pos,this.group.animate(e,this.options.animation),this.animate=null)},remove:function(){var a=this,b=a.chart;b.hasRendered&&o(b.series,function(b){if(b.type===a.type)b.isDirty=!0});R.prototype.remove.apply(a,arguments)}});M.column=wa;ba.bar=A(ba.column);pa=ka(wa,{type:\"bar\",inverted:!0});M.bar=pa;ba.scatter=A(U,{lineWidth:0,marker:{enabled:!0},tooltip:{headerFormat:'<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px;\"> {series.name}</span><br/>',pointFormat:\"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"}});\npa=ka(R,{type:\"scatter\",sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:[\"group\",\"markerGroup\",\"dataLabelsGroup\"],takeOrdinalPosition:!1,kdDimensions:2,drawGraph:function(){this.options.lineWidth&&R.prototype.drawGraph.call(this)}});M.scatter=pa;ba.pie=A(U,{borderColor:\"#FFFFFF\",borderWidth:1,center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{distance:30,enabled:!0,formatter:function(){return this.y===null?void 0:this.point.name},x:0},ignoreHiddenPoint:!0,legendType:\"point\",marker:null,\nsize:null,showInLegend:!1,slicedOffset:10,states:{hover:{brightness:0.1,shadow:!1}},stickyTracking:!1,tooltip:{followPointer:!0}});U={type:\"pie\",isCartesian:!1,pointClass:ka(Ea,{init:function(){Ea.prototype.init.apply(this,arguments);var a=this,b;r(a,{visible:a.visible!==!1,name:p(a.name,\"Slice\")});b=function(b){a.slice(b.type===\"select\")};H(a,\"select\",b);H(a,\"unselect\",b);return a},setVisible:function(a,b){var c=this,d=c.series,e=d.chart,f=d.options.ignoreHiddenPoint,b=p(b,f);if(a!==c.visible){c.visible=\nc.options.visible=a=a===v?!c.visible:a;d.options.data[Ka(c,d.data)]=c.options;o([\"graphic\",\"dataLabel\",\"connector\",\"shadowGroup\"],function(b){if(c[b])c[b][a?\"show\":\"hide\"](!0)});c.legendItem&&e.legend.colorizeItem(c,a);!a&&c.state===\"hover\"&&c.setState(\"\");if(f)d.isDirty=!0;b&&e.redraw()}},slice:function(a,b,c){var d=this.series;Qa(c,d.chart);p(b,!0);this.sliced=this.options.sliced=a=s(a)?a:!this.sliced;d.options.data[Ka(this,d.data)]=this.options;a=a?this.slicedTranslation:{translateX:0,translateY:0};\nthis.graphic.animate(a);this.shadowGroup&&this.shadowGroup.animate(a)},haloPath:function(a){var b=this.shapeArgs,c=this.series.chart;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(c.plotLeft+b.x,c.plotTop+b.y,b.r+a,b.r+a,{innerR:this.shapeArgs.r,start:b.start,end:b.end})}}),requireSorting:!1,directTouch:!0,noSharedTooltip:!0,trackerGroups:[\"group\",\"dataLabelsGroup\"],axisTypes:[],pointAttrToOptions:{stroke:\"borderColor\",\"stroke-width\":\"borderWidth\",fill:\"color\"},animate:function(a){var b=\nthis,c=b.points,d=b.startAngleRad;if(!a)o(c,function(a){var c=a.graphic,g=a.shapeArgs;c&&(c.attr({r:a.startR||b.center[3]/2,start:d,end:d}),c.animate({r:g.r,start:g.start,end:g.end},b.options.animation))}),b.animate=null},setData:function(a,b,c,d){R.prototype.setData.call(this,a,!1,c,d);this.processData();this.generatePoints();p(b,!0)&&this.chart.redraw(c)},updateTotals:function(){var a,b=0,c=this.points,d=c.length,e,f=this.options.ignoreHiddenPoint;for(a=0;a<d;a++)e=c[a],b+=f&&!e.visible?0:e.y;this.total=\nb;for(a=0;a<d;a++)e=c[a],e.percentage=b>0&&(e.visible||!f)?e.y/b*100:0,e.total=b},generatePoints:function(){R.prototype.generatePoints.call(this);this.updateTotals()},translate:function(a){this.generatePoints();var b=0,c=this.options,d=c.slicedOffset,e=d+c.borderWidth,f,g,h,i=c.startAngle||0,j=this.startAngleRad=ma/180*(i-90),i=(this.endAngleRad=ma/180*(p(c.endAngle,i+360)-90))-j,k=this.points,m=c.dataLabels.distance,c=c.ignoreHiddenPoint,l,n=k.length,o;if(!a)this.center=a=this.getCenter();this.getX=\nfunction(b,c){h=W.asin(z((b-a[1])/(a[2]/2+m),1));return a[0]+(c?-1:1)*X(h)*(a[2]/2+m)};for(l=0;l<n;l++){o=k[l];f=j+b*i;if(!c||o.visible)b+=o.percentage/100;g=j+b*i;o.shapeType=\"arc\";o.shapeArgs={x:a[0],y:a[1],r:a[2]/2,innerR:a[3]/2,start:w(f*1E3)/1E3,end:w(g*1E3)/1E3};h=(g+f)/2;h>1.5*ma?h-=2*ma:h<-ma/2&&(h+=2*ma);o.slicedTranslation={translateX:w(X(h)*d),translateY:w(aa(h)*d)};f=X(h)*a[2]/2;g=aa(h)*a[2]/2;o.tooltipPos=[a[0]+f*0.7,a[1]+g*0.7];o.half=h<-ma/2||h>ma/2?1:0;o.angle=h;e=z(e,m/2);o.labelPos=\n[a[0]+f+X(h)*m,a[1]+g+aa(h)*m,a[0]+f+X(h)*e,a[1]+g+aa(h)*e,a[0]+f,a[1]+g,m<0?\"center\":o.half?\"right\":\"left\",h]}},drawGraph:null,drawPoints:function(){var a=this,b=a.chart.renderer,c,d,e=a.options.shadow,f,g,h;if(e&&!a.shadowGroup)a.shadowGroup=b.g(\"shadow\").add(a.group);o(a.points,function(i){if(i.y!==null){d=i.graphic;g=i.shapeArgs;f=i.shadowGroup;if(e&&!f)f=i.shadowGroup=b.g(\"shadow\").add(a.shadowGroup);c=i.sliced?i.slicedTranslation:{translateX:0,translateY:0};f&&f.attr(c);if(d)d.animate(r(g,c));\nelse{h={\"stroke-linejoin\":\"round\"};if(!i.visible)h.visibility=\"hidden\";i.graphic=d=b[i.shapeType](g).setRadialReference(a.center).attr(i.pointAttr[i.selected?\"select\":\"\"]).attr(h).attr(c).add(a.group).shadow(e,f)}}})},searchPoint:ta,sortByAngle:function(a,b){a.sort(function(a,d){return a.angle!==void 0&&(d.angle-a.angle)*b})},drawLegendSymbol:La.drawRectangle,getCenter:Xb.getCenter,getSymbol:ta};U=ka(R,U);M.pie=U;R.prototype.drawDataLabels=function(){var a=this,b=a.options,c=b.cursor,d=b.dataLabels,\ne=a.points,f,g,h=a.hasRendered||0,i,j,k=a.chart.renderer;if(d.enabled||a._hasPointLabels)a.dlProcessOptions&&a.dlProcessOptions(d),j=a.plotGroup(\"dataLabelsGroup\",\"data-labels\",d.defer?\"hidden\":\"visible\",d.zIndex||6),p(d.defer,!0)&&(j.attr({opacity:+h}),h||H(a,\"afterAnimate\",function(){a.visible&&j.show();j[b.animation?\"animate\":\"attr\"]({opacity:1},{duration:200})})),g=d,o(e,function(e){var h,n=e.dataLabel,o,t,w=e.connector,z=!0,u,y={};f=e.dlOptions||e.options&&e.options.dataLabels;h=p(f&&f.enabled,\ng.enabled);if(n&&!h)e.dataLabel=n.destroy();else if(h){d=A(g,f);u=d.style;h=d.rotation;o=e.getLabelConfig();i=d.format?Ha(d.format,o):d.formatter.call(o,d);u.color=p(d.color,u.color,a.color,\"black\");if(n)if(s(i))n.attr({text:i}),z=!1;else{if(e.dataLabel=n=n.destroy(),w)e.connector=w.destroy()}else if(s(i)){n={fill:d.backgroundColor,stroke:d.borderColor,\"stroke-width\":d.borderWidth,r:d.borderRadius||0,rotation:h,padding:d.padding,zIndex:1};if(u.color===\"contrast\")y.color=d.inside||d.distance<0||b.stacking?\nk.getContrast(e.color||a.color):\"#000000\";if(c)y.cursor=c;for(t in n)n[t]===v&&delete n[t];n=e.dataLabel=k[h?\"text\":\"label\"](i,0,-999,d.shape,null,null,d.useHTML).attr(n).css(r(u,y)).add(j).shadow(d.shadow)}n&&a.alignDataLabel(e,n,d,null,z)}})};R.prototype.alignDataLabel=function(a,b,c,d,e){var f=this.chart,g=f.inverted,h=p(a.plotX,-999),i=p(a.plotY,-999),j=b.getBBox(),k=f.renderer.fontMetrics(c.style.fontSize).b,m=this.visible&&(a.series.forceDL||f.isInsidePlot(h,w(i),g)||d&&f.isInsidePlot(h,g?d.x+\n1:d.y+d.height-1,g));if(m)d=r({x:g?f.plotWidth-i:h,y:w(g?f.plotHeight-h:i),width:0,height:0},d),r(c,{width:j.width,height:j.height}),c.rotation?(a=f.renderer.rotCorr(k,c.rotation),b[e?\"attr\":\"animate\"]({x:d.x+c.x+d.width/2+a.x,y:d.y+c.y+d.height/2}).attr({align:c.align})):(b.align(c,null,d),g=b.alignAttr,p(c.overflow,\"justify\")===\"justify\"?this.justifyDataLabel(b,c,g,j,d,e):p(c.crop,!0)&&(m=f.isInsidePlot(g.x,g.y)&&f.isInsidePlot(g.x+j.width,g.y+j.height)),c.shape&&b.attr({anchorX:a.plotX,anchorY:a.plotY}));\nif(!m)b.attr({y:-999}),b.placed=!1};R.prototype.justifyDataLabel=function(a,b,c,d,e,f){var g=this.chart,h=b.align,i=b.verticalAlign,j,k,m=a.box?0:a.padding||0;j=c.x+m;if(j<0)h===\"right\"?b.align=\"left\":b.x=-j,k=!0;j=c.x+d.width-m;if(j>g.plotWidth)h===\"left\"?b.align=\"right\":b.x=g.plotWidth-j,k=!0;j=c.y+m;if(j<0)i===\"bottom\"?b.verticalAlign=\"top\":b.y=-j,k=!0;j=c.y+d.height-m;if(j>g.plotHeight)i===\"top\"?b.verticalAlign=\"bottom\":b.y=g.plotHeight-j,k=!0;if(k)a.placed=!f,a.align(b,null,e)};if(M.pie)M.pie.prototype.drawDataLabels=\nfunction(){var a=this,b=a.data,c,d=a.chart,e=a.options.dataLabels,f=p(e.connectorPadding,10),g=p(e.connectorWidth,1),h=d.plotWidth,i=d.plotHeight,j,k,m=p(e.softConnector,!0),l=e.distance,n=a.center,q=n[2]/2,r=n[1],s=l>0,v,u,y,C=[[],[]],A,B,D,F,G,E=[0,0,0,0],L=function(a,b){return b.y-a.y};if(a.visible&&(e.enabled||a._hasPointLabels)){R.prototype.drawDataLabels.apply(a);o(b,function(a){a.dataLabel&&a.visible&&C[a.half].push(a)});for(F=2;F--;){var I=[],M=[],H=C[F],K=H.length,J;if(K){a.sortByAngle(H,\nF-0.5);for(G=b=0;!b&&H[G];)b=H[G]&&H[G].dataLabel&&(H[G].dataLabel.getBBox().height||21),G++;if(l>0){u=z(r+q+l,d.plotHeight);for(G=t(0,r-q-l);G<=u;G+=b)I.push(G);u=I.length;if(K>u){c=[].concat(H);c.sort(L);for(G=K;G--;)c[G].rank=G;for(G=K;G--;)H[G].rank>=u&&H.splice(G,1);K=H.length}for(G=0;G<K;G++){c=H[G];y=c.labelPos;c=9999;var P,O;for(O=0;O<u;O++)P=N(I[O]-y[1]),P<c&&(c=P,J=O);if(J<G&&I[G]!==null)J=G;else for(u<K-G+J&&I[G]!==null&&(J=u-K+G);I[J]===null;)J++;M.push({i:J,y:I[J]});I[J]=null}M.sort(L)}for(G=\n0;G<K;G++){c=H[G];y=c.labelPos;v=c.dataLabel;D=c.visible===!1?\"hidden\":\"inherit\";c=y[1];if(l>0){if(u=M.pop(),J=u.i,B=u.y,c>B&&I[J+1]!==null||c<B&&I[J-1]!==null)B=z(t(0,c),d.plotHeight)}else B=c;A=e.justify?n[0]+(F?-1:1)*(q+l):a.getX(B===r-q-l||B===r+q+l?c:B,F);v._attr={visibility:D,align:y[6]};v._pos={x:A+e.x+({left:f,right:-f}[y[6]]||0),y:B+e.y-10};v.connX=A;v.connY=B;if(this.options.size===null)u=v.width,A-u<f?E[3]=t(w(u-A+f),E[3]):A+u>h-f&&(E[1]=t(w(A+u-h+f),E[1])),B-b/2<0?E[0]=t(w(-B+b/2),E[0]):\nB+b/2>i&&(E[2]=t(w(B+b/2-i),E[2]))}}}if(Ca(E)===0||this.verifyDataLabelOverflow(E))this.placeDataLabels(),s&&g&&o(this.points,function(b){j=b.connector;y=b.labelPos;if((v=b.dataLabel)&&v._pos&&b.visible)D=v._attr.visibility,A=v.connX,B=v.connY,k=m?[\"M\",A+(y[6]===\"left\"?5:-5),B,\"C\",A,B,2*y[2]-y[4],2*y[3]-y[5],y[2],y[3],\"L\",y[4],y[5]]:[\"M\",A+(y[6]===\"left\"?5:-5),B,\"L\",y[2],y[3],\"L\",y[4],y[5]],j?(j.animate({d:k}),j.attr(\"visibility\",D)):b.connector=j=a.chart.renderer.path(k).attr({\"stroke-width\":g,stroke:e.connectorColor||\nb.color||\"#606060\",visibility:D}).add(a.dataLabelsGroup);else if(j)b.connector=j.destroy()})}},M.pie.prototype.placeDataLabels=function(){o(this.points,function(a){var b=a.dataLabel;if(b&&a.visible)(a=b._pos)?(b.attr(b._attr),b[b.moved?\"animate\":\"attr\"](a),b.moved=!0):b&&b.attr({y:-999})})},M.pie.prototype.alignDataLabel=ta,M.pie.prototype.verifyDataLabelOverflow=function(a){var b=this.center,c=this.options,d=c.center,e=c.minSize||80,f=e,g;d[0]!==null?f=t(b[2]-t(a[1],a[3]),e):(f=t(b[2]-a[1]-a[3],\ne),b[0]+=(a[3]-a[1])/2);d[1]!==null?f=t(z(f,b[2]-t(a[0],a[2])),e):(f=t(z(f,b[2]-a[0]-a[2]),e),b[1]+=(a[0]-a[2])/2);f<b[2]?(b[2]=f,b[3]=/%$/.test(c.innerSize||0)?f*parseFloat(c.innerSize||0)/100:parseFloat(c.innerSize||0),this.translate(b),o(this.points,function(a){if(a.dataLabel)a.dataLabel._pos=null}),this.drawDataLabels&&this.drawDataLabels()):g=!0;return g};if(M.column)M.column.prototype.alignDataLabel=function(a,b,c,d,e){var f=this.chart.inverted,g=a.series,h=a.dlBox||a.shapeArgs,i=p(a.below,\na.plotY>p(this.translatedThreshold,g.yAxis.len)),j=p(c.inside,!!this.options.stacking);if(h&&(d=A(h),f&&(d={x:g.yAxis.len-d.y-d.height,y:g.xAxis.len-d.x-d.width,width:d.height,height:d.width}),!j))f?(d.x+=i?0:d.width,d.width=0):(d.y+=i?d.height:0,d.height=0);c.align=p(c.align,!f||j?\"center\":i?\"right\":\"left\");c.verticalAlign=p(c.verticalAlign,f||j?\"middle\":i?\"top\":\"bottom\");R.prototype.alignDataLabel.call(this,a,b,c,d,e)};(function(a){var b=a.Chart,c=a.each,d=a.pick,e=HighchartsAdapter.addEvent;b.prototype.callbacks.push(function(a){function b(){var e=\n[];c(a.series,function(a){var b=a.options.dataLabels,f=a.dataLabelCollections||[\"dataLabel\"];(b.enabled||a._hasPointLabels)&&!b.allowOverlap&&a.visible&&c(f,function(b){c(a.points,function(a){if(a[b])a[b].labelrank=d(a.labelrank,a.shapeArgs&&a.shapeArgs.height),e.push(a[b])})})});a.hideOverlappingLabels(e)}b();e(a,\"redraw\",b)});b.prototype.hideOverlappingLabels=function(a){var b=a.length,d,e,j,k,m,l,n;for(e=0;e<b;e++)if(d=a[e])d.oldOpacity=d.opacity,d.newOpacity=1;a.sort(function(a,b){return(b.labelrank||\n0)-(a.labelrank||0)});for(e=0;e<b;e++){j=a[e];for(d=e+1;d<b;++d)if(k=a[d],j&&k&&j.placed&&k.placed&&j.newOpacity!==0&&k.newOpacity!==0&&(m=j.alignAttr,l=k.alignAttr,n=2*(j.box?0:j.padding),m=!(l.x>m.x+(j.width-n)||l.x+(k.width-n)<m.x||l.y>m.y+(j.height-n)||l.y+(k.height-n)<m.y)))(j.labelrank<k.labelrank?j:k).newOpacity=0}c(a,function(a){var b,c;if(a){c=a.newOpacity;if(a.oldOpacity!==c&&a.placed)c?a.show(!0):b=function(){a.hide()},a.alignAttr.opacity=c,a[a.isOld?\"animate\":\"attr\"](a.alignAttr,null,\nb);a.isOld=!0}})}})(B);U=B.TrackerMixin={drawTrackerPoint:function(){var a=this,b=a.chart,c=b.pointer,d=a.options.cursor,e=d&&{cursor:d},f=function(a){for(var c=a.target,d;c&&!d;)d=c.point,c=c.parentNode;if(d!==v&&d!==b.hoverPoint)d.onMouseOver(a)};o(a.points,function(a){if(a.graphic)a.graphic.element.point=a;if(a.dataLabel)a.dataLabel.element.point=a});if(!a._hasTracking)o(a.trackerGroups,function(b){if(a[b]&&(a[b].addClass(\"highcharts-tracker\").on(\"mouseover\",f).on(\"mouseout\",function(a){c.onTrackerMouseOut(a)}).css(e),\n$a))a[b].on(\"touchstart\",f)}),a._hasTracking=!0},drawTrackerGraph:function(){var a=this,b=a.options,c=b.trackByArea,d=[].concat(c?a.areaPath:a.graphPath),e=d.length,f=a.chart,g=f.pointer,h=f.renderer,i=f.options.tooltip.snap,j=a.tracker,k=b.cursor,m=k&&{cursor:k},k=a.singlePoints,l,n=function(){if(f.hoverSeries!==a)a.onMouseOver()},p=\"rgba(192,192,192,\"+(ca?1.0E-4:0.002)+\")\";if(e&&!c)for(l=e+1;l--;)d[l]===\"M\"&&d.splice(l+1,0,d[l+1]-i,d[l+2],\"L\"),(l&&d[l]===\"M\"||l===e)&&d.splice(l,0,\"L\",d[l-2]+i,d[l-\n1]);for(l=0;l<k.length;l++)e=k[l],d.push(\"M\",e.plotX-i,e.plotY,\"L\",e.plotX+i,e.plotY);j?j.attr({d:d}):(a.tracker=h.path(d).attr({\"stroke-linejoin\":\"round\",visibility:a.visible?\"visible\":\"hidden\",stroke:p,fill:c?p:O,\"stroke-width\":b.lineWidth+(c?0:2*i),zIndex:2}).add(a.group),o([a.tracker,a.markerGroup],function(a){a.addClass(\"highcharts-tracker\").on(\"mouseover\",n).on(\"mouseout\",function(a){g.onTrackerMouseOut(a)}).css(m);if($a)a.on(\"touchstart\",n)}))}};if(M.column)wa.prototype.drawTracker=U.drawTrackerPoint;\nif(M.pie)M.pie.prototype.drawTracker=U.drawTrackerPoint;if(M.scatter)pa.prototype.drawTracker=U.drawTrackerPoint;r(lb.prototype,{setItemEvents:function(a,b,c,d,e){var f=this;(c?b:a.legendGroup).on(\"mouseover\",function(){a.setState(\"hover\");b.css(f.options.itemHoverStyle)}).on(\"mouseout\",function(){b.css(a.visible?d:e);a.setState()}).on(\"click\",function(b){var c=function(){a.setVisible()},b={browserEvent:b};a.firePointEvent?a.firePointEvent(\"legendItemClick\",b,c):I(a,\"legendItemClick\",b,c)})},createCheckboxForItem:function(a){a.checkbox=\n$(\"input\",{type:\"checkbox\",checked:a.selected,defaultChecked:a.selected},this.options.itemCheckboxStyle,this.chart.container);H(a.checkbox,\"click\",function(b){I(a.series||a,\"checkboxClick\",{checked:b.target.checked,item:a},function(){a.select()})})}});S.legend.itemStyle.cursor=\"pointer\";r(D.prototype,{showResetZoom:function(){var a=this,b=S.lang,c=a.options.chart.resetZoomButton,d=c.theme,e=d.states,f=c.relativeTo===\"chart\"?null:\"plotBox\";this.resetZoomButton=a.renderer.button(b.resetZoom,null,null,\nfunction(){a.zoomOut()},d,e&&e.hover).attr({align:c.position.align,title:b.resetZoomTitle}).add().align(c.position,!1,f)},zoomOut:function(){var a=this;I(a,\"selection\",{resetSelection:!0},function(){a.zoom()})},zoom:function(a){var b,c=this.pointer,d=!1,e;!a||a.resetSelection?o(this.axes,function(a){b=a.zoom()}):o(a.xAxis.concat(a.yAxis),function(a){var e=a.axis,h=e.isXAxis;if(c[h?\"zoomX\":\"zoomY\"]||c[h?\"pinchX\":\"pinchY\"])b=e.zoom(a.min,a.max),e.displayBtn&&(d=!0)});e=this.resetZoomButton;if(d&&!e)this.showResetZoom();\nelse if(!d&&da(e))this.resetZoomButton=e.destroy();b&&this.redraw(p(this.options.chart.animation,a&&a.animation,this.pointCount<100))},pan:function(a,b){var c=this,d=c.hoverPoints,e;d&&o(d,function(a){a.setState()});o(b===\"xy\"?[1,0]:[1],function(b){var d=a[b?\"chartX\":\"chartY\"],h=c[b?\"xAxis\":\"yAxis\"][0],i=c[b?\"mouseDownX\":\"mouseDownY\"],j=(h.pointRange||0)/2,k=h.getExtremes(),m=h.toValue(i-d,!0)+j,j=h.toValue(i+c[b?\"plotWidth\":\"plotHeight\"]-d,!0)-j,i=i>d;if(h.series.length&&(i||m>z(k.dataMin,k.min))&&\n(!i||j<t(k.dataMax,k.max)))h.setExtremes(m,j,!1,!1,{trigger:\"pan\"}),e=!0;c[b?\"mouseDownX\":\"mouseDownY\"]=d});e&&c.redraw(!1);L(c.container,{cursor:\"move\"})}});r(Ea.prototype,{select:function(a,b){var c=this,d=c.series,e=d.chart,a=p(a,!c.selected);c.firePointEvent(a?\"select\":\"unselect\",{accumulate:b},function(){c.selected=c.options.selected=a;d.options.data[Ka(c,d.data)]=c.options;c.setState(a&&\"select\");b||o(e.getSelectedPoints(),function(a){if(a.selected&&a!==c)a.selected=a.options.selected=!1,d.options.data[Ka(a,\nd.data)]=a.options,a.setState(\"\"),a.firePointEvent(\"unselect\")})})},onMouseOver:function(a,b){var c=this.series,d=c.chart,e=d.tooltip,f=d.hoverPoint;if(d.hoverSeries!==c)c.onMouseOver();if(f&&f!==this)f.onMouseOut();if(this.series&&(this.firePointEvent(\"mouseOver\"),e&&(!e.shared||c.noSharedTooltip)&&e.refresh(this,a),this.setState(\"hover\"),!b))d.hoverPoint=this},onMouseOut:function(){var a=this.series.chart,b=a.hoverPoints;this.firePointEvent(\"mouseOut\");if(!b||Ka(this,b)===-1)this.setState(),a.hoverPoint=\nnull},importEvents:function(){if(!this.hasImportedEvents){var a=A(this.series.options.point,this.options).events,b;this.events=a;for(b in a)H(this,b,a[b]);this.hasImportedEvents=!0}},setState:function(a,b){var c=this.plotX,d=this.plotY,e=this.series,f=e.options.states,g=ba[e.type].marker&&e.options.marker,h=g&&!g.enabled,i=g&&g.states[a],j=i&&i.enabled===!1,k=e.stateMarkerGraphic,m=this.marker||{},l=e.chart,n=e.halo,o,a=a||\"\";o=this.pointAttr[a]||e.pointAttr[a];if(!(a===this.state&&!b||this.selected&&\na!==\"select\"||f[a]&&f[a].enabled===!1||a&&(j||h&&i.enabled===!1)||a&&m.states&&m.states[a]&&m.states[a].enabled===!1)){if(this.graphic)g=g&&this.graphic.symbolName&&o.r,this.graphic.attr(A(o,g?{x:c-g,y:d-g,width:2*g,height:2*g}:{})),k&&k.hide();else{if(a&&i)if(g=i.radius,m=m.symbol||e.symbol,k&&k.currentSymbol!==m&&(k=k.destroy()),k)k[b?\"animate\":\"attr\"]({x:c-g,y:d-g});else if(m)e.stateMarkerGraphic=k=l.renderer.symbol(m,c-g,d-g,2*g,2*g).attr(o).add(e.markerGroup),k.currentSymbol=m;if(k)k[a&&l.isInsidePlot(c,\nd,l.inverted)?\"show\":\"hide\"](),k.element.point=this}if((c=f[a]&&f[a].halo)&&c.size){if(!n)e.halo=n=l.renderer.path().add(l.seriesGroup);n.attr(r({fill:na(this.color||e.color).setOpacity(c.opacity).get()},c.attributes))[b?\"animate\":\"attr\"]({d:this.haloPath(c.size)})}else n&&n.attr({d:[]});this.state=a}},haloPath:function(a){var b=this.series,c=b.chart,d=b.getPlotBox(),e=c.inverted;return c.renderer.symbols.circle(d.translateX+(e?b.yAxis.len-this.plotY:this.plotX)-a,d.translateY+(e?b.xAxis.len-this.plotX:\nthis.plotY)-a,a*2,a*2)}});r(R.prototype,{onMouseOver:function(){var a=this.chart,b=a.hoverSeries;if(b&&b!==this)b.onMouseOut();this.options.events.mouseOver&&I(this,\"mouseOver\");this.setState(\"hover\");a.hoverSeries=this},onMouseOut:function(){var a=this.options,b=this.chart,c=b.tooltip,d=b.hoverPoint;b.hoverSeries=null;if(d)d.onMouseOut();this&&a.events.mouseOut&&I(this,\"mouseOut\");c&&!a.stickyTracking&&(!c.shared||this.noSharedTooltip)&&c.hide();this.setState()},setState:function(a){var b=this.options,\nc=this.graph,d=b.states,e=b.lineWidth,b=0,a=a||\"\";if(this.state!==a&&(this.state=a,!(d[a]&&d[a].enabled===!1)&&(a&&(e=d[a].lineWidth||e+(d[a].lineWidthPlus||0)),c&&!c.dashstyle))){a={\"stroke-width\":e};for(c.attr(a);this[\"zoneGraph\"+b];)this[\"zoneGraph\"+b].attr(a),b+=1}},setVisible:function(a,b){var c=this,d=c.chart,e=c.legendItem,f,g=d.options.chart.ignoreHiddenSeries,h=c.visible;f=(c.visible=a=c.userOptions.visible=a===v?!h:a)?\"show\":\"hide\";o([\"group\",\"dataLabelsGroup\",\"markerGroup\",\"tracker\"],function(a){if(c[a])c[a][f]()});\nif(d.hoverSeries===c||(d.hoverPoint&&d.hoverPoint.series)===c)c.onMouseOut();e&&d.legend.colorizeItem(c,a);c.isDirty=!0;c.options.stacking&&o(d.series,function(a){if(a.options.stacking&&a.visible)a.isDirty=!0});o(c.linkedSeries,function(b){b.setVisible(a,!1)});if(g)d.isDirtyBox=!0;b!==!1&&d.redraw();I(c,f)},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(a){this.selected=a=a===v?!this.selected:a;if(this.checkbox)this.checkbox.checked=a;I(this,a?\"select\":\"unselect\")},\ndrawTracker:U.drawTrackerGraph});r(B,{Color:na,Point:Ea,Tick:Ra,Renderer:Za,SVGElement:P,SVGRenderer:ua,arrayMin:Na,arrayMax:Ca,charts:Y,dateFormat:Ma,error:la,format:Ha,pathAnim:xb,getOptions:function(){return S},hasBidiBug:Nb,isTouchDevice:Jb,setOptions:function(a){S=A(!0,S,a);Cb();return S},addEvent:H,removeEvent:Z,createElement:$,discardElement:Pa,css:L,each:o,map:Ta,merge:A,splat:ra,extendClass:ka,pInt:F,svg:ca,canvas:fa,vml:!ca&&!fa,product:\"Highcharts\",version:\"4.1.8\"})})();\n\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = Highcharts;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvdmVuZG9yL2hpZ2hjaGFydHMuanM/ZTJmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVksYUFBYSx3QkFBd0IsaUJBQWlCLFFBQVEsMEJBQTBCLEVBQUUsa0xBQWtMLFVBQVUsVUFBVSxzREFBc0QsV0FBVyxRQUFRLElBQUksZ0JBQWdCLFNBQVMsZ0JBQWdCLHlCQUF5QixlQUFlLDJCQUEyQixlQUFlO0FBQ3BmLG9CQUFvQixlQUFlLDREQUE0RCxlQUFlLDJCQUEyQixlQUFlLHVCQUF1QixlQUFlLG1CQUFtQixpQkFBaUIsbUJBQW1CLElBQUksY0FBYyxjQUFjLE9BQU8sY0FBYyx1QkFBdUIsa0JBQWtCLFFBQVEsMkVBQTJFLHNEQUFzRCxTQUFTLGVBQWU7QUFDcGYsTUFBTSxnQkFBZ0IseUVBQXlFLGFBQWEsc0JBQXNCLHFCQUFxQixVQUFVLFFBQVEsNEJBQTRCLEVBQUUsVUFBVSxvQkFBb0IsU0FBUyxpQkFBaUIsaUJBQWlCLFVBQVUsa0JBQWtCLGlCQUFpQixTQUFTLGlCQUFpQixrREFBa0QsZUFBZSw2QkFBNkIsaUJBQWlCLFlBQVksc0JBQXNCO0FBQ3hlLEdBQUcsRUFBRSxlQUFlLE1BQU0sZUFBZSx1QkFBdUIsV0FBVyxJQUFJLFFBQVEsSUFBSSxjQUFjLGlNQUFpTSxVQUFVLGVBQWUsV0FBVyxJQUFJLEVBQUUsVUFBVSxrQkFBa0IsZUFBZSxvQ0FBb0MsdUJBQXVCLG1CQUFtQixNQUFNO0FBQ25kLG1DQUFtQyxRQUFRLFdBQVcsOERBQThELEtBQUssU0FBUyxpQkFBaUIsbUJBQW1CLFFBQVEsSUFBSSxnQkFBZ0IscUJBQXFCLFNBQVMsNkJBQTZCLEVBQUUsUUFBUSxJQUFJLHFCQUFxQixlQUFlLDBCQUEwQixJQUFJLGtCQUFrQixTQUFTLGVBQWUsMEJBQTBCLElBQUksa0JBQWtCLFNBQVMsaUJBQWlCO0FBQ2pjLFlBQVks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QUFvRCxVQUFVLHlEQUF5RCxxQ0FBcUMsd0JBQXdCLEVBQUUsZ0JBQWdCLEtBQUssRUFBRSxjQUFjLHNCQUFzQiwwREFBMEQ7QUFDL1gsd0JBQXdCLEVBQUUsZUFBZSx1QkFBdUIsaUNBQWlDLDhCQUE4QixtREFBbUQsdUJBQXVCLG1CQUFtQix1QkFBdUIsMkRBQTJELG1CQUFtQixvQkFBb0IsNENBQTRDLGtFQUFrRSxnQkFBZ0Isc0JBQXNCO0FBQ3plLGtEQUFrRCxrSUFBa0ksR0FBRyxrQkFBa0IsY0FBYyxvQkFBb0IsbUNBQW1DLDBCQUEwQix1RkFBdUYsK0RBQStELGtFQUFrRSxrQkFBa0I7QUFDbGhCLDZFQUE2RSw4QkFBOEIsYUFBYSwyQ0FBMkMsOENBQThDLEVBQUUsNkJBQTZCLG1CQUFtQixFQUFFLHFCQUFxQixtQkFBbUIsT0FBTyxpQkFBaUIsb0JBQW9CLGlCQUFpQixvQkFBb0Isb0JBQW9CLHVDQUF1Qyx5Q0FBeUMsOEJBQThCO0FBQ2hnQiwrQkFBK0IsRUFBRSxLQUFLLHNLQUFzSyxTQUFTLHVEQUF1RCxZQUFZLEtBQUssU0FBUywwTEFBMEwsRUFBRTs7OztBQUlsZTtBQUNBIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIganF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKTtcblxuLypcbiBIaWdoY2hhcnRzIEpTIHY0LjEuOCAoMjAxNS0wOC0yMClcblxuIChjKSAyMDA5LTIwMTQgVG9yc3RlaW4gSG9uc2lcblxuIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG4qL1xuKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gQSgpe3ZhciBhLGI9YXJndW1lbnRzLGMsZD17fSxlPWZ1bmN0aW9uKGEsYil7dmFyIGMsZDt0eXBlb2YgYSE9PVwib2JqZWN0XCImJihhPXt9KTtmb3IoZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihjPWJbZF0sYVtkXT1jJiZ0eXBlb2YgYz09PVwib2JqZWN0XCImJk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjKSE9PVwiW29iamVjdCBBcnJheV1cIiYmZCE9PVwicmVuZGVyVG9cIiYmdHlwZW9mIGMubm9kZVR5cGUhPT1cIm51bWJlclwiP2UoYVtkXXx8e30sYyk6YltkXSk7cmV0dXJuIGF9O2JbMF09PT0hMCYmKGQ9YlsxXSxiPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGIsMikpO2M9Yi5sZW5ndGg7Zm9yKGE9MDthPGM7YSsrKWQ9ZShkLGJbYV0pO3JldHVybiBkfWZ1bmN0aW9uIEYoYSxiKXtyZXR1cm4gcGFyc2VJbnQoYSxifHwxMCl9ZnVuY3Rpb24gQWEoYSl7cmV0dXJuIHR5cGVvZiBhPT09XCJzdHJpbmdcIn1mdW5jdGlvbiBkYShhKXtyZXR1cm4gYSYmXG50eXBlb2YgYT09PVwib2JqZWN0XCJ9ZnVuY3Rpb24gRmEoYSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKT09PVwiW29iamVjdCBBcnJheV1cIn1mdW5jdGlvbiBxYShhKXtyZXR1cm4gdHlwZW9mIGE9PT1cIm51bWJlclwifWZ1bmN0aW9uIEJhKGEpe3JldHVybiBXLmxvZyhhKS9XLkxOMTB9ZnVuY3Rpb24gaWEoYSl7cmV0dXJuIFcucG93KDEwLGEpfWZ1bmN0aW9uIGphKGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoO2MtLTspaWYoYVtjXT09PWIpe2Euc3BsaWNlKGMsMSk7YnJlYWt9fWZ1bmN0aW9uIHMoYSl7cmV0dXJuIGEhPT12JiZhIT09bnVsbH1mdW5jdGlvbiBKKGEsYixjKXt2YXIgZCxlO2lmKEFhKGIpKXMoYyk/YS5zZXRBdHRyaWJ1dGUoYixjKTphJiZhLmdldEF0dHJpYnV0ZSYmKGU9YS5nZXRBdHRyaWJ1dGUoYikpO2Vsc2UgaWYocyhiKSYmZGEoYikpZm9yKGQgaW4gYilhLnNldEF0dHJpYnV0ZShkLGJbZF0pO3JldHVybiBlfWZ1bmN0aW9uIHJhKGEpe3JldHVybiBGYShhKT9cbmE6W2FdfWZ1bmN0aW9uIEwoYSxiKXtpZih4YSYmIWNhJiZiJiZiLm9wYWNpdHkhPT12KWIuZmlsdGVyPVwiYWxwaGEob3BhY2l0eT1cIitiLm9wYWNpdHkqMTAwK1wiKVwiO3IoYS5zdHlsZSxiKX1mdW5jdGlvbiAkKGEsYixjLGQsZSl7YT1DLmNyZWF0ZUVsZW1lbnQoYSk7YiYmcihhLGIpO2UmJkwoYSx7cGFkZGluZzowLGJvcmRlcjpPLG1hcmdpbjowfSk7YyYmTChhLGMpO2QmJmQuYXBwZW5kQ2hpbGQoYSk7cmV0dXJuIGF9ZnVuY3Rpb24ga2EoYSxiKXt2YXIgYz1mdW5jdGlvbigpe3JldHVybiB2fTtjLnByb3RvdHlwZT1uZXcgYTtyKGMucHJvdG90eXBlLGIpO3JldHVybiBjfWZ1bmN0aW9uIEdhKGEsYil7cmV0dXJuIEFycmF5KChifHwyKSsxLVN0cmluZyhhKS5sZW5ndGgpLmpvaW4oMCkrYX1mdW5jdGlvbiBWYShhKXtyZXR1cm4oYmImJmJiKGEpfHxtYnx8MCkqNkU0fWZ1bmN0aW9uIEhhKGEsYil7Zm9yKHZhciBjPVwie1wiLGQ9ITEsZSxmLGcsaCxpLGo9W107KGM9YS5pbmRleE9mKGMpKSE9PVxuLTE7KXtlPWEuc2xpY2UoMCxjKTtpZihkKXtmPWUuc3BsaXQoXCI6XCIpO2c9Zi5zaGlmdCgpLnNwbGl0KFwiLlwiKTtpPWcubGVuZ3RoO2U9Yjtmb3IoaD0wO2g8aTtoKyspZT1lW2dbaF1dO2lmKGYubGVuZ3RoKWY9Zi5qb2luKFwiOlwiKSxnPS9cXC4oWzAtOV0pLyxoPVMubGFuZyxpPXZvaWQgMCwvZiQvLnRlc3QoZik/KGk9KGk9Zi5tYXRjaChnKSk/aVsxXTotMSxlIT09bnVsbCYmKGU9Qi5udW1iZXJGb3JtYXQoZSxpLGguZGVjaW1hbFBvaW50LGYuaW5kZXhPZihcIixcIik+LTE/aC50aG91c2FuZHNTZXA6XCJcIikpKTplPU1hKGYsZSl9ai5wdXNoKGUpO2E9YS5zbGljZShjKzEpO2M9KGQ9IWQpP1wifVwiOlwie1wifWoucHVzaChhKTtyZXR1cm4gai5qb2luKFwiXCIpfWZ1bmN0aW9uIG5iKGEpe3JldHVybiBXLnBvdygxMCxWKFcubG9nKGEpL1cuTE4xMCkpfWZ1bmN0aW9uIG9iKGEsYixjLGQsZSl7dmFyIGYsZz1hLGM9cChjLDEpO2Y9YS9jO2J8fChiPVsxLDIsMi41LDUsMTBdLGQ9PT0hMSYmKGM9PT1cbjE/Yj1bMSwyLDUsMTBdOmM8PTAuMSYmKGI9WzEvY10pKSk7Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKylpZihnPWJbZF0sZSYmZypjPj1hfHwhZSYmZjw9KGJbZF0rKGJbZCsxXXx8YltkXSkpLzIpYnJlYWs7Zyo9YztyZXR1cm4gZ31mdW5jdGlvbiBwYihhLGIpe3ZhciBjPWEubGVuZ3RoLGQsZTtmb3IoZT0wO2U8YztlKyspYVtlXS5zc19pPWU7YS5zb3J0KGZ1bmN0aW9uKGEsYyl7ZD1iKGEsYyk7cmV0dXJuIGQ9PT0wP2Euc3NfaS1jLnNzX2k6ZH0pO2ZvcihlPTA7ZTxjO2UrKylkZWxldGUgYVtlXS5zc19pfWZ1bmN0aW9uIE5hKGEpe2Zvcih2YXIgYj1hLmxlbmd0aCxjPWFbMF07Yi0tOylhW2JdPGMmJihjPWFbYl0pO3JldHVybiBjfWZ1bmN0aW9uIENhKGEpe2Zvcih2YXIgYj1hLmxlbmd0aCxjPWFbMF07Yi0tOylhW2JdPmMmJihjPWFbYl0pO3JldHVybiBjfWZ1bmN0aW9uIE9hKGEsYil7Zm9yKHZhciBjIGluIGEpYVtjXSYmYVtjXSE9PWImJmFbY10uZGVzdHJveSYmYVtjXS5kZXN0cm95KCksXG5kZWxldGUgYVtjXX1mdW5jdGlvbiBQYShhKXtjYnx8KGNiPSQoSWEpKTthJiZjYi5hcHBlbmRDaGlsZChhKTtjYi5pbm5lckhUTUw9XCJcIn1mdW5jdGlvbiBsYShhLGIpe3ZhciBjPVwiSGlnaGNoYXJ0cyBlcnJvciAjXCIrYStcIjogd3d3LmhpZ2hjaGFydHMuY29tL2Vycm9ycy9cIithO2lmKGIpdGhyb3cgYztLLmNvbnNvbGUmJmNvbnNvbGUubG9nKGMpfWZ1bmN0aW9uIGVhKGEsYil7cmV0dXJuIHBhcnNlRmxvYXQoYS50b1ByZWNpc2lvbihifHwxNCkpfWZ1bmN0aW9uIFFhKGEsYil7Yi5yZW5kZXJlci5nbG9iYWxBbmltYXRpb249cChhLGIuYW5pbWF0aW9uKX1mdW5jdGlvbiBDYigpe3ZhciBhPVMuZ2xvYmFsLGI9YS51c2VVVEMsYz1iP1wiZ2V0VVRDXCI6XCJnZXRcIixkPWI/XCJzZXRVVENcIjpcInNldFwiO3lhPWEuRGF0ZXx8d2luZG93LkRhdGU7bWI9YiYmYS50aW1lem9uZU9mZnNldDtiYj1iJiZhLmdldFRpbWV6b25lT2Zmc2V0O2RiPWZ1bmN0aW9uKGEsYyxkLGgsaSxqKXt2YXIgaztiPyhrPVxueWEuVVRDLmFwcGx5KDAsYXJndW1lbnRzKSxrKz1WYShrKSk6az0obmV3IHlhKGEsYyxwKGQsMSkscChoLDApLHAoaSwwKSxwKGosMCkpKS5nZXRUaW1lKCk7cmV0dXJuIGt9O3FiPWMrXCJNaW51dGVzXCI7cmI9YytcIkhvdXJzXCI7c2I9YytcIkRheVwiO1dhPWMrXCJEYXRlXCI7WGE9YytcIk1vbnRoXCI7WWE9YytcIkZ1bGxZZWFyXCI7RGI9ZCtcIk1pbGxpc2Vjb25kc1wiO0ViPWQrXCJTZWNvbmRzXCI7RmI9ZCtcIk1pbnV0ZXNcIjtHYj1kK1wiSG91cnNcIjt0Yj1kK1wiRGF0ZVwiO3ViPWQrXCJNb250aFwiO3ZiPWQrXCJGdWxsWWVhclwifWZ1bmN0aW9uIFAoKXt9ZnVuY3Rpb24gUmEoYSxiLGMsZCl7dGhpcy5heGlzPWE7dGhpcy5wb3M9Yjt0aGlzLnR5cGU9Y3x8XCJcIjt0aGlzLmlzTmV3PSEwOyFjJiYhZCYmdGhpcy5hZGRMYWJlbCgpfWZ1bmN0aW9uIEhiKGEsYixjLGQsZSl7dmFyIGY9YS5jaGFydC5pbnZlcnRlZDt0aGlzLmF4aXM9YTt0aGlzLmlzTmVnYXRpdmU9Yzt0aGlzLm9wdGlvbnM9Yjt0aGlzLng9ZDt0aGlzLnRvdGFsPVxubnVsbDt0aGlzLnBvaW50cz17fTt0aGlzLnN0YWNrPWU7dGhpcy5hbGlnbk9wdGlvbnM9e2FsaWduOmIuYWxpZ258fChmP2M/XCJsZWZ0XCI6XCJyaWdodFwiOlwiY2VudGVyXCIpLHZlcnRpY2FsQWxpZ246Yi52ZXJ0aWNhbEFsaWdufHwoZj9cIm1pZGRsZVwiOmM/XCJib3R0b21cIjpcInRvcFwiKSx5OnAoYi55LGY/NDpjPzE0Oi02KSx4OnAoYi54LGY/Yz8tNjo2OjApfTt0aGlzLnRleHRBbGlnbj1iLnRleHRBbGlnbnx8KGY/Yz9cInJpZ2h0XCI6XCJsZWZ0XCI6XCJjZW50ZXJcIil9dmFyIHYsQz1kb2N1bWVudCxLPXdpbmRvdyxXPU1hdGgsdz1XLnJvdW5kLFY9Vy5mbG9vcixzYT1XLmNlaWwsdD1XLm1heCx6PVcubWluLE49Vy5hYnMsWD1XLmNvcyxhYT1XLnNpbixtYT1XLlBJLGdhPW1hKjIvMzYwLHphPW5hdmlnYXRvci51c2VyQWdlbnQsSWI9Sy5vcGVyYSx4YT0vKG1zaWV8dHJpZGVudCkvaS50ZXN0KHphKSYmIUliLGViPUMuZG9jdW1lbnRNb2RlPT09OCxmYj0vQXBwbGVXZWJLaXQvLnRlc3QoemEpLEphPVxuL0ZpcmVmb3gvLnRlc3QoemEpLEpiPS8oTW9iaWxlfEFuZHJvaWR8V2luZG93cyBQaG9uZSkvLnRlc3QoemEpLERhPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixjYT0hIUMuY3JlYXRlRWxlbWVudE5TJiYhIUMuY3JlYXRlRWxlbWVudE5TKERhLFwic3ZnXCIpLmNyZWF0ZVNWR1JlY3QsTmI9SmEmJnBhcnNlSW50KHphLnNwbGl0KFwiRmlyZWZveC9cIilbMV0sMTApPDQsZmE9IWNhJiYheGEmJiEhQy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQsWmEsJGEsS2I9e30sd2I9MCxjYixTLE1hLHhiLEUsdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdn0sWT1bXSxhYj0wLElhPVwiZGl2XCIsTz1cIm5vbmVcIixPYj0vXlswLTldKyQvLGdiPVtcInBsb3RUb3BcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Cb3R0b21cIixcInBsb3RMZWZ0XCJdLFBiPVwic3Ryb2tlLXdpZHRoXCIseWEsZGIsbWIsYmIscWIscmIsc2IsV2EsWGEsWWEsRGIsRWIsRmIsR2IsdGIsdWIsdmIsTT17fSxCO0I9Sy5IaWdoY2hhcnRzPVxuSy5IaWdoY2hhcnRzP2xhKDE2LCEwKTp7fTtCLnNlcmllc1R5cGVzPU07dmFyIHI9Qi5leHRlbmQ9ZnVuY3Rpb24oYSxiKXt2YXIgYzthfHwoYT17fSk7Zm9yKGMgaW4gYilhW2NdPWJbY107cmV0dXJuIGF9LHA9Qi5waWNrPWZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzLGIsYyxkPWEubGVuZ3RoO2ZvcihiPTA7YjxkO2IrKylpZihjPWFbYl0sYyE9PXYmJmMhPT1udWxsKXJldHVybiBjfSxTYT1CLndyYXA9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWFbYl07YVtiXT1mdW5jdGlvbigpe3ZhciBhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7YS51bnNoaWZ0KGQpO3JldHVybiBjLmFwcGx5KHRoaXMsYSl9fTtNYT1mdW5jdGlvbihhLGIsYyl7aWYoIXMoYil8fGlzTmFOKGIpKXJldHVybiBTLmxhbmcuaW52YWxpZERhdGV8fFwiXCI7dmFyIGE9cChhLFwiJVktJW0tJWQgJUg6JU06JVNcIiksZD1uZXcgeWEoYi1WYShiKSksZSxmPWRbcmJdKCksZz1kW3NiXSgpLGg9ZFtXYV0oKSxcbmk9ZFtYYV0oKSxqPWRbWWFdKCksaz1TLmxhbmcsbT1rLndlZWtkYXlzLGQ9cih7YTptW2ddLnN1YnN0cigwLDMpLEE6bVtnXSxkOkdhKGgpLGU6aCx3OmcsYjprLnNob3J0TW9udGhzW2ldLEI6ay5tb250aHNbaV0sbTpHYShpKzEpLHk6ai50b1N0cmluZygpLnN1YnN0cigyLDIpLFk6aixIOkdhKGYpLGs6ZixJOkdhKGYlMTJ8fDEyKSxsOmYlMTJ8fDEyLE06R2EoZFtxYl0oKSkscDpmPDEyP1wiQU1cIjpcIlBNXCIsUDpmPDEyP1wiYW1cIjpcInBtXCIsUzpHYShkLmdldFNlY29uZHMoKSksTDpHYSh3KGIlMUUzKSwzKX0sQi5kYXRlRm9ybWF0cyk7Zm9yKGUgaW4gZClmb3IoO2EuaW5kZXhPZihcIiVcIitlKSE9PS0xOylhPWEucmVwbGFjZShcIiVcIitlLHR5cGVvZiBkW2VdPT09XCJmdW5jdGlvblwiP2RbZV0oYik6ZFtlXSk7cmV0dXJuIGM/YS5zdWJzdHIoMCwxKS50b1VwcGVyQ2FzZSgpK2Euc3Vic3RyKDEpOmF9O0U9e21pbGxpc2Vjb25kOjEsc2Vjb25kOjFFMyxtaW51dGU6NkU0LGhvdXI6MzZFNSxkYXk6ODY0RTUsXG53ZWVrOjYwNDhFNSxtb250aDoyNDE5MkU1LHllYXI6MzE0NDk2RTV9O0IubnVtYmVyRm9ybWF0PWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPVMubGFuZyxhPSthfHwwLGY9Yj09PS0xP3ooKGEudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV18fFwiXCIpLmxlbmd0aCwyMCk6aXNOYU4oYj1OKGIpKT8yOmIsYj1jPT09dm9pZCAwP2UuZGVjaW1hbFBvaW50OmMsZD1kPT09dm9pZCAwP2UudGhvdXNhbmRzU2VwOmQsZT1hPDA/XCItXCI6XCJcIixjPVN0cmluZyhGKGE9TihhKS50b0ZpeGVkKGYpKSksZz1jLmxlbmd0aD4zP2MubGVuZ3RoJTM6MDtyZXR1cm4gZSsoZz9jLnN1YnN0cigwLGcpK2Q6XCJcIikrYy5zdWJzdHIoZykucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csXCIkMVwiK2QpKyhmP2IrTihhLWMpLnRvRml4ZWQoZikuc2xpY2UoMik6XCJcIil9O3hiPXtpbml0OmZ1bmN0aW9uKGEsYixjKXt2YXIgYj1ifHxcIlwiLGQ9YS5zaGlmdCxlPWIuaW5kZXhPZihcIkNcIik+LTEsZj1lPzc6MyxnLGI9Yi5zcGxpdChcIiBcIiksXG5jPVtdLmNvbmNhdChjKSxoLGksaj1mdW5jdGlvbihhKXtmb3IoZz1hLmxlbmd0aDtnLS07KWFbZ109PT1cIk1cIiYmYS5zcGxpY2UoZysxLDAsYVtnKzFdLGFbZysyXSxhW2crMV0sYVtnKzJdKX07ZSYmKGooYiksaihjKSk7YS5pc0FyZWEmJihoPWIuc3BsaWNlKGIubGVuZ3RoLTYsNiksaT1jLnNwbGljZShjLmxlbmd0aC02LDYpKTtpZihkPD1jLmxlbmd0aC9mJiZiLmxlbmd0aD09PWMubGVuZ3RoKWZvcig7ZC0tOyljPVtdLmNvbmNhdChjKS5zcGxpY2UoMCxmKS5jb25jYXQoYyk7YS5zaGlmdD0wO2lmKGIubGVuZ3RoKWZvcihhPWMubGVuZ3RoO2IubGVuZ3RoPGE7KWQ9W10uY29uY2F0KGIpLnNwbGljZShiLmxlbmd0aC1mLGYpLGUmJihkW2YtNl09ZFtmLTJdLGRbZi01XT1kW2YtMV0pLGI9Yi5jb25jYXQoZCk7aCYmKGI9Yi5jb25jYXQoaCksYz1jLmNvbmNhdChpKSk7cmV0dXJuW2IsY119LHN0ZXA6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9W10sZj1hLmxlbmd0aDtpZihjPT09MSllPVxuZDtlbHNlIGlmKGY9PT1iLmxlbmd0aCYmYzwxKWZvcig7Zi0tOylkPXBhcnNlRmxvYXQoYVtmXSksZVtmXT1pc05hTihkKT9hW2ZdOmMqcGFyc2VGbG9hdChiW2ZdLWQpK2Q7ZWxzZSBlPWI7cmV0dXJuIGV9fTsoZnVuY3Rpb24oYSl7Sy5IaWdoY2hhcnRzQWRhcHRlcj1LLkhpZ2hjaGFydHNBZGFwdGVyfHxhJiZ7aW5pdDpmdW5jdGlvbihiKXt2YXIgYz1hLmZ4O2EuZXh0ZW5kKGEuZWFzaW5nLHtlYXNlT3V0UXVhZDpmdW5jdGlvbihhLGIsYyxnLGgpe3JldHVybi1nKihiLz1oKSooYi0yKStjfX0pO2EuZWFjaChbXCJjdXJcIixcIl9kZWZhdWx0XCIsXCJ3aWR0aFwiLFwiaGVpZ2h0XCIsXCJvcGFjaXR5XCJdLGZ1bmN0aW9uKGIsZSl7dmFyIGY9Yy5zdGVwLGc7ZT09PVwiY3VyXCI/Zj1jLnByb3RvdHlwZTplPT09XCJfZGVmYXVsdFwiJiZhLlR3ZWVuJiYoZj1hLlR3ZWVuLnByb3BIb29rc1tlXSxlPVwic2V0XCIpOyhnPWZbZV0pJiYoZltlXT1mdW5jdGlvbihhKXt2YXIgYyxhPWI/YTp0aGlzO2lmKGEucHJvcCE9PVxuXCJhbGlnblwiKXJldHVybiBjPWEuZWxlbSxjLmF0dHI/Yy5hdHRyKGEucHJvcCxlPT09XCJjdXJcIj92OmEubm93KTpnLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSk7U2EoYS5jc3NIb29rcy5vcGFjaXR5LFwiZ2V0XCIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBiLmF0dHI/Yi5vcGFjaXR5fHwwOmEuY2FsbCh0aGlzLGIsYyl9KTt0aGlzLmFkZEFuaW1TZXR0ZXIoXCJkXCIsZnVuY3Rpb24oYSl7dmFyIGM9YS5lbGVtLGY7aWYoIWEuc3RhcnRlZClmPWIuaW5pdChjLGMuZCxjLnRvRCksYS5zdGFydD1mWzBdLGEuZW5kPWZbMV0sYS5zdGFydGVkPSEwO2MuYXR0cihcImRcIixiLnN0ZXAoYS5zdGFydCxhLmVuZCxhLnBvcyxjLnRvRCkpfSk7dGhpcy5lYWNoPUFycmF5LnByb3RvdHlwZS5mb3JFYWNoP2Z1bmN0aW9uKGEsYil7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYSxiKX06ZnVuY3Rpb24oYSxiKXt2YXIgYyxnPWEubGVuZ3RoO2ZvcihjPTA7YzxnO2MrKylpZihiLmNhbGwoYVtjXSxcbmFbY10sYyxhKT09PSExKXJldHVybiBjfTthLmZuLmhpZ2hjaGFydHM9ZnVuY3Rpb24oKXt2YXIgYT1cIkNoYXJ0XCIsYj1hcmd1bWVudHMsYyxnO2lmKHRoaXNbMF0pe0FhKGJbMF0pJiYoYT1iWzBdLGI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYiwxKSk7Yz1iWzBdO2lmKGMhPT12KWMuY2hhcnQ9Yy5jaGFydHx8e30sYy5jaGFydC5yZW5kZXJUbz10aGlzWzBdLG5ldyBCW2FdKGMsYlsxXSksZz10aGlzO2M9PT12JiYoZz1ZW0oodGhpc1swXSxcImRhdGEtaGlnaGNoYXJ0cy1jaGFydFwiKV0pfXJldHVybiBnfX0sYWRkQW5pbVNldHRlcjpmdW5jdGlvbihiLGMpe2EuVHdlZW4/YS5Ud2Vlbi5wcm9wSG9va3NbYl09e3NldDpjfTphLmZ4LnN0ZXBbYl09Y30sZ2V0U2NyaXB0OmEuZ2V0U2NyaXB0LGluQXJyYXk6YS5pbkFycmF5LGFkYXB0ZXJSdW46ZnVuY3Rpb24oYixjKXtyZXR1cm4gYShiKVtjXSgpfSxncmVwOmEuZ3JlcCxtYXA6ZnVuY3Rpb24oYSxjKXtmb3IodmFyIGQ9W10sZT1cbjAsZj1hLmxlbmd0aDtlPGY7ZSsrKWRbZV09Yy5jYWxsKGFbZV0sYVtlXSxlLGEpO3JldHVybiBkfSxvZmZzZXQ6ZnVuY3Rpb24oYil7cmV0dXJuIGEoYikub2Zmc2V0KCl9LGFkZEV2ZW50OmZ1bmN0aW9uKGIsYyxkKXthKGIpLmJpbmQoYyxkKX0scmVtb3ZlRXZlbnQ6ZnVuY3Rpb24oYixjLGQpe3ZhciBlPUMucmVtb3ZlRXZlbnRMaXN0ZW5lcj9cInJlbW92ZUV2ZW50TGlzdGVuZXJcIjpcImRldGFjaEV2ZW50XCI7Q1tlXSYmYiYmIWJbZV0mJihiW2VdPWZ1bmN0aW9uKCl7fSk7YShiKS51bmJpbmQoYyxkKX0sZmlyZUV2ZW50OmZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPWEuRXZlbnQoYyksZz1cImRldGFjaGVkXCIrYyxoOyF4YSYmZCYmKGRlbGV0ZSBkLmxheWVyWCxkZWxldGUgZC5sYXllclksZGVsZXRlIGQucmV0dXJuVmFsdWUpO3IoZixkKTtiW2NdJiYoYltnXT1iW2NdLGJbY109bnVsbCk7YS5lYWNoKFtcInByZXZlbnREZWZhdWx0XCIsXCJzdG9wUHJvcGFnYXRpb25cIl0sZnVuY3Rpb24oYSxcbmIpe3ZhciBjPWZbYl07ZltiXT1mdW5jdGlvbigpe3RyeXtjLmNhbGwoZil9Y2F0Y2goYSl7Yj09PVwicHJldmVudERlZmF1bHRcIiYmKGg9ITApfX19KTthKGIpLnRyaWdnZXIoZik7YltnXSYmKGJbY109YltnXSxiW2ddPW51bGwpO2UmJiFmLmlzRGVmYXVsdFByZXZlbnRlZCgpJiYhaCYmZShmKX0sd2FzaE1vdXNlRXZlbnQ6ZnVuY3Rpb24oYSl7dmFyIGM9YS5vcmlnaW5hbEV2ZW50fHxhO2lmKGMucGFnZVg9PT12KWMucGFnZVg9YS5wYWdlWCxjLnBhZ2VZPWEucGFnZVk7cmV0dXJuIGN9LGFuaW1hdGU6ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEoYik7aWYoIWIuc3R5bGUpYi5zdHlsZT17fTtpZihjLmQpYi50b0Q9Yy5kLGMuZD0xO2Uuc3RvcCgpO2Mub3BhY2l0eSE9PXYmJmIuYXR0ciYmKGMub3BhY2l0eSs9XCJweFwiKTtiLmhhc0FuaW09MTtlLmFuaW1hdGUoYyxkKX0sc3RvcDpmdW5jdGlvbihiKXtiLmhhc0FuaW0mJmEoYikuc3RvcCgpfX19KShLLmpRdWVyeSk7dmFyIFU9Sy5IaWdoY2hhcnRzQWRhcHRlcixcbkQ9VXx8e307VSYmVS5pbml0LmNhbGwoVSx4Yik7dmFyIGhiPUQuYWRhcHRlclJ1bixRYj1ELmdldFNjcmlwdCxLYT1ELmluQXJyYXksbz1CLmVhY2g9RC5lYWNoLGliPUQuZ3JlcCxSYj1ELm9mZnNldCxUYT1ELm1hcCxIPUQuYWRkRXZlbnQsWj1ELnJlbW92ZUV2ZW50LEk9RC5maXJlRXZlbnQsU2I9RC53YXNoTW91c2VFdmVudCxqYj1ELmFuaW1hdGUsa2I9RC5zdG9wO1M9e2NvbG9yczpcIiM3Y2I1ZWMsIzQzNDM0OCwjOTBlZDdkLCNmN2EzNWMsIzgwODVlOSwjZjE1YzgwLCNlNGQzNTQsIzJiOTA4ZiwjZjQ1YjViLCM5MWU4ZTFcIi5zcGxpdChcIixcIiksc3ltYm9sczpbXCJjaXJjbGVcIixcImRpYW1vbmRcIixcInNxdWFyZVwiLFwidHJpYW5nbGVcIixcInRyaWFuZ2xlLWRvd25cIl0sbGFuZzp7bG9hZGluZzpcIkxvYWRpbmcuLi5cIixtb250aHM6XCJKYW51YXJ5LEZlYnJ1YXJ5LE1hcmNoLEFwcmlsLE1heSxKdW5lLEp1bHksQXVndXN0LFNlcHRlbWJlcixPY3RvYmVyLE5vdmVtYmVyLERlY2VtYmVyXCIuc3BsaXQoXCIsXCIpLFxuc2hvcnRNb250aHM6XCJKYW4sRmViLE1hcixBcHIsTWF5LEp1bixKdWwsQXVnLFNlcCxPY3QsTm92LERlY1wiLnNwbGl0KFwiLFwiKSx3ZWVrZGF5czpcIlN1bmRheSxNb25kYXksVHVlc2RheSxXZWRuZXNkYXksVGh1cnNkYXksRnJpZGF5LFNhdHVyZGF5XCIuc3BsaXQoXCIsXCIpLGRlY2ltYWxQb2ludDpcIi5cIixudW1lcmljU3ltYm9sczpcImssTSxHLFQsUCxFXCIuc3BsaXQoXCIsXCIpLHJlc2V0Wm9vbTpcIlJlc2V0IHpvb21cIixyZXNldFpvb21UaXRsZTpcIlJlc2V0IHpvb20gbGV2ZWwgMToxXCIsdGhvdXNhbmRzU2VwOlwiIFwifSxnbG9iYWw6e3VzZVVUQzohMCxjYW52YXNUb29sc1VSTDpcImh0dHA6Ly9jb2RlLmhpZ2hjaGFydHMuY29tLzQuMS44L21vZHVsZXMvY2FudmFzLXRvb2xzLmpzXCIsVk1MUmFkaWFsR3JhZGllbnRVUkw6XCJodHRwOi8vY29kZS5oaWdoY2hhcnRzLmNvbS80LjEuOC9nZngvdm1sLXJhZGlhbC1ncmFkaWVudC5wbmdcIn0sY2hhcnQ6e2JvcmRlckNvbG9yOlwiIzQ1NzJBN1wiLGJvcmRlclJhZGl1czowLFxuZGVmYXVsdFNlcmllc1R5cGU6XCJsaW5lXCIsaWdub3JlSGlkZGVuU2VyaWVzOiEwLHNwYWNpbmc6WzEwLDEwLDE1LDEwXSxiYWNrZ3JvdW5kQ29sb3I6XCIjRkZGRkZGXCIscGxvdEJvcmRlckNvbG9yOlwiI0MwQzBDMFwiLHJlc2V0Wm9vbUJ1dHRvbjp7dGhlbWU6e3pJbmRleDoyMH0scG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4Oi0xMCx5OjEwfX19LHRpdGxlOnt0ZXh0OlwiQ2hhcnQgdGl0bGVcIixhbGlnbjpcImNlbnRlclwiLG1hcmdpbjoxNSxzdHlsZTp7Y29sb3I6XCIjMzMzMzMzXCIsZm9udFNpemU6XCIxOHB4XCJ9fSxzdWJ0aXRsZTp7dGV4dDpcIlwiLGFsaWduOlwiY2VudGVyXCIsc3R5bGU6e2NvbG9yOlwiIzU1NTU1NVwifX0scGxvdE9wdGlvbnM6e2xpbmU6e2FsbG93UG9pbnRTZWxlY3Q6ITEsc2hvd0NoZWNrYm94OiExLGFuaW1hdGlvbjp7ZHVyYXRpb246MUUzfSxldmVudHM6e30sbGluZVdpZHRoOjIsbWFya2VyOntsaW5lV2lkdGg6MCxyYWRpdXM6NCxsaW5lQ29sb3I6XCIjRkZGRkZGXCIsc3RhdGVzOntob3Zlcjp7ZW5hYmxlZDohMCxcbmxpbmVXaWR0aFBsdXM6MSxyYWRpdXNQbHVzOjJ9LHNlbGVjdDp7ZmlsbENvbG9yOlwiI0ZGRkZGRlwiLGxpbmVDb2xvcjpcIiMwMDAwMDBcIixsaW5lV2lkdGg6Mn19fSxwb2ludDp7ZXZlbnRzOnt9fSxkYXRhTGFiZWxzOnthbGlnbjpcImNlbnRlclwiLGZvcm1hdHRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnk9PT1udWxsP1wiXCI6Qi5udW1iZXJGb3JtYXQodGhpcy55LC0xKX0sc3R5bGU6e2NvbG9yOlwiY29udHJhc3RcIixmb250U2l6ZTpcIjExcHhcIixmb250V2VpZ2h0OlwiYm9sZFwiLHRleHRTaGFkb3c6XCIwIDAgNnB4IGNvbnRyYXN0LCAwIDAgM3B4IGNvbnRyYXN0XCJ9LHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix4OjAseTowLHBhZGRpbmc6NX0sY3JvcFRocmVzaG9sZDozMDAscG9pbnRSYW5nZTowLHN0YXRlczp7aG92ZXI6e2xpbmVXaWR0aFBsdXM6MSxtYXJrZXI6e30saGFsbzp7c2l6ZToxMCxvcGFjaXR5OjAuMjV9fSxzZWxlY3Q6e21hcmtlcjp7fX19LHN0aWNreVRyYWNraW5nOiEwLHR1cmJvVGhyZXNob2xkOjFFM319LFxubGFiZWxzOntzdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLGNvbG9yOlwiIzNFNTc2RlwifX0sbGVnZW5kOntlbmFibGVkOiEwLGFsaWduOlwiY2VudGVyXCIsbGF5b3V0OlwiaG9yaXpvbnRhbFwiLGxhYmVsRm9ybWF0dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZX0sYm9yZGVyQ29sb3I6XCIjOTA5MDkwXCIsYm9yZGVyUmFkaXVzOjAsbmF2aWdhdGlvbjp7YWN0aXZlQ29sb3I6XCIjMjc0YjZkXCIsaW5hY3RpdmVDb2xvcjpcIiNDQ0NcIn0sc2hhZG93OiExLGl0ZW1TdHlsZTp7Y29sb3I6XCIjMzMzMzMzXCIsZm9udFNpemU6XCIxMnB4XCIsZm9udFdlaWdodDpcImJvbGRcIn0saXRlbUhvdmVyU3R5bGU6e2NvbG9yOlwiIzAwMFwifSxpdGVtSGlkZGVuU3R5bGU6e2NvbG9yOlwiI0NDQ1wifSxpdGVtQ2hlY2tib3hTdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHdpZHRoOlwiMTNweFwiLGhlaWdodDpcIjEzcHhcIn0sc3ltYm9sUGFkZGluZzo1LHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix4OjAseTowLHRpdGxlOntzdHlsZTp7Zm9udFdlaWdodDpcImJvbGRcIn19fSxcbmxvYWRpbmc6e2xhYmVsU3R5bGU6e2ZvbnRXZWlnaHQ6XCJib2xkXCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLHRvcDpcIjQ1JVwifSxzdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLGJhY2tncm91bmRDb2xvcjpcIndoaXRlXCIsb3BhY2l0eTowLjUsdGV4dEFsaWduOlwiY2VudGVyXCJ9fSx0b29sdGlwOntlbmFibGVkOiEwLGFuaW1hdGlvbjpjYSxiYWNrZ3JvdW5kQ29sb3I6XCJyZ2JhKDI0OSwgMjQ5LCAyNDksIC44NSlcIixib3JkZXJXaWR0aDoxLGJvcmRlclJhZGl1czozLGRhdGVUaW1lTGFiZWxGb3JtYXRzOnttaWxsaXNlY29uZDpcIiVBLCAlYiAlZSwgJUg6JU06JVMuJUxcIixzZWNvbmQ6XCIlQSwgJWIgJWUsICVIOiVNOiVTXCIsbWludXRlOlwiJUEsICViICVlLCAlSDolTVwiLGhvdXI6XCIlQSwgJWIgJWUsICVIOiVNXCIsZGF5OlwiJUEsICViICVlLCAlWVwiLHdlZWs6XCJXZWVrIGZyb20gJUEsICViICVlLCAlWVwiLG1vbnRoOlwiJUIgJVlcIix5ZWFyOlwiJVlcIn0sZm9vdGVyRm9ybWF0OlwiXCIsaGVhZGVyRm9ybWF0Oic8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTBweFwiPntwb2ludC5rZXl9PC9zcGFuPjxici8+JyxcbnBvaW50Rm9ybWF0Oic8c3BhbiBzdHlsZT1cImNvbG9yOntwb2ludC5jb2xvcn1cIj5cXHUyNWNmPC9zcGFuPiB7c2VyaWVzLm5hbWV9OiA8Yj57cG9pbnQueX08L2I+PGJyLz4nLHNoYWRvdzohMCxzbmFwOkpiPzI1OjEwLHN0eWxlOntjb2xvcjpcIiMzMzMzMzNcIixjdXJzb3I6XCJkZWZhdWx0XCIsZm9udFNpemU6XCIxMnB4XCIscGFkZGluZzpcIjhweFwiLHdoaXRlU3BhY2U6XCJub3dyYXBcIn19LGNyZWRpdHM6e2VuYWJsZWQ6ITAsdGV4dDpcIkhpZ2hjaGFydHMuY29tXCIsaHJlZjpcImh0dHA6Ly93d3cuaGlnaGNoYXJ0cy5jb21cIixwb3NpdGlvbjp7YWxpZ246XCJyaWdodFwiLHg6LTEwLHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix5Oi01fSxzdHlsZTp7Y3Vyc29yOlwicG9pbnRlclwiLGNvbG9yOlwiIzkwOTA5MFwiLGZvbnRTaXplOlwiOXB4XCJ9fX07dmFyIGJhPVMucGxvdE9wdGlvbnMsVT1iYS5saW5lO0NiKCk7dmFyIFRiPS9yZ2JhXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XT8oPzpcXC5bMC05XSspPylcXHMqXFwpLyxcblViPS8jKFthLWZBLUYwLTldezJ9KShbYS1mQS1GMC05XXsyfSkoW2EtZkEtRjAtOV17Mn0pLyxWYj0vcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvLG5hPWZ1bmN0aW9uKGEpe3ZhciBiPVtdLGMsZDsoZnVuY3Rpb24oYSl7YSYmYS5zdG9wcz9kPVRhKGEuc3RvcHMsZnVuY3Rpb24oYSl7cmV0dXJuIG5hKGFbMV0pfSk6KGM9VGIuZXhlYyhhKSk/Yj1bRihjWzFdKSxGKGNbMl0pLEYoY1szXSkscGFyc2VGbG9hdChjWzRdLDEwKV06KGM9VWIuZXhlYyhhKSk/Yj1bRihjWzFdLDE2KSxGKGNbMl0sMTYpLEYoY1szXSwxNiksMV06KGM9VmIuZXhlYyhhKSkmJihiPVtGKGNbMV0pLEYoY1syXSksRihjWzNdKSwxXSl9KShhKTtyZXR1cm57Z2V0OmZ1bmN0aW9uKGMpe3ZhciBmO2Q/KGY9QShhKSxmLnN0b3BzPVtdLmNvbmNhdChmLnN0b3BzKSxvKGQsZnVuY3Rpb24oYSxiKXtmLnN0b3BzW2JdPVtmLnN0b3BzW2JdWzBdLGEuZ2V0KGMpXX0pKTpcbmY9YiYmIWlzTmFOKGJbMF0pP2M9PT1cInJnYlwiP1wicmdiKFwiK2JbMF0rXCIsXCIrYlsxXStcIixcIitiWzJdK1wiKVwiOmM9PT1cImFcIj9iWzNdOlwicmdiYShcIitiLmpvaW4oXCIsXCIpK1wiKVwiOmE7cmV0dXJuIGZ9LGJyaWdodGVuOmZ1bmN0aW9uKGEpe2lmKGQpbyhkLGZ1bmN0aW9uKGIpe2IuYnJpZ2h0ZW4oYSl9KTtlbHNlIGlmKHFhKGEpJiZhIT09MCl7dmFyIGM7Zm9yKGM9MDtjPDM7YysrKWJbY10rPUYoYSoyNTUpLGJbY108MCYmKGJbY109MCksYltjXT4yNTUmJihiW2NdPTI1NSl9cmV0dXJuIHRoaXN9LHJnYmE6YixzZXRPcGFjaXR5OmZ1bmN0aW9uKGEpe2JbM109YTtyZXR1cm4gdGhpc30scmF3OmF9fTtQLnByb3RvdHlwZT17b3BhY2l0eToxLHRleHRQcm9wczpcImZvbnRTaXplLGZvbnRXZWlnaHQsZm9udEZhbWlseSxmb250U3R5bGUsY29sb3IsbGluZUhlaWdodCx3aWR0aCx0ZXh0RGVjb3JhdGlvbix0ZXh0T3ZlcmZsb3csdGV4dFNoYWRvd1wiLnNwbGl0KFwiLFwiKSxpbml0OmZ1bmN0aW9uKGEsXG5iKXt0aGlzLmVsZW1lbnQ9Yj09PVwic3BhblwiPyQoYik6Qy5jcmVhdGVFbGVtZW50TlMoRGEsYik7dGhpcy5yZW5kZXJlcj1hfSxhbmltYXRlOmZ1bmN0aW9uKGEsYixjKXtiPXAoYix0aGlzLnJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbiwhMCk7a2IodGhpcyk7aWYoYil7Yj1BKGIse30pO2lmKGMpYi5jb21wbGV0ZT1jO2piKHRoaXMsYSxiKX1lbHNlIHRoaXMuYXR0cihhLG51bGwsYyk7cmV0dXJuIHRoaXN9LGNvbG9yR3JhZGllbnQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMucmVuZGVyZXIsZSxmLGcsaCxpLGosayxtLGwsbixxPVtdO2EubGluZWFyR3JhZGllbnQ/Zj1cImxpbmVhckdyYWRpZW50XCI6YS5yYWRpYWxHcmFkaWVudCYmKGY9XCJyYWRpYWxHcmFkaWVudFwiKTtpZihmKXtnPWFbZl07aD1kLmdyYWRpZW50cztqPWEuc3RvcHM7bD1jLnJhZGlhbFJlZmVyZW5jZTtGYShnKSYmKGFbZl09Zz17eDE6Z1swXSx5MTpnWzFdLHgyOmdbMl0seTI6Z1szXSxncmFkaWVudFVuaXRzOlwidXNlclNwYWNlT25Vc2VcIn0pO1xuZj09PVwicmFkaWFsR3JhZGllbnRcIiYmbCYmIXMoZy5ncmFkaWVudFVuaXRzKSYmKGc9QShnLHtjeDpsWzBdLWxbMl0vMitnLmN4KmxbMl0sY3k6bFsxXS1sWzJdLzIrZy5jeSpsWzJdLHI6Zy5yKmxbMl0sZ3JhZGllbnRVbml0czpcInVzZXJTcGFjZU9uVXNlXCJ9KSk7Zm9yKG4gaW4gZyluIT09XCJpZFwiJiZxLnB1c2gobixnW25dKTtmb3IobiBpbiBqKXEucHVzaChqW25dKTtxPXEuam9pbihcIixcIik7aFtxXT9hPWhbcV0uYXR0cihcImlkXCIpOihnLmlkPWE9XCJoaWdoY2hhcnRzLVwiK3diKyssaFtxXT1pPWQuY3JlYXRlRWxlbWVudChmKS5hdHRyKGcpLmFkZChkLmRlZnMpLGkuc3RvcHM9W10sbyhqLGZ1bmN0aW9uKGEpe2FbMV0uaW5kZXhPZihcInJnYmFcIik9PT0wPyhlPW5hKGFbMV0pLGs9ZS5nZXQoXCJyZ2JcIiksbT1lLmdldChcImFcIikpOihrPWFbMV0sbT0xKTthPWQuY3JlYXRlRWxlbWVudChcInN0b3BcIikuYXR0cih7b2Zmc2V0OmFbMF0sXCJzdG9wLWNvbG9yXCI6ayxcInN0b3Atb3BhY2l0eVwiOm19KS5hZGQoaSk7XG5pLnN0b3BzLnB1c2goYSl9KSk7Yy5zZXRBdHRyaWJ1dGUoYixcInVybChcIitkLnVybCtcIiNcIithK1wiKVwiKX19LGFwcGx5VGV4dFNoYWRvdzpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnQsYyxkPWEuaW5kZXhPZihcImNvbnRyYXN0XCIpIT09LTEsZT17fSxmPXRoaXMucmVuZGVyZXIuZm9yRXhwb3J0fHxiLnN0eWxlLnRleHRTaGFkb3chPT12JiYheGE7aWYoZCllLnRleHRTaGFkb3c9YT1hLnJlcGxhY2UoL2NvbnRyYXN0L2csdGhpcy5yZW5kZXJlci5nZXRDb250cmFzdChiLnN0eWxlLmZpbGwpKTtpZihmYillLnRleHRSZW5kZXJpbmc9XCJnZW9tZXRyaWNQcmVjaXNpb25cIjtmP0woYixlKToodGhpcy5mYWtlVFM9ITAsdGhpcy55U2V0dGVyPXRoaXMueFNldHRlcixjPVtdLnNsaWNlLmNhbGwoYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRzcGFuXCIpKSxvKGEuc3BsaXQoL1xccz8sXFxzPy9nKSxmdW5jdGlvbihhKXt2YXIgZD1iLmZpcnN0Q2hpbGQsZSxmLGE9YS5zcGxpdChcIiBcIik7ZT1hW2EubGVuZ3RoLVxuMV07KGY9YVthLmxlbmd0aC0yXSkmJm8oYyxmdW5jdGlvbihhLGMpe3ZhciBnO2M9PT0wJiYoYS5zZXRBdHRyaWJ1dGUoXCJ4XCIsYi5nZXRBdHRyaWJ1dGUoXCJ4XCIpKSxjPWIuZ2V0QXR0cmlidXRlKFwieVwiKSxhLnNldEF0dHJpYnV0ZShcInlcIixjfHwwKSxjPT09bnVsbCYmYi5zZXRBdHRyaWJ1dGUoXCJ5XCIsMCkpO2c9YS5jbG9uZU5vZGUoMSk7SihnLHtcImNsYXNzXCI6XCJoaWdoY2hhcnRzLXRleHQtc2hhZG93XCIsZmlsbDplLHN0cm9rZTplLFwic3Ryb2tlLW9wYWNpdHlcIjoxL3QoRihmKSwzKSxcInN0cm9rZS13aWR0aFwiOmYsXCJzdHJva2UtbGluZWpvaW5cIjpcInJvdW5kXCJ9KTtiLmluc2VydEJlZm9yZShnLGQpfSl9KSl9LGF0dHI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU9dGhpcy5lbGVtZW50LGYsZz10aGlzLGg7dHlwZW9mIGE9PT1cInN0cmluZ1wiJiZiIT09diYmKGQ9YSxhPXt9LGFbZF09Yik7aWYodHlwZW9mIGE9PT1cInN0cmluZ1wiKWc9KHRoaXNbYStcIkdldHRlclwiXXx8dGhpcy5fZGVmYXVsdEdldHRlcikuY2FsbCh0aGlzLFxuYSxlKTtlbHNle2ZvcihkIGluIGEpe2I9YVtkXTtoPSExO3RoaXMuc3ltYm9sTmFtZSYmL14oeHx5fHdpZHRofGhlaWdodHxyfHN0YXJ0fGVuZHxpbm5lclJ8YW5jaG9yWHxhbmNob3JZKS8udGVzdChkKSYmKGZ8fCh0aGlzLnN5bWJvbEF0dHIoYSksZj0hMCksaD0hMCk7aWYodGhpcy5yb3RhdGlvbiYmKGQ9PT1cInhcInx8ZD09PVwieVwiKSl0aGlzLmRvVHJhbnNmb3JtPSEwO2h8fCh0aGlzW2QrXCJTZXR0ZXJcIl18fHRoaXMuX2RlZmF1bHRTZXR0ZXIpLmNhbGwodGhpcyxiLGQsZSk7dGhpcy5zaGFkb3dzJiYvXih3aWR0aHxoZWlnaHR8dmlzaWJpbGl0eXx4fHl8ZHx0cmFuc2Zvcm18Y3h8Y3l8cikkLy50ZXN0KGQpJiZ0aGlzLnVwZGF0ZVNoYWRvd3MoZCxiKX1pZih0aGlzLmRvVHJhbnNmb3JtKXRoaXMudXBkYXRlVHJhbnNmb3JtKCksdGhpcy5kb1RyYW5zZm9ybT0hMX1jJiZjKCk7cmV0dXJuIGd9LHVwZGF0ZVNoYWRvd3M6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9dGhpcy5zaGFkb3dzLFxuZD1jLmxlbmd0aDtkLS07KWNbZF0uc2V0QXR0cmlidXRlKGEsYT09PVwiaGVpZ2h0XCI/dChiLShjW2RdLmN1dEhlaWdodHx8MCksMCk6YT09PVwiZFwiP3RoaXMuZDpiKX0sYWRkQ2xhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50LGM9SihiLFwiY2xhc3NcIil8fFwiXCI7Yy5pbmRleE9mKGEpPT09LTEmJkooYixcImNsYXNzXCIsYytcIiBcIithKTtyZXR1cm4gdGhpc30sc3ltYm9sQXR0cjpmdW5jdGlvbihhKXt2YXIgYj10aGlzO28oXCJ4LHkscixzdGFydCxlbmQsd2lkdGgsaGVpZ2h0LGlubmVyUixhbmNob3JYLGFuY2hvcllcIi5zcGxpdChcIixcIiksZnVuY3Rpb24oYyl7YltjXT1wKGFbY10sYltjXSl9KTtiLmF0dHIoe2Q6Yi5yZW5kZXJlci5zeW1ib2xzW2Iuc3ltYm9sTmFtZV0oYi54LGIueSxiLndpZHRoLGIuaGVpZ2h0LGIpfSl9LGNsaXA6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYXR0cihcImNsaXAtcGF0aFwiLGE/XCJ1cmwoXCIrdGhpcy5yZW5kZXJlci51cmwrXCIjXCIrYS5pZCtcIilcIjpPKX0sXG5jcmlzcDpmdW5jdGlvbihhKXt2YXIgYixjPXt9LGQsZT1hLnN0cm9rZVdpZHRofHx0aGlzLnN0cm9rZVdpZHRofHwwO2Q9dyhlKSUyLzI7YS54PVYoYS54fHx0aGlzLnh8fDApK2Q7YS55PVYoYS55fHx0aGlzLnl8fDApK2Q7YS53aWR0aD1WKChhLndpZHRofHx0aGlzLndpZHRofHwwKS0yKmQpO2EuaGVpZ2h0PVYoKGEuaGVpZ2h0fHx0aGlzLmhlaWdodHx8MCktMipkKTthLnN0cm9rZVdpZHRoPWU7Zm9yKGIgaW4gYSl0aGlzW2JdIT09YVtiXSYmKHRoaXNbYl09Y1tiXT1hW2JdKTtyZXR1cm4gY30sY3NzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3R5bGVzLGM9e30sZD10aGlzLmVsZW1lbnQsZSxmLGc9XCJcIjtlPSFiO2lmKGEmJmEuY29sb3IpYS5maWxsPWEuY29sb3I7aWYoYilmb3IoZiBpbiBhKWFbZl0hPT1iW2ZdJiYoY1tmXT1hW2ZdLGU9ITApO2lmKGUpe2U9dGhpcy50ZXh0V2lkdGg9YSYmYS53aWR0aCYmZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09XCJ0ZXh0XCImJkYoYS53aWR0aCl8fFxudGhpcy50ZXh0V2lkdGg7YiYmKGE9cihiLGMpKTt0aGlzLnN0eWxlcz1hO2UmJihmYXx8IWNhJiZ0aGlzLnJlbmRlcmVyLmZvckV4cG9ydCkmJmRlbGV0ZSBhLndpZHRoO2lmKHhhJiYhY2EpTCh0aGlzLmVsZW1lbnQsYSk7ZWxzZXtiPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCItXCIrYi50b0xvd2VyQ2FzZSgpfTtmb3IoZiBpbiBhKWcrPWYucmVwbGFjZSgvKFtBLVpdKS9nLGIpK1wiOlwiK2FbZl0rXCI7XCI7SihkLFwic3R5bGVcIixnKX1lJiZ0aGlzLmFkZGVkJiZ0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKX1yZXR1cm4gdGhpc30sb246ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yy5lbGVtZW50OyRhJiZhPT09XCJjbGlja1wiPyhkLm9udG91Y2hzdGFydD1mdW5jdGlvbihhKXtjLnRvdWNoRXZlbnRGaXJlZD15YS5ub3coKTthLnByZXZlbnREZWZhdWx0KCk7Yi5jYWxsKGQsYSl9LGQub25jbGljaz1mdW5jdGlvbihhKXsoemEuaW5kZXhPZihcIkFuZHJvaWRcIik9PT0tMXx8eWEubm93KCktXG4oYy50b3VjaEV2ZW50RmlyZWR8fDApPjExMDApJiZiLmNhbGwoZCxhKX0pOmRbXCJvblwiK2FdPWI7cmV0dXJuIHRoaXN9LHNldFJhZGlhbFJlZmVyZW5jZTpmdW5jdGlvbihhKXt0aGlzLmVsZW1lbnQucmFkaWFsUmVmZXJlbmNlPWE7cmV0dXJuIHRoaXN9LHRyYW5zbGF0ZTpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmF0dHIoe3RyYW5zbGF0ZVg6YSx0cmFuc2xhdGVZOmJ9KX0saW52ZXJ0OmZ1bmN0aW9uKCl7dGhpcy5pbnZlcnRlZD0hMDt0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO3JldHVybiB0aGlzfSx1cGRhdGVUcmFuc2Zvcm06ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnRyYW5zbGF0ZVh8fDAsYj10aGlzLnRyYW5zbGF0ZVl8fDAsYz10aGlzLnNjYWxlWCxkPXRoaXMuc2NhbGVZLGU9dGhpcy5pbnZlcnRlZCxmPXRoaXMucm90YXRpb24sZz10aGlzLmVsZW1lbnQ7ZSYmKGErPXRoaXMuYXR0cihcIndpZHRoXCIpLGIrPXRoaXMuYXR0cihcImhlaWdodFwiKSk7YT1bXCJ0cmFuc2xhdGUoXCIrYStcblwiLFwiK2IrXCIpXCJdO2U/YS5wdXNoKFwicm90YXRlKDkwKSBzY2FsZSgtMSwxKVwiKTpmJiZhLnB1c2goXCJyb3RhdGUoXCIrZitcIiBcIisoZy5nZXRBdHRyaWJ1dGUoXCJ4XCIpfHwwKStcIiBcIisoZy5nZXRBdHRyaWJ1dGUoXCJ5XCIpfHwwKStcIilcIik7KHMoYyl8fHMoZCkpJiZhLnB1c2goXCJzY2FsZShcIitwKGMsMSkrXCIgXCIrcChkLDEpK1wiKVwiKTthLmxlbmd0aCYmZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIixhLmpvaW4oXCIgXCIpKX0sdG9Gcm9udDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudDthLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoYSk7cmV0dXJuIHRoaXN9LGFsaWduOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoPXt9O2U9dGhpcy5yZW5kZXJlcjtmPWUuYWxpZ25lZE9iamVjdHM7aWYoYSl7aWYodGhpcy5hbGlnbk9wdGlvbnM9YSx0aGlzLmFsaWduQnlUcmFuc2xhdGU9YiwhY3x8QWEoYykpdGhpcy5hbGlnblRvPWQ9Y3x8XCJyZW5kZXJlclwiLGphKGYsdGhpcyksZi5wdXNoKHRoaXMpLFxuYz1udWxsfWVsc2UgYT10aGlzLmFsaWduT3B0aW9ucyxiPXRoaXMuYWxpZ25CeVRyYW5zbGF0ZSxkPXRoaXMuYWxpZ25UbztjPXAoYyxlW2RdLGUpO2Q9YS5hbGlnbjtlPWEudmVydGljYWxBbGlnbjtmPShjLnh8fDApKyhhLnh8fDApO2c9KGMueXx8MCkrKGEueXx8MCk7aWYoZD09PVwicmlnaHRcInx8ZD09PVwiY2VudGVyXCIpZis9KGMud2lkdGgtKGEud2lkdGh8fDApKS97cmlnaHQ6MSxjZW50ZXI6Mn1bZF07aFtiP1widHJhbnNsYXRlWFwiOlwieFwiXT13KGYpO2lmKGU9PT1cImJvdHRvbVwifHxlPT09XCJtaWRkbGVcIilnKz0oYy5oZWlnaHQtKGEuaGVpZ2h0fHwwKSkvKHtib3R0b206MSxtaWRkbGU6Mn1bZV18fDEpO2hbYj9cInRyYW5zbGF0ZVlcIjpcInlcIl09dyhnKTt0aGlzW3RoaXMucGxhY2VkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXShoKTt0aGlzLnBsYWNlZD0hMDt0aGlzLmFsaWduQXR0cj1oO3JldHVybiB0aGlzfSxnZXRCQm94OmZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcy5yZW5kZXJlcixkLGU9dGhpcy5yb3RhdGlvbixcbmY9dGhpcy5lbGVtZW50LGc9dGhpcy5zdHlsZXMsaD1lKmdhO2Q9dGhpcy50ZXh0U3RyO3ZhciBpLGo9Zi5zdHlsZSxrLG07ZCE9PXYmJihtPVtcIlwiLGV8fDAsZyYmZy5mb250U2l6ZSxmLnN0eWxlLndpZHRoXS5qb2luKFwiLFwiKSxtPWQ9PT1cIlwifHxPYi50ZXN0KGQpP1wibnVtOlwiK2QudG9TdHJpbmcoKS5sZW5ndGgrbTpkK20pO20mJiFhJiYoYj1jLmNhY2hlW21dKTtpZighYil7aWYoZi5uYW1lc3BhY2VVUkk9PT1EYXx8Yy5mb3JFeHBvcnQpe3RyeXtrPXRoaXMuZmFrZVRTJiZmdW5jdGlvbihhKXtvKGYucXVlcnlTZWxlY3RvckFsbChcIi5oaWdoY2hhcnRzLXRleHQtc2hhZG93XCIpLGZ1bmN0aW9uKGIpe2Iuc3R5bGUuZGlzcGxheT1hfSl9LEphJiZqLnRleHRTaGFkb3c/KGk9ai50ZXh0U2hhZG93LGoudGV4dFNoYWRvdz1cIlwiKTprJiZrKE8pLGI9Zi5nZXRCQm94P3Ioe30sZi5nZXRCQm94KCkpOnt3aWR0aDpmLm9mZnNldFdpZHRoLGhlaWdodDpmLm9mZnNldEhlaWdodH0saT9qLnRleHRTaGFkb3c9XG5pOmsmJmsoXCJcIil9Y2F0Y2gobCl7fWlmKCFifHxiLndpZHRoPDApYj17d2lkdGg6MCxoZWlnaHQ6MH19ZWxzZSBiPXRoaXMuaHRtbEdldEJCb3goKTtpZihjLmlzU1ZHKXthPWIud2lkdGg7ZD1iLmhlaWdodDtpZih4YSYmZyYmZy5mb250U2l6ZT09PVwiMTFweFwiJiZkLnRvUHJlY2lzaW9uKDMpPT09XCIxNi45XCIpYi5oZWlnaHQ9ZD0xNDtpZihlKWIud2lkdGg9TihkKmFhKGgpKStOKGEqWChoKSksYi5oZWlnaHQ9TihkKlgoaCkpK04oYSphYShoKSl9bSYmKGMuY2FjaGVbbV09Yil9cmV0dXJuIGJ9LHNob3c6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYXR0cih7dmlzaWJpbGl0eTphP1wiaW5oZXJpdFwiOlwidmlzaWJsZVwifSl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdHRyKHt2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9KX0sZmFkZU91dDpmdW5jdGlvbihhKXt2YXIgYj10aGlzO2IuYW5pbWF0ZSh7b3BhY2l0eTowfSx7ZHVyYXRpb246YXx8MTUwLGNvbXBsZXRlOmZ1bmN0aW9uKCl7Yi5hdHRyKHt5Oi05OTk5fSl9fSl9LFxuYWRkOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMucmVuZGVyZXIsYz10aGlzLmVsZW1lbnQsZDtpZihhKXRoaXMucGFyZW50R3JvdXA9YTt0aGlzLnBhcmVudEludmVydGVkPWEmJmEuaW52ZXJ0ZWQ7dGhpcy50ZXh0U3RyIT09dm9pZCAwJiZiLmJ1aWxkVGV4dCh0aGlzKTt0aGlzLmFkZGVkPSEwO2lmKCFhfHxhLmhhbmRsZVp8fHRoaXMuekluZGV4KWQ9dGhpcy56SW5kZXhTZXR0ZXIoKTtkfHwoYT9hLmVsZW1lbnQ6Yi5ib3gpLmFwcGVuZENoaWxkKGMpO2lmKHRoaXMub25BZGQpdGhpcy5vbkFkZCgpO3JldHVybiB0aGlzfSxzYWZlUmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO2ImJmIucmVtb3ZlQ2hpbGQoYSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5lbGVtZW50fHx7fSxjPWEuc2hhZG93cyxkPWEucmVuZGVyZXIuaXNTVkcmJmIubm9kZU5hbWU9PT1cIlNQQU5cIiYmYS5wYXJlbnRHcm91cCxlLGY7Yi5vbmNsaWNrPWIub25tb3VzZW91dD1cbmIub25tb3VzZW92ZXI9Yi5vbm1vdXNlbW92ZT1iLnBvaW50PW51bGw7a2IoYSk7aWYoYS5jbGlwUGF0aClhLmNsaXBQYXRoPWEuY2xpcFBhdGguZGVzdHJveSgpO2lmKGEuc3RvcHMpe2ZvcihmPTA7ZjxhLnN0b3BzLmxlbmd0aDtmKyspYS5zdG9wc1tmXT1hLnN0b3BzW2ZdLmRlc3Ryb3koKTthLnN0b3BzPW51bGx9YS5zYWZlUmVtb3ZlQ2hpbGQoYik7Zm9yKGMmJm8oYyxmdW5jdGlvbihiKXthLnNhZmVSZW1vdmVDaGlsZChiKX0pO2QmJmQuZGl2JiZkLmRpdi5jaGlsZE5vZGVzLmxlbmd0aD09PTA7KWI9ZC5wYXJlbnRHcm91cCxhLnNhZmVSZW1vdmVDaGlsZChkLmRpdiksZGVsZXRlIGQuZGl2LGQ9YjthLmFsaWduVG8mJmphKGEucmVuZGVyZXIuYWxpZ25lZE9iamVjdHMsYSk7Zm9yKGUgaW4gYSlkZWxldGUgYVtlXTtyZXR1cm4gbnVsbH0sc2hhZG93OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1bXSxlLGYsZz10aGlzLmVsZW1lbnQsaCxpLGosaztpZihhKXtpPXAoYS53aWR0aCwzKTtcbmo9KGEub3BhY2l0eXx8MC4xNSkvaTtrPXRoaXMucGFyZW50SW52ZXJ0ZWQ/XCIoLTEsLTEpXCI6XCIoXCIrcChhLm9mZnNldFgsMSkrXCIsIFwiK3AoYS5vZmZzZXRZLDEpK1wiKVwiO2ZvcihlPTE7ZTw9aTtlKyspe2Y9Zy5jbG9uZU5vZGUoMCk7aD1pKjIrMS0yKmU7SihmLHtpc1NoYWRvdzpcInRydWVcIixzdHJva2U6YS5jb2xvcnx8XCJibGFja1wiLFwic3Ryb2tlLW9wYWNpdHlcIjpqKmUsXCJzdHJva2Utd2lkdGhcIjpoLHRyYW5zZm9ybTpcInRyYW5zbGF0ZVwiK2ssZmlsbDpPfSk7aWYoYylKKGYsXCJoZWlnaHRcIix0KEooZixcImhlaWdodFwiKS1oLDApKSxmLmN1dEhlaWdodD1oO2I/Yi5lbGVtZW50LmFwcGVuZENoaWxkKGYpOmcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZixnKTtkLnB1c2goZil9dGhpcy5zaGFkb3dzPWR9cmV0dXJuIHRoaXN9LHhHZXR0ZXI6ZnVuY3Rpb24oYSl7dGhpcy5lbGVtZW50Lm5vZGVOYW1lPT09XCJjaXJjbGVcIiYmKGE9e3g6XCJjeFwiLHk6XCJjeVwifVthXXx8YSk7cmV0dXJuIHRoaXMuX2RlZmF1bHRHZXR0ZXIoYSl9LFxuX2RlZmF1bHRHZXR0ZXI6ZnVuY3Rpb24oYSl7YT1wKHRoaXNbYV0sdGhpcy5lbGVtZW50P3RoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoYSk6bnVsbCwwKTsvXltcXC0wLTlcXC5dKyQvLnRlc3QoYSkmJihhPXBhcnNlRmxvYXQoYSkpO3JldHVybiBhfSxkU2V0dGVyOmZ1bmN0aW9uKGEsYixjKXthJiZhLmpvaW4mJihhPWEuam9pbihcIiBcIikpOy8oTmFOfCB7Mn18XiQpLy50ZXN0KGEpJiYoYT1cIk0gMCAwXCIpO2Muc2V0QXR0cmlidXRlKGIsYSk7dGhpc1tiXT1hfSxkYXNoc3R5bGVTZXR0ZXI6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoYT1hJiZhLnRvTG93ZXJDYXNlKCkpe2E9YS5yZXBsYWNlKFwic2hvcnRkYXNoZG90ZG90XCIsXCIzLDEsMSwxLDEsMSxcIikucmVwbGFjZShcInNob3J0ZGFzaGRvdFwiLFwiMywxLDEsMVwiKS5yZXBsYWNlKFwic2hvcnRkb3RcIixcIjEsMSxcIikucmVwbGFjZShcInNob3J0ZGFzaFwiLFwiMywxLFwiKS5yZXBsYWNlKFwibG9uZ2Rhc2hcIixcIjgsMyxcIikucmVwbGFjZSgvZG90L2csXCIxLDMsXCIpLnJlcGxhY2UoXCJkYXNoXCIsXG5cIjQsMyxcIikucmVwbGFjZSgvLCQvLFwiXCIpLnNwbGl0KFwiLFwiKTtmb3IoYj1hLmxlbmd0aDtiLS07KWFbYl09RihhW2JdKSp0aGlzW1wic3Ryb2tlLXdpZHRoXCJdO2E9YS5qb2luKFwiLFwiKS5yZXBsYWNlKFwiTmFOXCIsXCJub25lXCIpO3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsYSl9fSxhbGlnblNldHRlcjpmdW5jdGlvbihhKXt0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGV4dC1hbmNob3JcIix7bGVmdDpcInN0YXJ0XCIsY2VudGVyOlwibWlkZGxlXCIscmlnaHQ6XCJlbmRcIn1bYV0pfSxvcGFjaXR5U2V0dGVyOmZ1bmN0aW9uKGEsYixjKXt0aGlzW2JdPWE7Yy5zZXRBdHRyaWJ1dGUoYixhKX0sdGl0bGVTZXR0ZXI6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGl0bGVcIilbMF07Ynx8KGI9Qy5jcmVhdGVFbGVtZW50TlMoRGEsXCJ0aXRsZVwiKSx0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoYikpO2IuYXBwZW5kQ2hpbGQoQy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcocChhKSxcblwiXCIpLnJlcGxhY2UoLzxbXj5dKj4vZyxcIlwiKSkpfSx0ZXh0U2V0dGVyOmZ1bmN0aW9uKGEpe2lmKGEhPT10aGlzLnRleHRTdHIpZGVsZXRlIHRoaXMuYkJveCx0aGlzLnRleHRTdHI9YSx0aGlzLmFkZGVkJiZ0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKX0sZmlsbFNldHRlcjpmdW5jdGlvbihhLGIsYyl7dHlwZW9mIGE9PT1cInN0cmluZ1wiP2Muc2V0QXR0cmlidXRlKGIsYSk6YSYmdGhpcy5jb2xvckdyYWRpZW50KGEsYixjKX0sdmlzaWJpbGl0eVNldHRlcjpmdW5jdGlvbihhLGIsYyl7YT09PVwiaW5oZXJpdFwiP2MucmVtb3ZlQXR0cmlidXRlKGIpOmMuc2V0QXR0cmlidXRlKGIsYSl9LHpJbmRleFNldHRlcjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMucmVuZGVyZXIsZD10aGlzLnBhcmVudEdyb3VwLGM9KGR8fGMpLmVsZW1lbnR8fGMuYm94LGUsZixnPXRoaXMuZWxlbWVudCxoO2U9dGhpcy5hZGRlZDt2YXIgaTtzKGEpJiYoZy5zZXRBdHRyaWJ1dGUoYixhKSxhPSthLHRoaXNbYl09PT1cbmEmJihlPSExKSx0aGlzW2JdPWEpO2lmKGUpe2lmKChhPXRoaXMuekluZGV4KSYmZClkLmhhbmRsZVo9ITA7ZD1jLmNoaWxkTm9kZXM7Zm9yKGk9MDtpPGQubGVuZ3RoJiYhaDtpKyspaWYoZT1kW2ldLGY9SihlLFwiekluZGV4XCIpLGUhPT1nJiYoRihmKT5hfHwhcyhhKSYmcyhmKSkpYy5pbnNlcnRCZWZvcmUoZyxlKSxoPSEwO2h8fGMuYXBwZW5kQ2hpbGQoZyl9cmV0dXJuIGh9LF9kZWZhdWx0U2V0dGVyOmZ1bmN0aW9uKGEsYixjKXtjLnNldEF0dHJpYnV0ZShiLGEpfX07UC5wcm90b3R5cGUueUdldHRlcj1QLnByb3RvdHlwZS54R2V0dGVyO1AucHJvdG90eXBlLnRyYW5zbGF0ZVhTZXR0ZXI9UC5wcm90b3R5cGUudHJhbnNsYXRlWVNldHRlcj1QLnByb3RvdHlwZS5yb3RhdGlvblNldHRlcj1QLnByb3RvdHlwZS52ZXJ0aWNhbEFsaWduU2V0dGVyPVAucHJvdG90eXBlLnNjYWxlWFNldHRlcj1QLnByb3RvdHlwZS5zY2FsZVlTZXR0ZXI9ZnVuY3Rpb24oYSxiKXt0aGlzW2JdPWE7dGhpcy5kb1RyYW5zZm9ybT1cbiEwfTtQLnByb3RvdHlwZVtcInN0cm9rZS13aWR0aFNldHRlclwiXT1QLnByb3RvdHlwZS5zdHJva2VTZXR0ZXI9ZnVuY3Rpb24oYSxiLGMpe3RoaXNbYl09YTtpZih0aGlzLnN0cm9rZSYmdGhpc1tcInN0cm9rZS13aWR0aFwiXSl0aGlzLnN0cm9rZVdpZHRoPXRoaXNbXCJzdHJva2Utd2lkdGhcIl0sUC5wcm90b3R5cGUuZmlsbFNldHRlci5jYWxsKHRoaXMsdGhpcy5zdHJva2UsXCJzdHJva2VcIixjKSxjLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLHRoaXNbXCJzdHJva2Utd2lkdGhcIl0pLHRoaXMuaGFzU3Ryb2tlPSEwO2Vsc2UgaWYoYj09PVwic3Ryb2tlLXdpZHRoXCImJmE9PT0wJiZ0aGlzLmhhc1N0cm9rZSljLnJlbW92ZUF0dHJpYnV0ZShcInN0cm9rZVwiKSx0aGlzLmhhc1N0cm9rZT0hMX07dmFyIHVhPWZ1bmN0aW9uKCl7dGhpcy5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dWEucHJvdG90eXBlPXtFbGVtZW50OlAsaW5pdDpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWxvY2F0aW9uLFxuZyxkPXRoaXMuY3JlYXRlRWxlbWVudChcInN2Z1wiKS5hdHRyKHt2ZXJzaW9uOlwiMS4xXCJ9KS5jc3ModGhpcy5nZXRTdHlsZShkKSk7Zz1kLmVsZW1lbnQ7YS5hcHBlbmRDaGlsZChnKTthLmlubmVySFRNTC5pbmRleE9mKFwieG1sbnNcIik9PT0tMSYmSihnLFwieG1sbnNcIixEYSk7dGhpcy5pc1NWRz0hMDt0aGlzLmJveD1nO3RoaXMuYm94V3JhcHBlcj1kO3RoaXMuYWxpZ25lZE9iamVjdHM9W107dGhpcy51cmw9KEphfHxmYikmJkMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJiYXNlXCIpLmxlbmd0aD9mLmhyZWYucmVwbGFjZSgvIy4qPyQvLFwiXCIpLnJlcGxhY2UoLyhbXFwoJ1xcKV0pL2csXCJcXFxcJDFcIikucmVwbGFjZSgvIC9nLFwiJTIwXCIpOlwiXCI7dGhpcy5jcmVhdGVFbGVtZW50KFwiZGVzY1wiKS5hZGQoKS5lbGVtZW50LmFwcGVuZENoaWxkKEMuY3JlYXRlVGV4dE5vZGUoXCJDcmVhdGVkIHdpdGggSGlnaGNoYXJ0cyA0LjEuOFwiKSk7dGhpcy5kZWZzPXRoaXMuY3JlYXRlRWxlbWVudChcImRlZnNcIikuYWRkKCk7XG50aGlzLmZvckV4cG9ydD1lO3RoaXMuZ3JhZGllbnRzPXt9O3RoaXMuY2FjaGU9e307dGhpcy5zZXRTaXplKGIsYywhMSk7dmFyIGg7aWYoSmEmJmEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KXRoaXMuc3ViUGl4ZWxGaXg9Yj1mdW5jdGlvbigpe0woYSx7bGVmdDowLHRvcDowfSk7aD1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO0woYSx7bGVmdDpzYShoLmxlZnQpLWgubGVmdCtcInB4XCIsdG9wOnNhKGgudG9wKS1oLnRvcCtcInB4XCJ9KX0sYigpLEgoSyxcInJlc2l6ZVwiLGIpfSxnZXRTdHlsZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zdHlsZT1yKHtmb250RmFtaWx5OidcIkx1Y2lkYSBHcmFuZGVcIiwgXCJMdWNpZGEgU2FucyBVbmljb2RlXCIsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLGZvbnRTaXplOlwiMTJweFwifSxhKX0saXNIaWRkZW46ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5ib3hXcmFwcGVyLmdldEJCb3goKS53aWR0aH0sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZGVmcztcbnRoaXMuYm94PW51bGw7dGhpcy5ib3hXcmFwcGVyPXRoaXMuYm94V3JhcHBlci5kZXN0cm95KCk7T2EodGhpcy5ncmFkaWVudHN8fHt9KTt0aGlzLmdyYWRpZW50cz1udWxsO2lmKGEpdGhpcy5kZWZzPWEuZGVzdHJveSgpO3RoaXMuc3ViUGl4ZWxGaXgmJlooSyxcInJlc2l6ZVwiLHRoaXMuc3ViUGl4ZWxGaXgpO3JldHVybiB0aGlzLmFsaWduZWRPYmplY3RzPW51bGx9LGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IHRoaXMuRWxlbWVudDtiLmluaXQodGhpcyxhKTtyZXR1cm4gYn0sZHJhdzpmdW5jdGlvbigpe30sYnVpbGRUZXh0OmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLmVsZW1lbnQsYz10aGlzLGQ9Yy5mb3JFeHBvcnQsZT1wKGEudGV4dFN0cixcIlwiKS50b1N0cmluZygpLGY9ZS5pbmRleE9mKFwiPFwiKSE9PS0xLGc9Yi5jaGlsZE5vZGVzLGgsaSxqPUooYixcInhcIiksaz1hLnN0eWxlcyxtPWEudGV4dFdpZHRoLGw9ayYmay5saW5lSGVpZ2h0LG49ayYmay50ZXh0U2hhZG93LFxucT1rJiZrLnRleHRPdmVyZmxvdz09PVwiZWxsaXBzaXNcIix4PWcubGVuZ3RoLFQ9bSYmIWEuYWRkZWQmJnRoaXMuYm94LFE9ZnVuY3Rpb24oYSl7cmV0dXJuIGw/RihsKTpjLmZvbnRNZXRyaWNzKC8ocHh8ZW0pJC8udGVzdChhJiZhLnN0eWxlLmZvbnRTaXplKT9hLnN0eWxlLmZvbnRTaXplOmsmJmsuZm9udFNpemV8fGMuc3R5bGUuZm9udFNpemV8fDEyLGEpLmh9LHU9ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZSgvJmx0Oy9nLFwiPFwiKS5yZXBsYWNlKC8mZ3Q7L2csXCI+XCIpfTt4LS07KWIucmVtb3ZlQ2hpbGQoZ1t4XSk7IWYmJiFuJiYhcSYmZS5pbmRleE9mKFwiIFwiKT09PS0xP2IuYXBwZW5kQ2hpbGQoQy5jcmVhdGVUZXh0Tm9kZSh1KGUpKSk6KGg9LzwuKnN0eWxlPVwiKFteXCJdKylcIi4qPi8saT0vPC4qaHJlZj1cIihodHRwW15cIl0rKVwiLio+LyxUJiZULmFwcGVuZENoaWxkKGIpLGU9Zj9lLnJlcGxhY2UoLzwoYnxzdHJvbmcpPi9nLCc8c3BhbiBzdHlsZT1cImZvbnQtd2VpZ2h0OmJvbGRcIj4nKS5yZXBsYWNlKC88KGl8ZW0pPi9nLFxuJzxzcGFuIHN0eWxlPVwiZm9udC1zdHlsZTppdGFsaWNcIj4nKS5yZXBsYWNlKC88YS9nLFwiPHNwYW5cIikucmVwbGFjZSgvPFxcLyhifHN0cm9uZ3xpfGVtfGEpPi9nLFwiPC9zcGFuPlwiKS5zcGxpdCgvPGJyLio/Pi9nKTpbZV0sZVtlLmxlbmd0aC0xXT09PVwiXCImJmUucG9wKCksbyhlLGZ1bmN0aW9uKGUsZil7dmFyIGcsbD0wLGU9ZS5yZXBsYWNlKC88c3Bhbi9nLFwifHx8PHNwYW5cIikucmVwbGFjZSgvPFxcL3NwYW4+L2csXCI8L3NwYW4+fHx8XCIpO2c9ZS5zcGxpdChcInx8fFwiKTtvKGcsZnVuY3Rpb24oZSl7aWYoZSE9PVwiXCJ8fGcubGVuZ3RoPT09MSl7dmFyIG49e30seD1DLmNyZWF0ZUVsZW1lbnROUyhEYSxcInRzcGFuXCIpLHA7aC50ZXN0KGUpJiYocD1lLm1hdGNoKGgpWzFdLnJlcGxhY2UoLyg7fCB8Xiljb2xvcihbIDpdKS8sXCIkMWZpbGwkMlwiKSxKKHgsXCJzdHlsZVwiLHApKTtpLnRlc3QoZSkmJiFkJiYoSih4LFwib25jbGlja1wiLCdsb2NhdGlvbi5ocmVmPVwiJytlLm1hdGNoKGkpWzFdKydcIicpLFxuTCh4LHtjdXJzb3I6XCJwb2ludGVyXCJ9KSk7ZT11KGUucmVwbGFjZSgvPCgufFxcbikqPz4vZyxcIlwiKXx8XCIgXCIpO2lmKGUhPT1cIiBcIil7eC5hcHBlbmRDaGlsZChDLmNyZWF0ZVRleHROb2RlKGUpKTtpZihsKW4uZHg9MDtlbHNlIGlmKGYmJmohPT1udWxsKW4ueD1qO0ooeCxuKTtiLmFwcGVuZENoaWxkKHgpOyFsJiZmJiYoIWNhJiZkJiZMKHgse2Rpc3BsYXk6XCJibG9ja1wifSksSih4LFwiZHlcIixRKHgpKSk7aWYobSl7Zm9yKHZhciBuPWUucmVwbGFjZSgvKFteXFxeXSktL2csXCIkMS0gXCIpLnNwbGl0KFwiIFwiKSxvPWcubGVuZ3RoPjF8fGZ8fG4ubGVuZ3RoPjEmJmsud2hpdGVTcGFjZSE9PVwibm93cmFwXCIsVCx5LHMsdD1bXSx2PVEoeCksdz0xLHI9YS5yb3RhdGlvbix6PWUsQT16Lmxlbmd0aDsob3x8cSkmJihuLmxlbmd0aHx8dC5sZW5ndGgpOylhLnJvdGF0aW9uPTAsVD1hLmdldEJCb3goITApLHM9VC53aWR0aCwhY2EmJmMuZm9yRXhwb3J0JiYocz1jLm1lYXN1cmVTcGFuV2lkdGgoeC5maXJzdENoaWxkLmRhdGEsXG5hLnN0eWxlcykpLFQ9cz5tLHk9PT12b2lkIDAmJih5PVQpLHEmJnk/KEEvPTIsej09PVwiXCJ8fCFUJiZBPDAuNT9uPVtdOihUJiYoeT0hMCksej1lLnN1YnN0cmluZygwLHoubGVuZ3RoKyhUPy0xOjEpKnNhKEEpKSxuPVt6KyhtPjM/XCJcXHUyMDI2XCI6XCJcIildLHgucmVtb3ZlQ2hpbGQoeC5maXJzdENoaWxkKSkpOiFUfHxuLmxlbmd0aD09PTE/KG49dCx0PVtdLG4ubGVuZ3RoJiYodysrLHg9Qy5jcmVhdGVFbGVtZW50TlMoRGEsXCJ0c3BhblwiKSxKKHgse2R5OnYseDpqfSkscCYmSih4LFwic3R5bGVcIixwKSxiLmFwcGVuZENoaWxkKHgpKSxzPm0mJihtPXMpKTooeC5yZW1vdmVDaGlsZCh4LmZpcnN0Q2hpbGQpLHQudW5zaGlmdChuLnBvcCgpKSksbi5sZW5ndGgmJnguYXBwZW5kQ2hpbGQoQy5jcmVhdGVUZXh0Tm9kZShuLmpvaW4oXCIgXCIpLnJlcGxhY2UoLy0gL2csXCItXCIpKSk7eSYmYS5hdHRyKFwidGl0bGVcIixhLnRleHRTdHIpO2Eucm90YXRpb249cn1sKyt9fX0pfSksVCYmVC5yZW1vdmVDaGlsZChiKSxcbm4mJmEuYXBwbHlUZXh0U2hhZG93JiZhLmFwcGx5VGV4dFNoYWRvdyhuKSl9LGdldENvbnRyYXN0OmZ1bmN0aW9uKGEpe2E9bmEoYSkucmdiYTtyZXR1cm4gYVswXSthWzFdK2FbMl0+Mzg0P1wiIzAwMDAwMFwiOlwiI0ZGRkZGRlwifSxidXR0b246ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe3ZhciBqPXRoaXMubGFiZWwoYSxiLGMsaSxudWxsLG51bGwsbnVsbCxudWxsLFwiYnV0dG9uXCIpLGs9MCxtLGwsbixxLHgscCxhPXt4MTowLHkxOjAseDI6MCx5MjoxfSxlPUEoe1wic3Ryb2tlLXdpZHRoXCI6MSxzdHJva2U6XCIjQ0NDQ0NDXCIsZmlsbDp7bGluZWFyR3JhZGllbnQ6YSxzdG9wczpbWzAsXCIjRkVGRUZFXCJdLFsxLFwiI0Y2RjZGNlwiXV19LHI6MixwYWRkaW5nOjUsc3R5bGU6e2NvbG9yOlwiYmxhY2tcIn19LGUpO249ZS5zdHlsZTtkZWxldGUgZS5zdHlsZTtmPUEoZSx7c3Ryb2tlOlwiIzY4QVwiLGZpbGw6e2xpbmVhckdyYWRpZW50OmEsc3RvcHM6W1swLFwiI0ZGRlwiXSxbMSxcIiNBQ0ZcIl1dfX0sZik7XG5xPWYuc3R5bGU7ZGVsZXRlIGYuc3R5bGU7Zz1BKGUse3N0cm9rZTpcIiM2OEFcIixmaWxsOntsaW5lYXJHcmFkaWVudDphLHN0b3BzOltbMCxcIiM5QkRcIl0sWzEsXCIjQ0RGXCJdXX19LGcpO3g9Zy5zdHlsZTtkZWxldGUgZy5zdHlsZTtoPUEoZSx7c3R5bGU6e2NvbG9yOlwiI0NDQ1wifX0saCk7cD1oLnN0eWxlO2RlbGV0ZSBoLnN0eWxlO0goai5lbGVtZW50LHhhP1wibW91c2VvdmVyXCI6XCJtb3VzZWVudGVyXCIsZnVuY3Rpb24oKXtrIT09MyYmai5hdHRyKGYpLmNzcyhxKX0pO0goai5lbGVtZW50LHhhP1wibW91c2VvdXRcIjpcIm1vdXNlbGVhdmVcIixmdW5jdGlvbigpe2shPT0zJiYobT1bZSxmLGddW2tdLGw9W24scSx4XVtrXSxqLmF0dHIobSkuY3NzKGwpKX0pO2ouc2V0U3RhdGU9ZnVuY3Rpb24oYSl7KGouc3RhdGU9az1hKT9hPT09Mj9qLmF0dHIoZykuY3NzKHgpOmE9PT0zJiZqLmF0dHIoaCkuY3NzKHApOmouYXR0cihlKS5jc3Mobil9O3JldHVybiBqLm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXtrIT09XG4zJiZkLmNhbGwoaixhKX0pLmF0dHIoZSkuY3NzKHIoe2N1cnNvcjpcImRlZmF1bHRcIn0sbikpfSxjcmlzcExpbmU6ZnVuY3Rpb24oYSxiKXthWzFdPT09YVs0XSYmKGFbMV09YVs0XT13KGFbMV0pLWIlMi8yKTthWzJdPT09YVs1XSYmKGFbMl09YVs1XT13KGFbMl0pK2IlMi8yKTtyZXR1cm4gYX0scGF0aDpmdW5jdGlvbihhKXt2YXIgYj17ZmlsbDpPfTtGYShhKT9iLmQ9YTpkYShhKSYmcihiLGEpO3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpLmF0dHIoYil9LGNpcmNsZTpmdW5jdGlvbihhLGIsYyl7YT1kYShhKT9hOnt4OmEseTpiLHI6Y307Yj10aGlzLmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIik7Yi54U2V0dGVyPWZ1bmN0aW9uKGEpe3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjeFwiLGEpfTtiLnlTZXR0ZXI9ZnVuY3Rpb24oYSl7dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImN5XCIsYSl9O3JldHVybiBiLmF0dHIoYSl9LGFyYzpmdW5jdGlvbihhLGIsYyxkLGUsXG5mKXtpZihkYShhKSliPWEueSxjPWEucixkPWEuaW5uZXJSLGU9YS5zdGFydCxmPWEuZW5kLGE9YS54O2E9dGhpcy5zeW1ib2woXCJhcmNcIixhfHwwLGJ8fDAsY3x8MCxjfHwwLHtpbm5lclI6ZHx8MCxzdGFydDplfHwwLGVuZDpmfHwwfSk7YS5yPWM7cmV0dXJuIGF9LHJlY3Q6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBlPWRhKGEpP2EucjplLGc9dGhpcy5jcmVhdGVFbGVtZW50KFwicmVjdFwiKSxhPWRhKGEpP2E6YT09PXY/e306e3g6YSx5OmIsd2lkdGg6dChjLDApLGhlaWdodDp0KGQsMCl9O2lmKGYhPT12KWEuc3Ryb2tlV2lkdGg9ZixhPWcuY3Jpc3AoYSk7aWYoZSlhLnI9ZTtnLnJTZXR0ZXI9ZnVuY3Rpb24oYSl7Sih0aGlzLmVsZW1lbnQse3J4OmEscnk6YX0pfTtyZXR1cm4gZy5hdHRyKGEpfSxzZXRTaXplOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmFsaWduZWRPYmplY3RzLGU9ZC5sZW5ndGg7dGhpcy53aWR0aD1hO3RoaXMuaGVpZ2h0PWI7Zm9yKHRoaXMuYm94V3JhcHBlcltwKGMsXG4hMCk/XCJhbmltYXRlXCI6XCJhdHRyXCJdKHt3aWR0aDphLGhlaWdodDpifSk7ZS0tOylkW2VdLmFsaWduKCl9LGc6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jcmVhdGVFbGVtZW50KFwiZ1wiKTtyZXR1cm4gcyhhKT9iLmF0dHIoe1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtXCIrYX0pOmJ9LGltYWdlOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9e3ByZXNlcnZlQXNwZWN0UmF0aW86T307YXJndW1lbnRzLmxlbmd0aD4xJiZyKGYse3g6Yix5OmMsd2lkdGg6ZCxoZWlnaHQ6ZX0pO2Y9dGhpcy5jcmVhdGVFbGVtZW50KFwiaW1hZ2VcIikuYXR0cihmKTtmLmVsZW1lbnQuc2V0QXR0cmlidXRlTlM/Zi5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFwiaHJlZlwiLGEpOmYuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoYy1zdmctaHJlZlwiLGEpO3JldHVybiBmfSxzeW1ib2w6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnLGg9dGhpcy5zeW1ib2xzW2FdLGg9aCYmaCh3KGIpLFxudyhjKSxkLGUsZiksaT0vXnVybFxcKCguKj8pXFwpJC8saixrO2lmKGgpZz10aGlzLnBhdGgoaCkscihnLHtzeW1ib2xOYW1lOmEseDpiLHk6Yyx3aWR0aDpkLGhlaWdodDplfSksZiYmcihnLGYpO2Vsc2UgaWYoaS50ZXN0KGEpKWs9ZnVuY3Rpb24oYSxiKXthLmVsZW1lbnQmJihhLmF0dHIoe3dpZHRoOmJbMF0saGVpZ2h0OmJbMV19KSxhLmFsaWduQnlUcmFuc2xhdGV8fGEudHJhbnNsYXRlKHcoKGQtYlswXSkvMiksdygoZS1iWzFdKS8yKSkpfSxqPWEubWF0Y2goaSlbMV0sYT1LYltqXXx8ZiYmZi53aWR0aCYmZi5oZWlnaHQmJltmLndpZHRoLGYuaGVpZ2h0XSxnPXRoaXMuaW1hZ2UoaikuYXR0cih7eDpiLHk6Y30pLGcuaXNJbWc9ITAsYT9rKGcsYSk6KGcuYXR0cih7d2lkdGg6MCxoZWlnaHQ6MH0pLCQoXCJpbWdcIix7b25sb2FkOmZ1bmN0aW9uKCl7ayhnLEtiW2pdPVt0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XSl9LHNyYzpqfSkpO3JldHVybiBnfSxzeW1ib2xzOntjaXJjbGU6ZnVuY3Rpb24oYSxcbmIsYyxkKXt2YXIgZT0wLjE2NipjO3JldHVybltcIk1cIixhK2MvMixiLFwiQ1wiLGErYytlLGIsYStjK2UsYitkLGErYy8yLGIrZCxcIkNcIixhLWUsYitkLGEtZSxiLGErYy8yLGIsXCJaXCJdfSxzcXVhcmU6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuW1wiTVwiLGEsYixcIkxcIixhK2MsYixhK2MsYitkLGEsYitkLFwiWlwiXX0sdHJpYW5nbGU6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuW1wiTVwiLGErYy8yLGIsXCJMXCIsYStjLGIrZCxhLGIrZCxcIlpcIl19LFwidHJpYW5nbGUtZG93blwiOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybltcIk1cIixhLGIsXCJMXCIsYStjLGIsYStjLzIsYitkLFwiWlwiXX0sZGlhbW9uZDpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm5bXCJNXCIsYStjLzIsYixcIkxcIixhK2MsYitkLzIsYStjLzIsYitkLGEsYitkLzIsXCJaXCJdfSxhcmM6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1lLnN0YXJ0LGM9ZS5yfHxjfHxkLGc9ZS5lbmQtMC4wMDEsZD1lLmlubmVyUixoPWUub3BlbixpPVgoZiksaj1hYShmKSxcbms9WChnKSxnPWFhKGcpLGU9ZS5lbmQtZjxtYT8wOjE7cmV0dXJuW1wiTVwiLGErYyppLGIrYypqLFwiQVwiLGMsYywwLGUsMSxhK2MqayxiK2MqZyxoP1wiTVwiOlwiTFwiLGErZCprLGIrZCpnLFwiQVwiLGQsZCwwLGUsMCxhK2QqaSxiK2QqaixoP1wiXCI6XCJaXCJdfSxjYWxsb3V0OmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9eihlJiZlLnJ8fDAsYyxkKSxnPWYrNixoPWUmJmUuYW5jaG9yWCxlPWUmJmUuYW5jaG9yWSxpO2k9W1wiTVwiLGErZixiLFwiTFwiLGErYy1mLGIsXCJDXCIsYStjLGIsYStjLGIsYStjLGIrZixcIkxcIixhK2MsYitkLWYsXCJDXCIsYStjLGIrZCxhK2MsYitkLGErYy1mLGIrZCxcIkxcIixhK2YsYitkLFwiQ1wiLGEsYitkLGEsYitkLGEsYitkLWYsXCJMXCIsYSxiK2YsXCJDXCIsYSxiLGEsYixhK2YsYl07aCYmaD5jJiZlPmIrZyYmZTxiK2QtZz9pLnNwbGljZSgxMywzLFwiTFwiLGErYyxlLTYsYStjKzYsZSxhK2MsZSs2LGErYyxiK2QtZik6aCYmaDwwJiZlPmIrZyYmZTxiK2QtZz9pLnNwbGljZSgzMywzLFwiTFwiLFxuYSxlKzYsYS02LGUsYSxlLTYsYSxiK2YpOmUmJmU+ZCYmaD5hK2cmJmg8YStjLWc/aS5zcGxpY2UoMjMsMyxcIkxcIixoKzYsYitkLGgsYitkKzYsaC02LGIrZCxhK2YsYitkKTplJiZlPDAmJmg+YStnJiZoPGErYy1nJiZpLnNwbGljZSgzLDMsXCJMXCIsaC02LGIsaCxiLTYsaCs2LGIsYy1mLGIpO3JldHVybiBpfX0sY2xpcFJlY3Q6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9XCJoaWdoY2hhcnRzLVwiK3diKyssZj10aGlzLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKS5hdHRyKHtpZDplfSkuYWRkKHRoaXMuZGVmcyksYT10aGlzLnJlY3QoYSxiLGMsZCwwKS5hZGQoZik7YS5pZD1lO2EuY2xpcFBhdGg9ZjthLmNvdW50PTA7cmV0dXJuIGF9LHRleHQ6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZmF8fCFjYSYmdGhpcy5mb3JFeHBvcnQsZj17fTtpZihkJiYhdGhpcy5mb3JFeHBvcnQpcmV0dXJuIHRoaXMuaHRtbChhLGIsYyk7Zi54PU1hdGgucm91bmQoYnx8MCk7aWYoYylmLnk9TWF0aC5yb3VuZChjKTtcbmlmKGF8fGE9PT0wKWYudGV4dD1hO2E9dGhpcy5jcmVhdGVFbGVtZW50KFwidGV4dFwiKS5hdHRyKGYpO2UmJmEuY3NzKHtwb3NpdGlvbjpcImFic29sdXRlXCJ9KTtpZighZClhLnhTZXR0ZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKSxlLGY9Yy5nZXRBdHRyaWJ1dGUoYiksbDtmb3IobD0wO2w8ZC5sZW5ndGg7bCsrKWU9ZFtsXSxlLmdldEF0dHJpYnV0ZShiKT09PWYmJmUuc2V0QXR0cmlidXRlKGIsYSk7Yy5zZXRBdHRyaWJ1dGUoYixhKX07cmV0dXJuIGF9LGZvbnRNZXRyaWNzOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxhPWF8fHRoaXMuc3R5bGUuZm9udFNpemU7YiYmSy5nZXRDb21wdXRlZFN0eWxlJiYoYj1iLmVsZW1lbnR8fGIsYT0oYz1LLmdldENvbXB1dGVkU3R5bGUoYixcIlwiKSkmJmMuZm9udFNpemUpO2E9L3B4Ly50ZXN0KGEpP0YoYSk6L2VtLy50ZXN0KGEpP3BhcnNlRmxvYXQoYSkqMTI6MTI7Yz1hPDI0P2ErMzp3KGEqMS4yKTtcbmQ9dyhjKjAuOCk7cmV0dXJue2g6YyxiOmQsZjphfX0scm90Q29ycjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9YTtiJiZjJiYoZD10KGQqWChiKmdhKSw0KSk7cmV0dXJue3g6LWEvMyphYShiKmdhKSx5OmR9fSxsYWJlbDpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsaSl7ZnVuY3Rpb24gaigpe3ZhciBhLGI7YT1xLmVsZW1lbnQuc3R5bGU7cD0odD09PXZvaWQgMHx8eWI9PT12b2lkIDB8fG4uc3R5bGVzLnRleHRBbGlnbikmJnMocS50ZXh0U3RyKSYmcS5nZXRCQm94KCk7bi53aWR0aD0odHx8cC53aWR0aHx8MCkrMip1K3k7bi5oZWlnaHQ9KHlifHxwLmhlaWdodHx8MCkrMip1O0I9dStsLmZvbnRNZXRyaWNzKGEmJmEuZm9udFNpemUscSkuYjtpZihEKXtpZigheClhPXcoLVEqdSkrQyxiPShoPy1COjApK0Msbi5ib3g9eD1kP2wuc3ltYm9sKGQsYSxiLG4ud2lkdGgsbi5oZWlnaHQsRyk6bC5yZWN0KGEsYixuLndpZHRoLG4uaGVpZ2h0LDAsR1tQYl0pLHguaXNJbWd8fHguYXR0cihcImZpbGxcIixcbk8pLHguYWRkKG4pO3guaXNJbWd8fHguYXR0cihyKHt3aWR0aDp3KG4ud2lkdGgpLGhlaWdodDp3KG4uaGVpZ2h0KX0sRykpO0c9bnVsbH19ZnVuY3Rpb24gaygpe3ZhciBhPW4uc3R5bGVzLGE9YSYmYS50ZXh0QWxpZ24sYj15K3UqKDEtUSksYztjPWg/MDpCO2lmKHModCkmJnAmJihhPT09XCJjZW50ZXJcInx8YT09PVwicmlnaHRcIikpYis9e2NlbnRlcjowLjUscmlnaHQ6MX1bYV0qKHQtcC53aWR0aCk7aWYoYiE9PXEueHx8YyE9PXEueSlxLmF0dHIoXCJ4XCIsYiksYyE9PXYmJnEuYXR0cihcInlcIixjKTtxLng9YjtxLnk9Y31mdW5jdGlvbiBtKGEsYil7eD94LmF0dHIoYSxiKTpHW2FdPWJ9dmFyIGw9dGhpcyxuPWwuZyhpKSxxPWwudGV4dChcIlwiLDAsMCxnKS5hdHRyKHt6SW5kZXg6MX0pLHgscCxRPTAsdT0zLHk9MCx0LHliLHpiLHosQz0wLEc9e30sQixEO24ub25BZGQ9ZnVuY3Rpb24oKXtxLmFkZChuKTtuLmF0dHIoe3RleHQ6YXx8YT09PTA/YTpcIlwiLHg6Yix5OmN9KTt4JiZzKGUpJiZuLmF0dHIoe2FuY2hvclg6ZSxcbmFuY2hvclk6Zn0pfTtuLndpZHRoU2V0dGVyPWZ1bmN0aW9uKGEpe3Q9YX07bi5oZWlnaHRTZXR0ZXI9ZnVuY3Rpb24oYSl7eWI9YX07bi5wYWRkaW5nU2V0dGVyPWZ1bmN0aW9uKGEpe2lmKHMoYSkmJmEhPT11KXU9bi5wYWRkaW5nPWEsaygpfTtuLnBhZGRpbmdMZWZ0U2V0dGVyPWZ1bmN0aW9uKGEpe3MoYSkmJmEhPT15JiYoeT1hLGsoKSl9O24uYWxpZ25TZXR0ZXI9ZnVuY3Rpb24oYSl7UT17bGVmdDowLGNlbnRlcjowLjUscmlnaHQ6MX1bYV19O24udGV4dFNldHRlcj1mdW5jdGlvbihhKXthIT09diYmcS50ZXh0U2V0dGVyKGEpO2ooKTtrKCl9O25bXCJzdHJva2Utd2lkdGhTZXR0ZXJcIl09ZnVuY3Rpb24oYSxiKXthJiYoRD0hMCk7Qz1hJTIvMjttKGIsYSl9O24uc3Ryb2tlU2V0dGVyPW4uZmlsbFNldHRlcj1uLnJTZXR0ZXI9ZnVuY3Rpb24oYSxiKXtiPT09XCJmaWxsXCImJmEmJihEPSEwKTttKGIsYSl9O24uYW5jaG9yWFNldHRlcj1mdW5jdGlvbihhLGIpe2U9YTttKGIsdyhhKS1cbkMtemIpfTtuLmFuY2hvcllTZXR0ZXI9ZnVuY3Rpb24oYSxiKXtmPWE7bShiLGEteil9O24ueFNldHRlcj1mdW5jdGlvbihhKXtuLng9YTtRJiYoYS09USooKHR8fHAud2lkdGgpK3UpKTt6Yj13KGEpO24uYXR0cihcInRyYW5zbGF0ZVhcIix6Yil9O24ueVNldHRlcj1mdW5jdGlvbihhKXt6PW4ueT13KGEpO24uYXR0cihcInRyYW5zbGF0ZVlcIix6KX07dmFyIEY9bi5jc3M7cmV0dXJuIHIobix7Y3NzOmZ1bmN0aW9uKGEpe2lmKGEpe3ZhciBiPXt9LGE9QShhKTtvKG4udGV4dFByb3BzLGZ1bmN0aW9uKGMpe2FbY10hPT12JiYoYltjXT1hW2NdLGRlbGV0ZSBhW2NdKX0pO3EuY3NzKGIpfXJldHVybiBGLmNhbGwobixhKX0sZ2V0QkJveDpmdW5jdGlvbigpe3JldHVybnt3aWR0aDpwLndpZHRoKzIqdSxoZWlnaHQ6cC5oZWlnaHQrMip1LHg6cC54LXUseTpwLnktdX19LHNoYWRvdzpmdW5jdGlvbihhKXt4JiZ4LnNoYWRvdyhhKTtyZXR1cm4gbn0sZGVzdHJveTpmdW5jdGlvbigpe1oobi5lbGVtZW50LFxuXCJtb3VzZWVudGVyXCIpO1oobi5lbGVtZW50LFwibW91c2VsZWF2ZVwiKTtxJiYocT1xLmRlc3Ryb3koKSk7eCYmKHg9eC5kZXN0cm95KCkpO1AucHJvdG90eXBlLmRlc3Ryb3kuY2FsbChuKTtuPWw9aj1rPW09bnVsbH19KX19O1phPXVhO3IoUC5wcm90b3R5cGUse2h0bWxDc3M6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50O2lmKGI9YSYmYi50YWdOYW1lPT09XCJTUEFOXCImJmEud2lkdGgpZGVsZXRlIGEud2lkdGgsdGhpcy50ZXh0V2lkdGg9Yix0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO2lmKGEmJmEudGV4dE92ZXJmbG93PT09XCJlbGxpcHNpc1wiKWEud2hpdGVTcGFjZT1cIm5vd3JhcFwiLGEub3ZlcmZsb3c9XCJoaWRkZW5cIjt0aGlzLnN0eWxlcz1yKHRoaXMuc3R5bGVzLGEpO0wodGhpcy5lbGVtZW50LGEpO3JldHVybiB0aGlzfSxodG1sR2V0QkJveDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudDtpZihhLm5vZGVOYW1lPT09XCJ0ZXh0XCIpYS5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCI7XG5yZXR1cm57eDphLm9mZnNldExlZnQseTphLm9mZnNldFRvcCx3aWR0aDphLm9mZnNldFdpZHRoLGhlaWdodDphLm9mZnNldEhlaWdodH19LGh0bWxVcGRhdGVUcmFuc2Zvcm06ZnVuY3Rpb24oKXtpZih0aGlzLmFkZGVkKXt2YXIgYT10aGlzLnJlbmRlcmVyLGI9dGhpcy5lbGVtZW50LGM9dGhpcy50cmFuc2xhdGVYfHwwLGQ9dGhpcy50cmFuc2xhdGVZfHwwLGU9dGhpcy54fHwwLGY9dGhpcy55fHwwLGc9dGhpcy50ZXh0QWxpZ258fFwibGVmdFwiLGg9e2xlZnQ6MCxjZW50ZXI6MC41LHJpZ2h0OjF9W2ddLGk9dGhpcy5zaGFkb3dzLGo9dGhpcy5zdHlsZXM7TChiLHttYXJnaW5MZWZ0OmMsbWFyZ2luVG9wOmR9KTtpJiZvKGksZnVuY3Rpb24oYSl7TChhLHttYXJnaW5MZWZ0OmMrMSxtYXJnaW5Ub3A6ZCsxfSl9KTt0aGlzLmludmVydGVkJiZvKGIuY2hpbGROb2RlcyxmdW5jdGlvbihjKXthLmludmVydENoaWxkKGMsYil9KTtpZihiLnRhZ05hbWU9PT1cIlNQQU5cIil7dmFyIGs9dGhpcy5yb3RhdGlvbixcbm0sbD1GKHRoaXMudGV4dFdpZHRoKSxuPVtrLGcsYi5pbm5lckhUTUwsdGhpcy50ZXh0V2lkdGgsdGhpcy50ZXh0QWxpZ25dLmpvaW4oXCIsXCIpO2lmKG4hPT10aGlzLmNUVCl7bT1hLmZvbnRNZXRyaWNzKGIuc3R5bGUuZm9udFNpemUpLmI7cyhrKSYmdGhpcy5zZXRTcGFuUm90YXRpb24oayxoLG0pO2k9cCh0aGlzLmVsZW1XaWR0aCxiLm9mZnNldFdpZHRoKTtpZihpPmwmJi9bIFxcLV0vLnRlc3QoYi50ZXh0Q29udGVudHx8Yi5pbm5lclRleHQpKUwoYix7d2lkdGg6bCtcInB4XCIsZGlzcGxheTpcImJsb2NrXCIsd2hpdGVTcGFjZTpqJiZqLndoaXRlU3BhY2V8fFwibm9ybWFsXCJ9KSxpPWw7dGhpcy5nZXRTcGFuQ29ycmVjdGlvbihpLG0saCxrLGcpfUwoYix7bGVmdDplKyh0aGlzLnhDb3JyfHwwKStcInB4XCIsdG9wOmYrKHRoaXMueUNvcnJ8fDApK1wicHhcIn0pO2lmKGZiKW09Yi5vZmZzZXRIZWlnaHQ7dGhpcy5jVFQ9bn19ZWxzZSB0aGlzLmFsaWduT25BZGQ9ITB9LHNldFNwYW5Sb3RhdGlvbjpmdW5jdGlvbihhLFxuYixjKXt2YXIgZD17fSxlPXhhP1wiLW1zLXRyYW5zZm9ybVwiOmZiP1wiLXdlYmtpdC10cmFuc2Zvcm1cIjpKYT9cIk1velRyYW5zZm9ybVwiOkliP1wiLW8tdHJhbnNmb3JtXCI6XCJcIjtkW2VdPWQudHJhbnNmb3JtPVwicm90YXRlKFwiK2ErXCJkZWcpXCI7ZFtlKyhKYT9cIk9yaWdpblwiOlwiLW9yaWdpblwiKV09ZC50cmFuc2Zvcm1PcmlnaW49YioxMDArXCIlIFwiK2MrXCJweFwiO0wodGhpcy5lbGVtZW50LGQpfSxnZXRTcGFuQ29ycmVjdGlvbjpmdW5jdGlvbihhLGIsYyl7dGhpcy54Q29ycj0tYSpjO3RoaXMueUNvcnI9LWJ9fSk7cih1YS5wcm90b3R5cGUse2h0bWw6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuY3JlYXRlRWxlbWVudChcInNwYW5cIiksZT1kLmVsZW1lbnQsZj1kLnJlbmRlcmVyO2QudGV4dFNldHRlcj1mdW5jdGlvbihhKXthIT09ZS5pbm5lckhUTUwmJmRlbGV0ZSB0aGlzLmJCb3g7ZS5pbm5lckhUTUw9dGhpcy50ZXh0U3RyPWE7ZC5odG1sVXBkYXRlVHJhbnNmb3JtKCl9O2QueFNldHRlcj1kLnlTZXR0ZXI9XG5kLmFsaWduU2V0dGVyPWQucm90YXRpb25TZXR0ZXI9ZnVuY3Rpb24oYSxiKXtiPT09XCJhbGlnblwiJiYoYj1cInRleHRBbGlnblwiKTtkW2JdPWE7ZC5odG1sVXBkYXRlVHJhbnNmb3JtKCl9O2QuYXR0cih7dGV4dDphLHg6dyhiKSx5OncoYyl9KS5jc3Moe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixmb250RmFtaWx5OnRoaXMuc3R5bGUuZm9udEZhbWlseSxmb250U2l6ZTp0aGlzLnN0eWxlLmZvbnRTaXplfSk7ZS5zdHlsZS53aGl0ZVNwYWNlPVwibm93cmFwXCI7ZC5jc3M9ZC5odG1sQ3NzO2lmKGYuaXNTVkcpZC5hZGQ9ZnVuY3Rpb24oYSl7dmFyIGIsYz1mLmJveC5wYXJlbnROb2RlLGo9W107aWYodGhpcy5wYXJlbnRHcm91cD1hKXtpZihiPWEuZGl2LCFiKXtmb3IoO2E7KWoucHVzaChhKSxhPWEucGFyZW50R3JvdXA7byhqLnJldmVyc2UoKSxmdW5jdGlvbihhKXt2YXIgZCxlPUooYS5lbGVtZW50LFwiY2xhc3NcIik7ZSYmKGU9e2NsYXNzTmFtZTplfSk7Yj1hLmRpdj1hLmRpdnx8JChJYSxlLHtwb3NpdGlvbjpcImFic29sdXRlXCIsXG5sZWZ0OihhLnRyYW5zbGF0ZVh8fDApK1wicHhcIix0b3A6KGEudHJhbnNsYXRlWXx8MCkrXCJweFwifSxifHxjKTtkPWIuc3R5bGU7cihhLHt0cmFuc2xhdGVYU2V0dGVyOmZ1bmN0aW9uKGIsYyl7ZC5sZWZ0PWIrXCJweFwiO2FbY109YjthLmRvVHJhbnNmb3JtPSEwfSx0cmFuc2xhdGVZU2V0dGVyOmZ1bmN0aW9uKGIsYyl7ZC50b3A9YitcInB4XCI7YVtjXT1iO2EuZG9UcmFuc2Zvcm09ITB9fSk7U2EoYSxcInZpc2liaWxpdHlTZXR0ZXJcIixmdW5jdGlvbihhLGIsYyxlKXthLmNhbGwodGhpcyxiLGMsZSk7ZFtjXT1ifSl9KX19ZWxzZSBiPWM7Yi5hcHBlbmRDaGlsZChlKTtkLmFkZGVkPSEwO2QuYWxpZ25PbkFkZCYmZC5odG1sVXBkYXRlVHJhbnNmb3JtKCk7cmV0dXJuIGR9O3JldHVybiBkfX0pO2lmKCFjYSYmIWZhKXtEPXtpbml0OmZ1bmN0aW9uKGEsYil7dmFyIGM9W1wiPFwiLGIsJyBmaWxsZWQ9XCJmXCIgc3Ryb2tlZD1cImZcIiddLGQ9W1wicG9zaXRpb246IFwiLFwiYWJzb2x1dGVcIixcIjtcIl0sZT1iPT09XG5JYTsoYj09PVwic2hhcGVcInx8ZSkmJmQucHVzaChcImxlZnQ6MDt0b3A6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDtcIik7ZC5wdXNoKFwidmlzaWJpbGl0eTogXCIsZT9cImhpZGRlblwiOlwidmlzaWJsZVwiKTtjLnB1c2goJyBzdHlsZT1cIicsZC5qb2luKFwiXCIpLCdcIi8+Jyk7aWYoYiljPWV8fGI9PT1cInNwYW5cInx8Yj09PVwiaW1nXCI/Yy5qb2luKFwiXCIpOmEucHJlcFZNTChjKSx0aGlzLmVsZW1lbnQ9JChjKTt0aGlzLnJlbmRlcmVyPWF9LGFkZDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnJlbmRlcmVyLGM9dGhpcy5lbGVtZW50LGQ9Yi5ib3gsZD1hP2EuZWxlbWVudHx8YTpkO2EmJmEuaW52ZXJ0ZWQmJmIuaW52ZXJ0Q2hpbGQoYyxkKTtkLmFwcGVuZENoaWxkKGMpO3RoaXMuYWRkZWQ9ITA7dGhpcy5hbGlnbk9uQWRkJiYhdGhpcy5kZWZlclVwZGF0ZVRyYW5zZm9ybSYmdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtpZih0aGlzLm9uQWRkKXRoaXMub25BZGQoKTtyZXR1cm4gdGhpc30sdXBkYXRlVHJhbnNmb3JtOlAucHJvdG90eXBlLmh0bWxVcGRhdGVUcmFuc2Zvcm0sXG5zZXRTcGFuUm90YXRpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnJvdGF0aW9uLGI9WChhKmdhKSxjPWFhKGEqZ2EpO0wodGhpcy5lbGVtZW50LHtmaWx0ZXI6YT9bXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT1cIixiLFwiLCBNMTI9XCIsLWMsXCIsIE0yMT1cIixjLFwiLCBNMjI9XCIsYixcIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpXCJdLmpvaW4oXCJcIik6T30pfSxnZXRTcGFuQ29ycmVjdGlvbjpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWQ/WChkKmdhKToxLGc9ZD9hYShkKmdhKTowLGg9cCh0aGlzLmVsZW1IZWlnaHQsdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCksaTt0aGlzLnhDb3JyPWY8MCYmLWE7dGhpcy55Q29ycj1nPDAmJi1oO2k9ZipnPDA7dGhpcy54Q29ycis9ZypiKihpPzEtYzpjKTt0aGlzLnlDb3JyLT1mKmIqKGQ/aT9jOjEtYzoxKTtlJiZlIT09XCJsZWZ0XCImJih0aGlzLnhDb3JyLT1hKmMqKGY8MD8tMToxKSxkJiYodGhpcy55Q29yci09XG5oKmMqKGc8MD8tMToxKSksTCh0aGlzLmVsZW1lbnQse3RleHRBbGlnbjplfSkpfSxwYXRoVG9WTUw6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWEubGVuZ3RoLGM9W107Yi0tOylpZihxYShhW2JdKSljW2JdPXcoYVtiXSoxMCktNTtlbHNlIGlmKGFbYl09PT1cIlpcIiljW2JdPVwieFwiO2Vsc2UgaWYoY1tiXT1hW2JdLGEuaXNBcmMmJihhW2JdPT09XCJ3YVwifHxhW2JdPT09XCJhdFwiKSljW2IrNV09PT1jW2IrN10mJihjW2IrN10rPWFbYis3XT5hW2IrNV0/MTotMSksY1tiKzZdPT09Y1tiKzhdJiYoY1tiKzhdKz1hW2IrOF0+YVtiKzZdPzE6LTEpO3JldHVybiBjLmpvaW4oXCIgXCIpfHxcInhcIn0sY2xpcDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM7YT8oYz1hLm1lbWJlcnMsamEoYyxiKSxjLnB1c2goYiksYi5kZXN0cm95Q2xpcD1mdW5jdGlvbigpe2phKGMsYil9LGE9YS5nZXRDU1MoYikpOihiLmRlc3Ryb3lDbGlwJiZiLmRlc3Ryb3lDbGlwKCksYT17Y2xpcDplYj9cImluaGVyaXRcIjpcInJlY3QoYXV0bylcIn0pO1xucmV0dXJuIGIuY3NzKGEpfSxjc3M6UC5wcm90b3R5cGUuaHRtbENzcyxzYWZlUmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24oYSl7YS5wYXJlbnROb2RlJiZQYShhKX0sZGVzdHJveTpmdW5jdGlvbigpe3RoaXMuZGVzdHJveUNsaXAmJnRoaXMuZGVzdHJveUNsaXAoKTtyZXR1cm4gUC5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzKX0sb246ZnVuY3Rpb24oYSxiKXt0aGlzLmVsZW1lbnRbXCJvblwiK2FdPWZ1bmN0aW9uKCl7dmFyIGE9Sy5ldmVudDthLnRhcmdldD1hLnNyY0VsZW1lbnQ7YihhKX07cmV0dXJuIHRoaXN9LGN1dE9mZlBhdGg6ZnVuY3Rpb24oYSxiKXt2YXIgYyxhPWEuc3BsaXQoL1sgLF0vKTtjPWEubGVuZ3RoO2lmKGM9PT05fHxjPT09MTEpYVtjLTRdPWFbYy0yXT1GKGFbYy0yXSktMTAqYjtyZXR1cm4gYS5qb2luKFwiIFwiKX0sc2hhZG93OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1bXSxlLGY9dGhpcy5lbGVtZW50LGc9dGhpcy5yZW5kZXJlcixoLGk9Zi5zdHlsZSxqLGs9Zi5wYXRoLFxubSxsLG4scTtrJiZ0eXBlb2Ygay52YWx1ZSE9PVwic3RyaW5nXCImJihrPVwieFwiKTtsPWs7aWYoYSl7bj1wKGEud2lkdGgsMyk7cT0oYS5vcGFjaXR5fHwwLjE1KS9uO2ZvcihlPTE7ZTw9MztlKyspe209bioyKzEtMiplO2MmJihsPXRoaXMuY3V0T2ZmUGF0aChrLnZhbHVlLG0rMC41KSk7aj1bJzxzaGFwZSBpc1NoYWRvdz1cInRydWVcIiBzdHJva2V3ZWlnaHQ9XCInLG0sJ1wiIGZpbGxlZD1cImZhbHNlXCIgcGF0aD1cIicsbCwnXCIgY29vcmRzaXplPVwiMTAgMTBcIiBzdHlsZT1cIicsZi5zdHlsZS5jc3NUZXh0LCdcIiAvPiddO2g9JChnLnByZXBWTUwoaiksbnVsbCx7bGVmdDpGKGkubGVmdCkrcChhLm9mZnNldFgsMSksdG9wOkYoaS50b3ApK3AoYS5vZmZzZXRZLDEpfSk7aWYoYyloLmN1dE9mZj1tKzE7aj1bJzxzdHJva2UgY29sb3I9XCInLGEuY29sb3J8fFwiYmxhY2tcIiwnXCIgb3BhY2l0eT1cIicscSplLCdcIi8+J107JChnLnByZXBWTUwoaiksbnVsbCxudWxsLGgpO2I/Yi5lbGVtZW50LmFwcGVuZENoaWxkKGgpOlxuZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShoLGYpO2QucHVzaChoKX10aGlzLnNoYWRvd3M9ZH1yZXR1cm4gdGhpc30sdXBkYXRlU2hhZG93czp0YSxzZXRBdHRyOmZ1bmN0aW9uKGEsYil7ZWI/dGhpcy5lbGVtZW50W2FdPWI6dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShhLGIpfSxjbGFzc1NldHRlcjpmdW5jdGlvbihhKXt0aGlzLmVsZW1lbnQuY2xhc3NOYW1lPWF9LGRhc2hzdHlsZVNldHRlcjpmdW5jdGlvbihhLGIsYyl7KGMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHJva2VcIilbMF18fCQodGhpcy5yZW5kZXJlci5wcmVwVk1MKFtcIjxzdHJva2UvPlwiXSksbnVsbCxudWxsLGMpKVtiXT1hfHxcInNvbGlkXCI7dGhpc1tiXT1hfSxkU2V0dGVyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLnNoYWRvd3MsYT1hfHxbXTt0aGlzLmQ9YS5qb2luJiZhLmpvaW4oXCIgXCIpO2MucGF0aD1hPXRoaXMucGF0aFRvVk1MKGEpO2lmKGQpZm9yKGM9ZC5sZW5ndGg7Yy0tOylkW2NdLnBhdGg9ZFtjXS5jdXRPZmY/XG50aGlzLmN1dE9mZlBhdGgoYSxkW2NdLmN1dE9mZik6YTt0aGlzLnNldEF0dHIoYixhKX0sZmlsbFNldHRlcjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9Yy5ub2RlTmFtZTtpZihkPT09XCJTUEFOXCIpYy5zdHlsZS5jb2xvcj1hO2Vsc2UgaWYoZCE9PVwiSU1HXCIpYy5maWxsZWQ9YSE9PU8sdGhpcy5zZXRBdHRyKFwiZmlsbGNvbG9yXCIsdGhpcy5yZW5kZXJlci5jb2xvcihhLGMsYix0aGlzKSl9LG9wYWNpdHlTZXR0ZXI6dGEscm90YXRpb25TZXR0ZXI6ZnVuY3Rpb24oYSxiLGMpe2M9Yy5zdHlsZTt0aGlzW2JdPWNbYl09YTtjLmxlZnQ9LXcoYWEoYSpnYSkrMSkrXCJweFwiO2MudG9wPXcoWChhKmdhKSkrXCJweFwifSxzdHJva2VTZXR0ZXI6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuc2V0QXR0cihcInN0cm9rZWNvbG9yXCIsdGhpcy5yZW5kZXJlci5jb2xvcihhLGMsYikpfSxcInN0cm9rZS13aWR0aFNldHRlclwiOmZ1bmN0aW9uKGEsYixjKXtjLnN0cm9rZWQ9ISFhO3RoaXNbYl09YTtxYShhKSYmKGErPVwicHhcIik7XG50aGlzLnNldEF0dHIoXCJzdHJva2V3ZWlnaHRcIixhKX0sdGl0bGVTZXR0ZXI6ZnVuY3Rpb24oYSxiKXt0aGlzLnNldEF0dHIoYixhKX0sdmlzaWJpbGl0eVNldHRlcjpmdW5jdGlvbihhLGIsYyl7YT09PVwiaW5oZXJpdFwiJiYoYT1cInZpc2libGVcIik7dGhpcy5zaGFkb3dzJiZvKHRoaXMuc2hhZG93cyxmdW5jdGlvbihjKXtjLnN0eWxlW2JdPWF9KTtjLm5vZGVOYW1lPT09XCJESVZcIiYmKGE9YT09PVwiaGlkZGVuXCI/XCItOTk5ZW1cIjowLGVifHwoYy5zdHlsZVtiXT1hP1widmlzaWJsZVwiOlwiaGlkZGVuXCIpLGI9XCJ0b3BcIik7Yy5zdHlsZVtiXT1hfSx4U2V0dGVyOmZ1bmN0aW9uKGEsYixjKXt0aGlzW2JdPWE7Yj09PVwieFwiP2I9XCJsZWZ0XCI6Yj09PVwieVwiJiYoYj1cInRvcFwiKTt0aGlzLnVwZGF0ZUNsaXBwaW5nPyh0aGlzW2JdPWEsdGhpcy51cGRhdGVDbGlwcGluZygpKTpjLnN0eWxlW2JdPWF9LHpJbmRleFNldHRlcjpmdW5jdGlvbihhLGIsYyl7Yy5zdHlsZVtiXT1hfX07Qi5WTUxFbGVtZW50PUQ9a2EoUCxcbkQpO0QucHJvdG90eXBlLnlTZXR0ZXI9RC5wcm90b3R5cGUud2lkdGhTZXR0ZXI9RC5wcm90b3R5cGUuaGVpZ2h0U2V0dGVyPUQucHJvdG90eXBlLnhTZXR0ZXI7dmFyIExhPXtFbGVtZW50OkQsaXNJRTg6emEuaW5kZXhPZihcIk1TSUUgOC4wXCIpPi0xLGluaXQ6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7dGhpcy5hbGlnbmVkT2JqZWN0cz1bXTtkPXRoaXMuY3JlYXRlRWxlbWVudChJYSkuY3NzKHIodGhpcy5nZXRTdHlsZShkKSx7cG9zaXRpb246XCJyZWxhdGl2ZVwifSkpO2U9ZC5lbGVtZW50O2EuYXBwZW5kQ2hpbGQoZC5lbGVtZW50KTt0aGlzLmlzVk1MPSEwO3RoaXMuYm94PWU7dGhpcy5ib3hXcmFwcGVyPWQ7dGhpcy5jYWNoZT17fTt0aGlzLnNldFNpemUoYixjLCExKTtpZighQy5uYW1lc3BhY2VzLmhjdil7Qy5uYW1lc3BhY2VzLmFkZChcImhjdlwiLFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIik7dHJ5e0MuY3JlYXRlU3R5bGVTaGVldCgpLmNzc1RleHQ9XCJoY3ZcXFxcOmZpbGwsIGhjdlxcXFw6cGF0aCwgaGN2XFxcXDpzaGFwZSwgaGN2XFxcXDpzdHJva2V7IGJlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH0gXCJ9Y2F0Y2goZil7Qy5zdHlsZVNoZWV0c1swXS5jc3NUZXh0Kz1cblwiaGN2XFxcXDpmaWxsLCBoY3ZcXFxcOnBhdGgsIGhjdlxcXFw6c2hhcGUsIGhjdlxcXFw6c3Ryb2tleyBiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKTsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9IFwifX19LGlzSGlkZGVuOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuYm94Lm9mZnNldFdpZHRofSxjbGlwUmVjdDpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmNyZWF0ZUVsZW1lbnQoKSxmPWRhKGEpO3JldHVybiByKGUse21lbWJlcnM6W10sY291bnQ6MCxsZWZ0OihmP2EueDphKSsxLHRvcDooZj9hLnk6YikrMSx3aWR0aDooZj9hLndpZHRoOmMpLTEsaGVpZ2h0OihmP2EuaGVpZ2h0OmQpLTEsZ2V0Q1NTOmZ1bmN0aW9uKGEpe3ZhciBiPWEuZWxlbWVudCxjPWIubm9kZU5hbWUsYT1hLmludmVydGVkLGQ9dGhpcy50b3AtKGM9PT1cInNoYXBlXCI/Yi5vZmZzZXRUb3A6MCksZT10aGlzLmxlZnQsYj1lK3RoaXMud2lkdGgsZj1kK3RoaXMuaGVpZ2h0LGQ9e2NsaXA6XCJyZWN0KFwiK3coYT9lOmQpK1wicHgsXCIrXG53KGE/ZjpiKStcInB4LFwiK3coYT9iOmYpK1wicHgsXCIrdyhhP2Q6ZSkrXCJweClcIn07IWEmJmViJiZjPT09XCJESVZcIiYmcihkLHt3aWR0aDpiK1wicHhcIixoZWlnaHQ6ZitcInB4XCJ9KTtyZXR1cm4gZH0sdXBkYXRlQ2xpcHBpbmc6ZnVuY3Rpb24oKXtvKGUubWVtYmVycyxmdW5jdGlvbihhKXthLmVsZW1lbnQmJmEuY3NzKGUuZ2V0Q1NTKGEpKX0pfX0pfSxjb2xvcjpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLGYsZz0vXnJnYmEvLGgsaSxqPU87YSYmYS5saW5lYXJHcmFkaWVudD9pPVwiZ3JhZGllbnRcIjphJiZhLnJhZGlhbEdyYWRpZW50JiYoaT1cInBhdHRlcm5cIik7aWYoaSl7dmFyIGssbSxsPWEubGluZWFyR3JhZGllbnR8fGEucmFkaWFsR3JhZGllbnQsbixxLHgscCxRLHU9XCJcIixhPWEuc3RvcHMseSx0PVtdLHM9ZnVuY3Rpb24oKXtoPVsnPGZpbGwgY29sb3JzPVwiJyt0LmpvaW4oXCIsXCIpKydcIiBvcGFjaXR5PVwiJyx4LCdcIiBvOm9wYWNpdHkyPVwiJyxxLCdcIiB0eXBlPVwiJyxpLCdcIiAnLHUsXG4nZm9jdXM9XCIxMDAlXCIgbWV0aG9kPVwiYW55XCIgLz4nXTskKGUucHJlcFZNTChoKSxudWxsLG51bGwsYil9O249YVswXTt5PWFbYS5sZW5ndGgtMV07blswXT4wJiZhLnVuc2hpZnQoWzAsblsxXV0pO3lbMF08MSYmYS5wdXNoKFsxLHlbMV1dKTtvKGEsZnVuY3Rpb24oYSxiKXtnLnRlc3QoYVsxXSk/KGY9bmEoYVsxXSksaz1mLmdldChcInJnYlwiKSxtPWYuZ2V0KFwiYVwiKSk6KGs9YVsxXSxtPTEpO3QucHVzaChhWzBdKjEwMCtcIiUgXCIrayk7Yj8oeD1tLHA9ayk6KHE9bSxRPWspfSk7aWYoYz09PVwiZmlsbFwiKWlmKGk9PT1cImdyYWRpZW50XCIpYz1sLngxfHxsWzBdfHwwLGE9bC55MXx8bFsxXXx8MCxuPWwueDJ8fGxbMl18fDAsbD1sLnkyfHxsWzNdfHwwLHU9J2FuZ2xlPVwiJysoOTAtVy5hdGFuKChsLWEpLyhuLWMpKSoxODAvbWEpKydcIicscygpO2Vsc2V7dmFyIGo9bC5yLHY9aioyLHc9aioyLHI9bC5jeCx6PWwuY3ksQT1iLnJhZGlhbFJlZmVyZW5jZSxDLGo9ZnVuY3Rpb24oKXtBJiYoQz1kLmdldEJCb3goKSxcbnIrPShBWzBdLUMueCkvQy53aWR0aC0wLjUseis9KEFbMV0tQy55KS9DLmhlaWdodC0wLjUsdio9QVsyXS9DLndpZHRoLHcqPUFbMl0vQy5oZWlnaHQpO3U9J3NyYz1cIicrUy5nbG9iYWwuVk1MUmFkaWFsR3JhZGllbnRVUkwrJ1wiIHNpemU9XCInK3YrXCIsXCIrdysnXCIgb3JpZ2luPVwiMC41LDAuNVwiIHBvc2l0aW9uPVwiJytyK1wiLFwiK3orJ1wiIGNvbG9yMj1cIicrUSsnXCIgJztzKCl9O2QuYWRkZWQ/aigpOmQub25BZGQ9ajtqPXB9ZWxzZSBqPWt9ZWxzZSBpZihnLnRlc3QoYSkmJmIudGFnTmFtZSE9PVwiSU1HXCIpZj1uYShhKSxoPVtcIjxcIixjLCcgb3BhY2l0eT1cIicsZi5nZXQoXCJhXCIpLCdcIi8+J10sJCh0aGlzLnByZXBWTUwoaCksbnVsbCxudWxsLGIpLGo9Zi5nZXQoXCJyZ2JcIik7ZWxzZXtqPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYyk7aWYoai5sZW5ndGgpalswXS5vcGFjaXR5PTEsalswXS50eXBlPVwic29saWRcIjtqPWF9cmV0dXJuIGp9LHByZXBWTUw6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5pc0lFOCxcbmE9YS5qb2luKFwiXCIpO2I/KGE9YS5yZXBsYWNlKFwiLz5cIiwnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIiAvPicpLGE9YS5pbmRleE9mKCdzdHlsZT1cIicpPT09LTE/YS5yZXBsYWNlKFwiLz5cIiwnIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2s7YmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCk7XCIgLz4nKTphLnJlcGxhY2UoJ3N0eWxlPVwiJywnc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jaztiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKTsnKSk6YT1hLnJlcGxhY2UoXCI8XCIsXCI8aGN2OlwiKTtyZXR1cm4gYX0sdGV4dDp1YS5wcm90b3R5cGUuaHRtbCxwYXRoOmZ1bmN0aW9uKGEpe3ZhciBiPXtjb29yZHNpemU6XCIxMCAxMFwifTtGYShhKT9iLmQ9YTpkYShhKSYmcihiLGEpO3JldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJzaGFwZVwiKS5hdHRyKGIpfSxjaXJjbGU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuc3ltYm9sKFwiY2lyY2xlXCIpO2lmKGRhKGEpKWM9YS5yLFxuYj1hLnksYT1hLng7ZC5pc0NpcmNsZT0hMDtkLnI9YztyZXR1cm4gZC5hdHRyKHt4OmEseTpifSl9LGc6ZnVuY3Rpb24oYSl7dmFyIGI7YSYmKGI9e2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtXCIrYSxcImNsYXNzXCI6XCJoaWdoY2hhcnRzLVwiK2F9KTtyZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KElhKS5hdHRyKGIpfSxpbWFnZTpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXMuY3JlYXRlRWxlbWVudChcImltZ1wiKS5hdHRyKHtzcmM6YX0pO2FyZ3VtZW50cy5sZW5ndGg+MSYmZi5hdHRyKHt4OmIseTpjLHdpZHRoOmQsaGVpZ2h0OmV9KTtyZXR1cm4gZn0sY3JlYXRlRWxlbWVudDpmdW5jdGlvbihhKXtyZXR1cm4gYT09PVwicmVjdFwiP3RoaXMuc3ltYm9sKGEpOnVhLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LmNhbGwodGhpcyxhKX0saW52ZXJ0Q2hpbGQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yi5zdHlsZSxlPWEudGFnTmFtZT09PVwiSU1HXCImJmEuc3R5bGU7TChhLHtmbGlwOlwieFwiLFxubGVmdDpGKGQud2lkdGgpLShlP0YoZS50b3ApOjEpLHRvcDpGKGQuaGVpZ2h0KS0oZT9GKGUubGVmdCk6MSkscm90YXRpb246LTkwfSk7byhhLmNoaWxkTm9kZXMsZnVuY3Rpb24oYil7Yy5pbnZlcnRDaGlsZChiLGEpfSl9LHN5bWJvbHM6e2FyYzpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWUuc3RhcnQsZz1lLmVuZCxoPWUucnx8Y3x8ZCxjPWUuaW5uZXJSLGQ9WChmKSxpPWFhKGYpLGo9WChnKSxrPWFhKGcpO2lmKGctZj09PTApcmV0dXJuW1wieFwiXTtmPVtcIndhXCIsYS1oLGItaCxhK2gsYitoLGEraCpkLGIraCppLGEraCpqLGIraCprXTtlLm9wZW4mJiFjJiZmLnB1c2goXCJlXCIsXCJNXCIsYSxiKTtmLnB1c2goXCJhdFwiLGEtYyxiLWMsYStjLGIrYyxhK2MqaixiK2MqayxhK2MqZCxiK2MqaSxcInhcIixcImVcIik7Zi5pc0FyYz0hMDtyZXR1cm4gZn0sY2lyY2xlOmZ1bmN0aW9uKGEsYixjLGQsZSl7ZSYmKGM9ZD0yKmUucik7ZSYmZS5pc0NpcmNsZSYmKGEtPWMvMixiLT1kLzIpO3JldHVybltcIndhXCIsXG5hLGIsYStjLGIrZCxhK2MsYitkLzIsYStjLGIrZC8yLFwiZVwiXX0scmVjdDpmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybiB1YS5wcm90b3R5cGUuc3ltYm9sc1shcyhlKXx8IWUucj9cInNxdWFyZVwiOlwiY2FsbG91dFwiXS5jYWxsKDAsYSxiLGMsZCxlKX19fTtCLlZNTFJlbmRlcmVyPUQ9ZnVuY3Rpb24oKXt0aGlzLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtELnByb3RvdHlwZT1BKHVhLnByb3RvdHlwZSxMYSk7WmE9RH11YS5wcm90b3R5cGUubWVhc3VyZVNwYW5XaWR0aD1mdW5jdGlvbihhLGIpe3ZhciBjPUMuY3JlYXRlRWxlbWVudChcInNwYW5cIiksZDtkPUMuY3JlYXRlVGV4dE5vZGUoYSk7Yy5hcHBlbmRDaGlsZChkKTtMKGMsYik7dGhpcy5ib3guYXBwZW5kQ2hpbGQoYyk7ZD1jLm9mZnNldFdpZHRoO1BhKGMpO3JldHVybiBkfTt2YXIgTGI7aWYoZmEpQi5DYW5WR1JlbmRlcmVyPUQ9ZnVuY3Rpb24oKXtEYT1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn0sRC5wcm90b3R5cGUuc3ltYm9scz1cbnt9LExiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3ZhciBhPWIubGVuZ3RoLGQ7Zm9yKGQ9MDtkPGE7ZCsrKWJbZF0oKTtiPVtdfXZhciBiPVtdO3JldHVybntwdXNoOmZ1bmN0aW9uKGMsZCl7Yi5sZW5ndGg9PT0wJiZRYihkLGEpO2IucHVzaChjKX19fSgpLFphPUQ7UmEucHJvdG90eXBlPXthZGRMYWJlbDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuYXhpcyxiPWEub3B0aW9ucyxjPWEuY2hhcnQsZD1hLmNhdGVnb3JpZXMsZT1hLm5hbWVzLGY9dGhpcy5wb3MsZz1iLmxhYmVscyxoPWEudGlja1Bvc2l0aW9ucyxpPWY9PT1oWzBdLGo9Zj09PWhbaC5sZW5ndGgtMV0sZT1kP3AoZFtmXSxlW2ZdLGYpOmYsZD10aGlzLmxhYmVsLGg9aC5pbmZvLGs7YS5pc0RhdGV0aW1lQXhpcyYmaCYmKGs9Yi5kYXRlVGltZUxhYmVsRm9ybWF0c1toLmhpZ2hlclJhbmtzW2ZdfHxoLnVuaXROYW1lXSk7dGhpcy5pc0ZpcnN0PWk7dGhpcy5pc0xhc3Q9ajtiPWEubGFiZWxGb3JtYXR0ZXIuY2FsbCh7YXhpczphLFxuY2hhcnQ6Yyxpc0ZpcnN0OmksaXNMYXN0OmosZGF0ZVRpbWVMYWJlbEZvcm1hdDprLHZhbHVlOmEuaXNMb2c/ZWEoaWEoZSkpOmV9KTtzKGQpP2QmJmQuYXR0cih7dGV4dDpifSk6KHRoaXMubGFiZWxMZW5ndGg9KHRoaXMubGFiZWw9ZD1zKGIpJiZnLmVuYWJsZWQ/Yy5yZW5kZXJlci50ZXh0KGIsMCwwLGcudXNlSFRNTCkuY3NzKEEoZy5zdHlsZSkpLmFkZChhLmxhYmVsR3JvdXApOm51bGwpJiZkLmdldEJCb3goKS53aWR0aCx0aGlzLnJvdGF0aW9uPTApfSxnZXRMYWJlbFNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbD90aGlzLmxhYmVsLmdldEJCb3goKVt0aGlzLmF4aXMuaG9yaXo/XCJoZWlnaHRcIjpcIndpZHRoXCJdOjB9LGhhbmRsZU92ZXJmbG93OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYXhpcyxjPWEueCxkPWIuY2hhcnQuY2hhcnRXaWR0aCxlPWIuY2hhcnQuc3BhY2luZyxmPXAoYi5sYWJlbExlZnQseihiLnBvcyxlWzNdKSksZT1wKGIubGFiZWxSaWdodCx0KGIucG9zK1xuYi5sZW4sZC1lWzFdKSksZz10aGlzLmxhYmVsLGg9dGhpcy5yb3RhdGlvbixpPXtsZWZ0OjAsY2VudGVyOjAuNSxyaWdodDoxfVtiLmxhYmVsQWxpZ25dLGo9Zy5nZXRCQm94KCkud2lkdGgsaz1iLnNsb3RXaWR0aCxtPTEsbCxuPXt9O2lmKGgpaDwwJiZjLWkqajxmP2w9dyhjL1goaCpnYSktZik6aD4wJiZjK2kqaj5lJiYobD13KChkLWMpL1goaCpnYSkpKTtlbHNlIGlmKGQ9YysoMS1pKSpqLGMtaSpqPGY/az1hLngrayooMS1pKS1mOmQ+ZSYmKGs9ZS1hLngrayppLG09LTEpLGs9eihiLnNsb3RXaWR0aCxrKSxrPGIuc2xvdFdpZHRoJiZiLmxhYmVsQWxpZ249PT1cImNlbnRlclwiJiYoYS54Kz1tKihiLnNsb3RXaWR0aC1rLWkqKGIuc2xvdFdpZHRoLXooaixrKSkpKSxqPmt8fGIuYXV0b1JvdGF0aW9uJiZnLnN0eWxlcy53aWR0aClsPWs7aWYobCl7bi53aWR0aD1sO2lmKCFiLm9wdGlvbnMubGFiZWxzLnN0eWxlLnRleHRPdmVyZmxvdyluLnRleHRPdmVyZmxvdz1cImVsbGlwc2lzXCI7Zy5jc3Mobil9fSxcbmdldFBvc2l0aW9uOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuYXhpcyxmPWUuY2hhcnQsZz1kJiZmLm9sZENoYXJ0SGVpZ2h0fHxmLmNoYXJ0SGVpZ2h0O3JldHVybnt4OmE/ZS50cmFuc2xhdGUoYitjLG51bGwsbnVsbCxkKStlLnRyYW5zQjplLmxlZnQrZS5vZmZzZXQrKGUub3Bwb3NpdGU/KGQmJmYub2xkQ2hhcnRXaWR0aHx8Zi5jaGFydFdpZHRoKS1lLnJpZ2h0LWUubGVmdDowKSx5OmE/Zy1lLmJvdHRvbStlLm9mZnNldC0oZS5vcHBvc2l0ZT9lLmhlaWdodDowKTpnLWUudHJhbnNsYXRlKGIrYyxudWxsLG51bGwsZCktZS50cmFuc0J9fSxnZXRMYWJlbFBvc2l0aW9uOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCl7dmFyIGk9dGhpcy5heGlzLGo9aS50cmFuc0Esaz1pLnJldmVyc2VkLG09aS5zdGFnZ2VyTGluZXMsbD1pLnRpY2tSb3RDb3JyfHx7eDowLHk6MH0sYz1wKGUueSxsLnkrKGkuc2lkZT09PTI/ODotKGMuZ2V0QkJveCgpLmhlaWdodC8yKSkpLGE9YStlLngrbC54LVxuKGYmJmQ/ZipqKihrPy0xOjEpOjApLGI9YitjLShmJiYhZD9mKmoqKGs/MTotMSk6MCk7bSYmKGIrPWcvKGh8fDEpJW0qKGkubGFiZWxPZmZzZXQvbSkpO3JldHVybnt4OmEseTp3KGIpfX0sZ2V0TWFya1BhdGg6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3JldHVybiBmLmNyaXNwTGluZShbXCJNXCIsYSxiLFwiTFwiLGErKGU/MDotYyksYisoZT9jOjApXSxkKX0scmVuZGVyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmF4aXMsZT1kLm9wdGlvbnMsZj1kLmNoYXJ0LnJlbmRlcmVyLGc9ZC5ob3JpeixoPXRoaXMudHlwZSxpPXRoaXMubGFiZWwsaj10aGlzLnBvcyxrPWUubGFiZWxzLG09dGhpcy5ncmlkTGluZSxsPWg/aCtcIkdyaWRcIjpcImdyaWRcIixuPWg/aCtcIlRpY2tcIjpcInRpY2tcIixxPWVbbCtcIkxpbmVXaWR0aFwiXSx4PWVbbCtcIkxpbmVDb2xvclwiXSxvPWVbbCtcIkxpbmVEYXNoU3R5bGVcIl0sUT1lW24rXCJMZW5ndGhcIl0sbD1wKGVbbitcIldpZHRoXCJdLCFoJiZkLmlzWEF4aXM/MTowKSx1PWVbbitcblwiQ29sb3JcIl0seT1lW24rXCJQb3NpdGlvblwiXSxuPXRoaXMubWFyayx0PWsuc3RlcCxzPSEwLHc9ZC50aWNrbWFya09mZnNldCxyPXRoaXMuZ2V0UG9zaXRpb24oZyxqLHcsYiksej1yLngscj1yLnksQz1nJiZ6PT09ZC5wb3MrZC5sZW58fCFnJiZyPT09ZC5wb3M/LTE6MSxjPXAoYywxKTt0aGlzLmlzQWN0aXZlPSEwO2lmKHEpe2o9ZC5nZXRQbG90TGluZVBhdGgoait3LHEqQyxiLCEwKTtpZihtPT09dil7bT17c3Ryb2tlOngsXCJzdHJva2Utd2lkdGhcIjpxfTtpZihvKW0uZGFzaHN0eWxlPW87aWYoIWgpbS56SW5kZXg9MTtpZihiKW0ub3BhY2l0eT0wO3RoaXMuZ3JpZExpbmU9bT1xP2YucGF0aChqKS5hdHRyKG0pLmFkZChkLmdyaWRHcm91cCk6bnVsbH1pZighYiYmbSYmailtW3RoaXMuaXNOZXc/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHtkOmosb3BhY2l0eTpjfSl9aWYobCYmUSl5PT09XCJpbnNpZGVcIiYmKFE9LVEpLGQub3Bwb3NpdGUmJihRPS1RKSxoPXRoaXMuZ2V0TWFya1BhdGgoeixyLFxuUSxsKkMsZyxmKSxuP24uYW5pbWF0ZSh7ZDpoLG9wYWNpdHk6Y30pOnRoaXMubWFyaz1mLnBhdGgoaCkuYXR0cih7c3Ryb2tlOnUsXCJzdHJva2Utd2lkdGhcIjpsLG9wYWNpdHk6Y30pLmFkZChkLmF4aXNHcm91cCk7aWYoaSYmIWlzTmFOKHopKWkueHk9cj10aGlzLmdldExhYmVsUG9zaXRpb24oeixyLGksZyxrLHcsYSx0KSx0aGlzLmlzRmlyc3QmJiF0aGlzLmlzTGFzdCYmIXAoZS5zaG93Rmlyc3RMYWJlbCwxKXx8dGhpcy5pc0xhc3QmJiF0aGlzLmlzRmlyc3QmJiFwKGUuc2hvd0xhc3RMYWJlbCwxKT9zPSExOmcmJiFkLmlzUmFkaWFsJiYhay5zdGVwJiYhay5yb3RhdGlvbiYmIWImJmMhPT0wJiZ0aGlzLmhhbmRsZU92ZXJmbG93KHIpLHQmJmEldCYmKHM9ITEpLHMmJiFpc05hTihyLnkpPyhyLm9wYWNpdHk9YyxpW3RoaXMuaXNOZXc/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHIpLHRoaXMuaXNOZXc9ITEpOmkuYXR0cihcInlcIiwtOTk5OSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtPYSh0aGlzLHRoaXMuYXhpcyl9fTtcbkIuUGxvdExpbmVPckJhbmQ9ZnVuY3Rpb24oYSxiKXt0aGlzLmF4aXM9YTtpZihiKXRoaXMub3B0aW9ucz1iLHRoaXMuaWQ9Yi5pZH07Qi5QbG90TGluZU9yQmFuZC5wcm90b3R5cGU9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmF4aXMsYz1iLmhvcml6LGQ9YS5vcHRpb25zLGU9ZC5sYWJlbCxmPWEubGFiZWwsZz1kLndpZHRoLGg9ZC50byxpPWQuZnJvbSxqPXMoaSkmJnMoaCksaz1kLnZhbHVlLG09ZC5kYXNoU3R5bGUsbD1hLnN2Z0VsZW0sbj1bXSxxLHg9ZC5jb2xvcixwPWQuekluZGV4LG89ZC5ldmVudHMsdT17fSx5PWIuY2hhcnQucmVuZGVyZXI7Yi5pc0xvZyYmKGk9QmEoaSksaD1CYShoKSxrPUJhKGspKTtpZihnKXtpZihuPWIuZ2V0UGxvdExpbmVQYXRoKGssZyksdT17c3Ryb2tlOngsXCJzdHJva2Utd2lkdGhcIjpnfSxtKXUuZGFzaHN0eWxlPW19ZWxzZSBpZihqKXtuPWIuZ2V0UGxvdEJhbmRQYXRoKGksaCxkKTtpZih4KXUuZmlsbD14O2lmKGQuYm9yZGVyV2lkdGgpdS5zdHJva2U9XG5kLmJvcmRlckNvbG9yLHVbXCJzdHJva2Utd2lkdGhcIl09ZC5ib3JkZXJXaWR0aH1lbHNlIHJldHVybjtpZihzKHApKXUuekluZGV4PXA7aWYobClpZihuKWwuYW5pbWF0ZSh7ZDpufSxudWxsLGwub25HZXRQYXRoKTtlbHNle2lmKGwuaGlkZSgpLGwub25HZXRQYXRoPWZ1bmN0aW9uKCl7bC5zaG93KCl9LGYpYS5sYWJlbD1mPWYuZGVzdHJveSgpfWVsc2UgaWYobiYmbi5sZW5ndGgmJihhLnN2Z0VsZW09bD15LnBhdGgobikuYXR0cih1KS5hZGQoKSxvKSlmb3IocSBpbiBkPWZ1bmN0aW9uKGIpe2wub24oYixmdW5jdGlvbihjKXtvW2JdLmFwcGx5KGEsW2NdKX0pfSxvKWQocSk7aWYoZSYmcyhlLnRleHQpJiZuJiZuLmxlbmd0aCYmYi53aWR0aD4wJiZiLmhlaWdodD4wKXtlPUEoe2FsaWduOmMmJmomJlwiY2VudGVyXCIseDpjPyFqJiY0OjEwLHZlcnRpY2FsQWxpZ246IWMmJmomJlwibWlkZGxlXCIseTpjP2o/MTY6MTA6aj82Oi00LHJvdGF0aW9uOmMmJiFqJiY5MH0sZSk7aWYoIWYpe3U9e2FsaWduOmUudGV4dEFsaWdufHxcbmUuYWxpZ24scm90YXRpb246ZS5yb3RhdGlvbn07aWYocyhwKSl1LnpJbmRleD1wO2EubGFiZWw9Zj15LnRleHQoZS50ZXh0LDAsMCxlLnVzZUhUTUwpLmF0dHIodSkuY3NzKGUuc3R5bGUpLmFkZCgpfWI9W25bMV0sbls0XSxqP25bNl06blsxXV07aj1bblsyXSxuWzVdLGo/bls3XTpuWzJdXTtuPU5hKGIpO2M9TmEoaik7Zi5hbGlnbihlLCExLHt4Om4seTpjLHdpZHRoOkNhKGIpLW4saGVpZ2h0OkNhKGopLWN9KTtmLnNob3coKX1lbHNlIGYmJmYuaGlkZSgpO3JldHVybiBhfSxkZXN0cm95OmZ1bmN0aW9uKCl7amEodGhpcy5heGlzLnBsb3RMaW5lc0FuZEJhbmRzLHRoaXMpO2RlbGV0ZSB0aGlzLmF4aXM7T2EodGhpcyl9fTt2YXIgaGE9Qi5BeGlzPWZ1bmN0aW9uKCl7dGhpcy5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07aGEucHJvdG90eXBlPXtkZWZhdWx0T3B0aW9uczp7ZGF0ZVRpbWVMYWJlbEZvcm1hdHM6e21pbGxpc2Vjb25kOlwiJUg6JU06JVMuJUxcIixzZWNvbmQ6XCIlSDolTTolU1wiLFxubWludXRlOlwiJUg6JU1cIixob3VyOlwiJUg6JU1cIixkYXk6XCIlZS4gJWJcIix3ZWVrOlwiJWUuICViXCIsbW9udGg6XCIlYiAnJXlcIix5ZWFyOlwiJVlcIn0sZW5kT25UaWNrOiExLGdyaWRMaW5lQ29sb3I6XCIjRDhEOEQ4XCIsbGFiZWxzOntlbmFibGVkOiEwLHN0eWxlOntjb2xvcjpcIiM2MDYwNjBcIixjdXJzb3I6XCJkZWZhdWx0XCIsZm9udFNpemU6XCIxMXB4XCJ9LHg6MCx5OjE1fSxsaW5lQ29sb3I6XCIjQzBEMEUwXCIsbGluZVdpZHRoOjEsbWluUGFkZGluZzowLjAxLG1heFBhZGRpbmc6MC4wMSxtaW5vckdyaWRMaW5lQ29sb3I6XCIjRTBFMEUwXCIsbWlub3JHcmlkTGluZVdpZHRoOjEsbWlub3JUaWNrQ29sb3I6XCIjQTBBMEEwXCIsbWlub3JUaWNrTGVuZ3RoOjIsbWlub3JUaWNrUG9zaXRpb246XCJvdXRzaWRlXCIsc3RhcnRPZldlZWs6MSxzdGFydE9uVGljazohMSx0aWNrQ29sb3I6XCIjQzBEMEUwXCIsdGlja0xlbmd0aDoxMCx0aWNrbWFya1BsYWNlbWVudDpcImJldHdlZW5cIix0aWNrUGl4ZWxJbnRlcnZhbDoxMDAsXG50aWNrUG9zaXRpb246XCJvdXRzaWRlXCIsdGl0bGU6e2FsaWduOlwibWlkZGxlXCIsc3R5bGU6e2NvbG9yOlwiIzcwNzA3MFwifX0sdHlwZTpcImxpbmVhclwifSxkZWZhdWx0WUF4aXNPcHRpb25zOntlbmRPblRpY2s6ITAsZ3JpZExpbmVXaWR0aDoxLHRpY2tQaXhlbEludGVydmFsOjcyLHNob3dMYXN0TGFiZWw6ITAsbGFiZWxzOnt4Oi04LHk6M30sbGluZVdpZHRoOjAsbWF4UGFkZGluZzowLjA1LG1pblBhZGRpbmc6MC4wNSxzdGFydE9uVGljazohMCx0aXRsZTp7cm90YXRpb246MjcwLHRleHQ6XCJWYWx1ZXNcIn0sc3RhY2tMYWJlbHM6e2VuYWJsZWQ6ITEsZm9ybWF0dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIEIubnVtYmVyRm9ybWF0KHRoaXMudG90YWwsLTEpfSxzdHlsZTpBKGJhLmxpbmUuZGF0YUxhYmVscy5zdHlsZSx7Y29sb3I6XCIjMDAwMDAwXCJ9KX19LGRlZmF1bHRMZWZ0QXhpc09wdGlvbnM6e2xhYmVsczp7eDotMTUseTpudWxsfSx0aXRsZTp7cm90YXRpb246MjcwfX0sZGVmYXVsdFJpZ2h0QXhpc09wdGlvbnM6e2xhYmVsczp7eDoxNSxcbnk6bnVsbH0sdGl0bGU6e3JvdGF0aW9uOjkwfX0sZGVmYXVsdEJvdHRvbUF4aXNPcHRpb25zOntsYWJlbHM6e2F1dG9Sb3RhdGlvbjpbLTQ1XSx4OjAseTpudWxsfSx0aXRsZTp7cm90YXRpb246MH19LGRlZmF1bHRUb3BBeGlzT3B0aW9uczp7bGFiZWxzOnthdXRvUm90YXRpb246Wy00NV0seDowLHk6LTE1fSx0aXRsZTp7cm90YXRpb246MH19LGluaXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1iLmlzWDt0aGlzLmNoYXJ0PWE7dGhpcy5ob3Jpej1hLmludmVydGVkPyFjOmM7dGhpcy5jb2xsPSh0aGlzLmlzWEF4aXM9Yyk/XCJ4QXhpc1wiOlwieUF4aXNcIjt0aGlzLm9wcG9zaXRlPWIub3Bwb3NpdGU7dGhpcy5zaWRlPWIuc2lkZXx8KHRoaXMuaG9yaXo/dGhpcy5vcHBvc2l0ZT8wOjI6dGhpcy5vcHBvc2l0ZT8xOjMpO3RoaXMuc2V0T3B0aW9ucyhiKTt2YXIgZD10aGlzLm9wdGlvbnMsZT1kLnR5cGU7dGhpcy5sYWJlbEZvcm1hdHRlcj1kLmxhYmVscy5mb3JtYXR0ZXJ8fHRoaXMuZGVmYXVsdExhYmVsRm9ybWF0dGVyO1xudGhpcy51c2VyT3B0aW9ucz1iO3RoaXMubWluUGl4ZWxQYWRkaW5nPTA7dGhpcy5yZXZlcnNlZD1kLnJldmVyc2VkO3RoaXMuem9vbUVuYWJsZWQ9ZC56b29tRW5hYmxlZCE9PSExO3RoaXMuY2F0ZWdvcmllcz1kLmNhdGVnb3JpZXN8fGU9PT1cImNhdGVnb3J5XCI7dGhpcy5uYW1lcz10aGlzLm5hbWVzfHxbXTt0aGlzLmlzTG9nPWU9PT1cImxvZ2FyaXRobWljXCI7dGhpcy5pc0RhdGV0aW1lQXhpcz1lPT09XCJkYXRldGltZVwiO3RoaXMuaXNMaW5rZWQ9cyhkLmxpbmtlZFRvKTt0aGlzLnRpY2tzPXt9O3RoaXMubGFiZWxFZGdlPVtdO3RoaXMubWlub3JUaWNrcz17fTt0aGlzLnBsb3RMaW5lc0FuZEJhbmRzPVtdO3RoaXMuYWx0ZXJuYXRlQmFuZHM9e307dGhpcy5sZW49MDt0aGlzLm1pblJhbmdlPXRoaXMudXNlck1pblJhbmdlPWQubWluUmFuZ2V8fGQubWF4Wm9vbTt0aGlzLnJhbmdlPWQucmFuZ2U7dGhpcy5vZmZzZXQ9ZC5vZmZzZXR8fDA7dGhpcy5zdGFja3M9e307dGhpcy5vbGRTdGFja3M9XG57fTt0aGlzLnN0YWNrc1RvdWNoZWQ9MDt0aGlzLm1pbj10aGlzLm1heD1udWxsO3RoaXMuY3Jvc3NoYWlyPXAoZC5jcm9zc2hhaXIscmEoYS5vcHRpb25zLnRvb2x0aXAuY3Jvc3NoYWlycylbYz8wOjFdLCExKTt2YXIgZixkPXRoaXMub3B0aW9ucy5ldmVudHM7S2EodGhpcyxhLmF4ZXMpPT09LTEmJihjJiYhdGhpcy5pc0NvbG9yQXhpcz9hLmF4ZXMuc3BsaWNlKGEueEF4aXMubGVuZ3RoLDAsdGhpcyk6YS5heGVzLnB1c2godGhpcyksYVt0aGlzLmNvbGxdLnB1c2godGhpcykpO3RoaXMuc2VyaWVzPXRoaXMuc2VyaWVzfHxbXTtpZihhLmludmVydGVkJiZjJiZ0aGlzLnJldmVyc2VkPT09dil0aGlzLnJldmVyc2VkPSEwO3RoaXMucmVtb3ZlUGxvdExpbmU9dGhpcy5yZW1vdmVQbG90QmFuZD10aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lO2ZvcihmIGluIGQpSCh0aGlzLGYsZFtmXSk7aWYodGhpcy5pc0xvZyl0aGlzLnZhbDJsaW49QmEsdGhpcy5saW4ydmFsPWlhfSxzZXRPcHRpb25zOmZ1bmN0aW9uKGEpe3RoaXMub3B0aW9ucz1cbkEodGhpcy5kZWZhdWx0T3B0aW9ucyx0aGlzLmlzWEF4aXM/e306dGhpcy5kZWZhdWx0WUF4aXNPcHRpb25zLFt0aGlzLmRlZmF1bHRUb3BBeGlzT3B0aW9ucyx0aGlzLmRlZmF1bHRSaWdodEF4aXNPcHRpb25zLHRoaXMuZGVmYXVsdEJvdHRvbUF4aXNPcHRpb25zLHRoaXMuZGVmYXVsdExlZnRBeGlzT3B0aW9uc11bdGhpcy5zaWRlXSxBKFNbdGhpcy5jb2xsXSxhKSl9LGRlZmF1bHRMYWJlbEZvcm1hdHRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuYXhpcyxiPXRoaXMudmFsdWUsYz1hLmNhdGVnb3JpZXMsZD10aGlzLmRhdGVUaW1lTGFiZWxGb3JtYXQsZT1TLmxhbmcubnVtZXJpY1N5bWJvbHMsZj1lJiZlLmxlbmd0aCxnLGg9YS5vcHRpb25zLmxhYmVscy5mb3JtYXQsYT1hLmlzTG9nP2I6YS50aWNrSW50ZXJ2YWw7aWYoaClnPUhhKGgsdGhpcyk7ZWxzZSBpZihjKWc9YjtlbHNlIGlmKGQpZz1NYShkLGIpO2Vsc2UgaWYoZiYmYT49MUUzKWZvcig7Zi0tJiZnPT09djspYz1NYXRoLnBvdygxRTMsXG5mKzEpLGE+PWMmJmIqMTAlYz09PTAmJmVbZl0hPT1udWxsJiYoZz1CLm51bWJlckZvcm1hdChiL2MsLTEpK2VbZl0pO2c9PT12JiYoZz1OKGIpPj0xRTQ/Qi5udW1iZXJGb3JtYXQoYiwtMSk6Qi5udW1iZXJGb3JtYXQoYiwtMSx2LFwiXCIpKTtyZXR1cm4gZ30sZ2V0U2VyaWVzRXh0cmVtZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydDthLmhhc1Zpc2libGVTZXJpZXM9ITE7YS5kYXRhTWluPWEuZGF0YU1heD1hLmlnbm9yZU1pblBhZGRpbmc9YS5pZ25vcmVNYXhQYWRkaW5nPW51bGw7YS5idWlsZFN0YWNrcyYmYS5idWlsZFN0YWNrcygpO28oYS5zZXJpZXMsZnVuY3Rpb24oYyl7aWYoYy52aXNpYmxlfHwhYi5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyl7dmFyIGQ7ZD1jLm9wdGlvbnMudGhyZXNob2xkO3ZhciBlO2EuaGFzVmlzaWJsZVNlcmllcz0hMDthLmlzTG9nJiZkPD0wJiYoZD1udWxsKTtpZihhLmlzWEF4aXMpe2lmKGQ9Yy54RGF0YSxkLmxlbmd0aClhLmRhdGFNaW49XG56KHAoYS5kYXRhTWluLGRbMF0pLE5hKGQpKSxhLmRhdGFNYXg9dChwKGEuZGF0YU1heCxkWzBdKSxDYShkKSl9ZWxzZXtjLmdldEV4dHJlbWVzKCk7ZT1jLmRhdGFNYXg7Yz1jLmRhdGFNaW47aWYocyhjKSYmcyhlKSlhLmRhdGFNaW49eihwKGEuZGF0YU1pbixjKSxjKSxhLmRhdGFNYXg9dChwKGEuZGF0YU1heCxlKSxlKTtpZihzKGQpKWlmKGEuZGF0YU1pbj49ZClhLmRhdGFNaW49ZCxhLmlnbm9yZU1pblBhZGRpbmc9ITA7ZWxzZSBpZihhLmRhdGFNYXg8ZClhLmRhdGFNYXg9ZCxhLmlnbm9yZU1heFBhZGRpbmc9ITB9fX0pfSx0cmFuc2xhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPXRoaXMubGlua2VkUGFyZW50fHx0aGlzLGg9MSxpPTAsaj1kP2cub2xkVHJhbnNBOmcudHJhbnNBLGQ9ZD9nLm9sZE1pbjpnLm1pbixrPWcubWluUGl4ZWxQYWRkaW5nLGU9KGcuZG9Qb3N0VHJhbnNsYXRlfHxnLmlzTG9nJiZlKSYmZy5saW4ydmFsO2lmKCFqKWo9Zy50cmFuc0E7aWYoYyloKj1cbi0xLGk9Zy5sZW47Zy5yZXZlcnNlZCYmKGgqPS0xLGktPWgqKGcuc2VjdG9yfHxnLmxlbikpO2I/KGE9YSpoK2ksYS09ayxhPWEvaitkLGUmJihhPWcubGluMnZhbChhKSkpOihlJiYoYT1nLnZhbDJsaW4oYSkpLGY9PT1cImJldHdlZW5cIiYmKGY9MC41KSxhPWgqKGEtZCkqaitpK2gqaysocWEoZik/aipmKmcucG9pbnRSYW5nZTowKSk7cmV0dXJuIGF9LHRvUGl4ZWxzOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMudHJhbnNsYXRlKGEsITEsIXRoaXMuaG9yaXosbnVsbCwhMCkrKGI/MDp0aGlzLnBvcyl9LHRvVmFsdWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy50cmFuc2xhdGUoYS0oYj8wOnRoaXMucG9zKSwhMCwhdGhpcy5ob3JpeixudWxsLCEwKX0sZ2V0UGxvdExpbmVQYXRoOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcy5jaGFydCxnPXRoaXMubGVmdCxoPXRoaXMudG9wLGksaixrPWMmJmYub2xkQ2hhcnRIZWlnaHR8fGYuY2hhcnRIZWlnaHQsbT1jJiZmLm9sZENoYXJ0V2lkdGh8fFxuZi5jaGFydFdpZHRoLGw7aT10aGlzLnRyYW5zQjt2YXIgbj1mdW5jdGlvbihhLGIsYyl7aWYoYTxifHxhPmMpZD9hPXoodChiLGEpLGMpOmw9ITA7cmV0dXJuIGF9LGU9cChlLHRoaXMudHJhbnNsYXRlKGEsbnVsbCxudWxsLGMpKSxhPWM9dyhlK2kpO2k9aj13KGstZS1pKTtpc05hTihlKT9sPSEwOnRoaXMuaG9yaXo/KGk9aCxqPWstdGhpcy5ib3R0b20sYT1jPW4oYSxnLGcrdGhpcy53aWR0aCkpOihhPWcsYz1tLXRoaXMucmlnaHQsaT1qPW4oaSxoLGgrdGhpcy5oZWlnaHQpKTtyZXR1cm4gbCYmIWQ/bnVsbDpmLnJlbmRlcmVyLmNyaXNwTGluZShbXCJNXCIsYSxpLFwiTFwiLGMsal0sYnx8MSl9LGdldExpbmVhclRpY2tQb3NpdGlvbnM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU9ZWEoVihiL2EpKmEpLGY9ZWEoc2EoYy9hKSphKSxnPVtdO2lmKGI9PT1jJiZxYShiKSlyZXR1cm5bYl07Zm9yKGI9ZTtiPD1mOyl7Zy5wdXNoKGIpO2I9ZWEoYithKTtpZihiPT09ZClicmVhaztkPWJ9cmV0dXJuIGd9LFxuZ2V0TWlub3JUaWNrUG9zaXRpb25zOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9dGhpcy50aWNrUG9zaXRpb25zLGM9dGhpcy5taW5vclRpY2tJbnRlcnZhbCxkPVtdLGUsZj10aGlzLnBvaW50UmFuZ2VQYWRkaW5nfHwwO2U9dGhpcy5taW4tZjt2YXIgZj10aGlzLm1heCtmLGc9Zi1lO2lmKGcmJmcvYzx0aGlzLmxlbi8zKWlmKHRoaXMuaXNMb2cpe2Y9Yi5sZW5ndGg7Zm9yKGU9MTtlPGY7ZSsrKWQ9ZC5jb25jYXQodGhpcy5nZXRMb2dUaWNrUG9zaXRpb25zKGMsYltlLTFdLGJbZV0sITApKX1lbHNlIGlmKHRoaXMuaXNEYXRldGltZUF4aXMmJmEubWlub3JUaWNrSW50ZXJ2YWw9PT1cImF1dG9cIilkPWQuY29uY2F0KHRoaXMuZ2V0VGltZVRpY2tzKHRoaXMubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbChjKSxlLGYsYS5zdGFydE9mV2VlaykpO2Vsc2UgZm9yKGI9ZSsoYlswXS1lKSVjO2I8PWY7Yis9YylkLnB1c2goYik7ZC5sZW5ndGghPT0wJiZ0aGlzLnRyaW1UaWNrcyhkLFxuYS5zdGFydE9uVGljayxhLmVuZE9uVGljayk7cmV0dXJuIGR9LGFkanVzdEZvck1pblJhbmdlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9dGhpcy5taW4sYz10aGlzLm1heCxkLGU9dGhpcy5kYXRhTWF4LXRoaXMuZGF0YU1pbj49dGhpcy5taW5SYW5nZSxmLGcsaCxpLGo7aWYodGhpcy5pc1hBeGlzJiZ0aGlzLm1pblJhbmdlPT09diYmIXRoaXMuaXNMb2cpcyhhLm1pbil8fHMoYS5tYXgpP3RoaXMubWluUmFuZ2U9bnVsbDoobyh0aGlzLnNlcmllcyxmdW5jdGlvbihhKXtpPWEueERhdGE7Zm9yKGc9aj1hLnhJbmNyZW1lbnQ/MTppLmxlbmd0aC0xO2c+MDtnLS0paWYoaD1pW2ddLWlbZy0xXSxmPT09dnx8aDxmKWY9aH0pLHRoaXMubWluUmFuZ2U9eihmKjUsdGhpcy5kYXRhTWF4LXRoaXMuZGF0YU1pbikpO2lmKGMtYjx0aGlzLm1pblJhbmdlKXt2YXIgaz10aGlzLm1pblJhbmdlO2Q9KGstYytiKS8yO2Q9W2ItZCxwKGEubWluLGItZCldO2lmKGUpZFsyXT10aGlzLmRhdGFNaW47XG5iPUNhKGQpO2M9W2IrayxwKGEubWF4LGIrayldO2lmKGUpY1syXT10aGlzLmRhdGFNYXg7Yz1OYShjKTtjLWI8ayYmKGRbMF09Yy1rLGRbMV09cChhLm1pbixjLWspLGI9Q2EoZCkpfXRoaXMubWluPWI7dGhpcy5tYXg9Y30sc2V0QXhpc1RyYW5zbGF0aW9uOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLm1heC1iLm1pbixkPWIuYXhpc1BvaW50UmFuZ2V8fDAsZSxmPTAsZz0wLGg9Yi5saW5rZWRQYXJlbnQsaT0hIWIuY2F0ZWdvcmllcyxqPWIudHJhbnNBLGs9Yi5pc1hBeGlzO2lmKGt8fGl8fGQpaWYoaD8oZj1oLm1pblBvaW50T2Zmc2V0LGc9aC5wb2ludFJhbmdlUGFkZGluZyk6byhiLnNlcmllcyxmdW5jdGlvbihhKXt2YXIgaD1pPzE6az9hLnBvaW50UmFuZ2U6Yi5heGlzUG9pbnRSYW5nZXx8MCxqPWEub3B0aW9ucy5wb2ludFBsYWNlbWVudCxxPWEuY2xvc2VzdFBvaW50UmFuZ2U7aD5jJiYoaD0wKTtkPXQoZCxoKTtiLnNpbmdsZXx8KGY9dChmLEFhKGopPzA6aC8yKSxnPXQoZyxcbmo9PT1cIm9uXCI/MDpoKSk7IWEubm9TaGFyZWRUb29sdGlwJiZzKHEpJiYoZT1zKGUpP3ooZSxxKTpxKX0pLGg9Yi5vcmRpbmFsU2xvcGUmJmU/Yi5vcmRpbmFsU2xvcGUvZToxLGIubWluUG9pbnRPZmZzZXQ9Zio9aCxiLnBvaW50UmFuZ2VQYWRkaW5nPWcqPWgsYi5wb2ludFJhbmdlPXooZCxjKSxrKWIuY2xvc2VzdFBvaW50UmFuZ2U9ZTtpZihhKWIub2xkVHJhbnNBPWo7Yi50cmFuc2xhdGlvblNsb3BlPWIudHJhbnNBPWo9Yi5sZW4vKGMrZ3x8MSk7Yi50cmFuc0I9Yi5ob3Jpej9iLmxlZnQ6Yi5ib3R0b207Yi5taW5QaXhlbFBhZGRpbmc9aipmfSxtaW5Gcm9tUmFuZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXgtdGhpcy5yYW5nZX0sc2V0VGlja0ludGVydmFsOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLmNoYXJ0LGQ9Yi5vcHRpb25zLGU9Yi5pc0xvZyxmPWIuaXNEYXRldGltZUF4aXMsZz1iLmlzWEF4aXMsaD1iLmlzTGlua2VkLGk9ZC5tYXhQYWRkaW5nLGo9ZC5taW5QYWRkaW5nLFxuaz1kLnRpY2tJbnRlcnZhbCxtPWQudGlja1BpeGVsSW50ZXJ2YWwsbD1iLmNhdGVnb3JpZXM7IWYmJiFsJiYhaCYmdGhpcy5nZXRUaWNrQW1vdW50KCk7aD8oYi5saW5rZWRQYXJlbnQ9Y1tiLmNvbGxdW2QubGlua2VkVG9dLGM9Yi5saW5rZWRQYXJlbnQuZ2V0RXh0cmVtZXMoKSxiLm1pbj1wKGMubWluLGMuZGF0YU1pbiksYi5tYXg9cChjLm1heCxjLmRhdGFNYXgpLGQudHlwZSE9PWIubGlua2VkUGFyZW50Lm9wdGlvbnMudHlwZSYmbGEoMTEsMSkpOihiLm1pbj1wKGIudXNlck1pbixkLm1pbixiLmRhdGFNaW4pLGIubWF4PXAoYi51c2VyTWF4LGQubWF4LGIuZGF0YU1heCkpO2lmKGUpIWEmJnooYi5taW4scChiLmRhdGFNaW4sYi5taW4pKTw9MCYmbGEoMTAsMSksYi5taW49ZWEoQmEoYi5taW4pLDE1KSxiLm1heD1lYShCYShiLm1heCksMTUpO2lmKGIucmFuZ2UmJnMoYi5tYXgpKWIudXNlck1pbj1iLm1pbj10KGIubWluLGIubWluRnJvbVJhbmdlKCkpLGIudXNlck1heD1iLm1heCxcbmIucmFuZ2U9bnVsbDtiLmJlZm9yZVBhZGRpbmcmJmIuYmVmb3JlUGFkZGluZygpO2IuYWRqdXN0Rm9yTWluUmFuZ2UoKTtpZighbCYmIWIuYXhpc1BvaW50UmFuZ2UmJiFiLnVzZVBlcmNlbnRhZ2UmJiFoJiZzKGIubWluKSYmcyhiLm1heCkmJihjPWIubWF4LWIubWluKSl7aWYoIXMoZC5taW4pJiYhcyhiLnVzZXJNaW4pJiZqJiYoYi5kYXRhTWluPDB8fCFiLmlnbm9yZU1pblBhZGRpbmcpKWIubWluLT1jKmo7aWYoIXMoZC5tYXgpJiYhcyhiLnVzZXJNYXgpJiZpJiYoYi5kYXRhTWF4PjB8fCFiLmlnbm9yZU1heFBhZGRpbmcpKWIubWF4Kz1jKml9aWYocWEoZC5mbG9vcikpYi5taW49dChiLm1pbixkLmZsb29yKTtpZihxYShkLmNlaWxpbmcpKWIubWF4PXooYi5tYXgsZC5jZWlsaW5nKTtiLnRpY2tJbnRlcnZhbD1iLm1pbj09PWIubWF4fHxiLm1pbj09PXZvaWQgMHx8Yi5tYXg9PT12b2lkIDA/MTpoJiYhayYmbT09PWIubGlua2VkUGFyZW50Lm9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWw/XG5rPWIubGlua2VkUGFyZW50LnRpY2tJbnRlcnZhbDpwKGssdGhpcy50aWNrQW1vdW50PyhiLm1heC1iLm1pbikvdCh0aGlzLnRpY2tBbW91bnQtMSwxKTp2b2lkIDAsbD8xOihiLm1heC1iLm1pbikqbS90KGIubGVuLG0pKTtnJiYhYSYmbyhiLnNlcmllcyxmdW5jdGlvbihhKXthLnByb2Nlc3NEYXRhKGIubWluIT09Yi5vbGRNaW58fGIubWF4IT09Yi5vbGRNYXgpfSk7Yi5zZXRBeGlzVHJhbnNsYXRpb24oITApO2IuYmVmb3JlU2V0VGlja1Bvc2l0aW9ucyYmYi5iZWZvcmVTZXRUaWNrUG9zaXRpb25zKCk7aWYoYi5wb3N0UHJvY2Vzc1RpY2tJbnRlcnZhbCliLnRpY2tJbnRlcnZhbD1iLnBvc3RQcm9jZXNzVGlja0ludGVydmFsKGIudGlja0ludGVydmFsKTtpZihiLnBvaW50UmFuZ2UpYi50aWNrSW50ZXJ2YWw9dChiLnBvaW50UmFuZ2UsYi50aWNrSW50ZXJ2YWwpO2E9cChkLm1pblRpY2tJbnRlcnZhbCxiLmlzRGF0ZXRpbWVBeGlzJiZiLmNsb3Nlc3RQb2ludFJhbmdlKTtpZighayYmXG5iLnRpY2tJbnRlcnZhbDxhKWIudGlja0ludGVydmFsPWE7aWYoIWYmJiFlJiYhayliLnRpY2tJbnRlcnZhbD1vYihiLnRpY2tJbnRlcnZhbCxudWxsLG5iKGIudGlja0ludGVydmFsKSxwKGQuYWxsb3dEZWNpbWFscywhKGIudGlja0ludGVydmFsPjAuNSYmYi50aWNrSW50ZXJ2YWw8NSYmYi5tYXg+MUUzJiZiLm1heDw5OTk5KSksISF0aGlzLnRpY2tBbW91bnQpO2lmKCF0aGlzLnRpY2tBbW91bnQmJnRoaXMubGVuKWIudGlja0ludGVydmFsPWIudW5zcXVpc2goKTt0aGlzLnNldFRpY2tQb3NpdGlvbnMoKX0sc2V0VGlja1Bvc2l0aW9uczpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiLGM9YS50aWNrUG9zaXRpb25zLGQ9YS50aWNrUG9zaXRpb25lcixlPWEuc3RhcnRPblRpY2ssZj1hLmVuZE9uVGljayxnO3RoaXMudGlja21hcmtPZmZzZXQ9dGhpcy5jYXRlZ29yaWVzJiZhLnRpY2ttYXJrUGxhY2VtZW50PT09XCJiZXR3ZWVuXCImJnRoaXMudGlja0ludGVydmFsPT09MT8wLjU6XG4wO3RoaXMubWlub3JUaWNrSW50ZXJ2YWw9YS5taW5vclRpY2tJbnRlcnZhbD09PVwiYXV0b1wiJiZ0aGlzLnRpY2tJbnRlcnZhbD90aGlzLnRpY2tJbnRlcnZhbC81OmEubWlub3JUaWNrSW50ZXJ2YWw7dGhpcy50aWNrUG9zaXRpb25zPWI9YyYmYy5zbGljZSgpO2lmKCFiJiYoYj10aGlzLmlzRGF0ZXRpbWVBeGlzP3RoaXMuZ2V0VGltZVRpY2tzKHRoaXMubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCh0aGlzLnRpY2tJbnRlcnZhbCxhLnVuaXRzKSx0aGlzLm1pbix0aGlzLm1heCxhLnN0YXJ0T2ZXZWVrLHRoaXMub3JkaW5hbFBvc2l0aW9ucyx0aGlzLmNsb3Nlc3RQb2ludFJhbmdlLCEwKTp0aGlzLmlzTG9nP3RoaXMuZ2V0TG9nVGlja1Bvc2l0aW9ucyh0aGlzLnRpY2tJbnRlcnZhbCx0aGlzLm1pbix0aGlzLm1heCk6dGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKHRoaXMudGlja0ludGVydmFsLHRoaXMubWluLHRoaXMubWF4KSxiLmxlbmd0aD50aGlzLmxlbiYmKGI9W2JbMF0sYi5wb3AoKV0pLFxudGhpcy50aWNrUG9zaXRpb25zPWIsZCYmKGQ9ZC5hcHBseSh0aGlzLFt0aGlzLm1pbix0aGlzLm1heF0pKSkpdGhpcy50aWNrUG9zaXRpb25zPWI9ZDtpZighdGhpcy5pc0xpbmtlZCl0aGlzLnRyaW1UaWNrcyhiLGUsZiksdGhpcy5taW49PT10aGlzLm1heCYmcyh0aGlzLm1pbikmJiF0aGlzLnRpY2tBbW91bnQmJihnPSEwLHRoaXMubWluLT0wLjUsdGhpcy5tYXgrPTAuNSksdGhpcy5zaW5nbGU9ZywhYyYmIWQmJnRoaXMuYWRqdXN0VGlja0Ftb3VudCgpfSx0cmltVGlja3M6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWFbMF0sZT1hW2EubGVuZ3RoLTFdLGY9dGhpcy5taW5Qb2ludE9mZnNldHx8MDtiP3RoaXMubWluPWQ6dGhpcy5taW4tZj5kJiZhLnNoaWZ0KCk7Yz90aGlzLm1heD1lOnRoaXMubWF4K2Y8ZSYmYS5wb3AoKTthLmxlbmd0aD09PTAmJnMoZCkmJmEucHVzaCgoZStkKS8yKX0sZ2V0VGlja0Ftb3VudDpmdW5jdGlvbigpe3ZhciBhPXt9LGIsYz10aGlzLm9wdGlvbnMsZD1jLnRpY2tBbW91bnQsXG5lPWMudGlja1BpeGVsSW50ZXJ2YWw7IXMoYy50aWNrSW50ZXJ2YWwpJiZ0aGlzLmxlbjxlJiYhdGhpcy5pc1JhZGlhbCYmIXRoaXMuaXNMb2cmJmMuc3RhcnRPblRpY2smJmMuZW5kT25UaWNrJiYoZD0yKTshZCYmdGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0LmFsaWduVGlja3MhPT0hMSYmYy5hbGlnblRpY2tzIT09ITEmJihvKHRoaXMuY2hhcnRbdGhpcy5jb2xsXSxmdW5jdGlvbihjKXt2YXIgZD1jLm9wdGlvbnMsZT1jLmhvcml6LGQ9W2U/ZC5sZWZ0OmQudG9wLGU/ZC53aWR0aDpkLmhlaWdodCxkLnBhbmVdLmpvaW4oXCIsXCIpO2FbZF0/Yy5zZXJpZXMubGVuZ3RoJiYoYj0hMCk6YVtkXT0xfSksYiYmKGQ9c2EodGhpcy5sZW4vZSkrMSkpO2lmKGQ8NCl0aGlzLmZpbmFsVGlja0FtdD1kLGQ9NTt0aGlzLnRpY2tBbW91bnQ9ZH0sYWRqdXN0VGlja0Ftb3VudDpmdW5jdGlvbigpe3ZhciBhPXRoaXMudGlja0ludGVydmFsLGI9dGhpcy50aWNrUG9zaXRpb25zLGM9dGhpcy50aWNrQW1vdW50LFxuZD10aGlzLmZpbmFsVGlja0FtdCxlPWImJmIubGVuZ3RoO2lmKGU8Yyl7Zm9yKDtiLmxlbmd0aDxjOyliLnB1c2goZWEoYltiLmxlbmd0aC0xXSthKSk7dGhpcy50cmFuc0EqPShlLTEpLyhjLTEpO3RoaXMubWF4PWJbYi5sZW5ndGgtMV19ZWxzZSBlPmMmJih0aGlzLnRpY2tJbnRlcnZhbCo9Mix0aGlzLnNldFRpY2tQb3NpdGlvbnMoKSk7aWYocyhkKSl7Zm9yKGE9Yz1iLmxlbmd0aDthLS07KShkPT09MyYmYSUyPT09MXx8ZDw9MiYmYT4wJiZhPGMtMSkmJmIuc3BsaWNlKGEsMSk7dGhpcy5maW5hbFRpY2tBbXQ9dn19LHNldFNjYWxlOmZ1bmN0aW9uKCl7dmFyIGEsYjt0aGlzLm9sZE1pbj10aGlzLm1pbjt0aGlzLm9sZE1heD10aGlzLm1heDt0aGlzLm9sZEF4aXNMZW5ndGg9dGhpcy5sZW47dGhpcy5zZXRBeGlzU2l6ZSgpO2I9dGhpcy5sZW4hPT10aGlzLm9sZEF4aXNMZW5ndGg7byh0aGlzLnNlcmllcyxmdW5jdGlvbihiKXtpZihiLmlzRGlydHlEYXRhfHxiLmlzRGlydHl8fGIueEF4aXMuaXNEaXJ0eSlhPVxuITB9KTtpZihifHxhfHx0aGlzLmlzTGlua2VkfHx0aGlzLmZvcmNlUmVkcmF3fHx0aGlzLnVzZXJNaW4hPT10aGlzLm9sZFVzZXJNaW58fHRoaXMudXNlck1heCE9PXRoaXMub2xkVXNlck1heCl7aWYodGhpcy5yZXNldFN0YWNrcyYmdGhpcy5yZXNldFN0YWNrcygpLHRoaXMuZm9yY2VSZWRyYXc9ITEsdGhpcy5nZXRTZXJpZXNFeHRyZW1lcygpLHRoaXMuc2V0VGlja0ludGVydmFsKCksdGhpcy5vbGRVc2VyTWluPXRoaXMudXNlck1pbix0aGlzLm9sZFVzZXJNYXg9dGhpcy51c2VyTWF4LCF0aGlzLmlzRGlydHkpdGhpcy5pc0RpcnR5PWJ8fHRoaXMubWluIT09dGhpcy5vbGRNaW58fHRoaXMubWF4IT09dGhpcy5vbGRNYXh9ZWxzZSB0aGlzLmNsZWFuU3RhY2tzJiZ0aGlzLmNsZWFuU3RhY2tzKCl9LHNldEV4dHJlbWVzOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpcyxnPWYuY2hhcnQsYz1wKGMsITApO28oZi5zZXJpZXMsZnVuY3Rpb24oYSl7ZGVsZXRlIGEua2RUcmVlfSk7XG5lPXIoZSx7bWluOmEsbWF4OmJ9KTtJKGYsXCJzZXRFeHRyZW1lc1wiLGUsZnVuY3Rpb24oKXtmLnVzZXJNaW49YTtmLnVzZXJNYXg9YjtmLmV2ZW50QXJncz1lO2MmJmcucmVkcmF3KGQpfSl9LHpvb206ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmRhdGFNaW4sZD10aGlzLmRhdGFNYXgsZT10aGlzLm9wdGlvbnMsZj16KGMscChlLm1pbixjKSksZT10KGQscChlLm1heCxkKSk7dGhpcy5hbGxvd1pvb21PdXRzaWRlfHwocyhjKSYmYTw9ZiYmKGE9ZikscyhkKSYmYj49ZSYmKGI9ZSkpO3RoaXMuZGlzcGxheUJ0bj1hIT09dnx8YiE9PXY7dGhpcy5zZXRFeHRyZW1lcyhhLGIsITEsdix7dHJpZ2dlcjpcInpvb21cIn0pO3JldHVybiEwfSxzZXRBeGlzU2l6ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj10aGlzLm9wdGlvbnMsYz1iLm9mZnNldExlZnR8fDAsZD10aGlzLmhvcml6LGU9cChiLndpZHRoLGEucGxvdFdpZHRoLWMrKGIub2Zmc2V0UmlnaHR8fDApKSxmPXAoYi5oZWlnaHQsXG5hLnBsb3RIZWlnaHQpLGc9cChiLnRvcCxhLnBsb3RUb3ApLGI9cChiLmxlZnQsYS5wbG90TGVmdCtjKSxjPS8lJC87Yy50ZXN0KGYpJiYoZj1wYXJzZUZsb2F0KGYpLzEwMCphLnBsb3RIZWlnaHQpO2MudGVzdChnKSYmKGc9cGFyc2VGbG9hdChnKS8xMDAqYS5wbG90SGVpZ2h0K2EucGxvdFRvcCk7dGhpcy5sZWZ0PWI7dGhpcy50b3A9Zzt0aGlzLndpZHRoPWU7dGhpcy5oZWlnaHQ9Zjt0aGlzLmJvdHRvbT1hLmNoYXJ0SGVpZ2h0LWYtZzt0aGlzLnJpZ2h0PWEuY2hhcnRXaWR0aC1lLWI7dGhpcy5sZW49dChkP2U6ZiwwKTt0aGlzLnBvcz1kP2I6Z30sZ2V0RXh0cmVtZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmlzTG9nO3JldHVybnttaW46YT9lYShpYSh0aGlzLm1pbikpOnRoaXMubWluLG1heDphP2VhKGlhKHRoaXMubWF4KSk6dGhpcy5tYXgsZGF0YU1pbjp0aGlzLmRhdGFNaW4sZGF0YU1heDp0aGlzLmRhdGFNYXgsdXNlck1pbjp0aGlzLnVzZXJNaW4sdXNlck1heDp0aGlzLnVzZXJNYXh9fSxcbmdldFRocmVzaG9sZDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmlzTG9nLGM9Yj9pYSh0aGlzLm1pbik6dGhpcy5taW4sYj1iP2lhKHRoaXMubWF4KTp0aGlzLm1heDthPT09bnVsbD9hPWI8MD9iOmM6Yz5hP2E9YzpiPGEmJihhPWIpO3JldHVybiB0aGlzLnRyYW5zbGF0ZShhLDAsMSwwLDEpfSxhdXRvTGFiZWxBbGlnbjpmdW5jdGlvbihhKXthPShwKGEsMCktdGhpcy5zaWRlKjkwKzcyMCklMzYwO3JldHVybiBhPjE1JiZhPDE2NT9cInJpZ2h0XCI6YT4xOTUmJmE8MzQ1P1wibGVmdFwiOlwiY2VudGVyXCJ9LHVuc3F1aXNoOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50aWNrcyxiPXRoaXMub3B0aW9ucy5sYWJlbHMsYz10aGlzLmhvcml6LGQ9dGhpcy50aWNrSW50ZXJ2YWwsZT1kLGY9dGhpcy5sZW4vKCgodGhpcy5jYXRlZ29yaWVzPzE6MCkrdGhpcy5tYXgtdGhpcy5taW4pL2QpLGcsaD1iLnJvdGF0aW9uLGk9dGhpcy5jaGFydC5yZW5kZXJlci5mb250TWV0cmljcyhiLnN0eWxlLmZvbnRTaXplLFxuYVswXSYmYVswXS5sYWJlbCksaixrPU51bWJlci5NQVhfVkFMVUUsbSxsPWZ1bmN0aW9uKGEpe2EvPWZ8fDE7YT1hPjE/c2EoYSk6MTtyZXR1cm4gYSpkfTtjPyhtPXMoaCk/W2hdOmY8cChiLmF1dG9Sb3RhdGlvbkxpbWl0LDgwKSYmIWIuc3RhZ2dlckxpbmVzJiYhYi5zdGVwJiZiLmF1dG9Sb3RhdGlvbikmJm8obSxmdW5jdGlvbihhKXt2YXIgYjtpZihhPT09aHx8YSYmYT49LTkwJiZhPD05MClqPWwoTihpLmgvYWEoZ2EqYSkpKSxiPWorTihhLzM2MCksYjxrJiYoaz1iLGc9YSxlPWopfSk6Yi5zdGVwfHwoZT1sKGkuaCkpO3RoaXMuYXV0b1JvdGF0aW9uPW07dGhpcy5sYWJlbFJvdGF0aW9uPWc7cmV0dXJuIGV9LHJlbmRlclVuc3F1aXNoOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydCxiPWEucmVuZGVyZXIsYz10aGlzLnRpY2tQb3NpdGlvbnMsZD10aGlzLnRpY2tzLGU9dGhpcy5vcHRpb25zLmxhYmVscyxmPXRoaXMuaG9yaXosZz1hLm1hcmdpbixoPXRoaXMuY2F0ZWdvcmllcz9cbmMubGVuZ3RoOmMubGVuZ3RoLTEsaT10aGlzLnNsb3RXaWR0aD1mJiYhZS5zdGVwJiYhZS5yb3RhdGlvbiYmKHRoaXMuc3RhZ2dlckxpbmVzfHwxKSphLnBsb3RXaWR0aC9ofHwhZiYmKGdbM10mJmdbM10tYS5zcGFjaW5nWzNdfHxhLmNoYXJ0V2lkdGgqMC4zMyksaj10KDEsdyhpLTIqKGUucGFkZGluZ3x8NSkpKSxrPXt9LGc9Yi5mb250TWV0cmljcyhlLnN0eWxlLmZvbnRTaXplLGRbMF0mJmRbMF0ubGFiZWwpLGg9ZS5zdHlsZS50ZXh0T3ZlcmZsb3csbSxsPTA7aWYoIUFhKGUucm90YXRpb24pKWsucm90YXRpb249ZS5yb3RhdGlvbnx8MDtpZih0aGlzLmF1dG9Sb3RhdGlvbilvKGMsZnVuY3Rpb24oYSl7aWYoKGE9ZFthXSkmJmEubGFiZWxMZW5ndGg+bClsPWEubGFiZWxMZW5ndGh9KSxsPmomJmw+Zy5oP2sucm90YXRpb249dGhpcy5sYWJlbFJvdGF0aW9uOnRoaXMubGFiZWxSb3RhdGlvbj0wO2Vsc2UgaWYoaSYmKG09e3dpZHRoOmorXCJweFwifSwhaCkpe20udGV4dE92ZXJmbG93PVxuXCJjbGlwXCI7Zm9yKGk9Yy5sZW5ndGg7IWYmJmktLTspaWYoaj1jW2ldLGo9ZFtqXS5sYWJlbClpZihqLnN0eWxlcy50ZXh0T3ZlcmZsb3c9PT1cImVsbGlwc2lzXCImJmouY3NzKHt0ZXh0T3ZlcmZsb3c6XCJjbGlwXCJ9KSxqLmdldEJCb3goKS5oZWlnaHQ+dGhpcy5sZW4vYy5sZW5ndGgtKGcuaC1nLmYpKWouc3BlY0Nzcz17dGV4dE92ZXJmbG93OlwiZWxsaXBzaXNcIn19aWYoay5yb3RhdGlvbiYmKG09e3dpZHRoOihsPmEuY2hhcnRIZWlnaHQqMC41P2EuY2hhcnRIZWlnaHQqMC4zMzphLmNoYXJ0SGVpZ2h0KStcInB4XCJ9LCFoKSltLnRleHRPdmVyZmxvdz1cImVsbGlwc2lzXCI7dGhpcy5sYWJlbEFsaWduPWsuYWxpZ249ZS5hbGlnbnx8dGhpcy5hdXRvTGFiZWxBbGlnbih0aGlzLmxhYmVsUm90YXRpb24pO28oYyxmdW5jdGlvbihhKXt2YXIgYj0oYT1kW2FdKSYmYS5sYWJlbDtpZihiKW0mJmIuY3NzKEEobSxiLnNwZWNDc3MpKSxkZWxldGUgYi5zcGVjQ3NzLGIuYXR0cihrKSxhLnJvdGF0aW9uPVxuay5yb3RhdGlvbn0pO3RoaXMudGlja1JvdENvcnI9Yi5yb3RDb3JyKGcuYix0aGlzLmxhYmVsUm90YXRpb258fDAsdGhpcy5zaWRlPT09Mil9LGhhc0RhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNWaXNpYmxlU2VyaWVzfHxzKHRoaXMubWluKSYmcyh0aGlzLm1heCkmJiEhdGhpcy50aWNrUG9zaXRpb25zfSxnZXRPZmZzZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydCxjPWIucmVuZGVyZXIsZD1hLm9wdGlvbnMsZT1hLnRpY2tQb3NpdGlvbnMsZj1hLnRpY2tzLGc9YS5ob3JpeixoPWEuc2lkZSxpPWIuaW52ZXJ0ZWQ/WzEsMCwzLDJdW2hdOmgsaixrLG09MCxsLG49MCxxPWQudGl0bGUseD1kLmxhYmVscyxUPTAsUT1iLmF4aXNPZmZzZXQsYj1iLmNsaXBPZmZzZXQsdT1bLTEsMSwxLC0xXVtoXSx5O2o9YS5oYXNEYXRhKCk7YS5zaG93QXhpcz1rPWp8fHAoZC5zaG93RW1wdHksITApO2Euc3RhZ2dlckxpbmVzPWEuaG9yaXomJnguc3RhZ2dlckxpbmVzO2lmKCFhLmF4aXNHcm91cClhLmdyaWRHcm91cD1cbmMuZyhcImdyaWRcIikuYXR0cih7ekluZGV4OmQuZ3JpZFpJbmRleHx8MX0pLmFkZCgpLGEuYXhpc0dyb3VwPWMuZyhcImF4aXNcIikuYXR0cih7ekluZGV4OmQuekluZGV4fHwyfSkuYWRkKCksYS5sYWJlbEdyb3VwPWMuZyhcImF4aXMtbGFiZWxzXCIpLmF0dHIoe3pJbmRleDp4LnpJbmRleHx8N30pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIithLmNvbGwudG9Mb3dlckNhc2UoKStcIi1sYWJlbHNcIikuYWRkKCk7aWYoanx8YS5pc0xpbmtlZCl7aWYobyhlLGZ1bmN0aW9uKGIpe2ZbYl0/ZltiXS5hZGRMYWJlbCgpOmZbYl09bmV3IFJhKGEsYil9KSxhLnJlbmRlclVuc3F1aXNoKCksbyhlLGZ1bmN0aW9uKGIpe2lmKGg9PT0wfHxoPT09Mnx8ezE6XCJsZWZ0XCIsMzpcInJpZ2h0XCJ9W2hdPT09YS5sYWJlbEFsaWduKVQ9dChmW2JdLmdldExhYmVsU2l6ZSgpLFQpfSksYS5zdGFnZ2VyTGluZXMpVCo9YS5zdGFnZ2VyTGluZXMsYS5sYWJlbE9mZnNldD1UfWVsc2UgZm9yKHkgaW4gZilmW3ldLmRlc3Ryb3koKSxcbmRlbGV0ZSBmW3ldO2lmKHEmJnEudGV4dCYmcS5lbmFibGVkIT09ITEpe2lmKCFhLmF4aXNUaXRsZSlhLmF4aXNUaXRsZT1jLnRleHQocS50ZXh0LDAsMCxxLnVzZUhUTUwpLmF0dHIoe3pJbmRleDo3LHJvdGF0aW9uOnEucm90YXRpb258fDAsYWxpZ246cS50ZXh0QWxpZ258fHtsb3c6XCJsZWZ0XCIsbWlkZGxlOlwiY2VudGVyXCIsaGlnaDpcInJpZ2h0XCJ9W3EuYWxpZ25dfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiK3RoaXMuY29sbC50b0xvd2VyQ2FzZSgpK1wiLXRpdGxlXCIpLmNzcyhxLnN0eWxlKS5hZGQoYS5heGlzR3JvdXApLGEuYXhpc1RpdGxlLmlzTmV3PSEwO2lmKGspbT1hLmF4aXNUaXRsZS5nZXRCQm94KClbZz9cImhlaWdodFwiOlwid2lkdGhcIl0sbD1xLm9mZnNldCxuPXMobCk/MDpwKHEubWFyZ2luLGc/NToxMCk7YS5heGlzVGl0bGVbaz9cInNob3dcIjpcImhpZGVcIl0oKX1hLm9mZnNldD11KnAoZC5vZmZzZXQsUVtoXSk7YS50aWNrUm90Q29ycj1hLnRpY2tSb3RDb3JyfHx7eDowLHk6MH07XG5jPWg9PT0yP2EudGlja1JvdENvcnIueTowO2c9VCtuKyhUJiZ1KihnP3AoeC55LGEudGlja1JvdENvcnIueSs4KTp4LngpLWMpO2EuYXhpc1RpdGxlTWFyZ2luPXAobCxnKTtRW2hdPXQoUVtoXSxhLmF4aXNUaXRsZU1hcmdpbittK3UqYS5vZmZzZXQsZyk7ZD1kLm9mZnNldD8wOlYoZC5saW5lV2lkdGgvMikqMjtiW2ldPXQoYltpXSxkKX0sZ2V0TGluZVBhdGg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPXRoaXMub3Bwb3NpdGUsZD10aGlzLm9mZnNldCxlPXRoaXMuaG9yaXosZj10aGlzLmxlZnQrKGM/dGhpcy53aWR0aDowKStkLGQ9Yi5jaGFydEhlaWdodC10aGlzLmJvdHRvbS0oYz90aGlzLmhlaWdodDowKStkO2MmJihhKj0tMSk7cmV0dXJuIGIucmVuZGVyZXIuY3Jpc3BMaW5lKFtcIk1cIixlP3RoaXMubGVmdDpmLGU/ZDp0aGlzLnRvcCxcIkxcIixlP2IuY2hhcnRXaWR0aC10aGlzLnJpZ2h0OmYsZT9kOmIuY2hhcnRIZWlnaHQtdGhpcy5ib3R0b21dLGEpfSxnZXRUaXRsZVBvc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9XG50aGlzLmhvcml6LGI9dGhpcy5sZWZ0LGM9dGhpcy50b3AsZD10aGlzLmxlbixlPXRoaXMub3B0aW9ucy50aXRsZSxmPWE/YjpjLGc9dGhpcy5vcHBvc2l0ZSxoPXRoaXMub2Zmc2V0LGk9ZS54fHwwLGo9ZS55fHwwLGs9RihlLnN0eWxlLmZvbnRTaXplfHwxMiksZD17bG93OmYrKGE/MDpkKSxtaWRkbGU6ZitkLzIsaGlnaDpmKyhhP2Q6MCl9W2UuYWxpZ25dLGI9KGE/Yyt0aGlzLmhlaWdodDpiKSsoYT8xOi0xKSooZz8tMToxKSp0aGlzLmF4aXNUaXRsZU1hcmdpbisodGhpcy5zaWRlPT09Mj9rOjApO3JldHVybnt4OmE/ZCtpOmIrKGc/dGhpcy53aWR0aDowKStoK2kseTphP2Irai0oZz90aGlzLmhlaWdodDowKStoOmQran19LHJlbmRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0LGM9Yi5yZW5kZXJlcixkPWEub3B0aW9ucyxlPWEuaXNMb2csZj1hLmlzTGlua2VkLGc9YS50aWNrUG9zaXRpb25zLGg9YS5heGlzVGl0bGUsaT1hLnRpY2tzLGo9YS5taW5vclRpY2tzLGs9XG5hLmFsdGVybmF0ZUJhbmRzLG09ZC5zdGFja0xhYmVscyxsPWQuYWx0ZXJuYXRlR3JpZENvbG9yLG49YS50aWNrbWFya09mZnNldCxxPWQubGluZVdpZHRoLHgscD1iLmhhc1JlbmRlcmVkJiZzKGEub2xkTWluKSYmIWlzTmFOKGEub2xkTWluKSxRPWEuc2hvd0F4aXMsdT1jLmdsb2JhbEFuaW1hdGlvbix5LHQ7YS5sYWJlbEVkZ2UubGVuZ3RoPTA7YS5vdmVybGFwPSExO28oW2ksaixrXSxmdW5jdGlvbihhKXtmb3IodmFyIGIgaW4gYSlhW2JdLmlzQWN0aXZlPSExfSk7aWYoYS5oYXNEYXRhKCl8fGYpe2EubWlub3JUaWNrSW50ZXJ2YWwmJiFhLmNhdGVnb3JpZXMmJm8oYS5nZXRNaW5vclRpY2tQb3NpdGlvbnMoKSxmdW5jdGlvbihiKXtqW2JdfHwoaltiXT1uZXcgUmEoYSxiLFwibWlub3JcIikpO3AmJmpbYl0uaXNOZXcmJmpbYl0ucmVuZGVyKG51bGwsITApO2pbYl0ucmVuZGVyKG51bGwsITEsMSl9KTtpZihnLmxlbmd0aCYmKG8oZyxmdW5jdGlvbihiLGMpe2lmKCFmfHxiPj1hLm1pbiYmXG5iPD1hLm1heClpW2JdfHwoaVtiXT1uZXcgUmEoYSxiKSkscCYmaVtiXS5pc05ldyYmaVtiXS5yZW5kZXIoYywhMCwwLjEpLGlbYl0ucmVuZGVyKGMpfSksbiYmKGEubWluPT09MHx8YS5zaW5nbGUpKSlpWy0xXXx8KGlbLTFdPW5ldyBSYShhLC0xLG51bGwsITApKSxpWy0xXS5yZW5kZXIoLTEpO2wmJm8oZyxmdW5jdGlvbihiLGMpe2lmKGMlMj09PTAmJmI8YS5tYXgpa1tiXXx8KGtbYl09bmV3IEIuUGxvdExpbmVPckJhbmQoYSkpLHk9YituLHQ9Z1tjKzFdIT09dj9nW2MrMV0rbjphLm1heCxrW2JdLm9wdGlvbnM9e2Zyb206ZT9pYSh5KTp5LHRvOmU/aWEodCk6dCxjb2xvcjpsfSxrW2JdLnJlbmRlcigpLGtbYl0uaXNBY3RpdmU9ITB9KTtpZighYS5fYWRkZWRQbG90TEIpbygoZC5wbG90TGluZXN8fFtdKS5jb25jYXQoZC5wbG90QmFuZHN8fFtdKSxmdW5jdGlvbihiKXthLmFkZFBsb3RCYW5kT3JMaW5lKGIpfSksYS5fYWRkZWRQbG90TEI9ITB9byhbaSxqLGtdLGZ1bmN0aW9uKGEpe3ZhciBjLFxuZCxlPVtdLGY9dT91LmR1cmF0aW9ufHw1MDA6MCxnPWZ1bmN0aW9uKCl7Zm9yKGQ9ZS5sZW5ndGg7ZC0tOylhW2VbZF1dJiYhYVtlW2RdXS5pc0FjdGl2ZSYmKGFbZVtkXV0uZGVzdHJveSgpLGRlbGV0ZSBhW2VbZF1dKX07Zm9yKGMgaW4gYSlpZighYVtjXS5pc0FjdGl2ZSlhW2NdLnJlbmRlcihjLCExLDApLGFbY10uaXNBY3RpdmU9ITEsZS5wdXNoKGMpO2E9PT1rfHwhYi5oYXNSZW5kZXJlZHx8IWY/ZygpOmYmJnNldFRpbWVvdXQoZyxmKX0pO2lmKHEpeD1hLmdldExpbmVQYXRoKHEpLGEuYXhpc0xpbmU/YS5heGlzTGluZS5hbmltYXRlKHtkOnh9KTphLmF4aXNMaW5lPWMucGF0aCh4KS5hdHRyKHtzdHJva2U6ZC5saW5lQ29sb3IsXCJzdHJva2Utd2lkdGhcIjpxLHpJbmRleDo3fSkuYWRkKGEuYXhpc0dyb3VwKSxhLmF4aXNMaW5lW1E/XCJzaG93XCI6XCJoaWRlXCJdKCk7aWYoaCYmUSloW2guaXNOZXc/XCJhdHRyXCI6XCJhbmltYXRlXCJdKGEuZ2V0VGl0bGVQb3NpdGlvbigpKSxoLmlzTmV3PVxuITE7bSYmbS5lbmFibGVkJiZhLnJlbmRlclN0YWNrVG90YWxzKCk7YS5pc0RpcnR5PSExfSxyZWRyYXc6ZnVuY3Rpb24oKXt0aGlzLnJlbmRlcigpO28odGhpcy5wbG90TGluZXNBbmRCYW5kcyxmdW5jdGlvbihhKXthLnJlbmRlcigpfSk7byh0aGlzLnNlcmllcyxmdW5jdGlvbihhKXthLmlzRGlydHk9ITB9KX0sZGVzdHJveTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9Yi5zdGFja3MsZCxlPWIucGxvdExpbmVzQW5kQmFuZHM7YXx8WihiKTtmb3IoZCBpbiBjKU9hKGNbZF0pLGNbZF09bnVsbDtvKFtiLnRpY2tzLGIubWlub3JUaWNrcyxiLmFsdGVybmF0ZUJhbmRzXSxmdW5jdGlvbihhKXtPYShhKX0pO2ZvcihhPWUubGVuZ3RoO2EtLTspZVthXS5kZXN0cm95KCk7byhcInN0YWNrVG90YWxHcm91cCxheGlzTGluZSxheGlzVGl0bGUsYXhpc0dyb3VwLGNyb3NzLGdyaWRHcm91cCxsYWJlbEdyb3VwXCIuc3BsaXQoXCIsXCIpLGZ1bmN0aW9uKGEpe2JbYV0mJihiW2FdPWJbYV0uZGVzdHJveSgpKX0pO1xudGhpcy5jcm9zcyYmdGhpcy5jcm9zcy5kZXN0cm95KCl9LGRyYXdDcm9zc2hhaXI6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPXRoaXMuY3Jvc3NoYWlyLGU9ZC5hbmltYXRpb247aWYoIXRoaXMuY3Jvc3NoYWlyfHwocyhiKXx8IXAodGhpcy5jcm9zc2hhaXIuc25hcCwhMCkpPT09ITF8fGImJmIuc2VyaWVzJiZiLnNlcmllc1t0aGlzLmNvbGxdIT09dGhpcyl0aGlzLmhpZGVDcm9zc2hhaXIoKTtlbHNlIGlmKHAoZC5zbmFwLCEwKT9zKGIpJiYoYz10aGlzLmlzWEF4aXM/Yi5wbG90WDp0aGlzLmxlbi1iLnBsb3RZKTpjPXRoaXMuaG9yaXo/YS5jaGFydFgtdGhpcy5wb3M6dGhpcy5sZW4tYS5jaGFydFkrdGhpcy5wb3MsYz10aGlzLmlzUmFkaWFsP3RoaXMuZ2V0UGxvdExpbmVQYXRoKHRoaXMuaXNYQXhpcz9iLng6cChiLnN0YWNrWSxiLnkpKXx8bnVsbDp0aGlzLmdldFBsb3RMaW5lUGF0aChudWxsLG51bGwsbnVsbCxudWxsLGMpfHxudWxsLGM9PT1udWxsKXRoaXMuaGlkZUNyb3NzaGFpcigpO1xuZWxzZSBpZih0aGlzLmNyb3NzKXRoaXMuY3Jvc3MuYXR0cih7dmlzaWJpbGl0eTpcInZpc2libGVcIn0pW2U/XCJhbmltYXRlXCI6XCJhdHRyXCJdKHtkOmN9LGUpO2Vsc2V7ZT10aGlzLmNhdGVnb3JpZXMmJiF0aGlzLmlzUmFkaWFsO2U9e1wic3Ryb2tlLXdpZHRoXCI6ZC53aWR0aHx8KGU/dGhpcy50cmFuc0E6MSksc3Ryb2tlOmQuY29sb3J8fChlP1wicmdiYSgxNTUsMjAwLDI1NSwwLjIpXCI6XCIjQzBDMEMwXCIpLHpJbmRleDpkLnpJbmRleHx8Mn07aWYoZC5kYXNoU3R5bGUpZS5kYXNoc3R5bGU9ZC5kYXNoU3R5bGU7dGhpcy5jcm9zcz10aGlzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoYykuYXR0cihlKS5hZGQoKX19LGhpZGVDcm9zc2hhaXI6ZnVuY3Rpb24oKXt0aGlzLmNyb3NzJiZ0aGlzLmNyb3NzLmhpZGUoKX19O3IoaGEucHJvdG90eXBlLHtnZXRQbG90QmFuZFBhdGg6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldFBsb3RMaW5lUGF0aChiLG51bGwsbnVsbCwhMCksZD10aGlzLmdldFBsb3RMaW5lUGF0aChhLFxubnVsbCxudWxsLCEwKTtkJiZjJiZkLnRvU3RyaW5nKCkhPT1jLnRvU3RyaW5nKCk/ZC5wdXNoKGNbNF0sY1s1XSxjWzFdLGNbMl0pOmQ9bnVsbDtyZXR1cm4gZH0sYWRkUGxvdEJhbmQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYWRkUGxvdEJhbmRPckxpbmUoYSxcInBsb3RCYW5kc1wiKX0sYWRkUGxvdExpbmU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYWRkUGxvdEJhbmRPckxpbmUoYSxcInBsb3RMaW5lc1wiKX0sYWRkUGxvdEJhbmRPckxpbmU6ZnVuY3Rpb24oYSxiKXt2YXIgYz0obmV3IEIuUGxvdExpbmVPckJhbmQodGhpcyxhKSkucmVuZGVyKCksZD10aGlzLnVzZXJPcHRpb25zO2MmJihiJiYoZFtiXT1kW2JdfHxbXSxkW2JdLnB1c2goYSkpLHRoaXMucGxvdExpbmVzQW5kQmFuZHMucHVzaChjKSk7cmV0dXJuIGN9LHJlbW92ZVBsb3RCYW5kT3JMaW5lOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLnBsb3RMaW5lc0FuZEJhbmRzLGM9dGhpcy5vcHRpb25zLGQ9dGhpcy51c2VyT3B0aW9ucyxcbmU9Yi5sZW5ndGg7ZS0tOyliW2VdLmlkPT09YSYmYltlXS5kZXN0cm95KCk7byhbYy5wbG90TGluZXN8fFtdLGQucGxvdExpbmVzfHxbXSxjLnBsb3RCYW5kc3x8W10sZC5wbG90QmFuZHN8fFtdXSxmdW5jdGlvbihiKXtmb3IoZT1iLmxlbmd0aDtlLS07KWJbZV0uaWQ9PT1hJiZqYShiLGJbZV0pfSl9fSk7aGEucHJvdG90eXBlLmdldFRpbWVUaWNrcz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1bXSxmPXt9LGc9Uy5nbG9iYWwudXNlVVRDLGgsaT1uZXcgeWEoYi1WYShiKSksaj1hLnVuaXRSYW5nZSxrPWEuY291bnQ7aWYocyhiKSl7aVtEYl0oaj49RS5zZWNvbmQ/MDprKlYoaS5nZXRNaWxsaXNlY29uZHMoKS9rKSk7aWYoaj49RS5zZWNvbmQpaVtFYl0oaj49RS5taW51dGU/MDprKlYoaS5nZXRTZWNvbmRzKCkvaykpO2lmKGo+PUUubWludXRlKWlbRmJdKGo+PUUuaG91cj8wOmsqVihpW3FiXSgpL2spKTtpZihqPj1FLmhvdXIpaVtHYl0oaj49RS5kYXk/MDprKlYoaVtyYl0oKS9rKSk7XG5pZihqPj1FLmRheSlpW3RiXShqPj1FLm1vbnRoPzE6aypWKGlbV2FdKCkvaykpO2o+PUUubW9udGgmJihpW3ViXShqPj1FLnllYXI/MDprKlYoaVtYYV0oKS9rKSksaD1pW1lhXSgpKTtqPj1FLnllYXImJihoLT1oJWssaVt2Yl0oaCkpO2lmKGo9PT1FLndlZWspaVt0Yl0oaVtXYV0oKS1pW3NiXSgpK3AoZCwxKSk7Yj0xO2lmKG1ifHxiYilpPWkuZ2V0VGltZSgpLGk9bmV3IHlhKGkrVmEoaSkpO2g9aVtZYV0oKTtmb3IodmFyIGQ9aS5nZXRUaW1lKCksbT1pW1hhXSgpLGw9aVtXYV0oKSxuPShFLmRheSsoZz9WYShpKTppLmdldFRpbWV6b25lT2Zmc2V0KCkqNkU0KSklRS5kYXk7ZDxjOyllLnB1c2goZCksaj09PUUueWVhcj9kPWRiKGgrYiprLDApOmo9PT1FLm1vbnRoP2Q9ZGIoaCxtK2Iqayk6IWcmJihqPT09RS5kYXl8fGo9PT1FLndlZWspP2Q9ZGIoaCxtLGwrYiprKihqPT09RS5kYXk/MTo3KSk6ZCs9aiprLGIrKztlLnB1c2goZCk7byhpYihlLGZ1bmN0aW9uKGEpe3JldHVybiBqPD1cbkUuaG91ciYmYSVFLmRheT09PW59KSxmdW5jdGlvbihhKXtmW2FdPVwiZGF5XCJ9KX1lLmluZm89cihhLHtoaWdoZXJSYW5rczpmLHRvdGFsUmFuZ2U6aiprfSk7cmV0dXJuIGV9O2hhLnByb3RvdHlwZS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsPWZ1bmN0aW9uKGEsYil7dmFyIGM9Ynx8W1tcIm1pbGxpc2Vjb25kXCIsWzEsMiw1LDEwLDIwLDI1LDUwLDEwMCwyMDAsNTAwXV0sW1wic2Vjb25kXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wibWludXRlXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wiaG91clwiLFsxLDIsMyw0LDYsOCwxMl1dLFtcImRheVwiLFsxLDJdXSxbXCJ3ZWVrXCIsWzEsMl1dLFtcIm1vbnRoXCIsWzEsMiwzLDQsNl1dLFtcInllYXJcIixudWxsXV0sZD1jW2MubGVuZ3RoLTFdLGU9RVtkWzBdXSxmPWRbMV0sZztmb3IoZz0wO2c8Yy5sZW5ndGg7ZysrKWlmKGQ9Y1tnXSxlPUVbZFswXV0sZj1kWzFdLGNbZysxXSYmYTw9KGUqZltmLmxlbmd0aC0xXStFW2NbZysxXVswXV0pLzIpYnJlYWs7ZT09PUUueWVhciYmXG5hPDUqZSYmKGY9WzEsMiw1XSk7Yz1vYihhL2UsZixkWzBdPT09XCJ5ZWFyXCI/dChuYihhL2UpLDEpOjEpO3JldHVybnt1bml0UmFuZ2U6ZSxjb3VudDpjLHVuaXROYW1lOmRbMF19fTtoYS5wcm90b3R5cGUuZ2V0TG9nVGlja1Bvc2l0aW9ucz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLm9wdGlvbnMsZj10aGlzLmxlbixnPVtdO2lmKCFkKXRoaXMuX21pbm9yQXV0b0ludGVydmFsPW51bGw7aWYoYT49MC41KWE9dyhhKSxnPXRoaXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhhLGIsYyk7ZWxzZSBpZihhPj0wLjA4KWZvcih2YXIgZj1WKGIpLGgsaSxqLGssbSxlPWE+MC4zP1sxLDIsNF06YT4wLjE1P1sxLDIsNCw2LDhdOlsxLDIsMyw0LDUsNiw3LDgsOV07ZjxjKzEmJiFtO2YrKyl7aT1lLmxlbmd0aDtmb3IoaD0wO2g8aSYmIW07aCsrKWo9QmEoaWEoZikqZVtoXSksaj5iJiYoIWR8fGs8PWMpJiZrIT09diYmZy5wdXNoKGspLGs+YyYmKG09ITApLGs9an1lbHNlIGlmKGI9aWEoYiksXG5jPWlhKGMpLGE9ZVtkP1wibWlub3JUaWNrSW50ZXJ2YWxcIjpcInRpY2tJbnRlcnZhbFwiXSxhPXAoYT09PVwiYXV0b1wiP251bGw6YSx0aGlzLl9taW5vckF1dG9JbnRlcnZhbCwoYy1iKSooZS50aWNrUGl4ZWxJbnRlcnZhbC8oZD81OjEpKS8oKGQ/Zi90aGlzLnRpY2tQb3NpdGlvbnMubGVuZ3RoOmYpfHwxKSksYT1vYihhLG51bGwsbmIoYSkpLGc9VGEodGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKGEsYixjKSxCYSksIWQpdGhpcy5fbWlub3JBdXRvSW50ZXJ2YWw9YS81O2lmKCFkKXRoaXMudGlja0ludGVydmFsPWE7cmV0dXJuIGd9O3ZhciBNYj1CLlRvb2x0aXA9ZnVuY3Rpb24oKXt0aGlzLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtNYi5wcm90b3R5cGU9e2luaXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1iLmJvcmRlcldpZHRoLGQ9Yi5zdHlsZSxlPUYoZC5wYWRkaW5nKTt0aGlzLmNoYXJ0PWE7dGhpcy5vcHRpb25zPWI7dGhpcy5jcm9zc2hhaXJzPVtdO3RoaXMubm93PXt4OjAsXG55OjB9O3RoaXMuaXNIaWRkZW49ITA7dGhpcy5sYWJlbD1hLnJlbmRlcmVyLmxhYmVsKFwiXCIsMCwwLGIuc2hhcGV8fFwiY2FsbG91dFwiLG51bGwsbnVsbCxiLnVzZUhUTUwsbnVsbCxcInRvb2x0aXBcIikuYXR0cih7cGFkZGluZzplLGZpbGw6Yi5iYWNrZ3JvdW5kQ29sb3IsXCJzdHJva2Utd2lkdGhcIjpjLHI6Yi5ib3JkZXJSYWRpdXMsekluZGV4Ojh9KS5jc3MoZCkuY3NzKHtwYWRkaW5nOjB9KS5hZGQoKS5hdHRyKHt5Oi05OTk5fSk7ZmF8fHRoaXMubGFiZWwuc2hhZG93KGIuc2hhZG93KTt0aGlzLnNoYXJlZD1iLnNoYXJlZH0sZGVzdHJveTpmdW5jdGlvbigpe2lmKHRoaXMubGFiZWwpdGhpcy5sYWJlbD10aGlzLmxhYmVsLmRlc3Ryb3koKTtjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO2NsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KX0sbW92ZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLGY9ZS5ub3csZz1lLm9wdGlvbnMuYW5pbWF0aW9uIT09ITEmJiFlLmlzSGlkZGVuJiZcbihOKGEtZi54KT4xfHxOKGItZi55KT4xKSxoPWUuZm9sbG93UG9pbnRlcnx8ZS5sZW4+MTtyKGYse3g6Zz8oMipmLngrYSkvMzphLHk6Zz8oZi55K2IpLzI6YixhbmNob3JYOmg/djpnPygyKmYuYW5jaG9yWCtjKS8zOmMsYW5jaG9yWTpoP3Y6Zz8oZi5hbmNob3JZK2QpLzI6ZH0pO2UubGFiZWwuYXR0cihmKTtpZihnKWNsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KSx0aGlzLnRvb2x0aXBUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlJiZlLm1vdmUoYSxiLGMsZCl9LDMyKX0saGlkZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzO2NsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7aWYoIXRoaXMuaXNIaWRkZW4pdGhpcy5oaWRlVGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe2IubGFiZWwuZmFkZU91dCgpO2IuaXNIaWRkZW49ITB9LHAoYSx0aGlzLm9wdGlvbnMuaGlkZURlbGF5LDUwMCkpfSxnZXRBbmNob3I6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPXRoaXMuY2hhcnQsXG5lPWQuaW52ZXJ0ZWQsZj1kLnBsb3RUb3AsZz1kLnBsb3RMZWZ0LGg9MCxpPTAsaixrLGE9cmEoYSk7Yz1hWzBdLnRvb2x0aXBQb3M7dGhpcy5mb2xsb3dQb2ludGVyJiZiJiYoYi5jaGFydFg9PT12JiYoYj1kLnBvaW50ZXIubm9ybWFsaXplKGIpKSxjPVtiLmNoYXJ0WC1kLnBsb3RMZWZ0LGIuY2hhcnRZLWZdKTtjfHwobyhhLGZ1bmN0aW9uKGEpe2o9YS5zZXJpZXMueUF4aXM7az1hLnNlcmllcy54QXhpcztoKz1hLnBsb3RYKyghZSYmaz9rLmxlZnQtZzowKTtpKz0oYS5wbG90TG93PyhhLnBsb3RMb3crYS5wbG90SGlnaCkvMjphLnBsb3RZKSsoIWUmJmo/ai50b3AtZjowKX0pLGgvPWEubGVuZ3RoLGkvPWEubGVuZ3RoLGM9W2U/ZC5wbG90V2lkdGgtaTpoLHRoaXMuc2hhcmVkJiYhZSYmYS5sZW5ndGg+MSYmYj9iLmNoYXJ0WS1mOmU/ZC5wbG90SGVpZ2h0LWg6aV0pO3JldHVybiBUYShjLHcpfSxnZXRQb3NpdGlvbjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5jaGFydCxlPXRoaXMuZGlzdGFuY2UsXG5mPXt9LGc9Yy5ofHwwLGgsaT1bXCJ5XCIsZC5jaGFydEhlaWdodCxiLGMucGxvdFkrZC5wbG90VG9wLGQucGxvdFRvcCxkLnBsb3RUb3ArZC5wbG90SGVpZ2h0XSxqPVtcInhcIixkLmNoYXJ0V2lkdGgsYSxjLnBsb3RYK2QucGxvdExlZnQsZC5wbG90TGVmdCxkLnBsb3RMZWZ0K2QucGxvdFdpZHRoXSxrPXAoYy50dEJlbG93LGQuaW52ZXJ0ZWQmJiFjLm5lZ2F0aXZlfHwhZC5pbnZlcnRlZCYmYy5uZWdhdGl2ZSksbT1mdW5jdGlvbihhLGIsYyxkLGgsaSl7dmFyIGo9YzxkLWUsbD1kK2UrYzxiLG09ZC1lLWM7ZCs9ZTtpZihrJiZsKWZbYV09ZDtlbHNlIGlmKCFrJiZqKWZbYV09bTtlbHNlIGlmKGopZlthXT16KGktYyxtLWc8MD9tOm0tZyk7ZWxzZSBpZihsKWZbYV09dChoLGQrZytjPmI/ZDpkK2cpO2Vsc2UgcmV0dXJuITF9LGw9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoZDxlfHxkPmItZSlyZXR1cm4hMTtlbHNlIGZbYV09ZDxjLzI/MTpkPmItYy8yP2ItYy0yOmQtYy8yfSxuPWZ1bmN0aW9uKGEpe3ZhciBiPVxuaTtpPWo7aj1iO2g9YX0scT1mdW5jdGlvbigpe20uYXBwbHkoMCxpKSE9PSExP2wuYXBwbHkoMCxqKT09PSExJiYhaCYmKG4oITApLHEoKSk6aD9mLng9Zi55PTA6KG4oITApLHEoKSl9OyhkLmludmVydGVkfHx0aGlzLmxlbj4xKSYmbigpO3EoKTtyZXR1cm4gZn0sZGVmYXVsdEZvcm1hdHRlcjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnBvaW50c3x8cmEodGhpcyksYztjPVthLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIoYlswXSldO2M9Yy5jb25jYXQoYS5ib2R5Rm9ybWF0dGVyKGIpKTtjLnB1c2goYS50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGJbMF0sITApKTtyZXR1cm4gYy5qb2luKFwiXCIpfSxyZWZyZXNoOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jaGFydCxkPXRoaXMubGFiZWwsZT10aGlzLm9wdGlvbnMsZixnLGgsaT17fSxqLGs9W107aj1lLmZvcm1hdHRlcnx8dGhpcy5kZWZhdWx0Rm9ybWF0dGVyO3ZhciBpPWMuaG92ZXJQb2ludHMsbSxsPXRoaXMuc2hhcmVkO1xuY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTt0aGlzLmZvbGxvd1BvaW50ZXI9cmEoYSlbMF0uc2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7aD10aGlzLmdldEFuY2hvcihhLGIpO2Y9aFswXTtnPWhbMV07bCYmKCFhLnNlcmllc3x8IWEuc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCk/KGMuaG92ZXJQb2ludHM9YSxpJiZvKGksZnVuY3Rpb24oYSl7YS5zZXRTdGF0ZSgpfSksbyhhLGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoXCJob3ZlclwiKTtrLnB1c2goYS5nZXRMYWJlbENvbmZpZygpKX0pLGk9e3g6YVswXS5jYXRlZ29yeSx5OmFbMF0ueX0saS5wb2ludHM9ayx0aGlzLmxlbj1rLmxlbmd0aCxhPWFbMF0pOmk9YS5nZXRMYWJlbENvbmZpZygpO2o9ai5jYWxsKGksdGhpcyk7aT1hLnNlcmllczt0aGlzLmRpc3RhbmNlPXAoaS50b29sdGlwT3B0aW9ucy5kaXN0YW5jZSwxNik7aj09PSExP3RoaXMuaGlkZSgpOih0aGlzLmlzSGlkZGVuJiYoa2IoZCksZC5hdHRyKFwib3BhY2l0eVwiLFxuMSkuc2hvdygpKSxkLmF0dHIoe3RleHQ6an0pLG09ZS5ib3JkZXJDb2xvcnx8YS5jb2xvcnx8aS5jb2xvcnx8XCIjNjA2MDYwXCIsZC5hdHRyKHtzdHJva2U6bX0pLHRoaXMudXBkYXRlUG9zaXRpb24oe3Bsb3RYOmYscGxvdFk6ZyxuZWdhdGl2ZTphLm5lZ2F0aXZlLHR0QmVsb3c6YS50dEJlbG93LGg6aFsyXXx8MH0pLHRoaXMuaXNIaWRkZW49ITEpO0koYyxcInRvb2x0aXBSZWZyZXNoXCIse3RleHQ6aix4OmYrYy5wbG90TGVmdCx5OmcrYy5wbG90VG9wLGJvcmRlckNvbG9yOm19KX0sdXBkYXRlUG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPXRoaXMubGFiZWwsYz0odGhpcy5vcHRpb25zLnBvc2l0aW9uZXJ8fHRoaXMuZ2V0UG9zaXRpb24pLmNhbGwodGhpcyxjLndpZHRoLGMuaGVpZ2h0LGEpO3RoaXMubW92ZSh3KGMueCksdyhjLnl8fDApLGEucGxvdFgrYi5wbG90TGVmdCxhLnBsb3RZK2IucGxvdFRvcCl9LGdldFhEYXRlRm9ybWF0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxcbmI9Yi5kYXRlVGltZUxhYmVsRm9ybWF0cyxlPWMmJmMuY2xvc2VzdFBvaW50UmFuZ2UsZixnPXttaWxsaXNlY29uZDoxNSxzZWNvbmQ6MTIsbWludXRlOjksaG91cjo2LGRheTozfSxoLGk9XCJtaWxsaXNlY29uZFwiO2lmKGUpe2g9TWEoXCIlbS0lZCAlSDolTTolUy4lTFwiLGEueCk7Zm9yKGYgaW4gRSl7aWYoZT09PUUud2VlayYmK01hKFwiJXdcIixhLngpPT09Yy5vcHRpb25zLnN0YXJ0T2ZXZWVrJiZoLnN1YnN0cig2KT09PVwiMDA6MDA6MDAuMDAwXCIpe2Y9XCJ3ZWVrXCI7YnJlYWt9ZWxzZSBpZihFW2ZdPmUpe2Y9aTticmVha31lbHNlIGlmKGdbZl0mJmguc3Vic3RyKGdbZl0pIT09XCIwMS0wMSAwMDowMDowMC4wMDBcIi5zdWJzdHIoZ1tmXSkpYnJlYWs7ZiE9PVwid2Vla1wiJiYoaT1mKX1mJiYoZD1iW2ZdKX1lbHNlIGQ9Yi5kYXk7cmV0dXJuIGR8fGIueWVhcn0sdG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcjpmdW5jdGlvbihhLGIpe3ZhciBjPWI/XCJmb290ZXJcIjpcImhlYWRlclwiLGQ9YS5zZXJpZXMsXG5lPWQudG9vbHRpcE9wdGlvbnMsZj1lLnhEYXRlRm9ybWF0LGc9ZC54QXhpcyxoPWcmJmcub3B0aW9ucy50eXBlPT09XCJkYXRldGltZVwiJiZxYShhLmtleSksYz1lW2MrXCJGb3JtYXRcIl07aCYmIWYmJihmPXRoaXMuZ2V0WERhdGVGb3JtYXQoYSxlLGcpKTtoJiZmJiYoYz1jLnJlcGxhY2UoXCJ7cG9pbnQua2V5fVwiLFwie3BvaW50LmtleTpcIitmK1wifVwiKSk7cmV0dXJuIEhhKGMse3BvaW50OmEsc2VyaWVzOmR9KX0sYm9keUZvcm1hdHRlcjpmdW5jdGlvbihhKXtyZXR1cm4gVGEoYSxmdW5jdGlvbihhKXt2YXIgYz1hLnNlcmllcy50b29sdGlwT3B0aW9ucztyZXR1cm4oYy5wb2ludEZvcm1hdHRlcnx8YS5wb2ludC50b29sdGlwRm9ybWF0dGVyKS5jYWxsKGEucG9pbnQsYy5wb2ludEZvcm1hdCl9KX19O3ZhciBvYTskYT1DLmRvY3VtZW50RWxlbWVudC5vbnRvdWNoc3RhcnQhPT12O3ZhciBVYT1CLlBvaW50ZXI9ZnVuY3Rpb24oYSxiKXt0aGlzLmluaXQoYSxiKX07VWEucHJvdG90eXBlPXtpbml0OmZ1bmN0aW9uKGEsXG5iKXt2YXIgYz1iLmNoYXJ0LGQ9Yy5ldmVudHMsZT1mYT9cIlwiOmMuem9vbVR5cGUsYz1hLmludmVydGVkLGY7dGhpcy5vcHRpb25zPWI7dGhpcy5jaGFydD1hO3RoaXMuem9vbVg9Zj0veC8udGVzdChlKTt0aGlzLnpvb21ZPWU9L3kvLnRlc3QoZSk7dGhpcy56b29tSG9yPWYmJiFjfHxlJiZjO3RoaXMuem9vbVZlcnQ9ZSYmIWN8fGYmJmM7dGhpcy5oYXNab29tPWZ8fGU7dGhpcy5ydW5DaGFydENsaWNrPWQmJiEhZC5jbGljazt0aGlzLnBpbmNoRG93bj1bXTt0aGlzLmxhc3RWYWxpZFRvdWNoPXt9O2lmKEIuVG9vbHRpcCYmYi50b29sdGlwLmVuYWJsZWQpYS50b29sdGlwPW5ldyBNYihhLGIudG9vbHRpcCksdGhpcy5mb2xsb3dUb3VjaE1vdmU9cChiLnRvb2x0aXAuZm9sbG93VG91Y2hNb3ZlLCEwKTt0aGlzLnNldERPTUV2ZW50cygpfSxub3JtYWxpemU6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGE9YXx8d2luZG93LmV2ZW50LGE9U2IoYSk7aWYoIWEudGFyZ2V0KWEudGFyZ2V0PWEuc3JjRWxlbWVudDtcbmQ9YS50b3VjaGVzP2EudG91Y2hlcy5sZW5ndGg/YS50b3VjaGVzLml0ZW0oMCk6YS5jaGFuZ2VkVG91Y2hlc1swXTphO2lmKCFiKXRoaXMuY2hhcnRQb3NpdGlvbj1iPVJiKHRoaXMuY2hhcnQuY29udGFpbmVyKTtkLnBhZ2VYPT09dj8oYz10KGEueCxhLmNsaWVudFgtYi5sZWZ0KSxkPWEueSk6KGM9ZC5wYWdlWC1iLmxlZnQsZD1kLnBhZ2VZLWIudG9wKTtyZXR1cm4gcihhLHtjaGFydFg6dyhjKSxjaGFydFk6dyhkKX0pfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbihhKXt2YXIgYj17eEF4aXM6W10seUF4aXM6W119O28odGhpcy5jaGFydC5heGVzLGZ1bmN0aW9uKGMpe2JbYy5pc1hBeGlzP1wieEF4aXNcIjpcInlBeGlzXCJdLnB1c2goe2F4aXM6Yyx2YWx1ZTpjLnRvVmFsdWUoYVtjLmhvcml6P1wiY2hhcnRYXCI6XCJjaGFydFlcIl0pfSl9KTtyZXR1cm4gYn0scnVuUG9pbnRBY3Rpb25zOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz1iLnNlcmllcyxkPWIudG9vbHRpcCxlPWQ/ZC5zaGFyZWQ6XG4hMSxmPWIuaG92ZXJQb2ludCxnPWIuaG92ZXJTZXJpZXMsaCxpPWIuY2hhcnRXaWR0aCxqLGssbT1bXSxsLG47aWYoIWUmJiFnKWZvcihoPTA7aDxjLmxlbmd0aDtoKyspaWYoY1toXS5kaXJlY3RUb3VjaHx8IWNbaF0ub3B0aW9ucy5zdGlja3lUcmFja2luZyljPVtdOyFlJiZnJiZnLmRpcmVjdFRvdWNoJiZmP2w9ZjoobyhjLGZ1bmN0aW9uKGIpe2o9Yi5ub1NoYXJlZFRvb2x0aXAmJmU7az0hZSYmYi5kaXJlY3RUb3VjaDtiLnZpc2libGUmJiFqJiYhayYmcChiLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZywhMCkmJihuPWIuc2VhcmNoUG9pbnQoYSwhaiYmYi5rZERpbWVuc2lvbnM9PT0xKSkmJm0ucHVzaChuKX0pLG8obSxmdW5jdGlvbihhKXtpZihhJiZ0eXBlb2YgYS5kaXN0PT09XCJudW1iZXJcIiYmYS5kaXN0PGkpaT1hLmRpc3QsbD1hfSkpO2lmKGwmJihsIT09dGhpcy5wcmV2S0RQb2ludHx8ZCYmZC5pc0hpZGRlbikpe2lmKGUmJiFsLnNlcmllcy5ub1NoYXJlZFRvb2x0aXApe2ZvcihoPVxubS5sZW5ndGg7aC0tOykobVtoXS5jbGllbnRYIT09bC5jbGllbnRYfHxtW2hdLnNlcmllcy5ub1NoYXJlZFRvb2x0aXApJiZtLnNwbGljZShoLDEpO20ubGVuZ3RoJiZkJiZkLnJlZnJlc2gobSxhKTtvKG0sZnVuY3Rpb24oYil7Yi5vbk1vdXNlT3ZlcihhLGIhPT0oZyYmZy5kaXJlY3RUb3VjaCYmZnx8bCkpfSl9ZWxzZSBpZihkJiZkLnJlZnJlc2gobCxhKSwhZ3x8IWcuZGlyZWN0VG91Y2gpbC5vbk1vdXNlT3ZlcihhKTt0aGlzLnByZXZLRFBvaW50PWx9ZWxzZSBjPWcmJmcudG9vbHRpcE9wdGlvbnMuZm9sbG93UG9pbnRlcixkJiZjJiYhZC5pc0hpZGRlbiYmKGM9ZC5nZXRBbmNob3IoW3t9XSxhKSxkLnVwZGF0ZVBvc2l0aW9uKHtwbG90WDpjWzBdLHBsb3RZOmNbMV19KSk7aWYoZCYmIXRoaXMuX29uRG9jdW1lbnRNb3VzZU1vdmUpdGhpcy5fb25Eb2N1bWVudE1vdXNlTW92ZT1mdW5jdGlvbihhKXtpZihZW29hXSlZW29hXS5wb2ludGVyLm9uRG9jdW1lbnRNb3VzZU1vdmUoYSl9LFxuSChDLFwibW91c2Vtb3ZlXCIsdGhpcy5fb25Eb2N1bWVudE1vdXNlTW92ZSk7byhiLmF4ZXMsZnVuY3Rpb24oYil7Yi5kcmF3Q3Jvc3NoYWlyKGEscChsLGYpKX0pfSxyZXNldDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY2hhcnQsZD1jLmhvdmVyU2VyaWVzLGU9Yy5ob3ZlclBvaW50LGY9Yy5ob3ZlclBvaW50cyxnPWMudG9vbHRpcCxoPWcmJmcuc2hhcmVkP2Y6ZTsoYT1hJiZnJiZoKSYmcmEoaClbMF0ucGxvdFg9PT12JiYoYT0hMSk7aWYoYSlnLnJlZnJlc2goaCksZSYmKGUuc2V0U3RhdGUoZS5zdGF0ZSwhMCksbyhjLmF4ZXMsZnVuY3Rpb24oYSl7cChhLm9wdGlvbnMuY3Jvc3NoYWlyJiZhLm9wdGlvbnMuY3Jvc3NoYWlyLnNuYXAsITApP2EuZHJhd0Nyb3NzaGFpcihudWxsLGUpOmEuaGlkZUNyb3NzaGFpcigpfSkpO2Vsc2V7aWYoZSllLm9uTW91c2VPdXQoKTtmJiZvKGYsZnVuY3Rpb24oYSl7YS5zZXRTdGF0ZSgpfSk7aWYoZClkLm9uTW91c2VPdXQoKTtnJiZnLmhpZGUoYik7XG5pZih0aGlzLl9vbkRvY3VtZW50TW91c2VNb3ZlKVooQyxcIm1vdXNlbW92ZVwiLHRoaXMuX29uRG9jdW1lbnRNb3VzZU1vdmUpLHRoaXMuX29uRG9jdW1lbnRNb3VzZU1vdmU9bnVsbDtvKGMuYXhlcyxmdW5jdGlvbihhKXthLmhpZGVDcm9zc2hhaXIoKX0pO3RoaXMuaG92ZXJYPWMuaG92ZXJQb2ludHM9Yy5ob3ZlclBvaW50PW51bGx9fSxzY2FsZUdyb3VwczpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY2hhcnQsZDtvKGMuc2VyaWVzLGZ1bmN0aW9uKGUpe2Q9YXx8ZS5nZXRQbG90Qm94KCk7ZS54QXhpcyYmZS54QXhpcy56b29tRW5hYmxlZCYmKGUuZ3JvdXAuYXR0cihkKSxlLm1hcmtlckdyb3VwJiYoZS5tYXJrZXJHcm91cC5hdHRyKGQpLGUubWFya2VyR3JvdXAuY2xpcChiP2MuY2xpcFJlY3Q6bnVsbCkpLGUuZGF0YUxhYmVsc0dyb3VwJiZlLmRhdGFMYWJlbHNHcm91cC5hdHRyKGQpKX0pO2MuY2xpcFJlY3QuYXR0cihifHxjLmNsaXBCb3gpfSxkcmFnU3RhcnQ6ZnVuY3Rpb24oYSl7dmFyIGI9XG50aGlzLmNoYXJ0O2IubW91c2VJc0Rvd249YS50eXBlO2IuY2FuY2VsQ2xpY2s9ITE7Yi5tb3VzZURvd25YPXRoaXMubW91c2VEb3duWD1hLmNoYXJ0WDtiLm1vdXNlRG93blk9dGhpcy5tb3VzZURvd25ZPWEuY2hhcnRZfSxkcmFnOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz1iLm9wdGlvbnMuY2hhcnQsZD1hLmNoYXJ0WCxlPWEuY2hhcnRZLGY9dGhpcy56b29tSG9yLGc9dGhpcy56b29tVmVydCxoPWIucGxvdExlZnQsaT1iLnBsb3RUb3Asaj1iLnBsb3RXaWR0aCxrPWIucGxvdEhlaWdodCxtLGw9dGhpcy5zZWxlY3Rpb25NYXJrZXIsbj10aGlzLm1vdXNlRG93blgscT10aGlzLm1vdXNlRG93blkseD1jLnBhbktleSYmYVtjLnBhbktleStcIktleVwiXTtpZighbHx8IWwudG91Y2gpaWYoZDxoP2Q9aDpkPmgraiYmKGQ9aCtqKSxlPGk/ZT1pOmU+aStrJiYoZT1pK2spLHRoaXMuaGFzRHJhZ2dlZD1NYXRoLnNxcnQoTWF0aC5wb3cobi1kLDIpK01hdGgucG93KHEtZSwyKSksdGhpcy5oYXNEcmFnZ2VkPlxuMTApe209Yi5pc0luc2lkZVBsb3Qobi1oLHEtaSk7aWYoYi5oYXNDYXJ0ZXNpYW5TZXJpZXMmJih0aGlzLnpvb21YfHx0aGlzLnpvb21ZKSYmbSYmIXgmJiFsKXRoaXMuc2VsZWN0aW9uTWFya2VyPWw9Yi5yZW5kZXJlci5yZWN0KGgsaSxmPzE6aixnPzE6aywwKS5hdHRyKHtmaWxsOmMuc2VsZWN0aW9uTWFya2VyRmlsbHx8XCJyZ2JhKDY5LDExNCwxNjcsMC4yNSlcIix6SW5kZXg6N30pLmFkZCgpO2wmJmYmJihkLT1uLGwuYXR0cih7d2lkdGg6TihkKSx4OihkPjA/MDpkKStufSkpO2wmJmcmJihkPWUtcSxsLmF0dHIoe2hlaWdodDpOKGQpLHk6KGQ+MD8wOmQpK3F9KSk7bSYmIWwmJmMucGFubmluZyYmYi5wYW4oYSxjLnBhbm5pbmcpfX0sZHJvcDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9dGhpcy5jaGFydCxkPXRoaXMuaGFzUGluY2hlZDtpZih0aGlzLnNlbGVjdGlvbk1hcmtlcil7dmFyIGU9e3hBeGlzOltdLHlBeGlzOltdLG9yaWdpbmFsRXZlbnQ6YS5vcmlnaW5hbEV2ZW50fHxcbmF9LGY9dGhpcy5zZWxlY3Rpb25NYXJrZXIsZz1mLmF0dHI/Zi5hdHRyKFwieFwiKTpmLngsaD1mLmF0dHI/Zi5hdHRyKFwieVwiKTpmLnksaT1mLmF0dHI/Zi5hdHRyKFwid2lkdGhcIik6Zi53aWR0aCxqPWYuYXR0cj9mLmF0dHIoXCJoZWlnaHRcIik6Zi5oZWlnaHQsaztpZih0aGlzLmhhc0RyYWdnZWR8fGQpbyhjLmF4ZXMsZnVuY3Rpb24oYyl7aWYoYy56b29tRW5hYmxlZCYmcyhjLm1pbikmJihkfHxiW3t4QXhpczpcInpvb21YXCIseUF4aXM6XCJ6b29tWVwifVtjLmNvbGxdXSkpe3ZhciBmPWMuaG9yaXosbj1hLnR5cGU9PT1cInRvdWNoZW5kXCI/Yy5taW5QaXhlbFBhZGRpbmc6MCxxPWMudG9WYWx1ZSgoZj9nOmgpK24pLGY9Yy50b1ZhbHVlKChmP2craTpoK2opLW4pO2VbYy5jb2xsXS5wdXNoKHtheGlzOmMsbWluOnoocSxmKSxtYXg6dChxLGYpfSk7az0hMH19KSxrJiZJKGMsXCJzZWxlY3Rpb25cIixlLGZ1bmN0aW9uKGEpe2Muem9vbShyKGEsZD97YW5pbWF0aW9uOiExfTpudWxsKSl9KTt0aGlzLnNlbGVjdGlvbk1hcmtlcj1cbnRoaXMuc2VsZWN0aW9uTWFya2VyLmRlc3Ryb3koKTtkJiZ0aGlzLnNjYWxlR3JvdXBzKCl9aWYoYylMKGMuY29udGFpbmVyLHtjdXJzb3I6Yy5fY3Vyc29yfSksYy5jYW5jZWxDbGljaz10aGlzLmhhc0RyYWdnZWQ+MTAsYy5tb3VzZUlzRG93bj10aGlzLmhhc0RyYWdnZWQ9dGhpcy5oYXNQaW5jaGVkPSExLHRoaXMucGluY2hEb3duPVtdfSxvbkNvbnRhaW5lck1vdXNlRG93bjpmdW5jdGlvbihhKXthPXRoaXMubm9ybWFsaXplKGEpO2EucHJldmVudERlZmF1bHQmJmEucHJldmVudERlZmF1bHQoKTt0aGlzLmRyYWdTdGFydChhKX0sb25Eb2N1bWVudE1vdXNlVXA6ZnVuY3Rpb24oYSl7WVtvYV0mJllbb2FdLnBvaW50ZXIuZHJvcChhKX0sb25Eb2N1bWVudE1vdXNlTW92ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9dGhpcy5jaGFydFBvc2l0aW9uLGE9dGhpcy5ub3JtYWxpemUoYSxjKTtjJiYhdGhpcy5pbkNsYXNzKGEudGFyZ2V0LFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpJiZcbiFiLmlzSW5zaWRlUGxvdChhLmNoYXJ0WC1iLnBsb3RMZWZ0LGEuY2hhcnRZLWIucGxvdFRvcCkmJnRoaXMucmVzZXQoKX0sb25Db250YWluZXJNb3VzZUxlYXZlOmZ1bmN0aW9uKCl7dmFyIGE9WVtvYV07aWYoYSlhLnBvaW50ZXIucmVzZXQoKSxhLnBvaW50ZXIuY2hhcnRQb3NpdGlvbj1udWxsfSxvbkNvbnRhaW5lck1vdXNlTW92ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0O29hPWIuaW5kZXg7YT10aGlzLm5vcm1hbGl6ZShhKTthLnJldHVyblZhbHVlPSExO2IubW91c2VJc0Rvd249PT1cIm1vdXNlZG93blwiJiZ0aGlzLmRyYWcoYSk7KHRoaXMuaW5DbGFzcyhhLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKXx8Yi5pc0luc2lkZVBsb3QoYS5jaGFydFgtYi5wbG90TGVmdCxhLmNoYXJ0WS1iLnBsb3RUb3ApKSYmIWIub3Blbk1lbnUmJnRoaXMucnVuUG9pbnRBY3Rpb25zKGEpfSxpbkNsYXNzOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjO2E7KXtpZihjPUooYSxcImNsYXNzXCIpKWlmKGMuaW5kZXhPZihiKSE9PVxuLTEpcmV0dXJuITA7ZWxzZSBpZihjLmluZGV4T2YoXCJoaWdoY2hhcnRzLWNvbnRhaW5lclwiKSE9PS0xKXJldHVybiExO2E9YS5wYXJlbnROb2RlfX0sb25UcmFja2VyTW91c2VPdXQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydC5ob3ZlclNlcmllcyxjPShhPWEucmVsYXRlZFRhcmdldHx8YS50b0VsZW1lbnQpJiZhLnBvaW50JiZhLnBvaW50LnNlcmllcztpZihiJiYhYi5vcHRpb25zLnN0aWNreVRyYWNraW5nJiYhdGhpcy5pbkNsYXNzKGEsXCJoaWdoY2hhcnRzLXRvb2x0aXBcIikmJmMhPT1iKWIub25Nb3VzZU91dCgpfSxvbkNvbnRhaW5lckNsaWNrOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz1iLmhvdmVyUG9pbnQsZD1iLnBsb3RMZWZ0LGU9Yi5wbG90VG9wLGE9dGhpcy5ub3JtYWxpemUoYSk7YS5vcmlnaW5hbEV2ZW50PWE7Yi5jYW5jZWxDbGlja3x8KGMmJnRoaXMuaW5DbGFzcyhhLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKT8oSShjLnNlcmllcyxcImNsaWNrXCIsXG5yKGEse3BvaW50OmN9KSksYi5ob3ZlclBvaW50JiZjLmZpcmVQb2ludEV2ZW50KFwiY2xpY2tcIixhKSk6KHIoYSx0aGlzLmdldENvb3JkaW5hdGVzKGEpKSxiLmlzSW5zaWRlUGxvdChhLmNoYXJ0WC1kLGEuY2hhcnRZLWUpJiZJKGIsXCJjbGlja1wiLGEpKSl9LHNldERPTUV2ZW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0LmNvbnRhaW5lcjtiLm9ubW91c2Vkb3duPWZ1bmN0aW9uKGIpe2Eub25Db250YWluZXJNb3VzZURvd24oYil9O2Iub25tb3VzZW1vdmU9ZnVuY3Rpb24oYil7YS5vbkNvbnRhaW5lck1vdXNlTW92ZShiKX07Yi5vbmNsaWNrPWZ1bmN0aW9uKGIpe2Eub25Db250YWluZXJDbGljayhiKX07SChiLFwibW91c2VsZWF2ZVwiLGEub25Db250YWluZXJNb3VzZUxlYXZlKTthYj09PTEmJkgoQyxcIm1vdXNldXBcIixhLm9uRG9jdW1lbnRNb3VzZVVwKTtpZigkYSliLm9udG91Y2hzdGFydD1mdW5jdGlvbihiKXthLm9uQ29udGFpbmVyVG91Y2hTdGFydChiKX0sYi5vbnRvdWNobW92ZT1cbmZ1bmN0aW9uKGIpe2Eub25Db250YWluZXJUb3VjaE1vdmUoYil9LGFiPT09MSYmSChDLFwidG91Y2hlbmRcIixhLm9uRG9jdW1lbnRUb3VjaEVuZCl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYTtaKHRoaXMuY2hhcnQuY29udGFpbmVyLFwibW91c2VsZWF2ZVwiLHRoaXMub25Db250YWluZXJNb3VzZUxlYXZlKTthYnx8KFooQyxcIm1vdXNldXBcIix0aGlzLm9uRG9jdW1lbnRNb3VzZVVwKSxaKEMsXCJ0b3VjaGVuZFwiLHRoaXMub25Eb2N1bWVudFRvdWNoRW5kKSk7Y2xlYXJJbnRlcnZhbCh0aGlzLnRvb2x0aXBUaW1lb3V0KTtmb3IoYSBpbiB0aGlzKXRoaXNbYV09bnVsbH19O3IoQi5Qb2ludGVyLnByb3RvdHlwZSx7cGluY2hUcmFuc2xhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpeyh0aGlzLnpvb21Ib3J8fHRoaXMucGluY2hIb3IpJiZ0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCEwLGEsYixjLGQsZSxmKTsodGhpcy56b29tVmVydHx8dGhpcy5waW5jaFZlcnQpJiZ0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCExLFxuYSxiLGMsZCxlLGYpfSxwaW5jaFRyYW5zbGF0ZURpcmVjdGlvbjpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgpe3ZhciBpPXRoaXMuY2hhcnQsaj1hP1wieFwiOlwieVwiLGs9YT9cIlhcIjpcIllcIixtPVwiY2hhcnRcIitrLGw9YT9cIndpZHRoXCI6XCJoZWlnaHRcIixuPWlbXCJwbG90XCIrKGE/XCJMZWZ0XCI6XCJUb3BcIildLHEseCxwPWh8fDEsbz1pLmludmVydGVkLHU9aS5ib3VuZHNbYT9cImhcIjpcInZcIl0sdD1iLmxlbmd0aD09PTEscz1iWzBdW21dLHI9Y1swXVttXSx3PSF0JiZiWzFdW21dLHY9IXQmJmNbMV1bbV0seixjPWZ1bmN0aW9uKCl7IXQmJk4ocy13KT4yMCYmKHA9aHx8TihyLXYpL04ocy13KSk7eD0obi1yKS9wK3M7cT1pW1wicGxvdFwiKyhhP1wiV2lkdGhcIjpcIkhlaWdodFwiKV0vcH07YygpO2I9eDtiPHUubWluPyhiPXUubWluLHo9ITApOmIrcT51Lm1heCYmKGI9dS5tYXgtcSx6PSEwKTt6PyhyLT0wLjgqKHItZ1tqXVswXSksdHx8KHYtPTAuOCoodi1nW2pdWzFdKSksYygpKTpnW2pdPVtyLHZdO298fChmW2pdPVxueC1uLGZbbF09cSk7Zj1vPzEvcDpwO2VbbF09cTtlW2pdPWI7ZFtvP2E/XCJzY2FsZVlcIjpcInNjYWxlWFwiOlwic2NhbGVcIitrXT1wO2RbXCJ0cmFuc2xhdGVcIitrXT1mKm4rKHItZipzKX0scGluY2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWIuY2hhcnQsZD1iLnBpbmNoRG93bixlPWEudG91Y2hlcyxmPWUubGVuZ3RoLGc9Yi5sYXN0VmFsaWRUb3VjaCxoPWIuaGFzWm9vbSxpPWIuc2VsZWN0aW9uTWFya2VyLGo9e30saz1mPT09MSYmKGIuaW5DbGFzcyhhLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKSYmYy5ydW5UcmFja2VyQ2xpY2t8fGIucnVuQ2hhcnRDbGljayksbT17fTtpZihmPjEpYi5pbml0aWF0ZWQ9ITA7aCYmYi5pbml0aWF0ZWQmJiFrJiZhLnByZXZlbnREZWZhdWx0KCk7VGEoZSxmdW5jdGlvbihhKXtyZXR1cm4gYi5ub3JtYWxpemUoYSl9KTtpZihhLnR5cGU9PT1cInRvdWNoc3RhcnRcIilvKGUsZnVuY3Rpb24oYSxiKXtkW2JdPXtjaGFydFg6YS5jaGFydFgsY2hhcnRZOmEuY2hhcnRZfX0pLFxuZy54PVtkWzBdLmNoYXJ0WCxkWzFdJiZkWzFdLmNoYXJ0WF0sZy55PVtkWzBdLmNoYXJ0WSxkWzFdJiZkWzFdLmNoYXJ0WV0sbyhjLmF4ZXMsZnVuY3Rpb24oYSl7aWYoYS56b29tRW5hYmxlZCl7dmFyIGI9Yy5ib3VuZHNbYS5ob3Jpej9cImhcIjpcInZcIl0sZD1hLm1pblBpeGVsUGFkZGluZyxlPWEudG9QaXhlbHMocChhLm9wdGlvbnMubWluLGEuZGF0YU1pbikpLGY9YS50b1BpeGVscyhwKGEub3B0aW9ucy5tYXgsYS5kYXRhTWF4KSksZz16KGUsZiksZT10KGUsZik7Yi5taW49eihhLnBvcyxnLWQpO2IubWF4PXQoYS5wb3MrYS5sZW4sZStkKX19KSxiLnJlcz0hMDtlbHNlIGlmKGQubGVuZ3RoKXtpZighaSliLnNlbGVjdGlvbk1hcmtlcj1pPXIoe2Rlc3Ryb3k6dGEsdG91Y2g6ITB9LGMucGxvdEJveCk7Yi5waW5jaFRyYW5zbGF0ZShkLGUsaixpLG0sZyk7Yi5oYXNQaW5jaGVkPWg7Yi5zY2FsZUdyb3VwcyhqLG0pO2lmKCFoJiZiLmZvbGxvd1RvdWNoTW92ZSYmZj09PTEpdGhpcy5ydW5Qb2ludEFjdGlvbnMoYi5ub3JtYWxpemUoYSkpO1xuZWxzZSBpZihiLnJlcyliLnJlcz0hMSx0aGlzLnJlc2V0KCExLDApfX0sdG91Y2g6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNoYXJ0O29hPWMuaW5kZXg7YS50b3VjaGVzLmxlbmd0aD09PTE/KGE9dGhpcy5ub3JtYWxpemUoYSksYy5pc0luc2lkZVBsb3QoYS5jaGFydFgtYy5wbG90TGVmdCxhLmNoYXJ0WS1jLnBsb3RUb3ApJiYhYy5vcGVuTWVudT8oYiYmdGhpcy5ydW5Qb2ludEFjdGlvbnMoYSksdGhpcy5waW5jaChhKSk6YiYmdGhpcy5yZXNldCgpKTphLnRvdWNoZXMubGVuZ3RoPT09MiYmdGhpcy5waW5jaChhKX0sb25Db250YWluZXJUb3VjaFN0YXJ0OmZ1bmN0aW9uKGEpe3RoaXMudG91Y2goYSwhMCl9LG9uQ29udGFpbmVyVG91Y2hNb3ZlOmZ1bmN0aW9uKGEpe3RoaXMudG91Y2goYSl9LG9uRG9jdW1lbnRUb3VjaEVuZDpmdW5jdGlvbihhKXtZW29hXSYmWVtvYV0ucG9pbnRlci5kcm9wKGEpfX0pO2lmKEsuUG9pbnRlckV2ZW50fHxLLk1TUG9pbnRlckV2ZW50KXt2YXIgdmE9XG57fSxBYj0hIUsuUG9pbnRlckV2ZW50LFdiPWZ1bmN0aW9uKCl7dmFyIGEsYj1bXTtiLml0ZW09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXNbYV19O2ZvcihhIGluIHZhKXZhLmhhc093blByb3BlcnR5KGEpJiZiLnB1c2goe3BhZ2VYOnZhW2FdLnBhZ2VYLHBhZ2VZOnZhW2FdLnBhZ2VZLHRhcmdldDp2YVthXS50YXJnZXR9KTtyZXR1cm4gYn0sQmI9ZnVuY3Rpb24oYSxiLGMsZCl7YT1hLm9yaWdpbmFsRXZlbnR8fGE7aWYoKGEucG9pbnRlclR5cGU9PT1cInRvdWNoXCJ8fGEucG9pbnRlclR5cGU9PT1hLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSYmWVtvYV0pZChhKSxkPVlbb2FdLnBvaW50ZXIsZFtiXSh7dHlwZTpjLHRhcmdldDphLmN1cnJlbnRUYXJnZXQscHJldmVudERlZmF1bHQ6dGEsdG91Y2hlczpXYigpfSl9O3IoVWEucHJvdG90eXBlLHtvbkNvbnRhaW5lclBvaW50ZXJEb3duOmZ1bmN0aW9uKGEpe0JiKGEsXCJvbkNvbnRhaW5lclRvdWNoU3RhcnRcIixcInRvdWNoc3RhcnRcIixmdW5jdGlvbihhKXt2YVthLnBvaW50ZXJJZF09XG57cGFnZVg6YS5wYWdlWCxwYWdlWTphLnBhZ2VZLHRhcmdldDphLmN1cnJlbnRUYXJnZXR9fSl9LG9uQ29udGFpbmVyUG9pbnRlck1vdmU6ZnVuY3Rpb24oYSl7QmIoYSxcIm9uQ29udGFpbmVyVG91Y2hNb3ZlXCIsXCJ0b3VjaG1vdmVcIixmdW5jdGlvbihhKXt2YVthLnBvaW50ZXJJZF09e3BhZ2VYOmEucGFnZVgscGFnZVk6YS5wYWdlWX07aWYoIXZhW2EucG9pbnRlcklkXS50YXJnZXQpdmFbYS5wb2ludGVySWRdLnRhcmdldD1hLmN1cnJlbnRUYXJnZXR9KX0sb25Eb2N1bWVudFBvaW50ZXJVcDpmdW5jdGlvbihhKXtCYihhLFwib25Eb2N1bWVudFRvdWNoRW5kXCIsXCJ0b3VjaGVuZFwiLGZ1bmN0aW9uKGEpe2RlbGV0ZSB2YVthLnBvaW50ZXJJZF19KX0sYmF0Y2hNU0V2ZW50czpmdW5jdGlvbihhKXthKHRoaXMuY2hhcnQuY29udGFpbmVyLEFiP1wicG9pbnRlcmRvd25cIjpcIk1TUG9pbnRlckRvd25cIix0aGlzLm9uQ29udGFpbmVyUG9pbnRlckRvd24pO2EodGhpcy5jaGFydC5jb250YWluZXIsQWI/XG5cInBvaW50ZXJtb3ZlXCI6XCJNU1BvaW50ZXJNb3ZlXCIsdGhpcy5vbkNvbnRhaW5lclBvaW50ZXJNb3ZlKTthKEMsQWI/XCJwb2ludGVydXBcIjpcIk1TUG9pbnRlclVwXCIsdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKX19KTtTYShVYS5wcm90b3R5cGUsXCJpbml0XCIsZnVuY3Rpb24oYSxiLGMpe2EuY2FsbCh0aGlzLGIsYyk7dGhpcy5oYXNab29tJiZMKGIuY29udGFpbmVyLHtcIi1tcy10b3VjaC1hY3Rpb25cIjpPLFwidG91Y2gtYWN0aW9uXCI6T30pfSk7U2EoVWEucHJvdG90eXBlLFwic2V0RE9NRXZlbnRzXCIsZnVuY3Rpb24oYSl7YS5hcHBseSh0aGlzKTsodGhpcy5oYXNab29tfHx0aGlzLmZvbGxvd1RvdWNoTW92ZSkmJnRoaXMuYmF0Y2hNU0V2ZW50cyhIKX0pO1NhKFVhLnByb3RvdHlwZSxcImRlc3Ryb3lcIixmdW5jdGlvbihhKXt0aGlzLmJhdGNoTVNFdmVudHMoWik7YS5jYWxsKHRoaXMpfSl9dmFyIGxiPUIuTGVnZW5kPWZ1bmN0aW9uKGEsYil7dGhpcy5pbml0KGEsYil9O2xiLnByb3RvdHlwZT1cbntpbml0OmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPWIuaXRlbVN0eWxlLGU9Yi5pdGVtTWFyZ2luVG9wfHwwO3RoaXMub3B0aW9ucz1iO2lmKGIuZW5hYmxlZCljLml0ZW1TdHlsZT1kLGMuaXRlbUhpZGRlblN0eWxlPUEoZCxiLml0ZW1IaWRkZW5TdHlsZSksYy5pdGVtTWFyZ2luVG9wPWUsYy5wYWRkaW5nPWQ9cChiLnBhZGRpbmcsOCksYy5pbml0aWFsSXRlbVg9ZCxjLmluaXRpYWxJdGVtWT1kLTUsYy5tYXhJdGVtV2lkdGg9MCxjLmNoYXJ0PWEsYy5pdGVtSGVpZ2h0PTAsYy5zeW1ib2xXaWR0aD1wKGIuc3ltYm9sV2lkdGgsMTYpLGMucGFnZXM9W10sYy5yZW5kZXIoKSxIKGMuY2hhcnQsXCJlbmRSZXNpemVcIixmdW5jdGlvbigpe2MucG9zaXRpb25DaGVja2JveGVzKCl9KX0sY29sb3JpemVJdGVtOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5vcHRpb25zLGQ9YS5sZWdlbmRJdGVtLGU9YS5sZWdlbmRMaW5lLGY9YS5sZWdlbmRTeW1ib2wsZz10aGlzLml0ZW1IaWRkZW5TdHlsZS5jb2xvcixcbmM9Yj9jLml0ZW1TdHlsZS5jb2xvcjpnLGg9Yj9hLmxlZ2VuZENvbG9yfHxhLmNvbG9yfHxcIiNDQ0NcIjpnLGc9YS5vcHRpb25zJiZhLm9wdGlvbnMubWFya2VyLGk9e2ZpbGw6aH0sajtkJiZkLmNzcyh7ZmlsbDpjLGNvbG9yOmN9KTtlJiZlLmF0dHIoe3N0cm9rZTpofSk7aWYoZil7aWYoZyYmZi5pc01hcmtlcilmb3IoaiBpbiBpLnN0cm9rZT1oLGc9YS5jb252ZXJ0QXR0cmlicyhnKSxnKWQ9Z1tqXSxkIT09diYmKGlbal09ZCk7Zi5hdHRyKGkpfX0scG9zaXRpb25JdGVtOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucyxjPWIuc3ltYm9sUGFkZGluZyxiPSFiLnJ0bCxkPWEuX2xlZ2VuZEl0ZW1Qb3MsZT1kWzBdLGQ9ZFsxXSxmPWEuY2hlY2tib3g7KGE9YS5sZWdlbmRHcm91cCkmJmEuZWxlbWVudCYmYS50cmFuc2xhdGUoYj9lOnRoaXMubGVnZW5kV2lkdGgtZS0yKmMtNCxkKTtpZihmKWYueD1lLGYueT1kfSxkZXN0cm95SXRlbTpmdW5jdGlvbihhKXt2YXIgYj1hLmNoZWNrYm94O1xubyhbXCJsZWdlbmRJdGVtXCIsXCJsZWdlbmRMaW5lXCIsXCJsZWdlbmRTeW1ib2xcIixcImxlZ2VuZEdyb3VwXCJdLGZ1bmN0aW9uKGIpe2FbYl0mJihhW2JdPWFbYl0uZGVzdHJveSgpKX0pO2ImJlBhKGEuY2hlY2tib3gpfSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ncm91cCxiPXRoaXMuYm94O2lmKGIpdGhpcy5ib3g9Yi5kZXN0cm95KCk7aWYoYSl0aGlzLmdyb3VwPWEuZGVzdHJveSgpfSxwb3NpdGlvbkNoZWNrYm94ZXM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncm91cC5hbGlnbkF0dHIsYyxkPXRoaXMuY2xpcEhlaWdodHx8dGhpcy5sZWdlbmRIZWlnaHQ7aWYoYiljPWIudHJhbnNsYXRlWSxvKHRoaXMuYWxsSXRlbXMsZnVuY3Rpb24oZSl7dmFyIGY9ZS5jaGVja2JveCxnO2YmJihnPWMrZi55KyhhfHwwKSszLEwoZix7bGVmdDpiLnRyYW5zbGF0ZVgrZS5jaGVja2JveE9mZnNldCtmLngtMjArXCJweFwiLHRvcDpnK1wicHhcIixkaXNwbGF5Omc+Yy02JiZnPGMrZC02P1wiXCI6T30pKX0pfSxcbnJlbmRlclRpdGxlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wYWRkaW5nLGI9dGhpcy5vcHRpb25zLnRpdGxlLGM9MDtpZihiLnRleHQpe2lmKCF0aGlzLnRpdGxlKXRoaXMudGl0bGU9dGhpcy5jaGFydC5yZW5kZXJlci5sYWJlbChiLnRleHQsYS0zLGEtNCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsXCJsZWdlbmQtdGl0bGVcIikuYXR0cih7ekluZGV4OjF9KS5jc3MoYi5zdHlsZSkuYWRkKHRoaXMuZ3JvdXApO2E9dGhpcy50aXRsZS5nZXRCQm94KCk7Yz1hLmhlaWdodDt0aGlzLm9mZnNldFdpZHRoPWEud2lkdGg7dGhpcy5jb250ZW50R3JvdXAuYXR0cih7dHJhbnNsYXRlWTpjfSl9dGhpcy50aXRsZUhlaWdodD1jfSxzZXRUZXh0OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9uczthLmxlZ2VuZEl0ZW0uYXR0cih7dGV4dDpiLmxhYmVsRm9ybWF0P0hhKGIubGFiZWxGb3JtYXQsYSk6Yi5sYWJlbEZvcm1hdHRlci5jYWxsKGEpfSl9LHJlbmRlckl0ZW06ZnVuY3Rpb24oYSl7dmFyIGI9XG50aGlzLmNoYXJ0LGM9Yi5yZW5kZXJlcixkPXRoaXMub3B0aW9ucyxlPWQubGF5b3V0PT09XCJob3Jpem9udGFsXCIsZj10aGlzLnN5bWJvbFdpZHRoLGc9ZC5zeW1ib2xQYWRkaW5nLGg9dGhpcy5pdGVtU3R5bGUsaT10aGlzLml0ZW1IaWRkZW5TdHlsZSxqPXRoaXMucGFkZGluZyxrPWU/cChkLml0ZW1EaXN0YW5jZSwyMCk6MCxtPSFkLnJ0bCxsPWQud2lkdGgsbj1kLml0ZW1NYXJnaW5Cb3R0b218fDAscT10aGlzLml0ZW1NYXJnaW5Ub3AseD10aGlzLmluaXRpYWxJdGVtWCxvPWEubGVnZW5kSXRlbSxzPWEuc2VyaWVzJiZhLnNlcmllcy5kcmF3TGVnZW5kU3ltYm9sP2Euc2VyaWVzOmEsdT1zLm9wdGlvbnMsdT10aGlzLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbSYmdSYmdS5zaG93Q2hlY2tib3gseT1kLnVzZUhUTUw7aWYoIW8pe2EubGVnZW5kR3JvdXA9Yy5nKFwibGVnZW5kLWl0ZW1cIikuYXR0cih7ekluZGV4OjF9KS5hZGQodGhpcy5zY3JvbGxHcm91cCk7YS5sZWdlbmRJdGVtPW89Yy50ZXh0KFwiXCIsXG5tP2YrZzotZyx0aGlzLmJhc2VsaW5lfHwwLHkpLmNzcyhBKGEudmlzaWJsZT9oOmkpKS5hdHRyKHthbGlnbjptP1wibGVmdFwiOlwicmlnaHRcIix6SW5kZXg6Mn0pLmFkZChhLmxlZ2VuZEdyb3VwKTtpZighdGhpcy5iYXNlbGluZSl0aGlzLmZvbnRNZXRyaWNzPWMuZm9udE1ldHJpY3MoaC5mb250U2l6ZSxvKSx0aGlzLmJhc2VsaW5lPXRoaXMuZm9udE1ldHJpY3MuZiszK3Esby5hdHRyKFwieVwiLHRoaXMuYmFzZWxpbmUpO3MuZHJhd0xlZ2VuZFN5bWJvbCh0aGlzLGEpO3RoaXMuc2V0SXRlbUV2ZW50cyYmdGhpcy5zZXRJdGVtRXZlbnRzKGEsbyx5LGgsaSk7dGhpcy5jb2xvcml6ZUl0ZW0oYSxhLnZpc2libGUpO3UmJnRoaXMuY3JlYXRlQ2hlY2tib3hGb3JJdGVtKGEpfXRoaXMuc2V0VGV4dChhKTtjPW8uZ2V0QkJveCgpO2Y9YS5jaGVja2JveE9mZnNldD1kLml0ZW1XaWR0aHx8YS5sZWdlbmRJdGVtV2lkdGh8fGYrZytjLndpZHRoK2srKHU/MjA6MCk7dGhpcy5pdGVtSGVpZ2h0PWc9dyhhLmxlZ2VuZEl0ZW1IZWlnaHR8fFxuYy5oZWlnaHQpO2lmKGUmJnRoaXMuaXRlbVgteCtmPihsfHxiLmNoYXJ0V2lkdGgtMipqLXgtZC54KSl0aGlzLml0ZW1YPXgsdGhpcy5pdGVtWSs9cSt0aGlzLmxhc3RMaW5lSGVpZ2h0K24sdGhpcy5sYXN0TGluZUhlaWdodD0wO3RoaXMubWF4SXRlbVdpZHRoPXQodGhpcy5tYXhJdGVtV2lkdGgsZik7dGhpcy5sYXN0SXRlbVk9cSt0aGlzLml0ZW1ZK247dGhpcy5sYXN0TGluZUhlaWdodD10KGcsdGhpcy5sYXN0TGluZUhlaWdodCk7YS5fbGVnZW5kSXRlbVBvcz1bdGhpcy5pdGVtWCx0aGlzLml0ZW1ZXTtlP3RoaXMuaXRlbVgrPWY6KHRoaXMuaXRlbVkrPXErZytuLHRoaXMubGFzdExpbmVIZWlnaHQ9Zyk7dGhpcy5vZmZzZXRXaWR0aD1sfHx0KChlP3RoaXMuaXRlbVgteC1rOmYpK2osdGhpcy5vZmZzZXRXaWR0aCl9LGdldEFsbEl0ZW1zOmZ1bmN0aW9uKCl7dmFyIGE9W107byh0aGlzLmNoYXJ0LnNlcmllcyxmdW5jdGlvbihiKXt2YXIgYz1iLm9wdGlvbnM7aWYocChjLnNob3dJbkxlZ2VuZCxcbiFzKGMubGlua2VkVG8pP3Y6ITEsITApKWE9YS5jb25jYXQoYi5sZWdlbmRJdGVtc3x8KGMubGVnZW5kVHlwZT09PVwicG9pbnRcIj9iLmRhdGE6YikpfSk7cmV0dXJuIGF9LGFkanVzdE1hcmdpbnM6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNoYXJ0LGQ9dGhpcy5vcHRpb25zLGU9ZC5hbGlnbi5jaGFyQXQoMCkrZC52ZXJ0aWNhbEFsaWduLmNoYXJBdCgwKStkLmxheW91dC5jaGFyQXQoMCk7dGhpcy5kaXNwbGF5JiYhZC5mbG9hdGluZyYmbyhbLyhsdGh8Y3R8cnRoKS8sLyhydHZ8cm18cmJ2KS8sLyhyYmh8Y2J8bGJoKS8sLyhsYnZ8bG18bHR2KS9dLGZ1bmN0aW9uKGYsZyl7Zi50ZXN0KGUpJiYhcyhhW2ddKSYmKGNbZ2JbZ11dPXQoY1tnYltnXV0sYy5sZWdlbmRbKGcrMSklMj9cImxlZ2VuZEhlaWdodFwiOlwibGVnZW5kV2lkdGhcIl0rWzEsLTEsLTEsMV1bZ10qZFtnJTI/XCJ4XCI6XCJ5XCJdK3AoZC5tYXJnaW4sMTIpK2JbZ10pKX0pfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9XG5hLmNoYXJ0LGM9Yi5yZW5kZXJlcixkPWEuZ3JvdXAsZSxmLGcsaCxpPWEuYm94LGo9YS5vcHRpb25zLGs9YS5wYWRkaW5nLG09ai5ib3JkZXJXaWR0aCxsPWouYmFja2dyb3VuZENvbG9yO2EuaXRlbVg9YS5pbml0aWFsSXRlbVg7YS5pdGVtWT1hLmluaXRpYWxJdGVtWTthLm9mZnNldFdpZHRoPTA7YS5sYXN0SXRlbVk9MDtpZighZClhLmdyb3VwPWQ9Yy5nKFwibGVnZW5kXCIpLmF0dHIoe3pJbmRleDo3fSkuYWRkKCksYS5jb250ZW50R3JvdXA9Yy5nKCkuYXR0cih7ekluZGV4OjF9KS5hZGQoZCksYS5zY3JvbGxHcm91cD1jLmcoKS5hZGQoYS5jb250ZW50R3JvdXApO2EucmVuZGVyVGl0bGUoKTtlPWEuZ2V0QWxsSXRlbXMoKTtwYihlLGZ1bmN0aW9uKGEsYil7cmV0dXJuKGEub3B0aW9ucyYmYS5vcHRpb25zLmxlZ2VuZEluZGV4fHwwKS0oYi5vcHRpb25zJiZiLm9wdGlvbnMubGVnZW5kSW5kZXh8fDApfSk7ai5yZXZlcnNlZCYmZS5yZXZlcnNlKCk7YS5hbGxJdGVtcz1lO2EuZGlzcGxheT1cbmY9ISFlLmxlbmd0aDthLmxhc3RMaW5lSGVpZ2h0PTA7byhlLGZ1bmN0aW9uKGIpe2EucmVuZGVySXRlbShiKX0pO2c9KGoud2lkdGh8fGEub2Zmc2V0V2lkdGgpK2s7aD1hLmxhc3RJdGVtWSthLmxhc3RMaW5lSGVpZ2h0K2EudGl0bGVIZWlnaHQ7aD1hLmhhbmRsZU92ZXJmbG93KGgpO2grPWs7aWYobXx8bCl7aWYoaSl7aWYoZz4wJiZoPjApaVtpLmlzTmV3P1wiYXR0clwiOlwiYW5pbWF0ZVwiXShpLmNyaXNwKHt3aWR0aDpnLGhlaWdodDpofSkpLGkuaXNOZXc9ITF9ZWxzZSBhLmJveD1pPWMucmVjdCgwLDAsZyxoLGouYm9yZGVyUmFkaXVzLG18fDApLmF0dHIoe3N0cm9rZTpqLmJvcmRlckNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6bXx8MCxmaWxsOmx8fE99KS5hZGQoZCkuc2hhZG93KGouc2hhZG93KSxpLmlzTmV3PSEwO2lbZj9cInNob3dcIjpcImhpZGVcIl0oKX1hLmxlZ2VuZFdpZHRoPWc7YS5sZWdlbmRIZWlnaHQ9aDtvKGUsZnVuY3Rpb24oYil7YS5wb3NpdGlvbkl0ZW0oYil9KTtmJiZkLmFsaWduKHIoe3dpZHRoOmcsXG5oZWlnaHQ6aH0saiksITAsXCJzcGFjaW5nQm94XCIpO2IuaXNSZXNpemluZ3x8dGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoKX0saGFuZGxlT3ZlcmZsb3c6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMuY2hhcnQsZD1jLnJlbmRlcmVyLGU9dGhpcy5vcHRpb25zLGY9ZS55LGY9Yy5zcGFjaW5nQm94LmhlaWdodCsoZS52ZXJ0aWNhbEFsaWduPT09XCJ0b3BcIj8tZjpmKS10aGlzLnBhZGRpbmcsZz1lLm1heEhlaWdodCxoLGk9dGhpcy5jbGlwUmVjdCxqPWUubmF2aWdhdGlvbixrPXAoai5hbmltYXRpb24sITApLG09ai5hcnJvd1NpemV8fDEyLGw9dGhpcy5uYXYsbj10aGlzLnBhZ2VzLHE9dGhpcy5wYWRkaW5nLHgscz10aGlzLmFsbEl0ZW1zLHI9ZnVuY3Rpb24oYSl7aS5hdHRyKHtoZWlnaHQ6YX0pO2lmKGIuY29udGVudEdyb3VwLmRpdiliLmNvbnRlbnRHcm91cC5kaXYuc3R5bGUuY2xpcD1cInJlY3QoXCIrcStcInB4LDk5OTlweCxcIisocSthKStcInB4LDApXCJ9O2UubGF5b3V0PT09XCJob3Jpem9udGFsXCImJlxuKGYvPTIpO2cmJihmPXooZixnKSk7bi5sZW5ndGg9MDtpZihhPmYpe3RoaXMuY2xpcEhlaWdodD1oPXQoZi0yMC10aGlzLnRpdGxlSGVpZ2h0LXEsMCk7dGhpcy5jdXJyZW50UGFnZT1wKHRoaXMuY3VycmVudFBhZ2UsMSk7dGhpcy5mdWxsSGVpZ2h0PWE7byhzLGZ1bmN0aW9uKGEsYil7dmFyIGM9YS5fbGVnZW5kSXRlbVBvc1sxXSxkPXcoYS5sZWdlbmRJdGVtLmdldEJCb3goKS5oZWlnaHQpLGU9bi5sZW5ndGg7aWYoIWV8fGMtbltlLTFdPmgmJih4fHxjKSE9PW5bZS0xXSluLnB1c2goeHx8YyksZSsrO2I9PT1zLmxlbmd0aC0xJiZjK2QtbltlLTFdPmgmJm4ucHVzaChjKTtjIT09eCYmKHg9Yyl9KTtpZighaSlpPWIuY2xpcFJlY3Q9ZC5jbGlwUmVjdCgwLHEsOTk5OSwwKSxiLmNvbnRlbnRHcm91cC5jbGlwKGkpO3IoaCk7aWYoIWwpdGhpcy5uYXY9bD1kLmcoKS5hdHRyKHt6SW5kZXg6MX0pLmFkZCh0aGlzLmdyb3VwKSx0aGlzLnVwPWQuc3ltYm9sKFwidHJpYW5nbGVcIiwwLDAsbSxcbm0pLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe2Iuc2Nyb2xsKC0xLGspfSkuYWRkKGwpLHRoaXMucGFnZXI9ZC50ZXh0KFwiXCIsMTUsMTApLmNzcyhqLnN0eWxlKS5hZGQobCksdGhpcy5kb3duPWQuc3ltYm9sKFwidHJpYW5nbGUtZG93blwiLDAsMCxtLG0pLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe2Iuc2Nyb2xsKDEsayl9KS5hZGQobCk7Yi5zY3JvbGwoMCk7YT1mfWVsc2UgaWYobClyKGMuY2hhcnRIZWlnaHQpLGwuaGlkZSgpLHRoaXMuc2Nyb2xsR3JvdXAuYXR0cih7dHJhbnNsYXRlWToxfSksdGhpcy5jbGlwSGVpZ2h0PTA7cmV0dXJuIGF9LHNjcm9sbDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMucGFnZXMsZD1jLmxlbmd0aCxlPXRoaXMuY3VycmVudFBhZ2UrYSxmPXRoaXMuY2xpcEhlaWdodCxnPXRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uLGg9Zy5hY3RpdmVDb2xvcixnPWcuaW5hY3RpdmVDb2xvcixpPXRoaXMucGFnZXIsaj10aGlzLnBhZGRpbmc7ZT5kJiYoZT1kKTtpZihlPjApYiE9PVxudiYmUWEoYix0aGlzLmNoYXJ0KSx0aGlzLm5hdi5hdHRyKHt0cmFuc2xhdGVYOmosdHJhbnNsYXRlWTpmK3RoaXMucGFkZGluZys3K3RoaXMudGl0bGVIZWlnaHQsdmlzaWJpbGl0eTpcInZpc2libGVcIn0pLHRoaXMudXAuYXR0cih7ZmlsbDplPT09MT9nOmh9KS5jc3Moe2N1cnNvcjplPT09MT9cImRlZmF1bHRcIjpcInBvaW50ZXJcIn0pLGkuYXR0cih7dGV4dDplK1wiL1wiK2R9KSx0aGlzLmRvd24uYXR0cih7eDoxOCt0aGlzLnBhZ2VyLmdldEJCb3goKS53aWR0aCxmaWxsOmU9PT1kP2c6aH0pLmNzcyh7Y3Vyc29yOmU9PT1kP1wiZGVmYXVsdFwiOlwicG9pbnRlclwifSksYz0tY1tlLTFdK3RoaXMuaW5pdGlhbEl0ZW1ZLHRoaXMuc2Nyb2xsR3JvdXAuYW5pbWF0ZSh7dHJhbnNsYXRlWTpjfSksdGhpcy5jdXJyZW50UGFnZT1lLHRoaXMucG9zaXRpb25DaGVja2JveGVzKGMpfX07TGE9Qi5MZWdlbmRTeW1ib2xNaXhpbj17ZHJhd1JlY3RhbmdsZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEub3B0aW9ucy5zeW1ib2xIZWlnaHR8fFxuYS5mb250TWV0cmljcy5mO2IubGVnZW5kU3ltYm9sPXRoaXMuY2hhcnQucmVuZGVyZXIucmVjdCgwLGEuYmFzZWxpbmUtYysxLGEuc3ltYm9sV2lkdGgsYyxhLm9wdGlvbnMuc3ltYm9sUmFkaXVzfHwwKS5hdHRyKHt6SW5kZXg6M30pLmFkZChiLmxlZ2VuZEdyb3VwKX0sZHJhd0xpbmVNYXJrZXI6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zLGM9Yi5tYXJrZXIsZDtkPWEuc3ltYm9sV2lkdGg7dmFyIGU9dGhpcy5jaGFydC5yZW5kZXJlcixmPXRoaXMubGVnZW5kR3JvdXAsYT1hLmJhc2VsaW5lLXcoYS5mb250TWV0cmljcy5iKjAuMyksZztpZihiLmxpbmVXaWR0aCl7Zz17XCJzdHJva2Utd2lkdGhcIjpiLmxpbmVXaWR0aH07aWYoYi5kYXNoU3R5bGUpZy5kYXNoc3R5bGU9Yi5kYXNoU3R5bGU7dGhpcy5sZWdlbmRMaW5lPWUucGF0aChbXCJNXCIsMCxhLFwiTFwiLGQsYV0pLmF0dHIoZykuYWRkKGYpfWlmKGMmJmMuZW5hYmxlZCE9PSExKWI9Yy5yYWRpdXMsdGhpcy5sZWdlbmRTeW1ib2w9XG5kPWUuc3ltYm9sKHRoaXMuc3ltYm9sLGQvMi1iLGEtYiwyKmIsMipiKS5hZGQoZiksZC5pc01hcmtlcj0hMH19OygvVHJpZGVudFxcLzdcXC4wLy50ZXN0KHphKXx8SmEpJiZTYShsYi5wcm90b3R5cGUsXCJwb3NpdGlvbkl0ZW1cIixmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1mdW5jdGlvbigpe2IuX2xlZ2VuZEl0ZW1Qb3MmJmEuY2FsbChjLGIpfTtkKCk7c2V0VGltZW91dChkKX0pO0Q9Qi5DaGFydD1mdW5jdGlvbigpe3RoaXMuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0QucHJvdG90eXBlPXtjYWxsYmFja3M6W10saW5pdDpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9YS5zZXJpZXM7YS5zZXJpZXM9bnVsbDtjPUEoUyxhKTtjLnNlcmllcz1hLnNlcmllcz1kO3RoaXMudXNlck9wdGlvbnM9YTtkPWMuY2hhcnQ7dGhpcy5tYXJnaW49dGhpcy5zcGxhc2hBcnJheShcIm1hcmdpblwiLGQpO3RoaXMuc3BhY2luZz10aGlzLnNwbGFzaEFycmF5KFwic3BhY2luZ1wiLGQpO3ZhciBlPWQuZXZlbnRzO1xudGhpcy5ib3VuZHM9e2g6e30sdjp7fX07dGhpcy5jYWxsYmFjaz1iO3RoaXMuaXNSZXNpemluZz0wO3RoaXMub3B0aW9ucz1jO3RoaXMuYXhlcz1bXTt0aGlzLnNlcmllcz1bXTt0aGlzLmhhc0NhcnRlc2lhblNlcmllcz1kLnNob3dBeGVzO3ZhciBmPXRoaXMsZztmLmluZGV4PVkubGVuZ3RoO1kucHVzaChmKTthYisrO2QucmVmbG93IT09ITEmJkgoZixcImxvYWRcIixmdW5jdGlvbigpe2YuaW5pdFJlZmxvdygpfSk7aWYoZSlmb3IoZyBpbiBlKUgoZixnLGVbZ10pO2YueEF4aXM9W107Zi55QXhpcz1bXTtmLmFuaW1hdGlvbj1mYT8hMTpwKGQuYW5pbWF0aW9uLCEwKTtmLnBvaW50Q291bnQ9Zi5jb2xvckNvdW50ZXI9Zi5zeW1ib2xDb3VudGVyPTA7Zi5maXJzdFJlbmRlcigpfSxpbml0U2VyaWVzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucy5jaGFydDsoYj1NW2EudHlwZXx8Yi50eXBlfHxiLmRlZmF1bHRTZXJpZXNUeXBlXSl8fGxhKDE3LCEwKTtiPW5ldyBiO2IuaW5pdCh0aGlzLFxuYSk7cmV0dXJuIGJ9LGlzSW5zaWRlUGxvdDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9Yz9iOmEsYT1jP2E6YjtyZXR1cm4gZD49MCYmZDw9dGhpcy5wbG90V2lkdGgmJmE+PTAmJmE8PXRoaXMucGxvdEhlaWdodH0scmVkcmF3OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYXhlcyxjPXRoaXMuc2VyaWVzLGQ9dGhpcy5wb2ludGVyLGU9dGhpcy5sZWdlbmQsZj10aGlzLmlzRGlydHlMZWdlbmQsZyxoLGk9dGhpcy5oYXNDYXJ0ZXNpYW5TZXJpZXMsaj10aGlzLmlzRGlydHlCb3gsaz1jLmxlbmd0aCxtPWssbD10aGlzLnJlbmRlcmVyLG49bC5pc0hpZGRlbigpLHE9W107UWEoYSx0aGlzKTtuJiZ0aGlzLmNsb25lUmVuZGVyVG8oKTtmb3IodGhpcy5sYXlPdXRUaXRsZXMoKTttLS07KWlmKGE9Y1ttXSxhLm9wdGlvbnMuc3RhY2tpbmcmJihnPSEwLGEuaXNEaXJ0eSkpe2g9ITA7YnJlYWt9aWYoaClmb3IobT1rO20tLTspaWYoYT1jW21dLGEub3B0aW9ucy5zdGFja2luZylhLmlzRGlydHk9ITA7XG5vKGMsZnVuY3Rpb24oYSl7YS5pc0RpcnR5JiZhLm9wdGlvbnMubGVnZW5kVHlwZT09PVwicG9pbnRcIiYmKGEudXBkYXRlVG90YWxzJiZhLnVwZGF0ZVRvdGFscygpLGY9ITApfSk7aWYoZiYmZS5vcHRpb25zLmVuYWJsZWQpZS5yZW5kZXIoKSx0aGlzLmlzRGlydHlMZWdlbmQ9ITE7ZyYmdGhpcy5nZXRTdGFja3MoKTtpZihpJiYhdGhpcy5pc1Jlc2l6aW5nKXRoaXMubWF4VGlja3M9bnVsbCxvKGIsZnVuY3Rpb24oYSl7YS5zZXRTY2FsZSgpfSk7dGhpcy5nZXRNYXJnaW5zKCk7aSYmKG8oYixmdW5jdGlvbihhKXthLmlzRGlydHkmJihqPSEwKX0pLG8oYixmdW5jdGlvbihhKXt2YXIgYj1hLm1pbitcIixcIithLm1heDtpZihhLmV4dEtleSE9PWIpYS5leHRLZXk9YixxLnB1c2goZnVuY3Rpb24oKXtJKGEsXCJhZnRlclNldEV4dHJlbWVzXCIscihhLmV2ZW50QXJncyxhLmdldEV4dHJlbWVzKCkpKTtkZWxldGUgYS5ldmVudEFyZ3N9KTsoanx8ZykmJmEucmVkcmF3KCl9KSk7aiYmdGhpcy5kcmF3Q2hhcnRCb3goKTtcbm8oYyxmdW5jdGlvbihhKXthLmlzRGlydHkmJmEudmlzaWJsZSYmKCFhLmlzQ2FydGVzaWFufHxhLnhBeGlzKSYmYS5yZWRyYXcoKX0pO2QmJmQucmVzZXQoITApO2wuZHJhdygpO0kodGhpcyxcInJlZHJhd1wiKTtuJiZ0aGlzLmNsb25lUmVuZGVyVG8oITApO28ocSxmdW5jdGlvbihhKXthLmNhbGwoKX0pfSxnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5heGVzLGM9dGhpcy5zZXJpZXMsZCxlO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspaWYoYltkXS5vcHRpb25zLmlkPT09YSlyZXR1cm4gYltkXTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWlmKGNbZF0ub3B0aW9ucy5pZD09PWEpcmV0dXJuIGNbZF07Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyl7ZT1jW2RdLnBvaW50c3x8W107Zm9yKGI9MDtiPGUubGVuZ3RoO2IrKylpZihlW2JdLmlkPT09YSlyZXR1cm4gZVtiXX1yZXR1cm4gbnVsbH0sZ2V0QXhlczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLm9wdGlvbnMsYz1iLnhBeGlzPXJhKGIueEF4aXN8fFxue30pLGI9Yi55QXhpcz1yYShiLnlBeGlzfHx7fSk7byhjLGZ1bmN0aW9uKGEsYil7YS5pbmRleD1iO2EuaXNYPSEwfSk7byhiLGZ1bmN0aW9uKGEsYil7YS5pbmRleD1ifSk7Yz1jLmNvbmNhdChiKTtvKGMsZnVuY3Rpb24oYil7bmV3IGhhKGEsYil9KX0sZ2V0U2VsZWN0ZWRQb2ludHM6ZnVuY3Rpb24oKXt2YXIgYT1bXTtvKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGIpe2E9YS5jb25jYXQoaWIoYi5wb2ludHN8fFtdLGZ1bmN0aW9uKGEpe3JldHVybiBhLnNlbGVjdGVkfSkpfSk7cmV0dXJuIGF9LGdldFNlbGVjdGVkU2VyaWVzOmZ1bmN0aW9uKCl7cmV0dXJuIGliKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGEpe3JldHVybiBhLnNlbGVjdGVkfSl9LHNldFRpdGxlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZzt2YXIgZD10aGlzLGU9ZC5vcHRpb25zLGY7Zj1lLnRpdGxlPUEoZS50aXRsZSxhKTtnPWUuc3VidGl0bGU9QShlLnN1YnRpdGxlLGIpLGU9ZztvKFtbXCJ0aXRsZVwiLGEsZl0sW1wic3VidGl0bGVcIixcbmIsZV1dLGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF0sYz1kW2JdLGU9YVsxXSxhPWFbMl07YyYmZSYmKGRbYl09Yz1jLmRlc3Ryb3koKSk7YSYmYS50ZXh0JiYhYyYmKGRbYl09ZC5yZW5kZXJlci50ZXh0KGEudGV4dCwwLDAsYS51c2VIVE1MKS5hdHRyKHthbGlnbjphLmFsaWduLFwiY2xhc3NcIjpcImhpZ2hjaGFydHMtXCIrYix6SW5kZXg6YS56SW5kZXh8fDR9KS5jc3MoYS5zdHlsZSkuYWRkKCkpfSk7ZC5sYXlPdXRUaXRsZXMoYyl9LGxheU91dFRpdGxlczpmdW5jdGlvbihhKXt2YXIgYj0wLGM9dGhpcy50aXRsZSxkPXRoaXMuc3VidGl0bGUsZT10aGlzLm9wdGlvbnMsZj1lLnRpdGxlLGU9ZS5zdWJ0aXRsZSxnPXRoaXMucmVuZGVyZXIsaD10aGlzLnNwYWNpbmdCb3gud2lkdGgtNDQ7aWYoYyYmKGMuY3NzKHt3aWR0aDooZi53aWR0aHx8aCkrXCJweFwifSkuYWxpZ24ocih7eTpnLmZvbnRNZXRyaWNzKGYuc3R5bGUuZm9udFNpemUsYykuYi0zfSxmKSwhMSxcInNwYWNpbmdCb3hcIiksIWYuZmxvYXRpbmcmJlxuIWYudmVydGljYWxBbGlnbikpYj1jLmdldEJCb3goKS5oZWlnaHQ7ZCYmKGQuY3NzKHt3aWR0aDooZS53aWR0aHx8aCkrXCJweFwifSkuYWxpZ24ocih7eTpiKyhmLm1hcmdpbi0xMykrZy5mb250TWV0cmljcyhmLnN0eWxlLmZvbnRTaXplLGQpLmJ9LGUpLCExLFwic3BhY2luZ0JveFwiKSwhZS5mbG9hdGluZyYmIWUudmVydGljYWxBbGlnbiYmKGI9c2EoYitkLmdldEJCb3goKS5oZWlnaHQpKSk7Yz10aGlzLnRpdGxlT2Zmc2V0IT09Yjt0aGlzLnRpdGxlT2Zmc2V0PWI7aWYoIXRoaXMuaXNEaXJ0eUJveCYmYyl0aGlzLmlzRGlydHlCb3g9Yyx0aGlzLmhhc1JlbmRlcmVkJiZwKGEsITApJiZ0aGlzLmlzRGlydHlCb3gmJnRoaXMucmVkcmF3KCl9LGdldENoYXJ0U2l6ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5jaGFydCxiPWEud2lkdGgsYT1hLmhlaWdodCxjPXRoaXMucmVuZGVyVG9DbG9uZXx8dGhpcy5yZW5kZXJUbztpZighcyhiKSl0aGlzLmNvbnRhaW5lcldpZHRoPWhiKGMsXG5cIndpZHRoXCIpO2lmKCFzKGEpKXRoaXMuY29udGFpbmVySGVpZ2h0PWhiKGMsXCJoZWlnaHRcIik7dGhpcy5jaGFydFdpZHRoPXQoMCxifHx0aGlzLmNvbnRhaW5lcldpZHRofHw2MDApO3RoaXMuY2hhcnRIZWlnaHQ9dCgwLHAoYSx0aGlzLmNvbnRhaW5lckhlaWdodD4xOT90aGlzLmNvbnRhaW5lckhlaWdodDo0MDApKX0sY2xvbmVSZW5kZXJUbzpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnJlbmRlclRvQ2xvbmUsYz10aGlzLmNvbnRhaW5lcjthP2ImJih0aGlzLnJlbmRlclRvLmFwcGVuZENoaWxkKGMpLFBhKGIpLGRlbGV0ZSB0aGlzLnJlbmRlclRvQ2xvbmUpOihjJiZjLnBhcmVudE5vZGU9PT10aGlzLnJlbmRlclRvJiZ0aGlzLnJlbmRlclRvLnJlbW92ZUNoaWxkKGMpLHRoaXMucmVuZGVyVG9DbG9uZT1iPXRoaXMucmVuZGVyVG8uY2xvbmVOb2RlKDApLEwoYix7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIi05OTk5cHhcIixkaXNwbGF5OlwiYmxvY2tcIn0pLGIuc3R5bGUuc2V0UHJvcGVydHkmJlxuYi5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcImJsb2NrXCIsXCJpbXBvcnRhbnRcIiksQy5ib2R5LmFwcGVuZENoaWxkKGIpLGMmJmIuYXBwZW5kQ2hpbGQoYykpfSxnZXRDb250YWluZXI6ZnVuY3Rpb24oKXt2YXIgYSxiPXRoaXMub3B0aW9ucy5jaGFydCxjLGQsZTt0aGlzLnJlbmRlclRvPWE9Yi5yZW5kZXJUbztlPVwiaGlnaGNoYXJ0cy1cIit3YisrO2lmKEFhKGEpKXRoaXMucmVuZGVyVG89YT1DLmdldEVsZW1lbnRCeUlkKGEpO2F8fGxhKDEzLCEwKTtjPUYoSihhLFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpKTshaXNOYU4oYykmJllbY10mJllbY10uaGFzUmVuZGVyZWQmJllbY10uZGVzdHJveSgpO0ooYSxcImRhdGEtaGlnaGNoYXJ0cy1jaGFydFwiLHRoaXMuaW5kZXgpO2EuaW5uZXJIVE1MPVwiXCI7IWIuc2tpcENsb25lJiYhYS5vZmZzZXRXaWR0aCYmdGhpcy5jbG9uZVJlbmRlclRvKCk7dGhpcy5nZXRDaGFydFNpemUoKTtjPXRoaXMuY2hhcnRXaWR0aDtkPXRoaXMuY2hhcnRIZWlnaHQ7XG50aGlzLmNvbnRhaW5lcj1hPSQoSWEse2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtY29udGFpbmVyXCIrKGIuY2xhc3NOYW1lP1wiIFwiK2IuY2xhc3NOYW1lOlwiXCIpLGlkOmV9LHIoe3Bvc2l0aW9uOlwicmVsYXRpdmVcIixvdmVyZmxvdzpcImhpZGRlblwiLHdpZHRoOmMrXCJweFwiLGhlaWdodDpkK1wicHhcIix0ZXh0QWxpZ246XCJsZWZ0XCIsbGluZUhlaWdodDpcIm5vcm1hbFwiLHpJbmRleDowLFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCI6XCJyZ2JhKDAsMCwwLDApXCJ9LGIuc3R5bGUpLHRoaXMucmVuZGVyVG9DbG9uZXx8YSk7dGhpcy5fY3Vyc29yPWEuc3R5bGUuY3Vyc29yO3RoaXMucmVuZGVyZXI9Yi5mb3JFeHBvcnQ/bmV3IHVhKGEsYyxkLGIuc3R5bGUsITApOm5ldyBaYShhLGMsZCxiLnN0eWxlKTtmYSYmdGhpcy5yZW5kZXJlci5jcmVhdGUodGhpcyxhLGMsZCk7dGhpcy5yZW5kZXJlci5jaGFydEluZGV4PXRoaXMuaW5kZXh9LGdldE1hcmdpbnM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zcGFjaW5nLFxuYz10aGlzLm1hcmdpbixkPXRoaXMudGl0bGVPZmZzZXQ7dGhpcy5yZXNldE1hcmdpbnMoKTtpZihkJiYhcyhjWzBdKSl0aGlzLnBsb3RUb3A9dCh0aGlzLnBsb3RUb3AsZCt0aGlzLm9wdGlvbnMudGl0bGUubWFyZ2luK2JbMF0pO3RoaXMubGVnZW5kLmFkanVzdE1hcmdpbnMoYyxiKTt0aGlzLmV4dHJhQm90dG9tTWFyZ2luJiYodGhpcy5tYXJnaW5Cb3R0b20rPXRoaXMuZXh0cmFCb3R0b21NYXJnaW4pO3RoaXMuZXh0cmFUb3BNYXJnaW4mJih0aGlzLnBsb3RUb3ArPXRoaXMuZXh0cmFUb3BNYXJnaW4pO2F8fHRoaXMuZ2V0QXhpc01hcmdpbnMoKX0sZ2V0QXhpc01hcmdpbnM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5heGlzT2Zmc2V0PVswLDAsMCwwXSxjPWEubWFyZ2luO2EuaGFzQ2FydGVzaWFuU2VyaWVzJiZvKGEuYXhlcyxmdW5jdGlvbihhKXthLmdldE9mZnNldCgpfSk7byhnYixmdW5jdGlvbihkLGUpe3MoY1tlXSl8fChhW2RdKz1iW2VdKX0pO2Euc2V0Q2hhcnRTaXplKCl9LFxucmVmbG93OmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLm9wdGlvbnMuY2hhcnQsZD1iLnJlbmRlclRvLGU9Yy53aWR0aHx8aGIoZCxcIndpZHRoXCIpLGY9Yy5oZWlnaHR8fGhiKGQsXCJoZWlnaHRcIiksYz1hP2EudGFyZ2V0OkssZD1mdW5jdGlvbigpe2lmKGIuY29udGFpbmVyKWIuc2V0U2l6ZShlLGYsITEpLGIuaGFzVXNlclNpemU9bnVsbH07aWYoIWIuaGFzVXNlclNpemUmJiFiLmlzUHJpbnRpbmcmJmUmJmYmJihjPT09S3x8Yz09PUMpKXtpZihlIT09Yi5jb250YWluZXJXaWR0aHx8ZiE9PWIuY29udGFpbmVySGVpZ2h0KWNsZWFyVGltZW91dChiLnJlZmxvd1RpbWVvdXQpLGE/Yi5yZWZsb3dUaW1lb3V0PXNldFRpbWVvdXQoZCwxMDApOmQoKTtiLmNvbnRhaW5lcldpZHRoPWU7Yi5jb250YWluZXJIZWlnaHQ9Zn19LGluaXRSZWZsb3c6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9ZnVuY3Rpb24oYil7YS5yZWZsb3coYil9O0goSyxcInJlc2l6ZVwiLGIpO0goYSxcImRlc3Ryb3lcIixmdW5jdGlvbigpe1ooSyxcblwicmVzaXplXCIsYil9KX0sc2V0U2l6ZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcyxlLGYsZyxoPWQucmVuZGVyZXIsaT1oLmdsb2JhbEFuaW1hdGlvbjtkLmlzUmVzaXppbmcrPTE7Zz1mdW5jdGlvbigpe2QmJkkoZCxcImVuZFJlc2l6ZVwiLG51bGwsZnVuY3Rpb24oKXtkLmlzUmVzaXppbmctPTF9KX07UWEoYyxkKTtkLm9sZENoYXJ0SGVpZ2h0PWQuY2hhcnRIZWlnaHQ7ZC5vbGRDaGFydFdpZHRoPWQuY2hhcnRXaWR0aDtpZihzKGEpKWQuY2hhcnRXaWR0aD1lPXQoMCx3KGEpKSxkLmhhc1VzZXJTaXplPSEhZTtpZihzKGIpKWQuY2hhcnRIZWlnaHQ9Zj10KDAsdyhiKSk7KGk/amI6TCkoZC5jb250YWluZXIse3dpZHRoOmUrXCJweFwiLGhlaWdodDpmK1wicHhcIn0saSk7ZC5zZXRDaGFydFNpemUoITApO2guc2V0U2l6ZShlLGYsYyk7ZC5tYXhUaWNrcz1udWxsO28oZC5heGVzLGZ1bmN0aW9uKGEpe2EuaXNEaXJ0eT0hMDthLnNldFNjYWxlKCl9KTtvKGQuc2VyaWVzLGZ1bmN0aW9uKGEpe2EuaXNEaXJ0eT1cbiEwfSk7ZC5pc0RpcnR5TGVnZW5kPSEwO2QuaXNEaXJ0eUJveD0hMDtkLmxheU91dFRpdGxlcygpO2QuZ2V0TWFyZ2lucygpO2QucmVkcmF3KGMpO2Qub2xkQ2hhcnRIZWlnaHQ9bnVsbDtJKGQsXCJyZXNpemVcIik7aT09PSExP2coKTpzZXRUaW1lb3V0KGcsaSYmaS5kdXJhdGlvbnx8NTAwKX0sc2V0Q2hhcnRTaXplOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuaW52ZXJ0ZWQsYz10aGlzLnJlbmRlcmVyLGQ9dGhpcy5jaGFydFdpZHRoLGU9dGhpcy5jaGFydEhlaWdodCxmPXRoaXMub3B0aW9ucy5jaGFydCxnPXRoaXMuc3BhY2luZyxoPXRoaXMuY2xpcE9mZnNldCxpLGosayxtO3RoaXMucGxvdExlZnQ9aT13KHRoaXMucGxvdExlZnQpO3RoaXMucGxvdFRvcD1qPXcodGhpcy5wbG90VG9wKTt0aGlzLnBsb3RXaWR0aD1rPXQoMCx3KGQtaS10aGlzLm1hcmdpblJpZ2h0KSk7dGhpcy5wbG90SGVpZ2h0PW09dCgwLHcoZS1qLXRoaXMubWFyZ2luQm90dG9tKSk7dGhpcy5wbG90U2l6ZVg9Yj9tOlxuazt0aGlzLnBsb3RTaXplWT1iP2s6bTt0aGlzLnBsb3RCb3JkZXJXaWR0aD1mLnBsb3RCb3JkZXJXaWR0aHx8MDt0aGlzLnNwYWNpbmdCb3g9Yy5zcGFjaW5nQm94PXt4OmdbM10seTpnWzBdLHdpZHRoOmQtZ1szXS1nWzFdLGhlaWdodDplLWdbMF0tZ1syXX07dGhpcy5wbG90Qm94PWMucGxvdEJveD17eDppLHk6aix3aWR0aDprLGhlaWdodDptfTtkPTIqVih0aGlzLnBsb3RCb3JkZXJXaWR0aC8yKTtiPXNhKHQoZCxoWzNdKS8yKTtjPXNhKHQoZCxoWzBdKS8yKTt0aGlzLmNsaXBCb3g9e3g6Yix5OmMsd2lkdGg6Vih0aGlzLnBsb3RTaXplWC10KGQsaFsxXSkvMi1iKSxoZWlnaHQ6dCgwLFYodGhpcy5wbG90U2l6ZVktdChkLGhbMl0pLzItYykpfTthfHxvKHRoaXMuYXhlcyxmdW5jdGlvbihhKXthLnNldEF4aXNTaXplKCk7YS5zZXRBeGlzVHJhbnNsYXRpb24oKX0pfSxyZXNldE1hcmdpbnM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzO28oZ2IsZnVuY3Rpb24oYixjKXthW2JdPXAoYS5tYXJnaW5bY10sXG5hLnNwYWNpbmdbY10pfSk7YS5heGlzT2Zmc2V0PVswLDAsMCwwXTthLmNsaXBPZmZzZXQ9WzAsMCwwLDBdfSxkcmF3Q2hhcnRCb3g6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMuY2hhcnQsYj10aGlzLnJlbmRlcmVyLGM9dGhpcy5jaGFydFdpZHRoLGQ9dGhpcy5jaGFydEhlaWdodCxlPXRoaXMuY2hhcnRCYWNrZ3JvdW5kLGY9dGhpcy5wbG90QmFja2dyb3VuZCxnPXRoaXMucGxvdEJvcmRlcixoPXRoaXMucGxvdEJHSW1hZ2UsaT1hLmJvcmRlcldpZHRofHwwLGo9YS5iYWNrZ3JvdW5kQ29sb3Isaz1hLnBsb3RCYWNrZ3JvdW5kQ29sb3IsbT1hLnBsb3RCYWNrZ3JvdW5kSW1hZ2UsbD1hLnBsb3RCb3JkZXJXaWR0aHx8MCxuLHE9dGhpcy5wbG90TGVmdCxwPXRoaXMucGxvdFRvcCxvPXRoaXMucGxvdFdpZHRoLHQ9dGhpcy5wbG90SGVpZ2h0LHU9dGhpcy5wbG90Qm94LHM9dGhpcy5jbGlwUmVjdCxyPXRoaXMuY2xpcEJveDtuPWkrKGEuc2hhZG93Pzg6MCk7aWYoaXx8ailpZihlKWUuYW5pbWF0ZShlLmNyaXNwKHt3aWR0aDpjLVxubixoZWlnaHQ6ZC1ufSkpO2Vsc2V7ZT17ZmlsbDpqfHxPfTtpZihpKWUuc3Ryb2tlPWEuYm9yZGVyQ29sb3IsZVtcInN0cm9rZS13aWR0aFwiXT1pO3RoaXMuY2hhcnRCYWNrZ3JvdW5kPWIucmVjdChuLzIsbi8yLGMtbixkLW4sYS5ib3JkZXJSYWRpdXMsaSkuYXR0cihlKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYmFja2dyb3VuZFwiKS5hZGQoKS5zaGFkb3coYS5zaGFkb3cpfWlmKGspZj9mLmFuaW1hdGUodSk6dGhpcy5wbG90QmFja2dyb3VuZD1iLnJlY3QocSxwLG8sdCwwKS5hdHRyKHtmaWxsOmt9KS5hZGQoKS5zaGFkb3coYS5wbG90U2hhZG93KTtpZihtKWg/aC5hbmltYXRlKHUpOnRoaXMucGxvdEJHSW1hZ2U9Yi5pbWFnZShtLHEscCxvLHQpLmFkZCgpO3M/cy5hbmltYXRlKHt3aWR0aDpyLndpZHRoLGhlaWdodDpyLmhlaWdodH0pOnRoaXMuY2xpcFJlY3Q9Yi5jbGlwUmVjdChyKTtpZihsKWc/Zy5hbmltYXRlKGcuY3Jpc3Aoe3g6cSx5OnAsd2lkdGg6byxoZWlnaHQ6dCxzdHJva2VXaWR0aDotbH0pKTpcbnRoaXMucGxvdEJvcmRlcj1iLnJlY3QocSxwLG8sdCwwLC1sKS5hdHRyKHtzdHJva2U6YS5wbG90Qm9yZGVyQ29sb3IsXCJzdHJva2Utd2lkdGhcIjpsLGZpbGw6Tyx6SW5kZXg6MX0pLmFkZCgpO3RoaXMuaXNEaXJ0eUJveD0hMX0scHJvcEZyb21TZXJpZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5vcHRpb25zLmNoYXJ0LGMsZD1hLm9wdGlvbnMuc2VyaWVzLGUsZjtvKFtcImludmVydGVkXCIsXCJhbmd1bGFyXCIsXCJwb2xhclwiXSxmdW5jdGlvbihnKXtjPU1bYi50eXBlfHxiLmRlZmF1bHRTZXJpZXNUeXBlXTtmPWFbZ118fGJbZ118fGMmJmMucHJvdG90eXBlW2ddO2ZvcihlPWQmJmQubGVuZ3RoOyFmJiZlLS07KShjPU1bZFtlXS50eXBlXSkmJmMucHJvdG90eXBlW2ddJiYoZj0hMCk7YVtnXT1mfSl9LGxpbmtTZXJpZXM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5zZXJpZXM7byhiLGZ1bmN0aW9uKGEpe2EubGlua2VkU2VyaWVzLmxlbmd0aD0wfSk7byhiLGZ1bmN0aW9uKGIpe3ZhciBkPVxuYi5vcHRpb25zLmxpbmtlZFRvO2lmKEFhKGQpJiYoZD1kPT09XCI6cHJldmlvdXNcIj9hLnNlcmllc1tiLmluZGV4LTFdOmEuZ2V0KGQpKSlkLmxpbmtlZFNlcmllcy5wdXNoKGIpLGIubGlua2VkUGFyZW50PWQsYi52aXNpYmxlPXAoYi5vcHRpb25zLnZpc2libGUsZC5vcHRpb25zLnZpc2libGUsYi52aXNpYmxlKX0pfSxyZW5kZXJTZXJpZXM6ZnVuY3Rpb24oKXtvKHRoaXMuc2VyaWVzLGZ1bmN0aW9uKGEpe2EudHJhbnNsYXRlKCk7YS5yZW5kZXIoKX0pfSxyZW5kZXJMYWJlbHM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5vcHRpb25zLmxhYmVscztiLml0ZW1zJiZvKGIuaXRlbXMsZnVuY3Rpb24oYyl7dmFyIGQ9cihiLnN0eWxlLGMuc3R5bGUpLGU9RihkLmxlZnQpK2EucGxvdExlZnQsZj1GKGQudG9wKSthLnBsb3RUb3ArMTI7ZGVsZXRlIGQubGVmdDtkZWxldGUgZC50b3A7YS5yZW5kZXJlci50ZXh0KGMuaHRtbCxlLGYpLmF0dHIoe3pJbmRleDoyfSkuY3NzKGQpLmFkZCgpfSl9LFxucmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5heGVzLGI9dGhpcy5yZW5kZXJlcixjPXRoaXMub3B0aW9ucyxkLGUsZixnO3RoaXMuc2V0VGl0bGUoKTt0aGlzLmxlZ2VuZD1uZXcgbGIodGhpcyxjLmxlZ2VuZCk7dGhpcy5nZXRTdGFja3MmJnRoaXMuZ2V0U3RhY2tzKCk7dGhpcy5nZXRNYXJnaW5zKCEwKTt0aGlzLnNldENoYXJ0U2l6ZSgpO2Q9dGhpcy5wbG90V2lkdGg7ZT10aGlzLnBsb3RIZWlnaHQtPTEzO28oYSxmdW5jdGlvbihhKXthLnNldFNjYWxlKCl9KTt0aGlzLmdldEF4aXNNYXJnaW5zKCk7Zj1kL3RoaXMucGxvdFdpZHRoPjEuMTtnPWUvdGhpcy5wbG90SGVpZ2h0PjEuMTtpZihmfHxnKXRoaXMubWF4VGlja3M9bnVsbCxvKGEsZnVuY3Rpb24oYSl7KGEuaG9yaXomJmZ8fCFhLmhvcml6JiZnKSYmYS5zZXRUaWNrSW50ZXJ2YWwoITApfSksdGhpcy5nZXRNYXJnaW5zKCk7dGhpcy5kcmF3Q2hhcnRCb3goKTt0aGlzLmhhc0NhcnRlc2lhblNlcmllcyYmbyhhLGZ1bmN0aW9uKGEpe2EucmVuZGVyKCl9KTtcbmlmKCF0aGlzLnNlcmllc0dyb3VwKXRoaXMuc2VyaWVzR3JvdXA9Yi5nKFwic2VyaWVzLWdyb3VwXCIpLmF0dHIoe3pJbmRleDozfSkuYWRkKCk7dGhpcy5yZW5kZXJTZXJpZXMoKTt0aGlzLnJlbmRlckxhYmVscygpO3RoaXMuc2hvd0NyZWRpdHMoYy5jcmVkaXRzKTt0aGlzLmhhc1JlbmRlcmVkPSEwfSxzaG93Q3JlZGl0czpmdW5jdGlvbihhKXtpZihhLmVuYWJsZWQmJiF0aGlzLmNyZWRpdHMpdGhpcy5jcmVkaXRzPXRoaXMucmVuZGVyZXIudGV4dChhLnRleHQsMCwwKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtpZihhLmhyZWYpbG9jYXRpb24uaHJlZj1hLmhyZWZ9KS5hdHRyKHthbGlnbjphLnBvc2l0aW9uLmFsaWduLHpJbmRleDo4fSkuY3NzKGEuc3R5bGUpLmFkZCgpLmFsaWduKGEucG9zaXRpb24pfSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuYXhlcyxjPWEuc2VyaWVzLGQ9YS5jb250YWluZXIsZSxmPWQmJmQucGFyZW50Tm9kZTtJKGEsXCJkZXN0cm95XCIpO1lbYS5pbmRleF09XG52O2FiLS07YS5yZW5kZXJUby5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIik7WihhKTtmb3IoZT1iLmxlbmd0aDtlLS07KWJbZV09YltlXS5kZXN0cm95KCk7Zm9yKGU9Yy5sZW5ndGg7ZS0tOyljW2VdPWNbZV0uZGVzdHJveSgpO28oXCJ0aXRsZSxzdWJ0aXRsZSxjaGFydEJhY2tncm91bmQscGxvdEJhY2tncm91bmQscGxvdEJHSW1hZ2UscGxvdEJvcmRlcixzZXJpZXNHcm91cCxjbGlwUmVjdCxjcmVkaXRzLHBvaW50ZXIsc2Nyb2xsZXIscmFuZ2VTZWxlY3RvcixsZWdlbmQscmVzZXRab29tQnV0dG9uLHRvb2x0aXAscmVuZGVyZXJcIi5zcGxpdChcIixcIiksZnVuY3Rpb24oYil7dmFyIGM9YVtiXTtjJiZjLmRlc3Ryb3kmJihhW2JdPWMuZGVzdHJveSgpKX0pO2lmKGQpZC5pbm5lckhUTUw9XCJcIixaKGQpLGYmJlBhKGQpO2ZvcihlIGluIGEpZGVsZXRlIGFbZV19LGlzUmVhZHlUb1JlbmRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIWNhJiZLPT1LLnRvcCYmXG5DLnJlYWR5U3RhdGUhPT1cImNvbXBsZXRlXCJ8fGZhJiYhSy5jYW52Zz8oZmE/TGIucHVzaChmdW5jdGlvbigpe2EuZmlyc3RSZW5kZXIoKX0sYS5vcHRpb25zLmdsb2JhbC5jYW52YXNUb29sc1VSTCk6Qy5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7Qy5kZXRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGEuZmlyc3RSZW5kZXIpO0MucmVhZHlTdGF0ZT09PVwiY29tcGxldGVcIiYmYS5maXJzdFJlbmRlcigpfSksITEpOiEwfSxmaXJzdFJlbmRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMsYz1hLmNhbGxiYWNrO2lmKGEuaXNSZWFkeVRvUmVuZGVyKCkpe2EuZ2V0Q29udGFpbmVyKCk7SShhLFwiaW5pdFwiKTthLnJlc2V0TWFyZ2lucygpO2Euc2V0Q2hhcnRTaXplKCk7YS5wcm9wRnJvbVNlcmllcygpO2EuZ2V0QXhlcygpO28oYi5zZXJpZXN8fFtdLGZ1bmN0aW9uKGIpe2EuaW5pdFNlcmllcyhiKX0pO2EubGlua1NlcmllcygpO0koYSxcblwiYmVmb3JlUmVuZGVyXCIpO2lmKEIuUG9pbnRlcilhLnBvaW50ZXI9bmV3IFVhKGEsYik7YS5yZW5kZXIoKTthLnJlbmRlcmVyLmRyYXcoKTtjJiZjLmFwcGx5KGEsW2FdKTtvKGEuY2FsbGJhY2tzLGZ1bmN0aW9uKGIpe2EuaW5kZXghPT12JiZiLmFwcGx5KGEsW2FdKX0pO0koYSxcImxvYWRcIik7YS5jbG9uZVJlbmRlclRvKCEwKX19LHNwbGFzaEFycmF5OmZ1bmN0aW9uKGEsYil7dmFyIGM9YlthXSxjPWRhKGMpP2M6W2MsYyxjLGNdO3JldHVybltwKGJbYStcIlRvcFwiXSxjWzBdKSxwKGJbYStcIlJpZ2h0XCJdLGNbMV0pLHAoYlthK1wiQm90dG9tXCJdLGNbMl0pLHAoYlthK1wiTGVmdFwiXSxjWzNdKV19fTt2YXIgWGI9Qi5DZW50ZXJlZFNlcmllc01peGluPXtnZXRDZW50ZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj10aGlzLmNoYXJ0LGM9MiooYS5zbGljZWRPZmZzZXR8fDApLGQ9Yi5wbG90V2lkdGgtMipjLGI9Yi5wbG90SGVpZ2h0LTIqYyxlPWEuY2VudGVyLGU9W3AoZVswXSxcblwiNTAlXCIpLHAoZVsxXSxcIjUwJVwiKSxhLnNpemV8fFwiMTAwJVwiLGEuaW5uZXJTaXplfHwwXSxmPXooZCxiKSxnLGg7Zm9yKGc9MDtnPDQ7KytnKWg9ZVtnXSxhPWc8Mnx8Zz09PTImJi8lJC8udGVzdChoKSxlW2ddPSgvJSQvLnRlc3QoaCk/W2QsYixmLGVbMl1dW2ddKnBhcnNlRmxvYXQoaCkvMTAwOnBhcnNlRmxvYXQoaCkpKyhhP2M6MCk7cmV0dXJuIGV9fSxFYT1mdW5jdGlvbigpe307RWEucHJvdG90eXBlPXtpbml0OmZ1bmN0aW9uKGEsYixjKXt0aGlzLnNlcmllcz1hO3RoaXMuY29sb3I9YS5jb2xvcjt0aGlzLmFwcGx5T3B0aW9ucyhiLGMpO3RoaXMucG9pbnRBdHRyPXt9O2lmKGEub3B0aW9ucy5jb2xvckJ5UG9pbnQmJihiPWEub3B0aW9ucy5jb2xvcnN8fGEuY2hhcnQub3B0aW9ucy5jb2xvcnMsdGhpcy5jb2xvcj10aGlzLmNvbG9yfHxiW2EuY29sb3JDb3VudGVyKytdLGEuY29sb3JDb3VudGVyPT09Yi5sZW5ndGgpKWEuY29sb3JDb3VudGVyPTA7YS5jaGFydC5wb2ludENvdW50Kys7XG5yZXR1cm4gdGhpc30sYXBwbHlPcHRpb25zOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5zZXJpZXMsZD1jLm9wdGlvbnMucG9pbnRWYWxLZXl8fGMucG9pbnRWYWxLZXksYT1FYS5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0LmNhbGwodGhpcyxhKTtyKHRoaXMsYSk7dGhpcy5vcHRpb25zPXRoaXMub3B0aW9ucz9yKHRoaXMub3B0aW9ucyxhKTphO2lmKGQpdGhpcy55PXRoaXNbZF07aWYodGhpcy54PT09diYmYyl0aGlzLng9Yj09PXY/Yy5hdXRvSW5jcmVtZW50KCk6YjtyZXR1cm4gdGhpc30sb3B0aW9uc1RvT2JqZWN0OmZ1bmN0aW9uKGEpe3ZhciBiPXt9LGM9dGhpcy5zZXJpZXMsZD1jLm9wdGlvbnMua2V5cyxlPWR8fGMucG9pbnRBcnJheU1hcHx8W1wieVwiXSxmPWUubGVuZ3RoLGc9MCxoPTA7aWYodHlwZW9mIGE9PT1cIm51bWJlclwifHxhPT09bnVsbCliW2VbMF1dPWE7ZWxzZSBpZihGYShhKSl7aWYoIWQmJmEubGVuZ3RoPmYpe2M9dHlwZW9mIGFbMF07aWYoYz09PVwic3RyaW5nXCIpYi5uYW1lPVxuYVswXTtlbHNlIGlmKGM9PT1cIm51bWJlclwiKWIueD1hWzBdO2crK31mb3IoO2g8ZjspYltlW2grK11dPWFbZysrXX1lbHNlIGlmKHR5cGVvZiBhPT09XCJvYmplY3RcIil7Yj1hO2lmKGEuZGF0YUxhYmVscyljLl9oYXNQb2ludExhYmVscz0hMDtpZihhLm1hcmtlciljLl9oYXNQb2ludE1hcmtlcnM9ITB9cmV0dXJuIGJ9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllcy5jaGFydCxiPWEuaG92ZXJQb2ludHMsYzthLnBvaW50Q291bnQtLTtpZihiJiYodGhpcy5zZXRTdGF0ZSgpLGphKGIsdGhpcyksIWIubGVuZ3RoKSlhLmhvdmVyUG9pbnRzPW51bGw7aWYodGhpcz09PWEuaG92ZXJQb2ludCl0aGlzLm9uTW91c2VPdXQoKTtpZih0aGlzLmdyYXBoaWN8fHRoaXMuZGF0YUxhYmVsKVoodGhpcyksdGhpcy5kZXN0cm95RWxlbWVudHMoKTt0aGlzLmxlZ2VuZEl0ZW0mJmEubGVnZW5kLmRlc3Ryb3lJdGVtKHRoaXMpO2ZvcihjIGluIHRoaXMpdGhpc1tjXT1udWxsfSxkZXN0cm95RWxlbWVudHM6ZnVuY3Rpb24oKXtmb3IodmFyIGE9XG5cImdyYXBoaWMsZGF0YUxhYmVsLGRhdGFMYWJlbFVwcGVyLGdyb3VwLGNvbm5lY3RvcixzaGFkb3dHcm91cFwiLnNwbGl0KFwiLFwiKSxiLGM9NjtjLS07KWI9YVtjXSx0aGlzW2JdJiYodGhpc1tiXT10aGlzW2JdLmRlc3Ryb3koKSl9LGdldExhYmVsQ29uZmlnOmZ1bmN0aW9uKCl7cmV0dXJue3g6dGhpcy5jYXRlZ29yeSx5OnRoaXMueSxjb2xvcjp0aGlzLmNvbG9yLGtleTp0aGlzLm5hbWV8fHRoaXMuY2F0ZWdvcnksc2VyaWVzOnRoaXMuc2VyaWVzLHBvaW50OnRoaXMscGVyY2VudGFnZTp0aGlzLnBlcmNlbnRhZ2UsdG90YWw6dGhpcy50b3RhbHx8dGhpcy5zdGFja1RvdGFsfX0sdG9vbHRpcEZvcm1hdHRlcjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnNlcmllcyxjPWIudG9vbHRpcE9wdGlvbnMsZD1wKGMudmFsdWVEZWNpbWFscyxcIlwiKSxlPWMudmFsdWVQcmVmaXh8fFwiXCIsZj1jLnZhbHVlU3VmZml4fHxcIlwiO28oYi5wb2ludEFycmF5TWFwfHxbXCJ5XCJdLGZ1bmN0aW9uKGIpe2I9XCJ7cG9pbnQuXCIrXG5iO2lmKGV8fGYpYT1hLnJlcGxhY2UoYitcIn1cIixlK2IrXCJ9XCIrZik7YT1hLnJlcGxhY2UoYitcIn1cIixiK1wiOiwuXCIrZCtcImZ9XCIpfSk7cmV0dXJuIEhhKGEse3BvaW50OnRoaXMsc2VyaWVzOnRoaXMuc2VyaWVzfSl9LGZpcmVQb2ludEV2ZW50OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLGU9dGhpcy5zZXJpZXMub3B0aW9uczsoZS5wb2ludC5ldmVudHNbYV18fGQub3B0aW9ucyYmZC5vcHRpb25zLmV2ZW50cyYmZC5vcHRpb25zLmV2ZW50c1thXSkmJnRoaXMuaW1wb3J0RXZlbnRzKCk7YT09PVwiY2xpY2tcIiYmZS5hbGxvd1BvaW50U2VsZWN0JiYoYz1mdW5jdGlvbihhKXtkLnNlbGVjdCYmZC5zZWxlY3QobnVsbCxhLmN0cmxLZXl8fGEubWV0YUtleXx8YS5zaGlmdEtleSl9KTtJKHRoaXMsYSxiLGMpfX07dmFyIFI9Qi5TZXJpZXM9ZnVuY3Rpb24oKXt9O1IucHJvdG90eXBlPXtpc0NhcnRlc2lhbjohMCx0eXBlOlwibGluZVwiLHBvaW50Q2xhc3M6RWEsc29ydGVkOiEwLHJlcXVpcmVTb3J0aW5nOiEwLFxucG9pbnRBdHRyVG9PcHRpb25zOntzdHJva2U6XCJsaW5lQ29sb3JcIixcInN0cm9rZS13aWR0aFwiOlwibGluZVdpZHRoXCIsZmlsbDpcImZpbGxDb2xvclwiLHI6XCJyYWRpdXNcIn0sYXhpc1R5cGVzOltcInhBeGlzXCIsXCJ5QXhpc1wiXSxjb2xvckNvdW50ZXI6MCxwYXJhbGxlbEFycmF5czpbXCJ4XCIsXCJ5XCJdLGluaXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQsZSxmPWEuc2VyaWVzLGc9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gcChhLm9wdGlvbnMuaW5kZXgsYS5faSktcChiLm9wdGlvbnMuaW5kZXgsYi5faSl9O2MuY2hhcnQ9YTtjLm9wdGlvbnM9Yj1jLnNldE9wdGlvbnMoYik7Yy5saW5rZWRTZXJpZXM9W107Yy5iaW5kQXhlcygpO3IoYyx7bmFtZTpiLm5hbWUsc3RhdGU6XCJcIixwb2ludEF0dHI6e30sdmlzaWJsZTpiLnZpc2libGUhPT0hMSxzZWxlY3RlZDpiLnNlbGVjdGVkPT09ITB9KTtpZihmYSliLmFuaW1hdGlvbj0hMTtlPWIuZXZlbnRzO2ZvcihkIGluIGUpSChjLGQsZVtkXSk7aWYoZSYmZS5jbGlja3x8XG5iLnBvaW50JiZiLnBvaW50LmV2ZW50cyYmYi5wb2ludC5ldmVudHMuY2xpY2t8fGIuYWxsb3dQb2ludFNlbGVjdClhLnJ1blRyYWNrZXJDbGljaz0hMDtjLmdldENvbG9yKCk7Yy5nZXRTeW1ib2woKTtvKGMucGFyYWxsZWxBcnJheXMsZnVuY3Rpb24oYSl7Y1thK1wiRGF0YVwiXT1bXX0pO2Muc2V0RGF0YShiLmRhdGEsITEpO2lmKGMuaXNDYXJ0ZXNpYW4pYS5oYXNDYXJ0ZXNpYW5TZXJpZXM9ITA7Zi5wdXNoKGMpO2MuX2k9Zi5sZW5ndGgtMTtwYihmLGcpO3RoaXMueUF4aXMmJnBiKHRoaXMueUF4aXMuc2VyaWVzLGcpO28oZixmdW5jdGlvbihhLGIpe2EuaW5kZXg9YjthLm5hbWU9YS5uYW1lfHxcIlNlcmllcyBcIisoYisxKX0pfSxiaW5kQXhlczpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMsYz1hLmNoYXJ0LGQ7byhhLmF4aXNUeXBlc3x8W10sZnVuY3Rpb24oZSl7byhjW2VdLGZ1bmN0aW9uKGMpe2Q9Yy5vcHRpb25zO2lmKGJbZV09PT1kLmluZGV4fHxiW2VdIT09diYmXG5iW2VdPT09ZC5pZHx8YltlXT09PXYmJmQuaW5kZXg9PT0wKWMuc2VyaWVzLnB1c2goYSksYVtlXT1jLGMuaXNEaXJ0eT0hMH0pOyFhW2VdJiZhLm9wdGlvbmFsQXhpcyE9PWUmJmxhKDE4LCEwKX0pfSx1cGRhdGVQYXJhbGxlbEFycmF5czpmdW5jdGlvbihhLGIpe3ZhciBjPWEuc2VyaWVzLGQ9YXJndW1lbnRzO28oYy5wYXJhbGxlbEFycmF5cyx0eXBlb2YgYj09PVwibnVtYmVyXCI/ZnVuY3Rpb24oZCl7dmFyIGY9ZD09PVwieVwiJiZjLnRvWURhdGE/Yy50b1lEYXRhKGEpOmFbZF07Y1tkK1wiRGF0YVwiXVtiXT1mfTpmdW5jdGlvbihhKXtBcnJheS5wcm90b3R5cGVbYl0uYXBwbHkoY1thK1wiRGF0YVwiXSxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkLDIpKX0pfSxhdXRvSW5jcmVtZW50OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9dGhpcy54SW5jcmVtZW50LGMsZD1hLnBvaW50SW50ZXJ2YWxVbml0LGI9cChiLGEucG9pbnRTdGFydCwwKTt0aGlzLnBvaW50SW50ZXJ2YWw9Yz1cbnAodGhpcy5wb2ludEludGVydmFsLGEucG9pbnRJbnRlcnZhbCwxKTtpZihkPT09XCJtb250aFwifHxkPT09XCJ5ZWFyXCIpYT1uZXcgeWEoYiksYT1kPT09XCJtb250aFwiPythW3ViXShhW1hhXSgpK2MpOithW3ZiXShhW1lhXSgpK2MpLGM9YS1iO3RoaXMueEluY3JlbWVudD1iK2M7cmV0dXJuIGJ9LGdldFNlZ21lbnRzOmZ1bmN0aW9uKCl7dmFyIGE9LTEsYj1bXSxjLGQ9dGhpcy5wb2ludHMsZT1kLmxlbmd0aDtpZihlKWlmKHRoaXMub3B0aW9ucy5jb25uZWN0TnVsbHMpe2ZvcihjPWU7Yy0tOylkW2NdLnk9PT1udWxsJiZkLnNwbGljZShjLDEpO2QubGVuZ3RoJiYoYj1bZF0pfWVsc2UgbyhkLGZ1bmN0aW9uKGMsZyl7Yy55PT09bnVsbD8oZz5hKzEmJmIucHVzaChkLnNsaWNlKGErMSxnKSksYT1nKTpnPT09ZS0xJiZiLnB1c2goZC5zbGljZShhKzEsZysxKSl9KTt0aGlzLnNlZ21lbnRzPWJ9LHNldE9wdGlvbnM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPWIub3B0aW9ucy5wbG90T3B0aW9ucyxcbmI9Yi51c2VyT3B0aW9uc3x8e30sZD1iLnBsb3RPcHRpb25zfHx7fSxlPWNbdGhpcy50eXBlXTt0aGlzLnVzZXJPcHRpb25zPWE7Yz1BKGUsYy5zZXJpZXMsYSk7dGhpcy50b29sdGlwT3B0aW9ucz1BKFMudG9vbHRpcCxTLnBsb3RPcHRpb25zW3RoaXMudHlwZV0udG9vbHRpcCxiLnRvb2x0aXAsZC5zZXJpZXMmJmQuc2VyaWVzLnRvb2x0aXAsZFt0aGlzLnR5cGVdJiZkW3RoaXMudHlwZV0udG9vbHRpcCxhLnRvb2x0aXApO2UubWFya2VyPT09bnVsbCYmZGVsZXRlIGMubWFya2VyO3RoaXMuem9uZUF4aXM9Yy56b25lQXhpczthPXRoaXMuem9uZXM9KGMuem9uZXN8fFtdKS5zbGljZSgpO2lmKChjLm5lZ2F0aXZlQ29sb3J8fGMubmVnYXRpdmVGaWxsQ29sb3IpJiYhYy56b25lcylhLnB1c2goe3ZhbHVlOmNbdGhpcy56b25lQXhpcytcIlRocmVzaG9sZFwiXXx8Yy50aHJlc2hvbGR8fDAsY29sb3I6Yy5uZWdhdGl2ZUNvbG9yLGZpbGxDb2xvcjpjLm5lZ2F0aXZlRmlsbENvbG9yfSk7YS5sZW5ndGgmJlxucyhhW2EubGVuZ3RoLTFdLnZhbHVlKSYmYS5wdXNoKHtjb2xvcjp0aGlzLmNvbG9yLGZpbGxDb2xvcjp0aGlzLmZpbGxDb2xvcn0pO3JldHVybiBjfSxnZXRDeWNsaWM6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMudXNlck9wdGlvbnMsZT1cIl9cIithK1wiSW5kZXhcIixmPWErXCJDb3VudGVyXCI7Ynx8KHMoZFtlXSk/Yj1kW2VdOihkW2VdPWI9dGhpcy5jaGFydFtmXSVjLmxlbmd0aCx0aGlzLmNoYXJ0W2ZdKz0xKSxiPWNbYl0pO3RoaXNbYV09Yn0sZ2V0Q29sb3I6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuY29sb3JCeVBvaW50P3RoaXMub3B0aW9ucy5jb2xvcj1udWxsOnRoaXMuZ2V0Q3ljbGljKFwiY29sb3JcIix0aGlzLm9wdGlvbnMuY29sb3J8fGJhW3RoaXMudHlwZV0uY29sb3IsdGhpcy5jaGFydC5vcHRpb25zLmNvbG9ycyl9LGdldFN5bWJvbDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5tYXJrZXI7dGhpcy5nZXRDeWNsaWMoXCJzeW1ib2xcIixhLnN5bWJvbCx0aGlzLmNoYXJ0Lm9wdGlvbnMuc3ltYm9scyk7XG5pZigvXnVybC8udGVzdCh0aGlzLnN5bWJvbCkpYS5yYWRpdXM9MH0sZHJhd0xlZ2VuZFN5bWJvbDpMYS5kcmF3TGluZU1hcmtlcixzZXREYXRhOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMsZj1lLnBvaW50cyxnPWYmJmYubGVuZ3RofHwwLGgsaT1lLm9wdGlvbnMsaj1lLmNoYXJ0LGs9bnVsbCxtPWUueEF4aXMsbD1tJiYhIW0uY2F0ZWdvcmllcyxuPWkudHVyYm9UaHJlc2hvbGQscT10aGlzLnhEYXRhLHg9dGhpcy55RGF0YSx0PShoPWUucG9pbnRBcnJheU1hcCkmJmgubGVuZ3RoLGE9YXx8W107aD1hLmxlbmd0aDtiPXAoYiwhMCk7aWYoZCE9PSExJiZoJiZnPT09aCYmIWUuY3JvcHBlZCYmIWUuaGFzR3JvdXBlZERhdGEmJmUudmlzaWJsZSlvKGEsZnVuY3Rpb24oYSxiKXtmW2JdLnVwZGF0ZSYmZltiXS51cGRhdGUoYSwhMSxudWxsLCExKX0pO2Vsc2V7ZS54SW5jcmVtZW50PW51bGw7ZS5wb2ludFJhbmdlPWw/MTppLnBvaW50UmFuZ2U7ZS5jb2xvckNvdW50ZXI9MDtvKHRoaXMucGFyYWxsZWxBcnJheXMsXG5mdW5jdGlvbihhKXtlW2ErXCJEYXRhXCJdLmxlbmd0aD0wfSk7aWYobiYmaD5uKXtmb3IoYz0wO2s9PT1udWxsJiZjPGg7KWs9YVtjXSxjKys7aWYocWEoaykpe2w9cChpLnBvaW50U3RhcnQsMCk7aT1wKGkucG9pbnRJbnRlcnZhbCwxKTtmb3IoYz0wO2M8aDtjKyspcVtjXT1sLHhbY109YVtjXSxsKz1pO2UueEluY3JlbWVudD1sfWVsc2UgaWYoRmEoaykpaWYodClmb3IoYz0wO2M8aDtjKyspaT1hW2NdLHFbY109aVswXSx4W2NdPWkuc2xpY2UoMSx0KzEpO2Vsc2UgZm9yKGM9MDtjPGg7YysrKWk9YVtjXSxxW2NdPWlbMF0seFtjXT1pWzFdO2Vsc2UgbGEoMTIpfWVsc2UgZm9yKGM9MDtjPGg7YysrKWlmKGFbY10hPT12JiYoaT17c2VyaWVzOmV9LGUucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KGksW2FbY11dKSxlLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGksYyksbCYmcyhpLm5hbWUpKSltLm5hbWVzW2kueF09aS5uYW1lO0FhKHhbMF0pJiZsYSgxNCwhMCk7ZS5kYXRhPVxuW107ZS5vcHRpb25zLmRhdGE9YTtmb3IoYz1nO2MtLTspZltjXSYmZltjXS5kZXN0cm95JiZmW2NdLmRlc3Ryb3koKTtpZihtKW0ubWluUmFuZ2U9bS51c2VyTWluUmFuZ2U7ZS5pc0RpcnR5PWUuaXNEaXJ0eURhdGE9ai5pc0RpcnR5Qm94PSEwO2M9ITF9YiYmai5yZWRyYXcoYyl9LHByb2Nlc3NEYXRhOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMueERhdGEsYz10aGlzLnlEYXRhLGQ9Yi5sZW5ndGgsZTtlPTA7dmFyIGYsZyxoPXRoaXMueEF4aXMsaSxqPXRoaXMub3B0aW9ucztpPWouY3JvcFRocmVzaG9sZDt2YXIgaz10aGlzLmlzQ2FydGVzaWFuLG0sbDtpZihrJiYhdGhpcy5pc0RpcnR5JiYhaC5pc0RpcnR5JiYhdGhpcy55QXhpcy5pc0RpcnR5JiYhYSlyZXR1cm4hMTtpZihoKWE9aC5nZXRFeHRyZW1lcygpLG09YS5taW4sbD1hLm1heDtpZihrJiZ0aGlzLnNvcnRlZCYmKCFpfHxkPml8fHRoaXMuZm9yY2VDcm9wKSlpZihiW2QtMV08bXx8YlswXT5sKWI9W10sYz1bXTtlbHNlIGlmKGJbMF08XG5tfHxiW2QtMV0+bCllPXRoaXMuY3JvcERhdGEodGhpcy54RGF0YSx0aGlzLnlEYXRhLG0sbCksYj1lLnhEYXRhLGM9ZS55RGF0YSxlPWUuc3RhcnQsZj0hMDtmb3IoaT1iLmxlbmd0aC0xO2k+PTA7aS0tKWQ9YltpXS1iW2ktMV0sZD4wJiYoZz09PXZ8fGQ8Zyk/Zz1kOmQ8MCYmdGhpcy5yZXF1aXJlU29ydGluZyYmbGEoMTUpO3RoaXMuY3JvcHBlZD1mO3RoaXMuY3JvcFN0YXJ0PWU7dGhpcy5wcm9jZXNzZWRYRGF0YT1iO3RoaXMucHJvY2Vzc2VkWURhdGE9YztpZihqLnBvaW50UmFuZ2U9PT1udWxsKXRoaXMucG9pbnRSYW5nZT1nfHwxO3RoaXMuY2xvc2VzdFBvaW50UmFuZ2U9Z30sY3JvcERhdGE6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS5sZW5ndGgsZj0wLGc9ZSxoPXAodGhpcy5jcm9wU2hvdWxkZXIsMSksaTtmb3IoaT0wO2k8ZTtpKyspaWYoYVtpXT49Yyl7Zj10KDAsaS1oKTticmVha31mb3IoO2k8ZTtpKyspaWYoYVtpXT5kKXtnPWkraDticmVha31yZXR1cm57eERhdGE6YS5zbGljZShmLFxuZykseURhdGE6Yi5zbGljZShmLGcpLHN0YXJ0OmYsZW5kOmd9fSxnZW5lcmF0ZVBvaW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5kYXRhLGI9dGhpcy5kYXRhLGMsZD10aGlzLnByb2Nlc3NlZFhEYXRhLGU9dGhpcy5wcm9jZXNzZWRZRGF0YSxmPXRoaXMucG9pbnRDbGFzcyxnPWQubGVuZ3RoLGg9dGhpcy5jcm9wU3RhcnR8fDAsaSxqPXRoaXMuaGFzR3JvdXBlZERhdGEsayxtPVtdLGw7aWYoIWImJiFqKWI9W10sYi5sZW5ndGg9YS5sZW5ndGgsYj10aGlzLmRhdGE9Yjtmb3IobD0wO2w8ZztsKyspaT1oK2wsaj9tW2xdPShuZXcgZikuaW5pdCh0aGlzLFtkW2xdXS5jb25jYXQocmEoZVtsXSkpKTooYltpXT9rPWJbaV06YVtpXSE9PXYmJihiW2ldPWs9KG5ldyBmKS5pbml0KHRoaXMsYVtpXSxkW2xdKSksbVtsXT1rKSxtW2xdLmluZGV4PWk7aWYoYiYmKGchPT0oYz1iLmxlbmd0aCl8fGopKWZvcihsPTA7bDxjO2wrKylpZihsPT09aCYmIWomJihsKz1nKSxiW2xdKWJbbF0uZGVzdHJveUVsZW1lbnRzKCksXG5iW2xdLnBsb3RYPXY7dGhpcy5kYXRhPWI7dGhpcy5wb2ludHM9bX0sZ2V0RXh0cmVtZXM6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy55QXhpcyxjPXRoaXMucHJvY2Vzc2VkWERhdGEsZCxlPVtdLGY9MDtkPXRoaXMueEF4aXMuZ2V0RXh0cmVtZXMoKTt2YXIgZz1kLm1pbixoPWQubWF4LGksaixrLG0sYT1hfHx0aGlzLnN0YWNrZWRZRGF0YXx8dGhpcy5wcm9jZXNzZWRZRGF0YTtkPWEubGVuZ3RoO2ZvcihtPTA7bTxkO20rKylpZihqPWNbbV0saz1hW21dLGk9ayE9PW51bGwmJmshPT12JiYoIWIuaXNMb2d8fGsubGVuZ3RofHxrPjApLGo9dGhpcy5nZXRFeHRyZW1lc0Zyb21BbGx8fHRoaXMub3B0aW9ucy5nZXRFeHRyZW1lc0Zyb21BbGx8fHRoaXMuY3JvcHBlZHx8KGNbbSsxXXx8aik+PWcmJihjW20tMV18fGopPD1oLGkmJmopaWYoaT1rLmxlbmd0aClmb3IoO2ktLTspa1tpXSE9PW51bGwmJihlW2YrK109a1tpXSk7ZWxzZSBlW2YrK109azt0aGlzLmRhdGFNaW49TmEoZSk7dGhpcy5kYXRhTWF4PVxuQ2EoZSl9LHRyYW5zbGF0ZTpmdW5jdGlvbigpe3RoaXMucHJvY2Vzc2VkWERhdGF8fHRoaXMucHJvY2Vzc0RhdGEoKTt0aGlzLmdlbmVyYXRlUG9pbnRzKCk7Zm9yKHZhciBhPXRoaXMub3B0aW9ucyxiPWEuc3RhY2tpbmcsYz10aGlzLnhBeGlzLGQ9Yy5jYXRlZ29yaWVzLGU9dGhpcy55QXhpcyxmPXRoaXMucG9pbnRzLGc9Zi5sZW5ndGgsaD0hIXRoaXMubW9kaWZ5VmFsdWUsaT1hLnBvaW50UGxhY2VtZW50LGo9aT09PVwiYmV0d2VlblwifHxxYShpKSxrPWEudGhyZXNob2xkLG09YS5zdGFydEZyb21UaHJlc2hvbGQ/azowLGwsbixxLG89TnVtYmVyLk1BWF9WQUxVRSxhPTA7YTxnO2ErKyl7dmFyIHI9ZlthXSx3PXIueCx1PXIueTtuPXIubG93O3ZhciB5PWImJmUuc3RhY2tzWyh0aGlzLm5lZ1N0YWNrcyYmdTwobT8wOmspP1wiLVwiOlwiXCIpK3RoaXMuc3RhY2tLZXldO2lmKGUuaXNMb2cmJnUhPT1udWxsJiZ1PD0wKXIueT11PW51bGwsbGEoMTApO3IucGxvdFg9bD16KHQoLTFFNSxjLnRyYW5zbGF0ZSh3LFxuMCwwLDAsMSxpLHRoaXMudHlwZT09PVwiZmxhZ3NcIikpLDFFNSk7aWYoYiYmdGhpcy52aXNpYmxlJiZ5JiZ5W3ddKXk9eVt3XSx1PXkucG9pbnRzW3RoaXMuaW5kZXgrXCIsXCIrYV0sbj11WzBdLHU9dVsxXSxuPT09bSYmKG49cChrLGUubWluKSksZS5pc0xvZyYmbjw9MCYmKG49bnVsbCksci50b3RhbD1yLnN0YWNrVG90YWw9eS50b3RhbCxyLnBlcmNlbnRhZ2U9eS50b3RhbCYmci55L3kudG90YWwqMTAwLHIuc3RhY2tZPXUseS5zZXRPZmZzZXQodGhpcy5wb2ludFhPZmZzZXR8fDAsdGhpcy5iYXJXfHwwKTtyLnlCb3R0b209cyhuKT9lLnRyYW5zbGF0ZShuLDAsMSwwLDEpOm51bGw7aCYmKHU9dGhpcy5tb2RpZnlWYWx1ZSh1LHIpKTtyLnBsb3RZPW49dHlwZW9mIHU9PT1cIm51bWJlclwiJiZ1IT09SW5maW5pdHk/eih0KC0xRTUsZS50cmFuc2xhdGUodSwwLDEsMCwxKSksMUU1KTp2O3IuaXNJbnNpZGU9biE9PXYmJm4+PTAmJm48PWUubGVuJiZsPj0wJiZsPD1jLmxlbjtyLmNsaWVudFg9XG5qP2MudHJhbnNsYXRlKHcsMCwwLDAsMSk6bDtyLm5lZ2F0aXZlPXIueTwoa3x8MCk7ci5jYXRlZ29yeT1kJiZkW3IueF0hPT12P2Rbci54XTpyLng7YSYmKG89eihvLE4obC1xKSkpO3E9bH10aGlzLmNsb3Nlc3RQb2ludFJhbmdlUHg9bzt0aGlzLmdldFNlZ21lbnRzKCl9LHNldENsaXA6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPWIucmVuZGVyZXIsZD1iLmludmVydGVkLGU9dGhpcy5jbGlwQm94LGY9ZXx8Yi5jbGlwQm94LGc9dGhpcy5zaGFyZWRDbGlwS2V5fHxbXCJfc2hhcmVkQ2xpcFwiLGEmJmEuZHVyYXRpb24sYSYmYS5lYXNpbmcsZi5oZWlnaHRdLmpvaW4oXCIsXCIpLGg9YltnXSxpPWJbZytcIm1cIl07aWYoIWgpe2lmKGEpZi53aWR0aD0wLGJbZytcIm1cIl09aT1jLmNsaXBSZWN0KC05OSxkPy1iLnBsb3RMZWZ0Oi1iLnBsb3RUb3AsOTksZD9iLmNoYXJ0V2lkdGg6Yi5jaGFydEhlaWdodCk7YltnXT1oPWMuY2xpcFJlY3QoZil9YSYmKGguY291bnQrPTEpO2lmKHRoaXMub3B0aW9ucy5jbGlwIT09XG4hMSl0aGlzLmdyb3VwLmNsaXAoYXx8ZT9oOmIuY2xpcFJlY3QpLHRoaXMubWFya2VyR3JvdXAuY2xpcChpKSx0aGlzLnNoYXJlZENsaXBLZXk9ZzthfHwoaC5jb3VudC09MSxoLmNvdW50PD0wJiZnJiZiW2ddJiYoZXx8KGJbZ109YltnXS5kZXN0cm95KCkpLGJbZytcIm1cIl0mJihiW2crXCJtXCJdPWJbZytcIm1cIl0uZGVzdHJveSgpKSkpfSxhbmltYXRlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsYz10aGlzLm9wdGlvbnMuYW5pbWF0aW9uLGQ7aWYoYyYmIWRhKGMpKWM9YmFbdGhpcy50eXBlXS5hbmltYXRpb247YT90aGlzLnNldENsaXAoYyk6KGQ9dGhpcy5zaGFyZWRDbGlwS2V5LChhPWJbZF0pJiZhLmFuaW1hdGUoe3dpZHRoOmIucGxvdFNpemVYfSxjKSxiW2QrXCJtXCJdJiZiW2QrXCJtXCJdLmFuaW1hdGUoe3dpZHRoOmIucGxvdFNpemVYKzk5fSxjKSx0aGlzLmFuaW1hdGU9bnVsbCl9LGFmdGVyQW5pbWF0ZTpmdW5jdGlvbigpe3RoaXMuc2V0Q2xpcCgpO0kodGhpcyxcImFmdGVyQW5pbWF0ZVwiKX0sXG5kcmF3UG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGEsYj10aGlzLnBvaW50cyxjPXRoaXMuY2hhcnQsZCxlLGYsZyxoLGksaixrLG09dGhpcy5vcHRpb25zLm1hcmtlcixsPXRoaXMucG9pbnRBdHRyW1wiXCJdLG4scSxvLHQ9dGhpcy5tYXJrZXJHcm91cCxzPXAobS5lbmFibGVkLHRoaXMueEF4aXMuaXNSYWRpYWwsdGhpcy5jbG9zZXN0UG9pbnRSYW5nZVB4PjIqbS5yYWRpdXMpO2lmKG0uZW5hYmxlZCE9PSExfHx0aGlzLl9oYXNQb2ludE1hcmtlcnMpZm9yKGY9Yi5sZW5ndGg7Zi0tOylpZihnPWJbZl0sZD1WKGcucGxvdFgpLGU9Zy5wbG90WSxrPWcuZ3JhcGhpYyxuPWcubWFya2VyfHx7fSxxPSEhZy5tYXJrZXIsYT1zJiZuLmVuYWJsZWQ9PT12fHxuLmVuYWJsZWQsbz1nLmlzSW5zaWRlLGEmJmUhPT12JiYhaXNOYU4oZSkmJmcueSE9PW51bGwpaWYoYT1nLnBvaW50QXR0cltnLnNlbGVjdGVkP1wic2VsZWN0XCI6XCJcIl18fGwsaD1hLnIsaT1wKG4uc3ltYm9sLHRoaXMuc3ltYm9sKSxqPWkuaW5kZXhPZihcInVybFwiKT09PVxuMCxrKWtbbz9cInNob3dcIjpcImhpZGVcIl0oITApLmFuaW1hdGUocih7eDpkLWgseTplLWh9LGsuc3ltYm9sTmFtZT97d2lkdGg6MipoLGhlaWdodDoyKmh9Ont9KSk7ZWxzZXtpZihvJiYoaD4wfHxqKSlnLmdyYXBoaWM9Yy5yZW5kZXJlci5zeW1ib2woaSxkLWgsZS1oLDIqaCwyKmgscT9uOm0pLmF0dHIoYSkuYWRkKHQpfWVsc2UgaWYoaylnLmdyYXBoaWM9ay5kZXN0cm95KCl9LGNvbnZlcnRBdHRyaWJzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMucG9pbnRBdHRyVG9PcHRpb25zLGYsZyxoPXt9LGE9YXx8e30sYj1ifHx7fSxjPWN8fHt9LGQ9ZHx8e307Zm9yKGYgaW4gZSlnPWVbZl0saFtmXT1wKGFbZ10sYltmXSxjW2ZdLGRbZl0pO3JldHVybiBofSxnZXRBdHRyaWJzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEub3B0aW9ucyxjPWJhW2EudHlwZV0ubWFya2VyP2IubWFya2VyOmIsZD1jLnN0YXRlcyxlPWQuaG92ZXIsZixnPWEuY29sb3IsaD1hLm9wdGlvbnMubmVnYXRpdmVDb2xvcjtcbmY9e3N0cm9rZTpnLGZpbGw6Z307dmFyIGk9YS5wb2ludHN8fFtdLGosayxtPVtdLGw9YS5wb2ludEF0dHJUb09wdGlvbnM7aj1hLmhhc1BvaW50U3BlY2lmaWNPcHRpb25zO3ZhciBuPWMubGluZUNvbG9yLHE9Yy5maWxsQ29sb3I7az1iLnR1cmJvVGhyZXNob2xkO3ZhciBwPWEuem9uZXMsdD1hLnpvbmVBeGlzfHxcInlcIix3O2IubWFya2VyPyhlLnJhZGl1cz1lLnJhZGl1c3x8Yy5yYWRpdXMrZS5yYWRpdXNQbHVzLGUubGluZVdpZHRoPWUubGluZVdpZHRofHxjLmxpbmVXaWR0aCtlLmxpbmVXaWR0aFBsdXMpOihlLmNvbG9yPWUuY29sb3J8fG5hKGUuY29sb3J8fGcpLmJyaWdodGVuKGUuYnJpZ2h0bmVzcykuZ2V0KCksZS5uZWdhdGl2ZUNvbG9yPWUubmVnYXRpdmVDb2xvcnx8bmEoZS5uZWdhdGl2ZUNvbG9yfHxoKS5icmlnaHRlbihlLmJyaWdodG5lc3MpLmdldCgpKTttW1wiXCJdPWEuY29udmVydEF0dHJpYnMoYyxmKTtvKFtcImhvdmVyXCIsXCJzZWxlY3RcIl0sZnVuY3Rpb24oYil7bVtiXT1cbmEuY29udmVydEF0dHJpYnMoZFtiXSxtW1wiXCJdKX0pO2EucG9pbnRBdHRyPW07Zz1pLmxlbmd0aDtpZigha3x8ZzxrfHxqKWZvcig7Zy0tOyl7az1pW2ddO2lmKChjPWsub3B0aW9ucyYmay5vcHRpb25zLm1hcmtlcnx8ay5vcHRpb25zKSYmYy5lbmFibGVkPT09ITEpYy5yYWRpdXM9MDtpZihwLmxlbmd0aCl7aj0wO2ZvcihmPXBbal07a1t0XT49Zi52YWx1ZTspZj1wWysral07aWYoZi5jb2xvcilrLmNvbG9yPWsuZmlsbENvbG9yPWYuY29sb3J9aj1iLmNvbG9yQnlQb2ludHx8ay5jb2xvcjtpZihrLm9wdGlvbnMpZm9yKHcgaW4gbClzKGNbbFt3XV0pJiYoaj0hMCk7aWYoail7Yz1jfHx7fTtqPVtdO2Q9Yy5zdGF0ZXN8fHt9O2Y9ZC5ob3Zlcj1kLmhvdmVyfHx7fTtpZighYi5tYXJrZXIpZi5jb2xvcj1mLmNvbG9yfHwhay5vcHRpb25zLmNvbG9yJiZlW2submVnYXRpdmUmJmg/XCJuZWdhdGl2ZUNvbG9yXCI6XCJjb2xvclwiXXx8bmEoay5jb2xvcikuYnJpZ2h0ZW4oZi5icmlnaHRuZXNzfHxcbmUuYnJpZ2h0bmVzcykuZ2V0KCk7Zj17Y29sb3I6ay5jb2xvcn07aWYoIXEpZi5maWxsQ29sb3I9ay5jb2xvcjtpZighbilmLmxpbmVDb2xvcj1rLmNvbG9yO2MuaGFzT3duUHJvcGVydHkoXCJjb2xvclwiKSYmIWMuY29sb3ImJmRlbGV0ZSBjLmNvbG9yO2pbXCJcIl09YS5jb252ZXJ0QXR0cmlicyhyKGYsYyksbVtcIlwiXSk7ai5ob3Zlcj1hLmNvbnZlcnRBdHRyaWJzKGQuaG92ZXIsbS5ob3ZlcixqW1wiXCJdKTtqLnNlbGVjdD1hLmNvbnZlcnRBdHRyaWJzKGQuc2VsZWN0LG0uc2VsZWN0LGpbXCJcIl0pfWVsc2Ugaj1tO2sucG9pbnRBdHRyPWp9fSxkZXN0cm95OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY2hhcnQsYz0vQXBwbGVXZWJLaXRcXC81MzMvLnRlc3QoemEpLGQsZT1hLmRhdGF8fFtdLGYsZyxoO0koYSxcImRlc3Ryb3lcIik7WihhKTtvKGEuYXhpc1R5cGVzfHxbXSxmdW5jdGlvbihiKXtpZihoPWFbYl0pamEoaC5zZXJpZXMsYSksaC5pc0RpcnR5PWguZm9yY2VSZWRyYXc9ITB9KTthLmxlZ2VuZEl0ZW0mJlxuYS5jaGFydC5sZWdlbmQuZGVzdHJveUl0ZW0oYSk7Zm9yKGQ9ZS5sZW5ndGg7ZC0tOykoZj1lW2RdKSYmZi5kZXN0cm95JiZmLmRlc3Ryb3koKTthLnBvaW50cz1udWxsO2NsZWFyVGltZW91dChhLmFuaW1hdGlvblRpbWVvdXQpO2ZvcihnIGluIGEpYVtnXWluc3RhbmNlb2YgUCYmIWFbZ10uc3Vydml2ZSYmKGQ9YyYmZz09PVwiZ3JvdXBcIj9cImhpZGVcIjpcImRlc3Ryb3lcIixhW2ddW2RdKCkpO2lmKGIuaG92ZXJTZXJpZXM9PT1hKWIuaG92ZXJTZXJpZXM9bnVsbDtqYShiLnNlcmllcyxhKTtmb3IoZyBpbiBhKWRlbGV0ZSBhW2ddfSxnZXRTZWdtZW50UGF0aDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9W10sZD1iLm9wdGlvbnMuc3RlcDtvKGEsZnVuY3Rpb24oZSxmKXt2YXIgZz1lLnBsb3RYLGg9ZS5wbG90WSxpO2IuZ2V0UG9pbnRTcGxpbmU/Yy5wdXNoLmFwcGx5KGMsYi5nZXRQb2ludFNwbGluZShhLGUsZikpOihjLnB1c2goZj9cIkxcIjpcIk1cIiksZCYmZiYmKGk9YVtmLTFdLGQ9PT1cInJpZ2h0XCI/XG5jLnB1c2goaS5wbG90WCxoKTpkPT09XCJjZW50ZXJcIj9jLnB1c2goKGkucGxvdFgrZykvMixpLnBsb3RZLChpLnBsb3RYK2cpLzIsaCk6Yy5wdXNoKGcsaS5wbG90WSkpLGMucHVzaChlLnBsb3RYLGUucGxvdFkpKX0pO3JldHVybiBjfSxnZXRHcmFwaFBhdGg6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9W10sYyxkPVtdO28oYS5zZWdtZW50cyxmdW5jdGlvbihlKXtjPWEuZ2V0U2VnbWVudFBhdGgoZSk7ZS5sZW5ndGg+MT9iPWIuY29uY2F0KGMpOmQucHVzaChlWzBdKX0pO2Euc2luZ2xlUG9pbnRzPWQ7cmV0dXJuIGEuZ3JhcGhQYXRoPWJ9LGRyYXdHcmFwaDpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLm9wdGlvbnMsYz1bW1wiZ3JhcGhcIixiLmxpbmVDb2xvcnx8dGhpcy5jb2xvcixiLmRhc2hTdHlsZV1dLGQ9Yi5saW5lV2lkdGgsZT1iLmxpbmVjYXAhPT1cInNxdWFyZVwiLGY9dGhpcy5nZXRHcmFwaFBhdGgoKSxnPXRoaXMuZmlsbEdyYXBoJiZ0aGlzLmNvbG9yfHxPO28odGhpcy56b25lcyxcbmZ1bmN0aW9uKGQsZSl7Yy5wdXNoKFtcInpvbmVHcmFwaFwiK2UsZC5jb2xvcnx8YS5jb2xvcixkLmRhc2hTdHlsZXx8Yi5kYXNoU3R5bGVdKX0pO28oYyxmdW5jdGlvbihjLGkpe3ZhciBqPWNbMF0saz1hW2pdO2lmKGspay5hbmltYXRlKHtkOmZ9KTtlbHNlIGlmKChkfHxnKSYmZi5sZW5ndGgpaz17c3Ryb2tlOmNbMV0sXCJzdHJva2Utd2lkdGhcIjpkLGZpbGw6Zyx6SW5kZXg6MX0sY1syXT9rLmRhc2hzdHlsZT1jWzJdOmUmJihrW1wic3Ryb2tlLWxpbmVjYXBcIl09a1tcInN0cm9rZS1saW5lam9pblwiXT1cInJvdW5kXCIpLGFbal09YS5jaGFydC5yZW5kZXJlci5wYXRoKGYpLmF0dHIoaykuYWRkKGEuZ3JvdXApLnNoYWRvdyhpPDImJmIuc2hhZG93KX0pfSxhcHBseVpvbmVzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXRoaXMuY2hhcnQsYz1iLnJlbmRlcmVyLGQ9dGhpcy56b25lcyxlLGYsZz10aGlzLmNsaXBzfHxbXSxoLGk9dGhpcy5ncmFwaCxqPXRoaXMuYXJlYSxrPXQoYi5jaGFydFdpZHRoLFxuYi5jaGFydEhlaWdodCksbT10aGlzWyh0aGlzLnpvbmVBeGlzfHxcInlcIikrXCJBeGlzXCJdLGwsbj1tLnJldmVyc2VkLHE9Yi5pbnZlcnRlZCx4PW0uaG9yaXoscixzLHUseT0hMTtpZihkLmxlbmd0aCYmKGl8fGopJiZtLm1pbiE9PXYpaSYmaS5oaWRlKCksaiYmai5oaWRlKCksbD1tLmdldEV4dHJlbWVzKCksbyhkLGZ1bmN0aW9uKGQsbyl7ZT1uP3g/Yi5wbG90V2lkdGg6MDp4PzA6bS50b1BpeGVscyhsLm1pbik7ZT16KHQocChmLGUpLDApLGspO2Y9eih0KHcobS50b1BpeGVscyhwKGQudmFsdWUsbC5tYXgpLCEwKSksMCksayk7eSYmKGU9Zj1tLnRvUGl4ZWxzKGwubWF4KSk7cj1NYXRoLmFicyhlLWYpO3M9eihlLGYpO3U9dChlLGYpO2lmKG0uaXNYQXhpcyl7aWYoaD17eDpxP3U6cyx5OjAsd2lkdGg6cixoZWlnaHQ6a30sIXgpaC54PWIucGxvdEhlaWdodC1oLnh9ZWxzZSBpZihoPXt4OjAseTpxP3U6cyx3aWR0aDprLGhlaWdodDpyfSx4KWgueT1iLnBsb3RXaWR0aC1oLnk7Yi5pbnZlcnRlZCYmXG5jLmlzVk1MJiYoaD1tLmlzWEF4aXM/e3g6MCx5Om4/czp1LGhlaWdodDpoLndpZHRoLHdpZHRoOmIuY2hhcnRXaWR0aH06e3g6aC55LWIucGxvdExlZnQtYi5zcGFjaW5nQm94LngseTowLHdpZHRoOmguaGVpZ2h0LGhlaWdodDpiLmNoYXJ0SGVpZ2h0fSk7Z1tvXT9nW29dLmFuaW1hdGUoaCk6KGdbb109Yy5jbGlwUmVjdChoKSxpJiZhW1wiem9uZUdyYXBoXCIrb10uY2xpcChnW29dKSxqJiZhW1wiem9uZUFyZWFcIitvXS5jbGlwKGdbb10pKTt5PWQudmFsdWU+bC5tYXh9KSx0aGlzLmNsaXBzPWd9LGludmVydEdyb3VwczpmdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt2YXIgYT17d2lkdGg6Yi55QXhpcy5sZW4saGVpZ2h0OmIueEF4aXMubGVufTtvKFtcImdyb3VwXCIsXCJtYXJrZXJHcm91cFwiXSxmdW5jdGlvbihjKXtiW2NdJiZiW2NdLmF0dHIoYSkuaW52ZXJ0KCl9KX12YXIgYj10aGlzLGM9Yi5jaGFydDtpZihiLnhBeGlzKUgoYyxcInJlc2l6ZVwiLGEpLEgoYixcImRlc3Ryb3lcIixmdW5jdGlvbigpe1ooYyxcblwicmVzaXplXCIsYSl9KSxhKCksYi5pbnZlcnRHcm91cHM9YX0scGxvdEdyb3VwOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9dGhpc1thXSxnPSFmO2cmJih0aGlzW2FdPWY9dGhpcy5jaGFydC5yZW5kZXJlci5nKGIpLmF0dHIoe3Zpc2liaWxpdHk6Yyx6SW5kZXg6ZHx8MC4xfSkuYWRkKGUpKTtmW2c/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHRoaXMuZ2V0UGxvdEJveCgpKTtyZXR1cm4gZn0sZ2V0UGxvdEJveDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj10aGlzLnhBeGlzLGM9dGhpcy55QXhpcztpZihhLmludmVydGVkKWI9YyxjPXRoaXMueEF4aXM7cmV0dXJue3RyYW5zbGF0ZVg6Yj9iLmxlZnQ6YS5wbG90TGVmdCx0cmFuc2xhdGVZOmM/Yy50b3A6YS5wbG90VG9wLHNjYWxlWDoxLHNjYWxlWToxfX0scmVuZGVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY2hhcnQsYyxkPWEub3B0aW9ucyxlPShjPWQuYW5pbWF0aW9uKSYmISFhLmFuaW1hdGUmJmIucmVuZGVyZXIuaXNTVkcmJlxucChjLmR1cmF0aW9uLDUwMCl8fDAsZj1hLnZpc2libGU/XCJ2aXNpYmxlXCI6XCJoaWRkZW5cIixnPWQuekluZGV4LGg9YS5oYXNSZW5kZXJlZCxpPWIuc2VyaWVzR3JvdXA7Yz1hLnBsb3RHcm91cChcImdyb3VwXCIsXCJzZXJpZXNcIixmLGcsaSk7YS5tYXJrZXJHcm91cD1hLnBsb3RHcm91cChcIm1hcmtlckdyb3VwXCIsXCJtYXJrZXJzXCIsZixnLGkpO2UmJmEuYW5pbWF0ZSghMCk7YS5nZXRBdHRyaWJzKCk7Yy5pbnZlcnRlZD1hLmlzQ2FydGVzaWFuP2IuaW52ZXJ0ZWQ6ITE7YS5kcmF3R3JhcGgmJihhLmRyYXdHcmFwaCgpLGEuYXBwbHlab25lcygpKTtvKGEucG9pbnRzLGZ1bmN0aW9uKGEpe2EucmVkcmF3JiZhLnJlZHJhdygpfSk7YS5kcmF3RGF0YUxhYmVscyYmYS5kcmF3RGF0YUxhYmVscygpO2EudmlzaWJsZSYmYS5kcmF3UG9pbnRzKCk7YS5kcmF3VHJhY2tlciYmYS5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmchPT0hMSYmYS5kcmF3VHJhY2tlcigpO2IuaW52ZXJ0ZWQmJmEuaW52ZXJ0R3JvdXBzKCk7XG5kLmNsaXAhPT0hMSYmIWEuc2hhcmVkQ2xpcEtleSYmIWgmJmMuY2xpcChiLmNsaXBSZWN0KTtlJiZhLmFuaW1hdGUoKTtpZighaCllP2EuYW5pbWF0aW9uVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5hZnRlckFuaW1hdGUoKX0sZSk6YS5hZnRlckFuaW1hdGUoKTthLmlzRGlydHk9YS5pc0RpcnR5RGF0YT0hMTthLmhhc1JlbmRlcmVkPSEwfSxyZWRyYXc6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9dGhpcy5pc0RpcnR5RGF0YSxjPXRoaXMuaXNEaXJ0eSxkPXRoaXMuZ3JvdXAsZT10aGlzLnhBeGlzLGY9dGhpcy55QXhpcztkJiYoYS5pbnZlcnRlZCYmZC5hdHRyKHt3aWR0aDphLnBsb3RXaWR0aCxoZWlnaHQ6YS5wbG90SGVpZ2h0fSksZC5hbmltYXRlKHt0cmFuc2xhdGVYOnAoZSYmZS5sZWZ0LGEucGxvdExlZnQpLHRyYW5zbGF0ZVk6cChmJiZmLnRvcCxhLnBsb3RUb3ApfSkpO3RoaXMudHJhbnNsYXRlKCk7dGhpcy5yZW5kZXIoKTtiJiZJKHRoaXMsXCJ1cGRhdGVkRGF0YVwiKTtcbihjfHxiKSYmZGVsZXRlIHRoaXMua2RUcmVlfSxrZERpbWVuc2lvbnM6MSxrZEF4aXNBcnJheTpbXCJjbGllbnRYXCIsXCJwbG90WVwiXSxzZWFyY2hQb2ludDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMueEF4aXMsZD10aGlzLnlBeGlzLGU9dGhpcy5jaGFydC5pbnZlcnRlZDtyZXR1cm4gdGhpcy5zZWFyY2hLRFRyZWUoe2NsaWVudFg6ZT9jLmxlbi1hLmNoYXJ0WStjLnBvczphLmNoYXJ0WC1jLnBvcyxwbG90WTplP2QubGVuLWEuY2hhcnRYK2QucG9zOmEuY2hhcnRZLWQucG9zfSxiKX0sYnVpbGRLRFRyZWU6ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGIsZCxnKXt2YXIgaCxpO2lmKGk9YiYmYi5sZW5ndGgpcmV0dXJuIGg9Yy5rZEF4aXNBcnJheVtkJWddLGIuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhW2hdLWJbaF19KSxpPU1hdGguZmxvb3IoaS8yKSx7cG9pbnQ6YltpXSxsZWZ0OmEoYi5zbGljZSgwLGkpLGQrMSxnKSxyaWdodDphKGIuc2xpY2UoaSsxKSxkKzEsZyl9fWZ1bmN0aW9uIGIoKXt2YXIgYj1cbmliKGMucG9pbnRzfHxbXSxmdW5jdGlvbihhKXtyZXR1cm4gYS55IT09bnVsbH0pO2Mua2RUcmVlPWEoYixkLGQpfXZhciBjPXRoaXMsZD1jLmtkRGltZW5zaW9ucztkZWxldGUgYy5rZFRyZWU7Yy5vcHRpb25zLmtkU3luYz9iKCk6c2V0VGltZW91dChiKX0sc2VhcmNoS0RUcmVlOmZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsaixrKXt2YXIgbT1iLnBvaW50LGw9ZC5rZEF4aXNBcnJheVtqJWtdLG4scSxwPW07cT1zKGFbZV0pJiZzKG1bZV0pP01hdGgucG93KGFbZV0tbVtlXSwyKTpudWxsO249cyhhW2ZdKSYmcyhtW2ZdKT9NYXRoLnBvdyhhW2ZdLW1bZl0sMik6bnVsbDtuPShxfHwwKSsobnx8MCk7bS5kaXN0PXMobik/TWF0aC5zcXJ0KG4pOk51bWJlci5NQVhfVkFMVUU7bS5kaXN0WD1zKHEpP01hdGguc3FydChxKTpOdW1iZXIuTUFYX1ZBTFVFO2w9YVtsXS1tW2xdO249bDwwP1wibGVmdFwiOlwicmlnaHRcIjtxPWw8MD9cInJpZ2h0XCI6XCJsZWZ0XCI7YltuXSYmKG49YyhhLGJbbl0sXG5qKzEsaykscD1uW2ddPHBbZ10/bjptKTtiW3FdJiZNYXRoLnNxcnQobCpsKTxwW2ddJiYoYT1jKGEsYltxXSxqKzEsaykscD1hW2ddPHBbZ10/YTpwKTtyZXR1cm4gcH12YXIgZD10aGlzLGU9dGhpcy5rZEF4aXNBcnJheVswXSxmPXRoaXMua2RBeGlzQXJyYXlbMV0sZz1iP1wiZGlzdFhcIjpcImRpc3RcIjt0aGlzLmtkVHJlZXx8dGhpcy5idWlsZEtEVHJlZSgpO2lmKHRoaXMua2RUcmVlKXJldHVybiBjKGEsdGhpcy5rZFRyZWUsdGhpcy5rZERpbWVuc2lvbnMsdGhpcy5rZERpbWVuc2lvbnMpfX07SGIucHJvdG90eXBlPXtkZXN0cm95OmZ1bmN0aW9uKCl7T2EodGhpcyx0aGlzLmF4aXMpfSxyZW5kZXI6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zLGM9Yi5mb3JtYXQsYz1jP0hhKGMsdGhpcyk6Yi5mb3JtYXR0ZXIuY2FsbCh0aGlzKTt0aGlzLmxhYmVsP3RoaXMubGFiZWwuYXR0cih7dGV4dDpjLHZpc2liaWxpdHk6XCJoaWRkZW5cIn0pOnRoaXMubGFiZWw9dGhpcy5heGlzLmNoYXJ0LnJlbmRlcmVyLnRleHQoYyxcbm51bGwsbnVsbCxiLnVzZUhUTUwpLmNzcyhiLnN0eWxlKS5hdHRyKHthbGlnbjp0aGlzLnRleHRBbGlnbixyb3RhdGlvbjpiLnJvdGF0aW9uLHZpc2liaWxpdHk6XCJoaWRkZW5cIn0pLmFkZChhKX0sc2V0T2Zmc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5heGlzLGQ9Yy5jaGFydCxlPWQuaW52ZXJ0ZWQsZj1jLnJldmVyc2VkLGY9dGhpcy5pc05lZ2F0aXZlJiYhZnx8IXRoaXMuaXNOZWdhdGl2ZSYmZixnPWMudHJhbnNsYXRlKGMudXNlUGVyY2VudGFnZT8xMDA6dGhpcy50b3RhbCwwLDAsMCwxKSxjPWMudHJhbnNsYXRlKDApLGM9TihnLWMpLGg9ZC54QXhpc1swXS50cmFuc2xhdGUodGhpcy54KSthLGk9ZC5wbG90SGVpZ2h0LGY9e3g6ZT9mP2c6Zy1jOmgseTplP2ktaC1iOmY/aS1nLWM6aS1nLHdpZHRoOmU/YzpiLGhlaWdodDplP2I6Y307aWYoZT10aGlzLmxhYmVsKWUuYWxpZ24odGhpcy5hbGlnbk9wdGlvbnMsbnVsbCxmKSxmPWUuYWxpZ25BdHRyLGVbdGhpcy5vcHRpb25zLmNyb3A9PT1cbiExfHxkLmlzSW5zaWRlUGxvdChmLngsZi55KT9cInNob3dcIjpcImhpZGVcIl0oITApfX07RC5wcm90b3R5cGUuZ2V0U3RhY2tzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztvKGEueUF4aXMsZnVuY3Rpb24oYSl7aWYoYS5zdGFja3MmJmEuaGFzVmlzaWJsZVNlcmllcylhLm9sZFN0YWNrcz1hLnN0YWNrc30pO28oYS5zZXJpZXMsZnVuY3Rpb24oYil7aWYoYi5vcHRpb25zLnN0YWNraW5nJiYoYi52aXNpYmxlPT09ITB8fGEub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXM9PT0hMSkpYi5zdGFja0tleT1iLnR5cGUrcChiLm9wdGlvbnMuc3RhY2ssXCJcIil9KX07aGEucHJvdG90eXBlLmJ1aWxkU3RhY2tzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zZXJpZXMsYj1wKHRoaXMub3B0aW9ucy5yZXZlcnNlZFN0YWNrcywhMCksYz1hLmxlbmd0aDtpZighdGhpcy5pc1hBeGlzKXtmb3IodGhpcy51c2VQZXJjZW50YWdlPSExO2MtLTspYVtiP2M6YS5sZW5ndGgtYy0xXS5zZXRTdGFja2VkUG9pbnRzKCk7XG5pZih0aGlzLnVzZVBlcmNlbnRhZ2UpZm9yKGM9MDtjPGEubGVuZ3RoO2MrKylhW2NdLnNldFBlcmNlbnRTdGFja3MoKX19O2hhLnByb3RvdHlwZS5yZW5kZXJTdGFja1RvdGFscz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj1hLnJlbmRlcmVyLGM9dGhpcy5zdGFja3MsZCxlLGY9dGhpcy5zdGFja1RvdGFsR3JvdXA7aWYoIWYpdGhpcy5zdGFja1RvdGFsR3JvdXA9Zj1iLmcoXCJzdGFjay1sYWJlbHNcIikuYXR0cih7dmlzaWJpbGl0eTpcInZpc2libGVcIix6SW5kZXg6Nn0pLmFkZCgpO2YudHJhbnNsYXRlKGEucGxvdExlZnQsYS5wbG90VG9wKTtmb3IoZCBpbiBjKWZvcihlIGluIGE9Y1tkXSxhKWFbZV0ucmVuZGVyKGYpfTtoYS5wcm90b3R5cGUucmVzZXRTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnN0YWNrcyxiLGM7aWYoIXRoaXMuaXNYQXhpcylmb3IoYiBpbiBhKWZvcihjIGluIGFbYl0pYVtiXVtjXS50b3VjaGVkPHRoaXMuc3RhY2tzVG91Y2hlZD8oYVtiXVtjXS5kZXN0cm95KCksXG5kZWxldGUgYVtiXVtjXSk6KGFbYl1bY10udG90YWw9bnVsbCxhW2JdW2NdLmN1bT0wKX07aGEucHJvdG90eXBlLmNsZWFuU3RhY2tzPWZ1bmN0aW9uKCl7dmFyIGEsYixjO2lmKCF0aGlzLmlzWEF4aXMpe2lmKHRoaXMub2xkU3RhY2tzKWE9dGhpcy5zdGFja3M9dGhpcy5vbGRTdGFja3M7Zm9yKGIgaW4gYSlmb3IoYyBpbiBhW2JdKWFbYl1bY10uY3VtPWFbYl1bY10udG90YWx9fTtSLnByb3RvdHlwZS5zZXRTdGFja2VkUG9pbnRzPWZ1bmN0aW9uKCl7aWYodGhpcy5vcHRpb25zLnN0YWNraW5nJiYhKHRoaXMudmlzaWJsZSE9PSEwJiZ0aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzIT09ITEpKXt2YXIgYT10aGlzLnByb2Nlc3NlZFhEYXRhLGI9dGhpcy5wcm9jZXNzZWRZRGF0YSxjPVtdLGQ9Yi5sZW5ndGgsZT10aGlzLm9wdGlvbnMsZj1lLnRocmVzaG9sZCxnPWUuc3RhcnRGcm9tVGhyZXNob2xkP2Y6MCxoPWUuc3RhY2ssZT1lLnN0YWNraW5nLGk9dGhpcy5zdGFja0tleSxcbmo9XCItXCIraSxrPXRoaXMubmVnU3RhY2tzLG09dGhpcy55QXhpcyxsPW0uc3RhY2tzLG49bS5vbGRTdGFja3MscSxvLHIscyx1LHk7bS5zdGFja3NUb3VjaGVkKz0xO2ZvcihzPTA7czxkO3MrKyl7dT1hW3NdO3k9YltzXTtyPXRoaXMuaW5kZXgrXCIsXCIrcztvPShxPWsmJnk8KGc/MDpmKSk/ajppO2xbb118fChsW29dPXt9KTtpZighbFtvXVt1XSluW29dJiZuW29dW3VdPyhsW29dW3VdPW5bb11bdV0sbFtvXVt1XS50b3RhbD1udWxsKTpsW29dW3VdPW5ldyBIYihtLG0ub3B0aW9ucy5zdGFja0xhYmVscyxxLHUsaCk7bz1sW29dW3VdO28ucG9pbnRzW3JdPVtwKG8uY3VtLGcpXTtvLnRvdWNoZWQ9bS5zdGFja3NUb3VjaGVkO2U9PT1cInBlcmNlbnRcIj8ocT1xP2k6aixrJiZsW3FdJiZsW3FdW3VdPyhxPWxbcV1bdV0sby50b3RhbD1xLnRvdGFsPXQocS50b3RhbCxvLnRvdGFsKStOKHkpfHwwKTpvLnRvdGFsPWVhKG8udG90YWwrKE4oeSl8fDApKSk6by50b3RhbD1lYShvLnRvdGFsKyh5fHxcbjApKTtvLmN1bT1wKG8uY3VtLGcpKyh5fHwwKTtvLnBvaW50c1tyXS5wdXNoKG8uY3VtKTtjW3NdPW8uY3VtfWlmKGU9PT1cInBlcmNlbnRcIiltLnVzZVBlcmNlbnRhZ2U9ITA7dGhpcy5zdGFja2VkWURhdGE9YzttLm9sZFN0YWNrcz17fX19O1IucHJvdG90eXBlLnNldFBlcmNlbnRTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5zdGFja0tleSxjPWEueUF4aXMuc3RhY2tzLGQ9YS5wcm9jZXNzZWRYRGF0YTtvKFtiLFwiLVwiK2JdLGZ1bmN0aW9uKGIpe3ZhciBlO2Zvcih2YXIgZj1kLmxlbmd0aCxnLGg7Zi0tOylpZihnPWRbZl0sZT0oaD1jW2JdJiZjW2JdW2ddKSYmaC5wb2ludHNbYS5pbmRleCtcIixcIitmXSxnPWUpaD1oLnRvdGFsPzEwMC9oLnRvdGFsOjAsZ1swXT1lYShnWzBdKmgpLGdbMV09ZWEoZ1sxXSpoKSxhLnN0YWNrZWRZRGF0YVtmXT1nWzFdfSl9O3IoRC5wcm90b3R5cGUse2FkZFNlcmllczpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZT10aGlzO2EmJihiPXAoYiwhMCksXG5JKGUsXCJhZGRTZXJpZXNcIix7b3B0aW9uczphfSxmdW5jdGlvbigpe2Q9ZS5pbml0U2VyaWVzKGEpO2UuaXNEaXJ0eUxlZ2VuZD0hMDtlLmxpbmtTZXJpZXMoKTtiJiZlLnJlZHJhdyhjKX0pKTtyZXR1cm4gZH0sYWRkQXhpczpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1iP1wieEF4aXNcIjpcInlBeGlzXCIsZj10aGlzLm9wdGlvbnM7bmV3IGhhKHRoaXMsQShhLHtpbmRleDp0aGlzW2VdLmxlbmd0aCxpc1g6Yn0pKTtmW2VdPXJhKGZbZV18fHt9KTtmW2VdLnB1c2goYSk7cChjLCEwKSYmdGhpcy5yZWRyYXcoZCl9LHNob3dMb2FkaW5nOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLm9wdGlvbnMsZD1iLmxvYWRpbmdEaXYsZT1jLmxvYWRpbmcsZj1mdW5jdGlvbigpe2QmJkwoZCx7bGVmdDpiLnBsb3RMZWZ0K1wicHhcIix0b3A6Yi5wbG90VG9wK1wicHhcIix3aWR0aDpiLnBsb3RXaWR0aCtcInB4XCIsaGVpZ2h0OmIucGxvdEhlaWdodCtcInB4XCJ9KX07aWYoIWQpYi5sb2FkaW5nRGl2PWQ9JChJYSx7Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1sb2FkaW5nXCJ9LFxucihlLnN0eWxlLHt6SW5kZXg6MTAsZGlzcGxheTpPfSksYi5jb250YWluZXIpLGIubG9hZGluZ1NwYW49JChcInNwYW5cIixudWxsLGUubGFiZWxTdHlsZSxkKSxIKGIsXCJyZWRyYXdcIixmKTtiLmxvYWRpbmdTcGFuLmlubmVySFRNTD1hfHxjLmxhbmcubG9hZGluZztpZighYi5sb2FkaW5nU2hvd24pTChkLHtvcGFjaXR5OjAsZGlzcGxheTpcIlwifSksamIoZCx7b3BhY2l0eTplLnN0eWxlLm9wYWNpdHl9LHtkdXJhdGlvbjplLnNob3dEdXJhdGlvbnx8MH0pLGIubG9hZGluZ1Nob3duPSEwO2YoKX0saGlkZUxvYWRpbmc6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj10aGlzLmxvYWRpbmdEaXY7YiYmamIoYix7b3BhY2l0eTowfSx7ZHVyYXRpb246YS5sb2FkaW5nLmhpZGVEdXJhdGlvbnx8MTAwLGNvbXBsZXRlOmZ1bmN0aW9uKCl7TChiLHtkaXNwbGF5Ok99KX19KTt0aGlzLmxvYWRpbmdTaG93bj0hMX19KTtyKEVhLnByb3RvdHlwZSx7dXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQpe2Z1bmN0aW9uIGUoKXtmLmFwcGx5T3B0aW9ucyhhKTtcbmlmKGYueT09PW51bGwmJmgpZi5ncmFwaGljPWguZGVzdHJveSgpO2lmKGRhKGEpJiYhRmEoYSkpZi5yZWRyYXc9ZnVuY3Rpb24oKXtpZihoJiZoLmVsZW1lbnQmJmEmJmEubWFya2VyJiZhLm1hcmtlci5zeW1ib2wpZi5ncmFwaGljPWguZGVzdHJveSgpO2lmKGEmJmEuZGF0YUxhYmVscyYmZi5kYXRhTGFiZWwpZi5kYXRhTGFiZWw9Zi5kYXRhTGFiZWwuZGVzdHJveSgpO2YucmVkcmF3PW51bGx9O2k9Zi5pbmRleDtnLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGYsaSk7aWYobSYmZi5uYW1lKW1bZi54XT1mLm5hbWU7ay5kYXRhW2ldPWYub3B0aW9ucztnLmlzRGlydHk9Zy5pc0RpcnR5RGF0YT0hMDtpZighZy5maXhlZEJveCYmZy5oYXNDYXJ0ZXNpYW5TZXJpZXMpai5pc0RpcnR5Qm94PSEwO2lmKGsubGVnZW5kVHlwZT09PVwicG9pbnRcIilqLmlzRGlydHlMZWdlbmQ9ITA7YiYmai5yZWRyYXcoYyl9dmFyIGY9dGhpcyxnPWYuc2VyaWVzLGg9Zi5ncmFwaGljLGksaj1nLmNoYXJ0LGs9Zy5vcHRpb25zLFxubT1nLnhBeGlzJiZnLnhBeGlzLm5hbWVzLGI9cChiLCEwKTtkPT09ITE/ZSgpOmYuZmlyZVBvaW50RXZlbnQoXCJ1cGRhdGVcIix7b3B0aW9uczphfSxlKX0scmVtb3ZlOmZ1bmN0aW9uKGEsYil7dGhpcy5zZXJpZXMucmVtb3ZlUG9pbnQoS2EodGhpcyx0aGlzLnNlcmllcy5kYXRhKSxhLGIpfX0pO3IoUi5wcm90b3R5cGUse2FkZFBvaW50OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMsZj1lLm9wdGlvbnMsZz1lLmRhdGEsaD1lLmdyYXBoLGk9ZS5hcmVhLGo9ZS5jaGFydCxrPWUueEF4aXMmJmUueEF4aXMubmFtZXMsbT1oJiZoLnNoaWZ0fHwwLGw9W1wiZ3JhcGhcIixcImFyZWFcIl0saD1mLmRhdGEsbixxPWUueERhdGE7UWEoZCxqKTtpZihjKXtmb3IoZD1lLnpvbmVzLmxlbmd0aDtkLS07KWwucHVzaChcInpvbmVHcmFwaFwiK2QsXCJ6b25lQXJlYVwiK2QpO28obCxmdW5jdGlvbihhKXtpZihlW2FdKWVbYV0uc2hpZnQ9bSsxfSl9aWYoaSlpLmlzQXJlYT0hMDtiPXAoYiwhMCk7aT17c2VyaWVzOmV9O1xuZS5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkoaSxbYV0pO2w9aS54O2Q9cS5sZW5ndGg7aWYoZS5yZXF1aXJlU29ydGluZyYmbDxxW2QtMV0pZm9yKG49ITA7ZCYmcVtkLTFdPmw7KWQtLTtlLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGksXCJzcGxpY2VcIixkLDAsMCk7ZS51cGRhdGVQYXJhbGxlbEFycmF5cyhpLGQpO2lmKGsmJmkubmFtZSlrW2xdPWkubmFtZTtoLnNwbGljZShkLDAsYSk7biYmKGUuZGF0YS5zcGxpY2UoZCwwLG51bGwpLGUucHJvY2Vzc0RhdGEoKSk7Zi5sZWdlbmRUeXBlPT09XCJwb2ludFwiJiZlLmdlbmVyYXRlUG9pbnRzKCk7YyYmKGdbMF0mJmdbMF0ucmVtb3ZlP2dbMF0ucmVtb3ZlKCExKTooZy5zaGlmdCgpLGUudXBkYXRlUGFyYWxsZWxBcnJheXMoaSxcInNoaWZ0XCIpLGguc2hpZnQoKSkpO2UuaXNEaXJ0eT0hMDtlLmlzRGlydHlEYXRhPSEwO2ImJihlLmdldEF0dHJpYnMoKSxqLnJlZHJhdygpKX0scmVtb3ZlUG9pbnQ6ZnVuY3Rpb24oYSxiLFxuYyl7dmFyIGQ9dGhpcyxlPWQuZGF0YSxmPWVbYV0sZz1kLnBvaW50cyxoPWQuY2hhcnQsaT1mdW5jdGlvbigpe2UubGVuZ3RoPT09Zy5sZW5ndGgmJmcuc3BsaWNlKGEsMSk7ZS5zcGxpY2UoYSwxKTtkLm9wdGlvbnMuZGF0YS5zcGxpY2UoYSwxKTtkLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGZ8fHtzZXJpZXM6ZH0sXCJzcGxpY2VcIixhLDEpO2YmJmYuZGVzdHJveSgpO2QuaXNEaXJ0eT0hMDtkLmlzRGlydHlEYXRhPSEwO2ImJmgucmVkcmF3KCl9O1FhKGMsaCk7Yj1wKGIsITApO2Y/Zi5maXJlUG9pbnRFdmVudChcInJlbW92ZVwiLG51bGwsaSk6aSgpfSxyZW1vdmU6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yy5jaGFydCxhPXAoYSwhMCk7aWYoIWMuaXNSZW1vdmluZyljLmlzUmVtb3Zpbmc9ITAsSShjLFwicmVtb3ZlXCIsbnVsbCxmdW5jdGlvbigpe2MuZGVzdHJveSgpO2QuaXNEaXJ0eUxlZ2VuZD1kLmlzRGlydHlCb3g9ITA7ZC5saW5rU2VyaWVzKCk7YSYmZC5yZWRyYXcoYil9KTtjLmlzUmVtb3Zpbmc9XG4hMX0sdXBkYXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPXRoaXMuY2hhcnQsZT10aGlzLnVzZXJPcHRpb25zLGY9dGhpcy50eXBlLGc9TVtmXS5wcm90b3R5cGUsaD1bXCJncm91cFwiLFwibWFya2VyR3JvdXBcIixcImRhdGFMYWJlbHNHcm91cFwiXSxpO2lmKGEudHlwZSYmYS50eXBlIT09Znx8YS56SW5kZXghPT12b2lkIDApaC5sZW5ndGg9MDtvKGgsZnVuY3Rpb24oYSl7aFthXT1jW2FdO2RlbGV0ZSBjW2FdfSk7YT1BKGUse2FuaW1hdGlvbjohMSxpbmRleDp0aGlzLmluZGV4LHBvaW50U3RhcnQ6dGhpcy54RGF0YVswXX0se2RhdGE6dGhpcy5vcHRpb25zLmRhdGF9LGEpO3RoaXMucmVtb3ZlKCExKTtmb3IoaSBpbiBnKXRoaXNbaV09djtyKHRoaXMsTVthLnR5cGV8fGZdLnByb3RvdHlwZSk7byhoLGZ1bmN0aW9uKGEpe2NbYV09aFthXX0pO3RoaXMuaW5pdChkLGEpO2QubGlua1NlcmllcygpO3AoYiwhMCkmJmQucmVkcmF3KCExKX19KTtyKGhhLnByb3RvdHlwZSx7dXBkYXRlOmZ1bmN0aW9uKGEsXG5iKXt2YXIgYz10aGlzLmNoYXJ0LGE9Yy5vcHRpb25zW3RoaXMuY29sbF1bdGhpcy5vcHRpb25zLmluZGV4XT1BKHRoaXMudXNlck9wdGlvbnMsYSk7dGhpcy5kZXN0cm95KCEwKTt0aGlzLl9hZGRlZFBsb3RMQj10aGlzLmNoYXJ0Ll9sYWJlbFBhbmVzPXY7dGhpcy5pbml0KGMscihhLHtldmVudHM6dn0pKTtjLmlzRGlydHlCb3g9ITA7cChiLCEwKSYmYy5yZWRyYXcoKX0scmVtb3ZlOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmNoYXJ0LGM9dGhpcy5jb2xsLGQ9dGhpcy5zZXJpZXMsZT1kLmxlbmd0aDtlLS07KWRbZV0mJmRbZV0ucmVtb3ZlKCExKTtqYShiLmF4ZXMsdGhpcyk7amEoYltjXSx0aGlzKTtiLm9wdGlvbnNbY10uc3BsaWNlKHRoaXMub3B0aW9ucy5pbmRleCwxKTtvKGJbY10sZnVuY3Rpb24oYSxiKXthLm9wdGlvbnMuaW5kZXg9Yn0pO3RoaXMuZGVzdHJveSgpO2IuaXNEaXJ0eUJveD0hMDtwKGEsITApJiZiLnJlZHJhdygpfSxzZXRUaXRsZTpmdW5jdGlvbihhLGIpe3RoaXMudXBkYXRlKHt0aXRsZTphfSxcbmIpfSxzZXRDYXRlZ29yaWVzOmZ1bmN0aW9uKGEsYil7dGhpcy51cGRhdGUoe2NhdGVnb3JpZXM6YX0sYil9fSk7dmFyIHdhPWthKFIpO00ubGluZT13YTtiYS5hcmVhPUEoVSx7dGhyZXNob2xkOjB9KTt2YXIgcGE9a2EoUix7dHlwZTpcImFyZWFcIixnZXRTZWdtZW50czpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1bXSxjPVtdLGQ9W10sZT10aGlzLnhBeGlzLGY9dGhpcy55QXhpcyxnPWYuc3RhY2tzW3RoaXMuc3RhY2tLZXldLGg9e30saSxqLGs9dGhpcy5wb2ludHMsbT10aGlzLm9wdGlvbnMuY29ubmVjdE51bGxzLGwsbjtpZih0aGlzLm9wdGlvbnMuc3RhY2tpbmcmJiF0aGlzLmNyb3BwZWQpe2ZvcihsPTA7bDxrLmxlbmd0aDtsKyspaFtrW2xdLnhdPWtbbF07Zm9yKG4gaW4gZylnW25dLnRvdGFsIT09bnVsbCYmZC5wdXNoKCtuKTtkLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS1ifSk7byhkLGZ1bmN0aW9uKGIpe3ZhciBkPTAsaztpZighbXx8aFtiXSYmaFtiXS55IT09bnVsbClpZihoW2JdKWMucHVzaChoW2JdKTtcbmVsc2V7Zm9yKGw9YS5pbmRleDtsPD1mLnNlcmllcy5sZW5ndGg7bCsrKWlmKGs9Z1tiXS5wb2ludHNbbCtcIixcIitiXSl7ZD1rWzFdO2JyZWFrfWk9ZS50cmFuc2xhdGUoYik7aj1mLnRvUGl4ZWxzKGQsITApO2MucHVzaCh7eTpudWxsLHBsb3RYOmksY2xpZW50WDppLHBsb3RZOmoseUJvdHRvbTpqLG9uTW91c2VPdmVyOnRhfSl9fSk7Yy5sZW5ndGgmJmIucHVzaChjKX1lbHNlIFIucHJvdG90eXBlLmdldFNlZ21lbnRzLmNhbGwodGhpcyksYj10aGlzLnNlZ21lbnRzO3RoaXMuc2VnbWVudHM9Yn0sZ2V0U2VnbWVudFBhdGg6ZnVuY3Rpb24oYSl7dmFyIGI9Ui5wcm90b3R5cGUuZ2V0U2VnbWVudFBhdGguY2FsbCh0aGlzLGEpLGM9W10uY29uY2F0KGIpLGQsZT10aGlzLm9wdGlvbnM7ZD1iLmxlbmd0aDt2YXIgZj10aGlzLnlBeGlzLmdldFRocmVzaG9sZChlLnRocmVzaG9sZCksZztkPT09MyYmYy5wdXNoKFwiTFwiLGJbMV0sYlsyXSk7aWYoZS5zdGFja2luZyYmIXRoaXMuY2xvc2VkU3RhY2tzKWZvcihkPVxuYS5sZW5ndGgtMTtkPj0wO2QtLSlnPXAoYVtkXS55Qm90dG9tLGYpLGQ8YS5sZW5ndGgtMSYmZS5zdGVwJiZjLnB1c2goYVtkKzFdLnBsb3RYLGcpLGMucHVzaChhW2RdLnBsb3RYLGcpO2Vsc2UgdGhpcy5jbG9zZVNlZ21lbnQoYyxhLGYpO3RoaXMuYXJlYVBhdGg9dGhpcy5hcmVhUGF0aC5jb25jYXQoYyk7cmV0dXJuIGJ9LGNsb3NlU2VnbWVudDpmdW5jdGlvbihhLGIsYyl7YS5wdXNoKFwiTFwiLGJbYi5sZW5ndGgtMV0ucGxvdFgsYyxcIkxcIixiWzBdLnBsb3RYLGMpfSxkcmF3R3JhcGg6ZnVuY3Rpb24oKXt0aGlzLmFyZWFQYXRoPVtdO1IucHJvdG90eXBlLmRyYXdHcmFwaC5hcHBseSh0aGlzKTt2YXIgYT10aGlzLGI9dGhpcy5hcmVhUGF0aCxjPXRoaXMub3B0aW9ucyxkPVtbXCJhcmVhXCIsdGhpcy5jb2xvcixjLmZpbGxDb2xvcl1dO28odGhpcy56b25lcyxmdW5jdGlvbihiLGYpe2QucHVzaChbXCJ6b25lQXJlYVwiK2YsYi5jb2xvcnx8YS5jb2xvcixiLmZpbGxDb2xvcnx8Yy5maWxsQ29sb3JdKX0pO1xubyhkLGZ1bmN0aW9uKGQpe3ZhciBmPWRbMF0sZz1hW2ZdO2c/Zy5hbmltYXRlKHtkOmJ9KTphW2ZdPWEuY2hhcnQucmVuZGVyZXIucGF0aChiKS5hdHRyKHtmaWxsOnAoZFsyXSxuYShkWzFdKS5zZXRPcGFjaXR5KHAoYy5maWxsT3BhY2l0eSwwLjc1KSkuZ2V0KCkpLHpJbmRleDowfSkuYWRkKGEuZ3JvdXApfSl9LGRyYXdMZWdlbmRTeW1ib2w6TGEuZHJhd1JlY3RhbmdsZX0pO00uYXJlYT1wYTtiYS5zcGxpbmU9QShVKTt3YT1rYShSLHt0eXBlOlwic3BsaW5lXCIsZ2V0UG9pbnRTcGxpbmU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWIucGxvdFgsZT1iLnBsb3RZLGY9YVtjLTFdLGc9YVtjKzFdLGgsaSxqLGs7aWYoZiYmZyl7YT1mLnBsb3RZO2o9Zy5wbG90WDt2YXIgZz1nLnBsb3RZLG07aD0oMS41KmQrZi5wbG90WCkvMi41O2k9KDEuNSplK2EpLzIuNTtqPSgxLjUqZCtqKS8yLjU7az0oMS41KmUrZykvMi41O209KGstaSkqKGotZCkvKGotaCkrZS1rO2krPW07ays9bTtpPmEmJmk+ZT9cbihpPXQoYSxlKSxrPTIqZS1pKTppPGEmJmk8ZSYmKGk9eihhLGUpLGs9MiplLWkpO2s+ZyYmaz5lPyhrPXQoZyxlKSxpPTIqZS1rKTprPGcmJms8ZSYmKGs9eihnLGUpLGk9MiplLWspO2IucmlnaHRDb250WD1qO2IucmlnaHRDb250WT1rfWM/KGI9W1wiQ1wiLGYucmlnaHRDb250WHx8Zi5wbG90WCxmLnJpZ2h0Q29udFl8fGYucGxvdFksaHx8ZCxpfHxlLGQsZV0sZi5yaWdodENvbnRYPWYucmlnaHRDb250WT1udWxsKTpiPVtcIk1cIixkLGVdO3JldHVybiBifX0pO00uc3BsaW5lPXdhO2JhLmFyZWFzcGxpbmU9QShiYS5hcmVhKTtwYT1wYS5wcm90b3R5cGU7d2E9a2Eod2Ese3R5cGU6XCJhcmVhc3BsaW5lXCIsY2xvc2VkU3RhY2tzOiEwLGdldFNlZ21lbnRQYXRoOnBhLmdldFNlZ21lbnRQYXRoLGNsb3NlU2VnbWVudDpwYS5jbG9zZVNlZ21lbnQsZHJhd0dyYXBoOnBhLmRyYXdHcmFwaCxkcmF3TGVnZW5kU3ltYm9sOkxhLmRyYXdSZWN0YW5nbGV9KTtNLmFyZWFzcGxpbmU9d2E7YmEuY29sdW1uPVxuQShVLHtib3JkZXJDb2xvcjpcIiNGRkZGRkZcIixib3JkZXJSYWRpdXM6MCxncm91cFBhZGRpbmc6MC4yLG1hcmtlcjpudWxsLHBvaW50UGFkZGluZzowLjEsbWluUG9pbnRMZW5ndGg6MCxjcm9wVGhyZXNob2xkOjUwLHBvaW50UmFuZ2U6bnVsbCxzdGF0ZXM6e2hvdmVyOnticmlnaHRuZXNzOjAuMSxzaGFkb3c6ITEsaGFsbzohMX0sc2VsZWN0Ontjb2xvcjpcIiNDMEMwQzBcIixib3JkZXJDb2xvcjpcIiMwMDAwMDBcIixzaGFkb3c6ITF9fSxkYXRhTGFiZWxzOnthbGlnbjpudWxsLHZlcnRpY2FsQWxpZ246bnVsbCx5Om51bGx9LHN0YXJ0RnJvbVRocmVzaG9sZDohMCxzdGlja3lUcmFja2luZzohMSx0b29sdGlwOntkaXN0YW5jZTo2fSx0aHJlc2hvbGQ6MH0pO3dhPWthKFIse3R5cGU6XCJjb2x1bW5cIixwb2ludEF0dHJUb09wdGlvbnM6e3N0cm9rZTpcImJvcmRlckNvbG9yXCIsZmlsbDpcImNvbG9yXCIscjpcImJvcmRlclJhZGl1c1wifSxjcm9wU2hvdWxkZXI6MCxkaXJlY3RUb3VjaDohMCx0cmFja2VyR3JvdXBzOltcImdyb3VwXCIsXG5cImRhdGFMYWJlbHNHcm91cFwiXSxuZWdTdGFja3M6ITAsaW5pdDpmdW5jdGlvbigpe1IucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBhPXRoaXMsYj1hLmNoYXJ0O2IuaGFzUmVuZGVyZWQmJm8oYi5zZXJpZXMsZnVuY3Rpb24oYil7aWYoYi50eXBlPT09YS50eXBlKWIuaXNEaXJ0eT0hMH0pfSxnZXRDb2x1bW5NZXRyaWNzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEub3B0aW9ucyxjPWEueEF4aXMsZD1hLnlBeGlzLGU9Yy5yZXZlcnNlZCxmLGc9e30saCxpPTA7Yi5ncm91cGluZz09PSExP2k9MTpvKGEuY2hhcnQuc2VyaWVzLGZ1bmN0aW9uKGIpe3ZhciBjPWIub3B0aW9ucyxlPWIueUF4aXM7aWYoYi50eXBlPT09YS50eXBlJiZiLnZpc2libGUmJmQubGVuPT09ZS5sZW4mJmQucG9zPT09ZS5wb3MpYy5zdGFja2luZz8oZj1iLnN0YWNrS2V5LGdbZl09PT12JiYoZ1tmXT1pKyspLGg9Z1tmXSk6Yy5ncm91cGluZyE9PSExJiYoaD1pKyspLGIuY29sdW1uSW5kZXg9XG5ofSk7dmFyIGo9eihOKGMudHJhbnNBKSooYy5vcmRpbmFsU2xvcGV8fGIucG9pbnRSYW5nZXx8Yy5jbG9zZXN0UG9pbnRSYW5nZXx8Yy50aWNrSW50ZXJ2YWx8fDEpLGMubGVuKSxrPWoqYi5ncm91cFBhZGRpbmcsbT0oai0yKmspL2ksYj16KGIubWF4UG9pbnRXaWR0aHx8Yy5sZW4scChiLnBvaW50V2lkdGgsbSooMS0yKmIucG9pbnRQYWRkaW5nKSkpO3JldHVybiBhLmNvbHVtbk1ldHJpY3M9e3dpZHRoOmIsb2Zmc2V0OihtLWIpLzIrKGsrKChlP2ktKGEuY29sdW1uSW5kZXh8fDApOmEuY29sdW1uSW5kZXgpfHwwKSptLWovMikqKGU/LTE6MSl9fSx0cmFuc2xhdGU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydCxjPWEub3B0aW9ucyxkPWEuYm9yZGVyV2lkdGg9cChjLmJvcmRlcldpZHRoLGEuY2xvc2VzdFBvaW50UmFuZ2UqYS54QXhpcy50cmFuc0E8Mj8wOjEpLGU9YS55QXhpcyxmPWEudHJhbnNsYXRlZFRocmVzaG9sZD1lLmdldFRocmVzaG9sZChjLnRocmVzaG9sZCksXG5nPXAoYy5taW5Qb2ludExlbmd0aCw1KSxoPWEuZ2V0Q29sdW1uTWV0cmljcygpLGk9aC53aWR0aCxqPWEuYmFyVz10KGksMSsyKmQpLGs9YS5wb2ludFhPZmZzZXQ9aC5vZmZzZXQsbT0tKGQlMj8wLjU6MCksbD1kJTI/MC41OjE7Yi5pbnZlcnRlZCYmKGYtPTAuNSxiLnJlbmRlcmVyLmlzVk1MJiYobCs9MSkpO2MucG9pbnRQYWRkaW5nJiYoaj1zYShqKSk7Ui5wcm90b3R5cGUudHJhbnNsYXRlLmFwcGx5KGEpO28oYS5wb2ludHMsZnVuY3Rpb24oYyl7dmFyIGQ9cChjLnlCb3R0b20sZiksaD05OTkrTihkKSxoPXoodCgtaCxjLnBsb3RZKSxlLmxlbitoKSxvPWMucGxvdFgrayxyPWoscz16KGgsZCkseSx2O3k9dChoLGQpLXM7Tih5KTxnJiZnJiYoeT1nLHY9IWUucmV2ZXJzZWQmJiFjLm5lZ2F0aXZlfHxlLnJldmVyc2VkJiZjLm5lZ2F0aXZlLHM9dyhOKHMtZik+Zz9kLWc6Zi0odj9nOjApKSk7Yy5iYXJYPW87Yy5wb2ludFdpZHRoPWk7cj13KG8rcikrbTtvPXcobykrbTtyLT1vO2Q9XG5OKHMpPDAuNTt5PXoodyhzK3kpK2wsOUU0KTtzPXcocykrbDt5LT1zO2QmJihzLT0xLHkrPTEpO2MudG9vbHRpcFBvcz1iLmludmVydGVkP1tlLmxlbitlLnBvcy1iLnBsb3RMZWZ0LWgsYS54QXhpcy5sZW4tby1yLzIseV06W28rci8yLGgrZS5wb3MtYi5wbG90VG9wLHldO2Muc2hhcGVUeXBlPVwicmVjdFwiO2Muc2hhcGVBcmdzPXt4Om8seTpzLHdpZHRoOnIsaGVpZ2h0Onl9fSl9LGdldFN5bWJvbDp0YSxkcmF3TGVnZW5kU3ltYm9sOkxhLmRyYXdSZWN0YW5nbGUsZHJhd0dyYXBoOnRhLGRyYXdQb2ludHM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5jaGFydCxjPWEub3B0aW9ucyxkPWIucmVuZGVyZXIsZT1jLmFuaW1hdGlvbkxpbWl0fHwyNTAsZixnO28oYS5wb2ludHMsZnVuY3Rpb24oaCl7dmFyIGk9aC5wbG90WSxqPWguZ3JhcGhpYztpZihpIT09diYmIWlzTmFOKGkpJiZoLnkhPT1udWxsKWY9aC5zaGFwZUFyZ3MsaT1zKGEuYm9yZGVyV2lkdGgpP3tcInN0cm9rZS13aWR0aFwiOmEuYm9yZGVyV2lkdGh9Olxue30sZz1oLnBvaW50QXR0cltoLnNlbGVjdGVkP1wic2VsZWN0XCI6XCJcIl18fGEucG9pbnRBdHRyW1wiXCJdLGo/KGtiKGopLGouYXR0cihpKVtiLnBvaW50Q291bnQ8ZT9cImFuaW1hdGVcIjpcImF0dHJcIl0oQShmKSkpOmguZ3JhcGhpYz1kW2guc2hhcGVUeXBlXShmKS5hdHRyKGkpLmF0dHIoZykuYWRkKGEuZ3JvdXApLnNoYWRvdyhjLnNoYWRvdyxudWxsLGMuc3RhY2tpbmcmJiFjLmJvcmRlclJhZGl1cyk7ZWxzZSBpZihqKWguZ3JhcGhpYz1qLmRlc3Ryb3koKX0pfSxhbmltYXRlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMueUF4aXMsYz10aGlzLm9wdGlvbnMsZD10aGlzLmNoYXJ0LmludmVydGVkLGU9e307aWYoY2EpYT8oZS5zY2FsZVk9MC4wMDEsYT16KGIucG9zK2IubGVuLHQoYi5wb3MsYi50b1BpeGVscyhjLnRocmVzaG9sZCkpKSxkP2UudHJhbnNsYXRlWD1hLWIubGVuOmUudHJhbnNsYXRlWT1hLHRoaXMuZ3JvdXAuYXR0cihlKSk6KGUuc2NhbGVZPTEsZVtkP1widHJhbnNsYXRlWFwiOlwidHJhbnNsYXRlWVwiXT1cbmIucG9zLHRoaXMuZ3JvdXAuYW5pbWF0ZShlLHRoaXMub3B0aW9ucy5hbmltYXRpb24pLHRoaXMuYW5pbWF0ZT1udWxsKX0scmVtb3ZlOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY2hhcnQ7Yi5oYXNSZW5kZXJlZCYmbyhiLnNlcmllcyxmdW5jdGlvbihiKXtpZihiLnR5cGU9PT1hLnR5cGUpYi5pc0RpcnR5PSEwfSk7Ui5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KGEsYXJndW1lbnRzKX19KTtNLmNvbHVtbj13YTtiYS5iYXI9QShiYS5jb2x1bW4pO3BhPWthKHdhLHt0eXBlOlwiYmFyXCIsaW52ZXJ0ZWQ6ITB9KTtNLmJhcj1wYTtiYS5zY2F0dGVyPUEoVSx7bGluZVdpZHRoOjAsbWFya2VyOntlbmFibGVkOiEwfSx0b29sdGlwOntoZWFkZXJGb3JtYXQ6JzxzcGFuIHN0eWxlPVwiY29sb3I6e3BvaW50LmNvbG9yfVwiPlxcdTI1Y2Y8L3NwYW4+IDxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxMHB4O1wiPiB7c2VyaWVzLm5hbWV9PC9zcGFuPjxici8+Jyxwb2ludEZvcm1hdDpcIng6IDxiPntwb2ludC54fTwvYj48YnIvPnk6IDxiPntwb2ludC55fTwvYj48YnIvPlwifX0pO1xucGE9a2EoUix7dHlwZTpcInNjYXR0ZXJcIixzb3J0ZWQ6ITEscmVxdWlyZVNvcnRpbmc6ITEsbm9TaGFyZWRUb29sdGlwOiEwLHRyYWNrZXJHcm91cHM6W1wiZ3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIl0sdGFrZU9yZGluYWxQb3NpdGlvbjohMSxrZERpbWVuc2lvbnM6MixkcmF3R3JhcGg6ZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMubGluZVdpZHRoJiZSLnByb3RvdHlwZS5kcmF3R3JhcGguY2FsbCh0aGlzKX19KTtNLnNjYXR0ZXI9cGE7YmEucGllPUEoVSx7Ym9yZGVyQ29sb3I6XCIjRkZGRkZGXCIsYm9yZGVyV2lkdGg6MSxjZW50ZXI6W251bGwsbnVsbF0sY2xpcDohMSxjb2xvckJ5UG9pbnQ6ITAsZGF0YUxhYmVsczp7ZGlzdGFuY2U6MzAsZW5hYmxlZDohMCxmb3JtYXR0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy55PT09bnVsbD92b2lkIDA6dGhpcy5wb2ludC5uYW1lfSx4OjB9LGlnbm9yZUhpZGRlblBvaW50OiEwLGxlZ2VuZFR5cGU6XCJwb2ludFwiLG1hcmtlcjpudWxsLFxuc2l6ZTpudWxsLHNob3dJbkxlZ2VuZDohMSxzbGljZWRPZmZzZXQ6MTAsc3RhdGVzOntob3Zlcjp7YnJpZ2h0bmVzczowLjEsc2hhZG93OiExfX0sc3RpY2t5VHJhY2tpbmc6ITEsdG9vbHRpcDp7Zm9sbG93UG9pbnRlcjohMH19KTtVPXt0eXBlOlwicGllXCIsaXNDYXJ0ZXNpYW46ITEscG9pbnRDbGFzczprYShFYSx7aW5pdDpmdW5jdGlvbigpe0VhLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYT10aGlzLGI7cihhLHt2aXNpYmxlOmEudmlzaWJsZSE9PSExLG5hbWU6cChhLm5hbWUsXCJTbGljZVwiKX0pO2I9ZnVuY3Rpb24oYil7YS5zbGljZShiLnR5cGU9PT1cInNlbGVjdFwiKX07SChhLFwic2VsZWN0XCIsYik7SChhLFwidW5zZWxlY3RcIixiKTtyZXR1cm4gYX0sc2V0VmlzaWJsZTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1jLnNlcmllcyxlPWQuY2hhcnQsZj1kLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQsYj1wKGIsZik7aWYoYSE9PWMudmlzaWJsZSl7Yy52aXNpYmxlPVxuYy5vcHRpb25zLnZpc2libGU9YT1hPT09dj8hYy52aXNpYmxlOmE7ZC5vcHRpb25zLmRhdGFbS2EoYyxkLmRhdGEpXT1jLm9wdGlvbnM7byhbXCJncmFwaGljXCIsXCJkYXRhTGFiZWxcIixcImNvbm5lY3RvclwiLFwic2hhZG93R3JvdXBcIl0sZnVuY3Rpb24oYil7aWYoY1tiXSljW2JdW2E/XCJzaG93XCI6XCJoaWRlXCJdKCEwKX0pO2MubGVnZW5kSXRlbSYmZS5sZWdlbmQuY29sb3JpemVJdGVtKGMsYSk7IWEmJmMuc3RhdGU9PT1cImhvdmVyXCImJmMuc2V0U3RhdGUoXCJcIik7aWYoZilkLmlzRGlydHk9ITA7YiYmZS5yZWRyYXcoKX19LHNsaWNlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLnNlcmllcztRYShjLGQuY2hhcnQpO3AoYiwhMCk7dGhpcy5zbGljZWQ9dGhpcy5vcHRpb25zLnNsaWNlZD1hPXMoYSk/YTohdGhpcy5zbGljZWQ7ZC5vcHRpb25zLmRhdGFbS2EodGhpcyxkLmRhdGEpXT10aGlzLm9wdGlvbnM7YT1hP3RoaXMuc2xpY2VkVHJhbnNsYXRpb246e3RyYW5zbGF0ZVg6MCx0cmFuc2xhdGVZOjB9O1xudGhpcy5ncmFwaGljLmFuaW1hdGUoYSk7dGhpcy5zaGFkb3dHcm91cCYmdGhpcy5zaGFkb3dHcm91cC5hbmltYXRlKGEpfSxoYWxvUGF0aDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnNoYXBlQXJncyxjPXRoaXMuc2VyaWVzLmNoYXJ0O3JldHVybiB0aGlzLnNsaWNlZHx8IXRoaXMudmlzaWJsZT9bXTp0aGlzLnNlcmllcy5jaGFydC5yZW5kZXJlci5zeW1ib2xzLmFyYyhjLnBsb3RMZWZ0K2IueCxjLnBsb3RUb3ArYi55LGIucithLGIucithLHtpbm5lclI6dGhpcy5zaGFwZUFyZ3MucixzdGFydDpiLnN0YXJ0LGVuZDpiLmVuZH0pfX0pLHJlcXVpcmVTb3J0aW5nOiExLGRpcmVjdFRvdWNoOiEwLG5vU2hhcmVkVG9vbHRpcDohMCx0cmFja2VyR3JvdXBzOltcImdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIl0sYXhpc1R5cGVzOltdLHBvaW50QXR0clRvT3B0aW9uczp7c3Ryb2tlOlwiYm9yZGVyQ29sb3JcIixcInN0cm9rZS13aWR0aFwiOlwiYm9yZGVyV2lkdGhcIixmaWxsOlwiY29sb3JcIn0sYW5pbWF0ZTpmdW5jdGlvbihhKXt2YXIgYj1cbnRoaXMsYz1iLnBvaW50cyxkPWIuc3RhcnRBbmdsZVJhZDtpZighYSlvKGMsZnVuY3Rpb24oYSl7dmFyIGM9YS5ncmFwaGljLGc9YS5zaGFwZUFyZ3M7YyYmKGMuYXR0cih7cjphLnN0YXJ0Unx8Yi5jZW50ZXJbM10vMixzdGFydDpkLGVuZDpkfSksYy5hbmltYXRlKHtyOmcucixzdGFydDpnLnN0YXJ0LGVuZDpnLmVuZH0sYi5vcHRpb25zLmFuaW1hdGlvbikpfSksYi5hbmltYXRlPW51bGx9LHNldERhdGE6ZnVuY3Rpb24oYSxiLGMsZCl7Ui5wcm90b3R5cGUuc2V0RGF0YS5jYWxsKHRoaXMsYSwhMSxjLGQpO3RoaXMucHJvY2Vzc0RhdGEoKTt0aGlzLmdlbmVyYXRlUG9pbnRzKCk7cChiLCEwKSYmdGhpcy5jaGFydC5yZWRyYXcoYyl9LHVwZGF0ZVRvdGFsczpmdW5jdGlvbigpe3ZhciBhLGI9MCxjPXRoaXMucG9pbnRzLGQ9Yy5sZW5ndGgsZSxmPXRoaXMub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtmb3IoYT0wO2E8ZDthKyspZT1jW2FdLGIrPWYmJiFlLnZpc2libGU/MDplLnk7dGhpcy50b3RhbD1cbmI7Zm9yKGE9MDthPGQ7YSsrKWU9Y1thXSxlLnBlcmNlbnRhZ2U9Yj4wJiYoZS52aXNpYmxlfHwhZik/ZS55L2IqMTAwOjAsZS50b3RhbD1ifSxnZW5lcmF0ZVBvaW50czpmdW5jdGlvbigpe1IucHJvdG90eXBlLmdlbmVyYXRlUG9pbnRzLmNhbGwodGhpcyk7dGhpcy51cGRhdGVUb3RhbHMoKX0sdHJhbnNsYXRlOmZ1bmN0aW9uKGEpe3RoaXMuZ2VuZXJhdGVQb2ludHMoKTt2YXIgYj0wLGM9dGhpcy5vcHRpb25zLGQ9Yy5zbGljZWRPZmZzZXQsZT1kK2MuYm9yZGVyV2lkdGgsZixnLGgsaT1jLnN0YXJ0QW5nbGV8fDAsaj10aGlzLnN0YXJ0QW5nbGVSYWQ9bWEvMTgwKihpLTkwKSxpPSh0aGlzLmVuZEFuZ2xlUmFkPW1hLzE4MCoocChjLmVuZEFuZ2xlLGkrMzYwKS05MCkpLWosaz10aGlzLnBvaW50cyxtPWMuZGF0YUxhYmVscy5kaXN0YW5jZSxjPWMuaWdub3JlSGlkZGVuUG9pbnQsbCxuPWsubGVuZ3RoLG87aWYoIWEpdGhpcy5jZW50ZXI9YT10aGlzLmdldENlbnRlcigpO3RoaXMuZ2V0WD1cbmZ1bmN0aW9uKGIsYyl7aD1XLmFzaW4oeigoYi1hWzFdKS8oYVsyXS8yK20pLDEpKTtyZXR1cm4gYVswXSsoYz8tMToxKSpYKGgpKihhWzJdLzIrbSl9O2ZvcihsPTA7bDxuO2wrKyl7bz1rW2xdO2Y9aitiKmk7aWYoIWN8fG8udmlzaWJsZSliKz1vLnBlcmNlbnRhZ2UvMTAwO2c9aitiKmk7by5zaGFwZVR5cGU9XCJhcmNcIjtvLnNoYXBlQXJncz17eDphWzBdLHk6YVsxXSxyOmFbMl0vMixpbm5lclI6YVszXS8yLHN0YXJ0OncoZioxRTMpLzFFMyxlbmQ6dyhnKjFFMykvMUUzfTtoPShnK2YpLzI7aD4xLjUqbWE/aC09MiptYTpoPC1tYS8yJiYoaCs9MiptYSk7by5zbGljZWRUcmFuc2xhdGlvbj17dHJhbnNsYXRlWDp3KFgoaCkqZCksdHJhbnNsYXRlWTp3KGFhKGgpKmQpfTtmPVgoaCkqYVsyXS8yO2c9YWEoaCkqYVsyXS8yO28udG9vbHRpcFBvcz1bYVswXStmKjAuNyxhWzFdK2cqMC43XTtvLmhhbGY9aDwtbWEvMnx8aD5tYS8yPzE6MDtvLmFuZ2xlPWg7ZT16KGUsbS8yKTtvLmxhYmVsUG9zPVxuW2FbMF0rZitYKGgpKm0sYVsxXStnK2FhKGgpKm0sYVswXStmK1goaCkqZSxhWzFdK2crYWEoaCkqZSxhWzBdK2YsYVsxXStnLG08MD9cImNlbnRlclwiOm8uaGFsZj9cInJpZ2h0XCI6XCJsZWZ0XCIsaF19fSxkcmF3R3JhcGg6bnVsbCxkcmF3UG9pbnRzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY2hhcnQucmVuZGVyZXIsYyxkLGU9YS5vcHRpb25zLnNoYWRvdyxmLGcsaDtpZihlJiYhYS5zaGFkb3dHcm91cClhLnNoYWRvd0dyb3VwPWIuZyhcInNoYWRvd1wiKS5hZGQoYS5ncm91cCk7byhhLnBvaW50cyxmdW5jdGlvbihpKXtpZihpLnkhPT1udWxsKXtkPWkuZ3JhcGhpYztnPWkuc2hhcGVBcmdzO2Y9aS5zaGFkb3dHcm91cDtpZihlJiYhZilmPWkuc2hhZG93R3JvdXA9Yi5nKFwic2hhZG93XCIpLmFkZChhLnNoYWRvd0dyb3VwKTtjPWkuc2xpY2VkP2kuc2xpY2VkVHJhbnNsYXRpb246e3RyYW5zbGF0ZVg6MCx0cmFuc2xhdGVZOjB9O2YmJmYuYXR0cihjKTtpZihkKWQuYW5pbWF0ZShyKGcsYykpO1xuZWxzZXtoPXtcInN0cm9rZS1saW5lam9pblwiOlwicm91bmRcIn07aWYoIWkudmlzaWJsZSloLnZpc2liaWxpdHk9XCJoaWRkZW5cIjtpLmdyYXBoaWM9ZD1iW2kuc2hhcGVUeXBlXShnKS5zZXRSYWRpYWxSZWZlcmVuY2UoYS5jZW50ZXIpLmF0dHIoaS5wb2ludEF0dHJbaS5zZWxlY3RlZD9cInNlbGVjdFwiOlwiXCJdKS5hdHRyKGgpLmF0dHIoYykuYWRkKGEuZ3JvdXApLnNoYWRvdyhlLGYpfX19KX0sc2VhcmNoUG9pbnQ6dGEsc29ydEJ5QW5nbGU6ZnVuY3Rpb24oYSxiKXthLnNvcnQoZnVuY3Rpb24oYSxkKXtyZXR1cm4gYS5hbmdsZSE9PXZvaWQgMCYmKGQuYW5nbGUtYS5hbmdsZSkqYn0pfSxkcmF3TGVnZW5kU3ltYm9sOkxhLmRyYXdSZWN0YW5nbGUsZ2V0Q2VudGVyOlhiLmdldENlbnRlcixnZXRTeW1ib2w6dGF9O1U9a2EoUixVKTtNLnBpZT1VO1IucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEub3B0aW9ucyxjPWIuY3Vyc29yLGQ9Yi5kYXRhTGFiZWxzLFxuZT1hLnBvaW50cyxmLGcsaD1hLmhhc1JlbmRlcmVkfHwwLGksaixrPWEuY2hhcnQucmVuZGVyZXI7aWYoZC5lbmFibGVkfHxhLl9oYXNQb2ludExhYmVscylhLmRsUHJvY2Vzc09wdGlvbnMmJmEuZGxQcm9jZXNzT3B0aW9ucyhkKSxqPWEucGxvdEdyb3VwKFwiZGF0YUxhYmVsc0dyb3VwXCIsXCJkYXRhLWxhYmVsc1wiLGQuZGVmZXI/XCJoaWRkZW5cIjpcInZpc2libGVcIixkLnpJbmRleHx8NikscChkLmRlZmVyLCEwKSYmKGouYXR0cih7b3BhY2l0eToraH0pLGh8fEgoYSxcImFmdGVyQW5pbWF0ZVwiLGZ1bmN0aW9uKCl7YS52aXNpYmxlJiZqLnNob3coKTtqW2IuYW5pbWF0aW9uP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7b3BhY2l0eToxfSx7ZHVyYXRpb246MjAwfSl9KSksZz1kLG8oZSxmdW5jdGlvbihlKXt2YXIgaCxuPWUuZGF0YUxhYmVsLG8sdCx3PWUuY29ubmVjdG9yLHo9ITAsdSx5PXt9O2Y9ZS5kbE9wdGlvbnN8fGUub3B0aW9ucyYmZS5vcHRpb25zLmRhdGFMYWJlbHM7aD1wKGYmJmYuZW5hYmxlZCxcbmcuZW5hYmxlZCk7aWYobiYmIWgpZS5kYXRhTGFiZWw9bi5kZXN0cm95KCk7ZWxzZSBpZihoKXtkPUEoZyxmKTt1PWQuc3R5bGU7aD1kLnJvdGF0aW9uO289ZS5nZXRMYWJlbENvbmZpZygpO2k9ZC5mb3JtYXQ/SGEoZC5mb3JtYXQsbyk6ZC5mb3JtYXR0ZXIuY2FsbChvLGQpO3UuY29sb3I9cChkLmNvbG9yLHUuY29sb3IsYS5jb2xvcixcImJsYWNrXCIpO2lmKG4paWYocyhpKSluLmF0dHIoe3RleHQ6aX0pLHo9ITE7ZWxzZXtpZihlLmRhdGFMYWJlbD1uPW4uZGVzdHJveSgpLHcpZS5jb25uZWN0b3I9dy5kZXN0cm95KCl9ZWxzZSBpZihzKGkpKXtuPXtmaWxsOmQuYmFja2dyb3VuZENvbG9yLHN0cm9rZTpkLmJvcmRlckNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6ZC5ib3JkZXJXaWR0aCxyOmQuYm9yZGVyUmFkaXVzfHwwLHJvdGF0aW9uOmgscGFkZGluZzpkLnBhZGRpbmcsekluZGV4OjF9O2lmKHUuY29sb3I9PT1cImNvbnRyYXN0XCIpeS5jb2xvcj1kLmluc2lkZXx8ZC5kaXN0YW5jZTwwfHxiLnN0YWNraW5nP1xuay5nZXRDb250cmFzdChlLmNvbG9yfHxhLmNvbG9yKTpcIiMwMDAwMDBcIjtpZihjKXkuY3Vyc29yPWM7Zm9yKHQgaW4gbiluW3RdPT09diYmZGVsZXRlIG5bdF07bj1lLmRhdGFMYWJlbD1rW2g/XCJ0ZXh0XCI6XCJsYWJlbFwiXShpLDAsLTk5OSxkLnNoYXBlLG51bGwsbnVsbCxkLnVzZUhUTUwpLmF0dHIobikuY3NzKHIodSx5KSkuYWRkKGopLnNoYWRvdyhkLnNoYWRvdyl9biYmYS5hbGlnbkRhdGFMYWJlbChlLG4sZCxudWxsLHopfX0pfTtSLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbD1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPXRoaXMuY2hhcnQsZz1mLmludmVydGVkLGg9cChhLnBsb3RYLC05OTkpLGk9cChhLnBsb3RZLC05OTkpLGo9Yi5nZXRCQm94KCksaz1mLnJlbmRlcmVyLmZvbnRNZXRyaWNzKGMuc3R5bGUuZm9udFNpemUpLmIsbT10aGlzLnZpc2libGUmJihhLnNlcmllcy5mb3JjZURMfHxmLmlzSW5zaWRlUGxvdChoLHcoaSksZyl8fGQmJmYuaXNJbnNpZGVQbG90KGgsZz9kLngrXG4xOmQueStkLmhlaWdodC0xLGcpKTtpZihtKWQ9cih7eDpnP2YucGxvdFdpZHRoLWk6aCx5OncoZz9mLnBsb3RIZWlnaHQtaDppKSx3aWR0aDowLGhlaWdodDowfSxkKSxyKGMse3dpZHRoOmoud2lkdGgsaGVpZ2h0OmouaGVpZ2h0fSksYy5yb3RhdGlvbj8oYT1mLnJlbmRlcmVyLnJvdENvcnIoayxjLnJvdGF0aW9uKSxiW2U/XCJhdHRyXCI6XCJhbmltYXRlXCJdKHt4OmQueCtjLngrZC53aWR0aC8yK2EueCx5OmQueStjLnkrZC5oZWlnaHQvMn0pLmF0dHIoe2FsaWduOmMuYWxpZ259KSk6KGIuYWxpZ24oYyxudWxsLGQpLGc9Yi5hbGlnbkF0dHIscChjLm92ZXJmbG93LFwianVzdGlmeVwiKT09PVwianVzdGlmeVwiP3RoaXMuanVzdGlmeURhdGFMYWJlbChiLGMsZyxqLGQsZSk6cChjLmNyb3AsITApJiYobT1mLmlzSW5zaWRlUGxvdChnLngsZy55KSYmZi5pc0luc2lkZVBsb3QoZy54K2oud2lkdGgsZy55K2ouaGVpZ2h0KSksYy5zaGFwZSYmYi5hdHRyKHthbmNob3JYOmEucGxvdFgsYW5jaG9yWTphLnBsb3RZfSkpO1xuaWYoIW0pYi5hdHRyKHt5Oi05OTl9KSxiLnBsYWNlZD0hMX07Ui5wcm90b3R5cGUuanVzdGlmeURhdGFMYWJlbD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9dGhpcy5jaGFydCxoPWIuYWxpZ24saT1iLnZlcnRpY2FsQWxpZ24saixrLG09YS5ib3g/MDphLnBhZGRpbmd8fDA7aj1jLngrbTtpZihqPDApaD09PVwicmlnaHRcIj9iLmFsaWduPVwibGVmdFwiOmIueD0taixrPSEwO2o9Yy54K2Qud2lkdGgtbTtpZihqPmcucGxvdFdpZHRoKWg9PT1cImxlZnRcIj9iLmFsaWduPVwicmlnaHRcIjpiLng9Zy5wbG90V2lkdGgtaixrPSEwO2o9Yy55K207aWYoajwwKWk9PT1cImJvdHRvbVwiP2IudmVydGljYWxBbGlnbj1cInRvcFwiOmIueT0taixrPSEwO2o9Yy55K2QuaGVpZ2h0LW07aWYoaj5nLnBsb3RIZWlnaHQpaT09PVwidG9wXCI/Yi52ZXJ0aWNhbEFsaWduPVwiYm90dG9tXCI6Yi55PWcucGxvdEhlaWdodC1qLGs9ITA7aWYoaylhLnBsYWNlZD0hZixhLmFsaWduKGIsbnVsbCxlKX07aWYoTS5waWUpTS5waWUucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzPVxuZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5kYXRhLGMsZD1hLmNoYXJ0LGU9YS5vcHRpb25zLmRhdGFMYWJlbHMsZj1wKGUuY29ubmVjdG9yUGFkZGluZywxMCksZz1wKGUuY29ubmVjdG9yV2lkdGgsMSksaD1kLnBsb3RXaWR0aCxpPWQucGxvdEhlaWdodCxqLGssbT1wKGUuc29mdENvbm5lY3RvciwhMCksbD1lLmRpc3RhbmNlLG49YS5jZW50ZXIscT1uWzJdLzIscj1uWzFdLHM9bD4wLHYsdSx5LEM9W1tdLFtdXSxBLEIsRCxGLEcsRT1bMCwwLDAsMF0sTD1mdW5jdGlvbihhLGIpe3JldHVybiBiLnktYS55fTtpZihhLnZpc2libGUmJihlLmVuYWJsZWR8fGEuX2hhc1BvaW50TGFiZWxzKSl7Ui5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMuYXBwbHkoYSk7byhiLGZ1bmN0aW9uKGEpe2EuZGF0YUxhYmVsJiZhLnZpc2libGUmJkNbYS5oYWxmXS5wdXNoKGEpfSk7Zm9yKEY9MjtGLS07KXt2YXIgST1bXSxNPVtdLEg9Q1tGXSxLPUgubGVuZ3RoLEo7aWYoSyl7YS5zb3J0QnlBbmdsZShILFxuRi0wLjUpO2ZvcihHPWI9MDshYiYmSFtHXTspYj1IW0ddJiZIW0ddLmRhdGFMYWJlbCYmKEhbR10uZGF0YUxhYmVsLmdldEJCb3goKS5oZWlnaHR8fDIxKSxHKys7aWYobD4wKXt1PXoocitxK2wsZC5wbG90SGVpZ2h0KTtmb3IoRz10KDAsci1xLWwpO0c8PXU7Rys9YilJLnB1c2goRyk7dT1JLmxlbmd0aDtpZihLPnUpe2M9W10uY29uY2F0KEgpO2Muc29ydChMKTtmb3IoRz1LO0ctLTspY1tHXS5yYW5rPUc7Zm9yKEc9SztHLS07KUhbR10ucmFuaz49dSYmSC5zcGxpY2UoRywxKTtLPUgubGVuZ3RofWZvcihHPTA7RzxLO0crKyl7Yz1IW0ddO3k9Yy5sYWJlbFBvcztjPTk5OTk7dmFyIFAsTztmb3IoTz0wO088dTtPKyspUD1OKElbT10teVsxXSksUDxjJiYoYz1QLEo9Tyk7aWYoSjxHJiZJW0ddIT09bnVsbClKPUc7ZWxzZSBmb3IodTxLLUcrSiYmSVtHXSE9PW51bGwmJihKPXUtSytHKTtJW0pdPT09bnVsbDspSisrO00ucHVzaCh7aTpKLHk6SVtKXX0pO0lbSl09bnVsbH1NLnNvcnQoTCl9Zm9yKEc9XG4wO0c8SztHKyspe2M9SFtHXTt5PWMubGFiZWxQb3M7dj1jLmRhdGFMYWJlbDtEPWMudmlzaWJsZT09PSExP1wiaGlkZGVuXCI6XCJpbmhlcml0XCI7Yz15WzFdO2lmKGw+MCl7aWYodT1NLnBvcCgpLEo9dS5pLEI9dS55LGM+QiYmSVtKKzFdIT09bnVsbHx8YzxCJiZJW0otMV0hPT1udWxsKUI9eih0KDAsYyksZC5wbG90SGVpZ2h0KX1lbHNlIEI9YztBPWUuanVzdGlmeT9uWzBdKyhGPy0xOjEpKihxK2wpOmEuZ2V0WChCPT09ci1xLWx8fEI9PT1yK3ErbD9jOkIsRik7di5fYXR0cj17dmlzaWJpbGl0eTpELGFsaWduOnlbNl19O3YuX3Bvcz17eDpBK2UueCsoe2xlZnQ6ZixyaWdodDotZn1beVs2XV18fDApLHk6QitlLnktMTB9O3YuY29ublg9QTt2LmNvbm5ZPUI7aWYodGhpcy5vcHRpb25zLnNpemU9PT1udWxsKXU9di53aWR0aCxBLXU8Zj9FWzNdPXQodyh1LUErZiksRVszXSk6QSt1PmgtZiYmKEVbMV09dCh3KEErdS1oK2YpLEVbMV0pKSxCLWIvMjwwP0VbMF09dCh3KC1CK2IvMiksRVswXSk6XG5CK2IvMj5pJiYoRVsyXT10KHcoQitiLzItaSksRVsyXSkpfX19aWYoQ2EoRSk9PT0wfHx0aGlzLnZlcmlmeURhdGFMYWJlbE92ZXJmbG93KEUpKXRoaXMucGxhY2VEYXRhTGFiZWxzKCkscyYmZyYmbyh0aGlzLnBvaW50cyxmdW5jdGlvbihiKXtqPWIuY29ubmVjdG9yO3k9Yi5sYWJlbFBvcztpZigodj1iLmRhdGFMYWJlbCkmJnYuX3BvcyYmYi52aXNpYmxlKUQ9di5fYXR0ci52aXNpYmlsaXR5LEE9di5jb25uWCxCPXYuY29ublksaz1tP1tcIk1cIixBKyh5WzZdPT09XCJsZWZ0XCI/NTotNSksQixcIkNcIixBLEIsMip5WzJdLXlbNF0sMip5WzNdLXlbNV0seVsyXSx5WzNdLFwiTFwiLHlbNF0seVs1XV06W1wiTVwiLEErKHlbNl09PT1cImxlZnRcIj81Oi01KSxCLFwiTFwiLHlbMl0seVszXSxcIkxcIix5WzRdLHlbNV1dLGo/KGouYW5pbWF0ZSh7ZDprfSksai5hdHRyKFwidmlzaWJpbGl0eVwiLEQpKTpiLmNvbm5lY3Rvcj1qPWEuY2hhcnQucmVuZGVyZXIucGF0aChrKS5hdHRyKHtcInN0cm9rZS13aWR0aFwiOmcsc3Ryb2tlOmUuY29ubmVjdG9yQ29sb3J8fFxuYi5jb2xvcnx8XCIjNjA2MDYwXCIsdmlzaWJpbGl0eTpEfSkuYWRkKGEuZGF0YUxhYmVsc0dyb3VwKTtlbHNlIGlmKGopYi5jb25uZWN0b3I9ai5kZXN0cm95KCl9KX19LE0ucGllLnByb3RvdHlwZS5wbGFjZURhdGFMYWJlbHM9ZnVuY3Rpb24oKXtvKHRoaXMucG9pbnRzLGZ1bmN0aW9uKGEpe3ZhciBiPWEuZGF0YUxhYmVsO2lmKGImJmEudmlzaWJsZSkoYT1iLl9wb3MpPyhiLmF0dHIoYi5fYXR0ciksYltiLm1vdmVkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXShhKSxiLm1vdmVkPSEwKTpiJiZiLmF0dHIoe3k6LTk5OX0pfSl9LE0ucGllLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbD10YSxNLnBpZS5wcm90b3R5cGUudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3c9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jZW50ZXIsYz10aGlzLm9wdGlvbnMsZD1jLmNlbnRlcixlPWMubWluU2l6ZXx8ODAsZj1lLGc7ZFswXSE9PW51bGw/Zj10KGJbMl0tdChhWzFdLGFbM10pLGUpOihmPXQoYlsyXS1hWzFdLWFbM10sXG5lKSxiWzBdKz0oYVszXS1hWzFdKS8yKTtkWzFdIT09bnVsbD9mPXQoeihmLGJbMl0tdChhWzBdLGFbMl0pKSxlKTooZj10KHooZixiWzJdLWFbMF0tYVsyXSksZSksYlsxXSs9KGFbMF0tYVsyXSkvMik7ZjxiWzJdPyhiWzJdPWYsYlszXT0vJSQvLnRlc3QoYy5pbm5lclNpemV8fDApP2YqcGFyc2VGbG9hdChjLmlubmVyU2l6ZXx8MCkvMTAwOnBhcnNlRmxvYXQoYy5pbm5lclNpemV8fDApLHRoaXMudHJhbnNsYXRlKGIpLG8odGhpcy5wb2ludHMsZnVuY3Rpb24oYSl7aWYoYS5kYXRhTGFiZWwpYS5kYXRhTGFiZWwuX3Bvcz1udWxsfSksdGhpcy5kcmF3RGF0YUxhYmVscyYmdGhpcy5kcmF3RGF0YUxhYmVscygpKTpnPSEwO3JldHVybiBnfTtpZihNLmNvbHVtbilNLmNvbHVtbi5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWw9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLmNoYXJ0LmludmVydGVkLGc9YS5zZXJpZXMsaD1hLmRsQm94fHxhLnNoYXBlQXJncyxpPXAoYS5iZWxvdyxcbmEucGxvdFk+cCh0aGlzLnRyYW5zbGF0ZWRUaHJlc2hvbGQsZy55QXhpcy5sZW4pKSxqPXAoYy5pbnNpZGUsISF0aGlzLm9wdGlvbnMuc3RhY2tpbmcpO2lmKGgmJihkPUEoaCksZiYmKGQ9e3g6Zy55QXhpcy5sZW4tZC55LWQuaGVpZ2h0LHk6Zy54QXhpcy5sZW4tZC54LWQud2lkdGgsd2lkdGg6ZC5oZWlnaHQsaGVpZ2h0OmQud2lkdGh9KSwhaikpZj8oZC54Kz1pPzA6ZC53aWR0aCxkLndpZHRoPTApOihkLnkrPWk/ZC5oZWlnaHQ6MCxkLmhlaWdodD0wKTtjLmFsaWduPXAoYy5hbGlnbiwhZnx8aj9cImNlbnRlclwiOmk/XCJyaWdodFwiOlwibGVmdFwiKTtjLnZlcnRpY2FsQWxpZ249cChjLnZlcnRpY2FsQWxpZ24sZnx8aj9cIm1pZGRsZVwiOmk/XCJ0b3BcIjpcImJvdHRvbVwiKTtSLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsYSxiLGMsZCxlKX07KGZ1bmN0aW9uKGEpe3ZhciBiPWEuQ2hhcnQsYz1hLmVhY2gsZD1hLnBpY2ssZT1IaWdoY2hhcnRzQWRhcHRlci5hZGRFdmVudDtiLnByb3RvdHlwZS5jYWxsYmFja3MucHVzaChmdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7dmFyIGU9XG5bXTtjKGEuc2VyaWVzLGZ1bmN0aW9uKGEpe3ZhciBiPWEub3B0aW9ucy5kYXRhTGFiZWxzLGY9YS5kYXRhTGFiZWxDb2xsZWN0aW9uc3x8W1wiZGF0YUxhYmVsXCJdOyhiLmVuYWJsZWR8fGEuX2hhc1BvaW50TGFiZWxzKSYmIWIuYWxsb3dPdmVybGFwJiZhLnZpc2libGUmJmMoZixmdW5jdGlvbihiKXtjKGEucG9pbnRzLGZ1bmN0aW9uKGEpe2lmKGFbYl0pYVtiXS5sYWJlbHJhbms9ZChhLmxhYmVscmFuayxhLnNoYXBlQXJncyYmYS5zaGFwZUFyZ3MuaGVpZ2h0KSxlLnB1c2goYVtiXSl9KX0pfSk7YS5oaWRlT3ZlcmxhcHBpbmdMYWJlbHMoZSl9YigpO2UoYSxcInJlZHJhd1wiLGIpfSk7Yi5wcm90b3R5cGUuaGlkZU92ZXJsYXBwaW5nTGFiZWxzPWZ1bmN0aW9uKGEpe3ZhciBiPWEubGVuZ3RoLGQsZSxqLGssbSxsLG47Zm9yKGU9MDtlPGI7ZSsrKWlmKGQ9YVtlXSlkLm9sZE9wYWNpdHk9ZC5vcGFjaXR5LGQubmV3T3BhY2l0eT0xO2Euc29ydChmdW5jdGlvbihhLGIpe3JldHVybihiLmxhYmVscmFua3x8XG4wKS0oYS5sYWJlbHJhbmt8fDApfSk7Zm9yKGU9MDtlPGI7ZSsrKXtqPWFbZV07Zm9yKGQ9ZSsxO2Q8YjsrK2QpaWYoaz1hW2RdLGomJmsmJmoucGxhY2VkJiZrLnBsYWNlZCYmai5uZXdPcGFjaXR5IT09MCYmay5uZXdPcGFjaXR5IT09MCYmKG09ai5hbGlnbkF0dHIsbD1rLmFsaWduQXR0cixuPTIqKGouYm94PzA6ai5wYWRkaW5nKSxtPSEobC54Pm0ueCsoai53aWR0aC1uKXx8bC54KyhrLndpZHRoLW4pPG0ueHx8bC55Pm0ueSsoai5oZWlnaHQtbil8fGwueSsoay5oZWlnaHQtbik8bS55KSkpKGoubGFiZWxyYW5rPGsubGFiZWxyYW5rP2o6aykubmV3T3BhY2l0eT0wfWMoYSxmdW5jdGlvbihhKXt2YXIgYixjO2lmKGEpe2M9YS5uZXdPcGFjaXR5O2lmKGEub2xkT3BhY2l0eSE9PWMmJmEucGxhY2VkKWM/YS5zaG93KCEwKTpiPWZ1bmN0aW9uKCl7YS5oaWRlKCl9LGEuYWxpZ25BdHRyLm9wYWNpdHk9YyxhW2EuaXNPbGQ/XCJhbmltYXRlXCI6XCJhdHRyXCJdKGEuYWxpZ25BdHRyLG51bGwsXG5iKTthLmlzT2xkPSEwfX0pfX0pKEIpO1U9Qi5UcmFja2VyTWl4aW49e2RyYXdUcmFja2VyUG9pbnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydCxjPWIucG9pbnRlcixkPWEub3B0aW9ucy5jdXJzb3IsZT1kJiZ7Y3Vyc29yOmR9LGY9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWEudGFyZ2V0LGQ7YyYmIWQ7KWQ9Yy5wb2ludCxjPWMucGFyZW50Tm9kZTtpZihkIT09diYmZCE9PWIuaG92ZXJQb2ludClkLm9uTW91c2VPdmVyKGEpfTtvKGEucG9pbnRzLGZ1bmN0aW9uKGEpe2lmKGEuZ3JhcGhpYylhLmdyYXBoaWMuZWxlbWVudC5wb2ludD1hO2lmKGEuZGF0YUxhYmVsKWEuZGF0YUxhYmVsLmVsZW1lbnQucG9pbnQ9YX0pO2lmKCFhLl9oYXNUcmFja2luZylvKGEudHJhY2tlckdyb3VwcyxmdW5jdGlvbihiKXtpZihhW2JdJiYoYVtiXS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdHJhY2tlclwiKS5vbihcIm1vdXNlb3ZlclwiLGYpLm9uKFwibW91c2VvdXRcIixmdW5jdGlvbihhKXtjLm9uVHJhY2tlck1vdXNlT3V0KGEpfSkuY3NzKGUpLFxuJGEpKWFbYl0ub24oXCJ0b3VjaHN0YXJ0XCIsZil9KSxhLl9oYXNUcmFja2luZz0hMH0sZHJhd1RyYWNrZXJHcmFwaDpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMsYz1iLnRyYWNrQnlBcmVhLGQ9W10uY29uY2F0KGM/YS5hcmVhUGF0aDphLmdyYXBoUGF0aCksZT1kLmxlbmd0aCxmPWEuY2hhcnQsZz1mLnBvaW50ZXIsaD1mLnJlbmRlcmVyLGk9Zi5vcHRpb25zLnRvb2x0aXAuc25hcCxqPWEudHJhY2tlcixrPWIuY3Vyc29yLG09ayYme2N1cnNvcjprfSxrPWEuc2luZ2xlUG9pbnRzLGwsbj1mdW5jdGlvbigpe2lmKGYuaG92ZXJTZXJpZXMhPT1hKWEub25Nb3VzZU92ZXIoKX0scD1cInJnYmEoMTkyLDE5MiwxOTIsXCIrKGNhPzEuMEUtNDowLjAwMikrXCIpXCI7aWYoZSYmIWMpZm9yKGw9ZSsxO2wtLTspZFtsXT09PVwiTVwiJiZkLnNwbGljZShsKzEsMCxkW2wrMV0taSxkW2wrMl0sXCJMXCIpLChsJiZkW2xdPT09XCJNXCJ8fGw9PT1lKSYmZC5zcGxpY2UobCwwLFwiTFwiLGRbbC0yXStpLGRbbC1cbjFdKTtmb3IobD0wO2w8ay5sZW5ndGg7bCsrKWU9a1tsXSxkLnB1c2goXCJNXCIsZS5wbG90WC1pLGUucGxvdFksXCJMXCIsZS5wbG90WCtpLGUucGxvdFkpO2o/ai5hdHRyKHtkOmR9KTooYS50cmFja2VyPWgucGF0aChkKS5hdHRyKHtcInN0cm9rZS1saW5lam9pblwiOlwicm91bmRcIix2aXNpYmlsaXR5OmEudmlzaWJsZT9cInZpc2libGVcIjpcImhpZGRlblwiLHN0cm9rZTpwLGZpbGw6Yz9wOk8sXCJzdHJva2Utd2lkdGhcIjpiLmxpbmVXaWR0aCsoYz8wOjIqaSksekluZGV4OjJ9KS5hZGQoYS5ncm91cCksbyhbYS50cmFja2VyLGEubWFya2VyR3JvdXBdLGZ1bmN0aW9uKGEpe2EuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikub24oXCJtb3VzZW92ZXJcIixuKS5vbihcIm1vdXNlb3V0XCIsZnVuY3Rpb24oYSl7Zy5vblRyYWNrZXJNb3VzZU91dChhKX0pLmNzcyhtKTtpZigkYSlhLm9uKFwidG91Y2hzdGFydFwiLG4pfSkpfX07aWYoTS5jb2x1bW4pd2EucHJvdG90eXBlLmRyYXdUcmFja2VyPVUuZHJhd1RyYWNrZXJQb2ludDtcbmlmKE0ucGllKU0ucGllLnByb3RvdHlwZS5kcmF3VHJhY2tlcj1VLmRyYXdUcmFja2VyUG9pbnQ7aWYoTS5zY2F0dGVyKXBhLnByb3RvdHlwZS5kcmF3VHJhY2tlcj1VLmRyYXdUcmFja2VyUG9pbnQ7cihsYi5wcm90b3R5cGUse3NldEl0ZW1FdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzOyhjP2I6YS5sZWdlbmRHcm91cCkub24oXCJtb3VzZW92ZXJcIixmdW5jdGlvbigpe2Euc2V0U3RhdGUoXCJob3ZlclwiKTtiLmNzcyhmLm9wdGlvbnMuaXRlbUhvdmVyU3R5bGUpfSkub24oXCJtb3VzZW91dFwiLGZ1bmN0aW9uKCl7Yi5jc3MoYS52aXNpYmxlP2Q6ZSk7YS5zZXRTdGF0ZSgpfSkub24oXCJjbGlja1wiLGZ1bmN0aW9uKGIpe3ZhciBjPWZ1bmN0aW9uKCl7YS5zZXRWaXNpYmxlKCl9LGI9e2Jyb3dzZXJFdmVudDpifTthLmZpcmVQb2ludEV2ZW50P2EuZmlyZVBvaW50RXZlbnQoXCJsZWdlbmRJdGVtQ2xpY2tcIixiLGMpOkkoYSxcImxlZ2VuZEl0ZW1DbGlja1wiLGIsYyl9KX0sY3JlYXRlQ2hlY2tib3hGb3JJdGVtOmZ1bmN0aW9uKGEpe2EuY2hlY2tib3g9XG4kKFwiaW5wdXRcIix7dHlwZTpcImNoZWNrYm94XCIsY2hlY2tlZDphLnNlbGVjdGVkLGRlZmF1bHRDaGVja2VkOmEuc2VsZWN0ZWR9LHRoaXMub3B0aW9ucy5pdGVtQ2hlY2tib3hTdHlsZSx0aGlzLmNoYXJ0LmNvbnRhaW5lcik7SChhLmNoZWNrYm94LFwiY2xpY2tcIixmdW5jdGlvbihiKXtJKGEuc2VyaWVzfHxhLFwiY2hlY2tib3hDbGlja1wiLHtjaGVja2VkOmIudGFyZ2V0LmNoZWNrZWQsaXRlbTphfSxmdW5jdGlvbigpe2Euc2VsZWN0KCl9KX0pfX0pO1MubGVnZW5kLml0ZW1TdHlsZS5jdXJzb3I9XCJwb2ludGVyXCI7cihELnByb3RvdHlwZSx7c2hvd1Jlc2V0Wm9vbTpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1TLmxhbmcsYz1hLm9wdGlvbnMuY2hhcnQucmVzZXRab29tQnV0dG9uLGQ9Yy50aGVtZSxlPWQuc3RhdGVzLGY9Yy5yZWxhdGl2ZVRvPT09XCJjaGFydFwiP251bGw6XCJwbG90Qm94XCI7dGhpcy5yZXNldFpvb21CdXR0b249YS5yZW5kZXJlci5idXR0b24oYi5yZXNldFpvb20sbnVsbCxudWxsLFxuZnVuY3Rpb24oKXthLnpvb21PdXQoKX0sZCxlJiZlLmhvdmVyKS5hdHRyKHthbGlnbjpjLnBvc2l0aW9uLmFsaWduLHRpdGxlOmIucmVzZXRab29tVGl0bGV9KS5hZGQoKS5hbGlnbihjLnBvc2l0aW9uLCExLGYpfSx6b29tT3V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcztJKGEsXCJzZWxlY3Rpb25cIix7cmVzZXRTZWxlY3Rpb246ITB9LGZ1bmN0aW9uKCl7YS56b29tKCl9KX0sem9vbTpmdW5jdGlvbihhKXt2YXIgYixjPXRoaXMucG9pbnRlcixkPSExLGU7IWF8fGEucmVzZXRTZWxlY3Rpb24/byh0aGlzLmF4ZXMsZnVuY3Rpb24oYSl7Yj1hLnpvb20oKX0pOm8oYS54QXhpcy5jb25jYXQoYS55QXhpcyksZnVuY3Rpb24oYSl7dmFyIGU9YS5heGlzLGg9ZS5pc1hBeGlzO2lmKGNbaD9cInpvb21YXCI6XCJ6b29tWVwiXXx8Y1toP1wicGluY2hYXCI6XCJwaW5jaFlcIl0pYj1lLnpvb20oYS5taW4sYS5tYXgpLGUuZGlzcGxheUJ0biYmKGQ9ITApfSk7ZT10aGlzLnJlc2V0Wm9vbUJ1dHRvbjtpZihkJiYhZSl0aGlzLnNob3dSZXNldFpvb20oKTtcbmVsc2UgaWYoIWQmJmRhKGUpKXRoaXMucmVzZXRab29tQnV0dG9uPWUuZGVzdHJveSgpO2ImJnRoaXMucmVkcmF3KHAodGhpcy5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbixhJiZhLmFuaW1hdGlvbix0aGlzLnBvaW50Q291bnQ8MTAwKSl9LHBhbjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1jLmhvdmVyUG9pbnRzLGU7ZCYmbyhkLGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoKX0pO28oYj09PVwieHlcIj9bMSwwXTpbMV0sZnVuY3Rpb24oYil7dmFyIGQ9YVtiP1wiY2hhcnRYXCI6XCJjaGFydFlcIl0saD1jW2I/XCJ4QXhpc1wiOlwieUF4aXNcIl1bMF0saT1jW2I/XCJtb3VzZURvd25YXCI6XCJtb3VzZURvd25ZXCJdLGo9KGgucG9pbnRSYW5nZXx8MCkvMixrPWguZ2V0RXh0cmVtZXMoKSxtPWgudG9WYWx1ZShpLWQsITApK2osaj1oLnRvVmFsdWUoaStjW2I/XCJwbG90V2lkdGhcIjpcInBsb3RIZWlnaHRcIl0tZCwhMCktaixpPWk+ZDtpZihoLnNlcmllcy5sZW5ndGgmJihpfHxtPnooay5kYXRhTWluLGsubWluKSkmJlxuKCFpfHxqPHQoay5kYXRhTWF4LGsubWF4KSkpaC5zZXRFeHRyZW1lcyhtLGosITEsITEse3RyaWdnZXI6XCJwYW5cIn0pLGU9ITA7Y1tiP1wibW91c2VEb3duWFwiOlwibW91c2VEb3duWVwiXT1kfSk7ZSYmYy5yZWRyYXcoITEpO0woYy5jb250YWluZXIse2N1cnNvcjpcIm1vdmVcIn0pfX0pO3IoRWEucHJvdG90eXBlLHtzZWxlY3Q6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yy5zZXJpZXMsZT1kLmNoYXJ0LGE9cChhLCFjLnNlbGVjdGVkKTtjLmZpcmVQb2ludEV2ZW50KGE/XCJzZWxlY3RcIjpcInVuc2VsZWN0XCIse2FjY3VtdWxhdGU6Yn0sZnVuY3Rpb24oKXtjLnNlbGVjdGVkPWMub3B0aW9ucy5zZWxlY3RlZD1hO2Qub3B0aW9ucy5kYXRhW0thKGMsZC5kYXRhKV09Yy5vcHRpb25zO2Muc2V0U3RhdGUoYSYmXCJzZWxlY3RcIik7Ynx8byhlLmdldFNlbGVjdGVkUG9pbnRzKCksZnVuY3Rpb24oYSl7aWYoYS5zZWxlY3RlZCYmYSE9PWMpYS5zZWxlY3RlZD1hLm9wdGlvbnMuc2VsZWN0ZWQ9ITEsZC5vcHRpb25zLmRhdGFbS2EoYSxcbmQuZGF0YSldPWEub3B0aW9ucyxhLnNldFN0YXRlKFwiXCIpLGEuZmlyZVBvaW50RXZlbnQoXCJ1bnNlbGVjdFwiKX0pfSl9LG9uTW91c2VPdmVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5zZXJpZXMsZD1jLmNoYXJ0LGU9ZC50b29sdGlwLGY9ZC5ob3ZlclBvaW50O2lmKGQuaG92ZXJTZXJpZXMhPT1jKWMub25Nb3VzZU92ZXIoKTtpZihmJiZmIT09dGhpcylmLm9uTW91c2VPdXQoKTtpZih0aGlzLnNlcmllcyYmKHRoaXMuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU92ZXJcIiksZSYmKCFlLnNoYXJlZHx8Yy5ub1NoYXJlZFRvb2x0aXApJiZlLnJlZnJlc2godGhpcyxhKSx0aGlzLnNldFN0YXRlKFwiaG92ZXJcIiksIWIpKWQuaG92ZXJQb2ludD10aGlzfSxvbk1vdXNlT3V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zZXJpZXMuY2hhcnQsYj1hLmhvdmVyUG9pbnRzO3RoaXMuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU91dFwiKTtpZighYnx8S2EodGhpcyxiKT09PS0xKXRoaXMuc2V0U3RhdGUoKSxhLmhvdmVyUG9pbnQ9XG5udWxsfSxpbXBvcnRFdmVudHM6ZnVuY3Rpb24oKXtpZighdGhpcy5oYXNJbXBvcnRlZEV2ZW50cyl7dmFyIGE9QSh0aGlzLnNlcmllcy5vcHRpb25zLnBvaW50LHRoaXMub3B0aW9ucykuZXZlbnRzLGI7dGhpcy5ldmVudHM9YTtmb3IoYiBpbiBhKUgodGhpcyxiLGFbYl0pO3RoaXMuaGFzSW1wb3J0ZWRFdmVudHM9ITB9fSxzZXRTdGF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMucGxvdFgsZD10aGlzLnBsb3RZLGU9dGhpcy5zZXJpZXMsZj1lLm9wdGlvbnMuc3RhdGVzLGc9YmFbZS50eXBlXS5tYXJrZXImJmUub3B0aW9ucy5tYXJrZXIsaD1nJiYhZy5lbmFibGVkLGk9ZyYmZy5zdGF0ZXNbYV0saj1pJiZpLmVuYWJsZWQ9PT0hMSxrPWUuc3RhdGVNYXJrZXJHcmFwaGljLG09dGhpcy5tYXJrZXJ8fHt9LGw9ZS5jaGFydCxuPWUuaGFsbyxvLGE9YXx8XCJcIjtvPXRoaXMucG9pbnRBdHRyW2FdfHxlLnBvaW50QXR0clthXTtpZighKGE9PT10aGlzLnN0YXRlJiYhYnx8dGhpcy5zZWxlY3RlZCYmXG5hIT09XCJzZWxlY3RcInx8ZlthXSYmZlthXS5lbmFibGVkPT09ITF8fGEmJihqfHxoJiZpLmVuYWJsZWQ9PT0hMSl8fGEmJm0uc3RhdGVzJiZtLnN0YXRlc1thXSYmbS5zdGF0ZXNbYV0uZW5hYmxlZD09PSExKSl7aWYodGhpcy5ncmFwaGljKWc9ZyYmdGhpcy5ncmFwaGljLnN5bWJvbE5hbWUmJm8ucix0aGlzLmdyYXBoaWMuYXR0cihBKG8sZz97eDpjLWcseTpkLWcsd2lkdGg6MipnLGhlaWdodDoyKmd9Ont9KSksayYmay5oaWRlKCk7ZWxzZXtpZihhJiZpKWlmKGc9aS5yYWRpdXMsbT1tLnN5bWJvbHx8ZS5zeW1ib2wsayYmay5jdXJyZW50U3ltYm9sIT09bSYmKGs9ay5kZXN0cm95KCkpLGspa1tiP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7eDpjLWcseTpkLWd9KTtlbHNlIGlmKG0pZS5zdGF0ZU1hcmtlckdyYXBoaWM9az1sLnJlbmRlcmVyLnN5bWJvbChtLGMtZyxkLWcsMipnLDIqZykuYXR0cihvKS5hZGQoZS5tYXJrZXJHcm91cCksay5jdXJyZW50U3ltYm9sPW07aWYoaylrW2EmJmwuaXNJbnNpZGVQbG90KGMsXG5kLGwuaW52ZXJ0ZWQpP1wic2hvd1wiOlwiaGlkZVwiXSgpLGsuZWxlbWVudC5wb2ludD10aGlzfWlmKChjPWZbYV0mJmZbYV0uaGFsbykmJmMuc2l6ZSl7aWYoIW4pZS5oYWxvPW49bC5yZW5kZXJlci5wYXRoKCkuYWRkKGwuc2VyaWVzR3JvdXApO24uYXR0cihyKHtmaWxsOm5hKHRoaXMuY29sb3J8fGUuY29sb3IpLnNldE9wYWNpdHkoYy5vcGFjaXR5KS5nZXQoKX0sYy5hdHRyaWJ1dGVzKSlbYj9cImFuaW1hdGVcIjpcImF0dHJcIl0oe2Q6dGhpcy5oYWxvUGF0aChjLnNpemUpfSl9ZWxzZSBuJiZuLmF0dHIoe2Q6W119KTt0aGlzLnN0YXRlPWF9fSxoYWxvUGF0aDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnNlcmllcyxjPWIuY2hhcnQsZD1iLmdldFBsb3RCb3goKSxlPWMuaW52ZXJ0ZWQ7cmV0dXJuIGMucmVuZGVyZXIuc3ltYm9scy5jaXJjbGUoZC50cmFuc2xhdGVYKyhlP2IueUF4aXMubGVuLXRoaXMucGxvdFk6dGhpcy5wbG90WCktYSxkLnRyYW5zbGF0ZVkrKGU/Yi54QXhpcy5sZW4tdGhpcy5wbG90WDpcbnRoaXMucGxvdFkpLWEsYSoyLGEqMil9fSk7cihSLnByb3RvdHlwZSx7b25Nb3VzZU92ZXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9YS5ob3ZlclNlcmllcztpZihiJiZiIT09dGhpcyliLm9uTW91c2VPdXQoKTt0aGlzLm9wdGlvbnMuZXZlbnRzLm1vdXNlT3ZlciYmSSh0aGlzLFwibW91c2VPdmVyXCIpO3RoaXMuc2V0U3RhdGUoXCJob3ZlclwiKTthLmhvdmVyU2VyaWVzPXRoaXN9LG9uTW91c2VPdXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj10aGlzLmNoYXJ0LGM9Yi50b29sdGlwLGQ9Yi5ob3ZlclBvaW50O2IuaG92ZXJTZXJpZXM9bnVsbDtpZihkKWQub25Nb3VzZU91dCgpO3RoaXMmJmEuZXZlbnRzLm1vdXNlT3V0JiZJKHRoaXMsXCJtb3VzZU91dFwiKTtjJiYhYS5zdGlja3lUcmFja2luZyYmKCFjLnNoYXJlZHx8dGhpcy5ub1NoYXJlZFRvb2x0aXApJiZjLmhpZGUoKTt0aGlzLnNldFN0YXRlKCl9LHNldFN0YXRlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucyxcbmM9dGhpcy5ncmFwaCxkPWIuc3RhdGVzLGU9Yi5saW5lV2lkdGgsYj0wLGE9YXx8XCJcIjtpZih0aGlzLnN0YXRlIT09YSYmKHRoaXMuc3RhdGU9YSwhKGRbYV0mJmRbYV0uZW5hYmxlZD09PSExKSYmKGEmJihlPWRbYV0ubGluZVdpZHRofHxlKyhkW2FdLmxpbmVXaWR0aFBsdXN8fDApKSxjJiYhYy5kYXNoc3R5bGUpKSl7YT17XCJzdHJva2Utd2lkdGhcIjplfTtmb3IoYy5hdHRyKGEpO3RoaXNbXCJ6b25lR3JhcGhcIitiXTspdGhpc1tcInpvbmVHcmFwaFwiK2JdLmF0dHIoYSksYis9MX19LHNldFZpc2libGU6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9Yy5jaGFydCxlPWMubGVnZW5kSXRlbSxmLGc9ZC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyxoPWMudmlzaWJsZTtmPShjLnZpc2libGU9YT1jLnVzZXJPcHRpb25zLnZpc2libGU9YT09PXY/IWg6YSk/XCJzaG93XCI6XCJoaWRlXCI7byhbXCJncm91cFwiLFwiZGF0YUxhYmVsc0dyb3VwXCIsXCJtYXJrZXJHcm91cFwiLFwidHJhY2tlclwiXSxmdW5jdGlvbihhKXtpZihjW2FdKWNbYV1bZl0oKX0pO1xuaWYoZC5ob3ZlclNlcmllcz09PWN8fChkLmhvdmVyUG9pbnQmJmQuaG92ZXJQb2ludC5zZXJpZXMpPT09YyljLm9uTW91c2VPdXQoKTtlJiZkLmxlZ2VuZC5jb2xvcml6ZUl0ZW0oYyxhKTtjLmlzRGlydHk9ITA7Yy5vcHRpb25zLnN0YWNraW5nJiZvKGQuc2VyaWVzLGZ1bmN0aW9uKGEpe2lmKGEub3B0aW9ucy5zdGFja2luZyYmYS52aXNpYmxlKWEuaXNEaXJ0eT0hMH0pO28oYy5saW5rZWRTZXJpZXMsZnVuY3Rpb24oYil7Yi5zZXRWaXNpYmxlKGEsITEpfSk7aWYoZylkLmlzRGlydHlCb3g9ITA7YiE9PSExJiZkLnJlZHJhdygpO0koYyxmKX0sc2hvdzpmdW5jdGlvbigpe3RoaXMuc2V0VmlzaWJsZSghMCl9LGhpZGU6ZnVuY3Rpb24oKXt0aGlzLnNldFZpc2libGUoITEpfSxzZWxlY3Q6ZnVuY3Rpb24oYSl7dGhpcy5zZWxlY3RlZD1hPWE9PT12PyF0aGlzLnNlbGVjdGVkOmE7aWYodGhpcy5jaGVja2JveCl0aGlzLmNoZWNrYm94LmNoZWNrZWQ9YTtJKHRoaXMsYT9cInNlbGVjdFwiOlwidW5zZWxlY3RcIil9LFxuZHJhd1RyYWNrZXI6VS5kcmF3VHJhY2tlckdyYXBofSk7cihCLHtDb2xvcjpuYSxQb2ludDpFYSxUaWNrOlJhLFJlbmRlcmVyOlphLFNWR0VsZW1lbnQ6UCxTVkdSZW5kZXJlcjp1YSxhcnJheU1pbjpOYSxhcnJheU1heDpDYSxjaGFydHM6WSxkYXRlRm9ybWF0Ok1hLGVycm9yOmxhLGZvcm1hdDpIYSxwYXRoQW5pbTp4YixnZXRPcHRpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIFN9LGhhc0JpZGlCdWc6TmIsaXNUb3VjaERldmljZTpKYixzZXRPcHRpb25zOmZ1bmN0aW9uKGEpe1M9QSghMCxTLGEpO0NiKCk7cmV0dXJuIFN9LGFkZEV2ZW50OkgscmVtb3ZlRXZlbnQ6WixjcmVhdGVFbGVtZW50OiQsZGlzY2FyZEVsZW1lbnQ6UGEsY3NzOkwsZWFjaDpvLG1hcDpUYSxtZXJnZTpBLHNwbGF0OnJhLGV4dGVuZENsYXNzOmthLHBJbnQ6Rixzdmc6Y2EsY2FudmFzOmZhLHZtbDohY2EmJiFmYSxwcm9kdWN0OlwiSGlnaGNoYXJ0c1wiLHZlcnNpb246XCI0LjEuOFwifSl9KSgpO1xuXG5cblxuLyoqKiBFWFBPUlRTIEZST00gZXhwb3J0cy1sb2FkZXIgKioqL1xubW9kdWxlLmV4cG9ydHMgPSBIaWdoY2hhcnRzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hc3NldHMvanMvdmVuZG9yL2hpZ2hjaGFydHMuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);